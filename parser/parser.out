Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start_symbol
Rule 1     start_symbol -> compilation
Rule 2     pragma -> PRAGMA IDENTIFIER ;
Rule 3     pragma -> PRAGMA simple_name ( pragma_arg_s ) ;
Rule 4     pragma_arg_s -> pragma_arg
Rule 5     pragma_arg_s -> pragma_arg_s , pragma_arg
Rule 6     pragma_arg -> expression
Rule 7     pragma_arg -> simple_name ARROW expression
Rule 8     pragma_s -> <empty>
Rule 9     pragma_s -> pragma_s pragma
Rule 10    decl -> object_decl
Rule 11    decl -> number_decl
Rule 12    decl -> type_decl
Rule 13    decl -> subtype_decl
Rule 14    decl -> subprog_decl
Rule 15    decl -> pkg_decl
Rule 16    decl -> task_decl
Rule 17    decl -> prot_decl
Rule 18    decl -> exception_decl
Rule 19    decl -> rename_decl
Rule 20    decl -> generic_decl
Rule 21    decl -> body_stub
Rule 22    decl -> error ;
Rule 23    object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ;
Rule 24    def_id_s -> def_id
Rule 25    def_id_s -> def_id_s , def_id
Rule 26    def_id -> IDENTIFIER
Rule 27    object_qualifier_opt -> <empty>
Rule 28    object_qualifier_opt -> ALIASED
Rule 29    object_qualifier_opt -> CONSTANT
Rule 30    object_qualifier_opt -> ALIASED CONSTANT
Rule 31    object_subtype_def -> subtype_ind
Rule 32    object_subtype_def -> array_type
Rule 33    init_opt -> <empty>
Rule 34    init_opt -> ASSIGNMENT expression
Rule 35    number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ;
Rule 36    type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ;
Rule 37    discrim_part_opt -> <empty>
Rule 38    discrim_part_opt -> discrim_part
Rule 39    discrim_part_opt -> ( LESSMORE )
Rule 40    type_completion -> <empty>
Rule 41    type_completion -> IS type_def
Rule 42    type_def -> enumeration_type
Rule 43    type_def -> integer_type
Rule 44    type_def -> real_type
Rule 45    type_def -> array_type
Rule 46    type_def -> record_type
Rule 47    type_def -> access_type
Rule 48    type_def -> derived_type
Rule 49    type_def -> private_type
Rule 50    subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ;
Rule 51    subtype_ind -> name constraint
Rule 52    subtype_ind -> name
Rule 53    constraint -> range_constraint
Rule 54    constraint -> decimal_digits_constraint
Rule 55    decimal_digits_constraint -> DIGITS expression range_constr_opt
Rule 56    derived_type -> NEW subtype_ind
Rule 57    derived_type -> NEW subtype_ind WITH PRIVATE
Rule 58    derived_type -> NEW subtype_ind WITH record_def
Rule 59    derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE
Rule 60    derived_type -> ABSTRACT NEW subtype_ind WITH record_def
Rule 61    range_constraint -> RANGE range
Rule 62    range -> simple_expression DOTDOT simple_expression
Rule 63    range -> name TICK RANGE
Rule 64    range -> name TICK RANGE ( expression )
Rule 65    enumeration_type -> ( enum_id_s )
Rule 66    enum_id_s -> enum_id
Rule 67    enum_id_s -> enum_id_s , enum_id
Rule 68    enum_id -> IDENTIFIER
Rule 69    enum_id -> CHAR
Rule 70    integer_type -> range_spec
Rule 71    integer_type -> MOD expression
Rule 72    range_spec -> range_constraint
Rule 73    range_spec_opt -> <empty>
Rule 74    range_spec_opt -> range_spec
Rule 75    real_type -> float_type
Rule 76    real_type -> fixed_type
Rule 77    float_type -> DIGITS expression range_spec_opt
Rule 78    fixed_type -> DELTA expression range_spec
Rule 79    fixed_type -> DELTA expression DIGITS expression range_spec_opt
Rule 80    array_type -> unconstr_array_type
Rule 81    array_type -> constr_array_type
Rule 82    unconstr_array_type -> ARRAY ( index_s ) OF component_subtype_def
Rule 83    constr_array_type -> ARRAY iter_index_constraint OF component_subtype_def
Rule 84    component_subtype_def -> aliased_opt subtype_ind
Rule 85    aliased_opt -> <empty>
Rule 86    aliased_opt -> ALIASED
Rule 87    index_s -> index
Rule 88    index_s -> index_s , index
Rule 89    index -> name RANGE LESSMORE
Rule 90    iter_index_constraint -> ( iter_discrete_range_s )
Rule 91    iter_discrete_range_s -> discrete_range
Rule 92    iter_discrete_range_s -> iter_discrete_range_s , discrete_range
Rule 93    discrete_range -> name range_constr_opt
Rule 94    discrete_range -> range
Rule 95    range_constr_opt -> <empty>
Rule 96    range_constr_opt -> range_constraint
Rule 97    record_type -> tagged_opt limited_opt record_def
Rule 98    record_def -> RECORD pragma_s comp_list END RECORD
Rule 99    record_def -> NuLL RECORD
Rule 100   tagged_opt -> <empty>
Rule 101   tagged_opt -> TAGGED
Rule 102   tagged_opt -> ABSTRACT TAGGED
Rule 103   comp_list -> comp_decl_s variant_part_opt
Rule 104   comp_list -> variant_part pragma_s
Rule 105   comp_list -> NuLL ; pragma_s
Rule 106   comp_decl_s -> comp_decl
Rule 107   comp_decl_s -> comp_decl_s pragma_s comp_decl
Rule 108   variant_part_opt -> pragma_s
Rule 109   variant_part_opt -> pragma_s variant_part pragma_s
Rule 110   comp_decl -> def_id_s : component_subtype_def init_opt ;
Rule 111   comp_decl -> error ;
Rule 112   discrim_part -> ( discrim_spec_s )
Rule 113   discrim_spec_s -> discrim_spec
Rule 114   discrim_spec_s -> discrim_spec_s ; discrim_spec
Rule 115   discrim_spec -> def_id_s : access_opt mark init_opt
Rule 116   discrim_spec -> error
Rule 117   access_opt -> <empty>
Rule 118   access_opt -> ACCESS
Rule 119   variant_part -> CASE simple_name IS pragma_s variant_s END CASE ;
Rule 120   variant_s -> variant
Rule 121   variant_s -> variant_s variant
Rule 122   variant -> WHEN choice_s ARROW pragma_s comp_list
Rule 123   choice_s -> choice
Rule 124   choice_s -> choice_s | choice
Rule 125   choice -> expression
Rule 126   choice -> discrete_with_range
Rule 127   choice -> OTHERS
Rule 128   discrete_with_range -> name range_constraint
Rule 129   discrete_with_range -> range
Rule 130   access_type -> ACCESS subtype_ind
Rule 131   access_type -> ACCESS CONSTANT subtype_ind
Rule 132   access_type -> ACCESS ALL subtype_ind
Rule 133   access_type -> ACCESS prot_opt PROCEDURE formal_part_opt
Rule 134   access_type -> ACCESS prot_opt FUNCTION formal_part_opt RETURN mark
Rule 135   prot_opt -> <empty>
Rule 136   prot_opt -> PROTECTED
Rule 137   decl_part -> <empty>
Rule 138   decl_part -> decl_item_or_body_s1
Rule 139   decl_item_s -> <empty>
Rule 140   decl_item_s -> decl_item_s1
Rule 141   decl_item_s1 -> decl_item
Rule 142   decl_item_s1 -> decl_item_s1 decl_item
Rule 143   decl_item -> decl
Rule 144   decl_item -> use_clause
Rule 145   decl_item -> rep_spec
Rule 146   decl_item -> pragma
Rule 147   decl_item_or_body_s1 -> decl_item_or_body
Rule 148   decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body
Rule 149   decl_item_or_body -> body
Rule 150   decl_item_or_body -> decl_item
Rule 151   body -> subprog_body
Rule 152   body -> pkg_body
Rule 153   body -> task_body
Rule 154   body -> prot_body
Rule 155   name -> simple_name
Rule 156   name -> indexed_comp
Rule 157   name -> selected_comp
Rule 158   name -> attribute
Rule 159   name -> operator_symbol
Rule 160   mark -> simple_name
Rule 161   mark -> mark TICK attribute_id
Rule 162   mark -> mark . simple_name
Rule 163   simple_name -> IDENTIFIER
Rule 164   compound_name -> simple_name
Rule 165   compound_name -> compound_name . simple_name
Rule 166   c_name_list -> compound_name
Rule 167   c_name_list -> c_name_list , compound_name
Rule 168   used_char -> CHAR
Rule 169   operator_symbol -> STRING
Rule 170   indexed_comp -> name ( value_s )
Rule 171   value_s -> value
Rule 172   value_s -> value_s , value
Rule 173   value -> expression
Rule 174   value -> comp_assoc
Rule 175   value -> discrete_with_range
Rule 176   value -> error
Rule 177   selected_comp -> name . simple_name
Rule 178   selected_comp -> name . used_char
Rule 179   selected_comp -> name . operator_symbol
Rule 180   selected_comp -> name . ALL
Rule 181   attribute -> name TICK attribute_id
Rule 182   attribute_id -> IDENTIFIER
Rule 183   attribute_id -> DIGITS
Rule 184   attribute_id -> DELTA
Rule 185   attribute_id -> ACCESS
Rule 186   literal -> INTEGER
Rule 187   literal -> BASE_INTEGER
Rule 188   literal -> FLOAT
Rule 189   literal -> BASE_FLOAT
Rule 190   literal -> used_char
Rule 191   literal -> NuLL
Rule 192   aggregate -> ( comp_assoc )
Rule 193   aggregate -> ( value_s_2 )
Rule 194   aggregate -> ( expression WITH value_s )
Rule 195   aggregate -> ( expression WITH NuLL RECORD )
Rule 196   aggregate -> ( NuLL RECORD )
Rule 197   value_s_2 -> value , value
Rule 198   value_s_2 -> value_s_2 , value
Rule 199   comp_assoc -> choice_s ARROW expression
Rule 200   expression -> relation
Rule 201   expression -> expression logical relation
Rule 202   expression -> expression short_circuit relation
Rule 203   logical -> AND
Rule 204   logical -> OR
Rule 205   logical -> XOR
Rule 206   short_circuit -> AND THEN
Rule 207   short_circuit -> OR ELSE
Rule 208   relation -> simple_expression
Rule 209   relation -> simple_expression relational simple_expression
Rule 210   relation -> simple_expression membership range
Rule 211   relation -> simple_expression membership name
Rule 212   relational -> =
Rule 213   relational -> NOTEQUAL
Rule 214   relational -> <
Rule 215   relational -> LESSEQ
Rule 216   relational -> >
Rule 217   relational -> GREATEREQ
Rule 218   membership -> IN
Rule 219   membership -> NOT IN
Rule 220   simple_expression -> unary term
Rule 221   simple_expression -> term
Rule 222   simple_expression -> simple_expression adding term
Rule 223   unary -> +
Rule 224   unary -> -
Rule 225   adding -> +
Rule 226   adding -> -
Rule 227   adding -> &
Rule 228   term -> factor
Rule 229   term -> term multiplying factor
Rule 230   multiplying -> *
Rule 231   multiplying -> /
Rule 232   multiplying -> MOD
Rule 233   multiplying -> REM
Rule 234   factor -> primary
Rule 235   factor -> NOT primary
Rule 236   factor -> ABS primary
Rule 237   factor -> primary STARSTAR primary
Rule 238   primary -> literal
Rule 239   primary -> name
Rule 240   primary -> allocator
Rule 241   primary -> qualified
Rule 242   primary -> parenthesized_primary
Rule 243   parenthesized_primary -> aggregate
Rule 244   parenthesized_primary -> ( expression )
Rule 245   qualified -> name TICK parenthesized_primary
Rule 246   allocator -> NEW name
Rule 247   allocator -> NEW qualified
Rule 248   statement_s -> statement
Rule 249   statement_s -> statement_s statement
Rule 250   statement -> unlabeled
Rule 251   statement -> label statement
Rule 252   unlabeled -> simple_stmt
Rule 253   unlabeled -> compound_stmt
Rule 254   unlabeled -> pragma
Rule 255   simple_stmt -> null_stmt
Rule 256   simple_stmt -> assign_stmt
Rule 257   simple_stmt -> exit_stmt
Rule 258   simple_stmt -> return_stmt
Rule 259   simple_stmt -> goto_stmt
Rule 260   simple_stmt -> procedure_call
Rule 261   simple_stmt -> delay_stmt
Rule 262   simple_stmt -> abort_stmt
Rule 263   simple_stmt -> raise_stmt
Rule 264   simple_stmt -> code_stmt
Rule 265   simple_stmt -> requeue_stmt
Rule 266   simple_stmt -> error ;
Rule 267   compound_stmt -> if_stmt
Rule 268   compound_stmt -> case_stmt
Rule 269   compound_stmt -> loop_stmt
Rule 270   compound_stmt -> block
Rule 271   compound_stmt -> accept_stmt
Rule 272   compound_stmt -> select_stmt
Rule 273   label -> LESSLESS IDENTIFIER MOREMORE
Rule 274   null_stmt -> NuLL ;
Rule 275   assign_stmt -> name ASSIGNMENT expression ;
Rule 276   if_stmt -> IF cond_clause_s else_opt END IF ;
Rule 277   cond_clause_s -> cond_clause
Rule 278   cond_clause_s -> cond_clause_s ELSIF cond_clause
Rule 279   cond_clause -> cond_part statement_s
Rule 280   cond_part -> condition THEN
Rule 281   condition -> expression
Rule 282   else_opt -> <empty>
Rule 283   else_opt -> ELSE statement_s
Rule 284   case_stmt -> case_hdr pragma_s alternative_s END CASE ;
Rule 285   case_hdr -> CASE expression IS
Rule 286   alternative_s -> <empty>
Rule 287   alternative_s -> alternative_s alternative
Rule 288   alternative -> WHEN choice_s ARROW statement_s
Rule 289   loop_stmt -> label_opt iteration basic_loop id_opt ;
Rule 290   label_opt -> <empty>
Rule 291   label_opt -> IDENTIFIER :
Rule 292   iteration -> <empty>
Rule 293   iteration -> WHILE condition
Rule 294   iteration -> iter_part reverse_opt discrete_range
Rule 295   iter_part -> FOR IDENTIFIER IN
Rule 296   reverse_opt -> <empty>
Rule 297   reverse_opt -> REVERSE
Rule 298   basic_loop -> LOOP statement_s END LOOP
Rule 299   id_opt -> <empty>
Rule 300   id_opt -> designator
Rule 301   block -> label_opt block_decl block_body END id_opt ;
Rule 302   block_decl -> <empty>
Rule 303   block_decl -> DECLARE decl_part
Rule 304   block_body -> BEGIN handled_stmt_s
Rule 305   handled_stmt_s -> statement_s except_handler_part_opt
Rule 306   except_handler_part_opt -> <empty>
Rule 307   except_handler_part_opt -> except_handler_part
Rule 308   exit_stmt -> EXIT name_opt when_opt ;
Rule 309   name_opt -> <empty>
Rule 310   name_opt -> name
Rule 311   when_opt -> <empty>
Rule 312   when_opt -> WHEN condition
Rule 313   return_stmt -> RETURN ;
Rule 314   return_stmt -> RETURN expression ;
Rule 315   goto_stmt -> GOTO name ;
Rule 316   subprog_decl -> subprog_spec ;
Rule 317   subprog_decl -> generic_subp_inst ;
Rule 318   subprog_decl -> subprog_spec_is_push ABSTRACT ;
Rule 319   subprog_spec -> PROCEDURE compound_name formal_part_opt
Rule 320   subprog_spec -> FUNCTION designator formal_part_opt RETURN name
Rule 321   subprog_spec -> FUNCTION designator
Rule 322   designator -> compound_name
Rule 323   designator -> STRING
Rule 324   formal_part_opt -> <empty>
Rule 325   formal_part_opt -> formal_part
Rule 326   formal_part -> ( param_s )
Rule 327   param_s -> param
Rule 328   param_s -> param_s ; param
Rule 329   param -> def_id_s : mode mark init_opt
Rule 330   param -> error
Rule 331   mode -> <empty>
Rule 332   mode -> IN
Rule 333   mode -> OUT
Rule 334   mode -> IN OUT
Rule 335   mode -> ACCESS
Rule 336   subprog_spec_is_push -> subprog_spec IS
Rule 337   subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ;
Rule 338   procedure_call -> name ;
Rule 339   pkg_decl -> pkg_spec ;
Rule 340   pkg_decl -> generic_pkg_inst ;
Rule 341   pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END c_id_opt
Rule 342   private_part -> <empty>
Rule 343   private_part -> PRIVATE decl_item_s
Rule 344   c_id_opt -> <empty>
Rule 345   c_id_opt -> compound_name
Rule 346   pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
Rule 347   body_opt -> <empty>
Rule 348   body_opt -> block_body
Rule 349   private_type -> tagged_opt limited_opt PRIVATE
Rule 350   limited_opt -> <empty>
Rule 351   limited_opt -> LIMITED
Rule 352   use_clause -> USE name_s ;
Rule 353   use_clause -> USE TYPE name_s ;
Rule 354   name_s -> name
Rule 355   name_s -> name_s , name
Rule 356   rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ;
Rule 357   rename_decl -> def_id_s : EXCEPTION renames ;
Rule 358   rename_decl -> rename_unit
Rule 359   rename_unit -> PACKAGE compound_name renames ;
Rule 360   rename_unit -> subprog_spec renames ;
Rule 361   rename_unit -> generic_formal_part PACKAGE compound_name renames ;
Rule 362   rename_unit -> generic_formal_part subprog_spec renames ;
Rule 363   renames -> RENAMES name
Rule 364   task_decl -> task_spec ;
Rule 365   task_spec -> TASK simple_name task_def
Rule 366   task_spec -> TASK TYPE simple_name discrim_part_opt task_def
Rule 367   task_def -> <empty>
Rule 368   task_def -> IS entry_decl_s rep_spec_s task_private_opt END id_opt
Rule 369   task_private_opt -> <empty>
Rule 370   task_private_opt -> PRIVATE entry_decl_s rep_spec_s
Rule 371   task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ;
Rule 372   prot_decl -> prot_spec ;
Rule 373   prot_spec -> PROTECTED IDENTIFIER prot_def
Rule 374   prot_spec -> PROTECTED TYPE simple_name discrim_part_opt prot_def
Rule 375   prot_def -> IS prot_op_decl_s prot_private_opt END id_opt
Rule 376   prot_private_opt -> <empty>
Rule 377   prot_private_opt -> PRIVATE prot_elem_decl_s
Rule 378   prot_op_decl_s -> <empty>
Rule 379   prot_op_decl_s -> prot_op_decl_s prot_op_decl
Rule 380   prot_op_decl -> entry_decl
Rule 381   prot_op_decl -> subprog_spec ;
Rule 382   prot_op_decl -> rep_spec
Rule 383   prot_op_decl -> pragma
Rule 384   prot_elem_decl_s -> <empty>
Rule 385   prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl
Rule 386   prot_elem_decl -> prot_op_decl
Rule 387   prot_elem_decl -> comp_decl
Rule 388   prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
Rule 389   prot_op_body_s -> pragma_s
Rule 390   prot_op_body_s -> prot_op_body_s prot_op_body pragma_s
Rule 391   prot_op_body -> entry_body
Rule 392   prot_op_body -> subprog_body
Rule 393   prot_op_body -> subprog_spec ;
Rule 394   entry_decl_s -> pragma_s
Rule 395   entry_decl_s -> entry_decl_s entry_decl pragma_s
Rule 396   entry_decl -> ENTRY IDENTIFIER formal_part_opt ;
Rule 397   entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ;
Rule 398   entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part
Rule 399   entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part
Rule 400   entry_body_part -> ;
Rule 401   entry_body_part -> IS decl_part block_body END id_opt ;
Rule 402   rep_spec_s -> <empty>
Rule 403   rep_spec_s -> rep_spec_s rep_spec pragma_s
Rule 404   entry_call -> procedure_call
Rule 405   accept_stmt -> accept_hdr ;
Rule 406   accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ;
Rule 407   accept_hdr -> ACCEPT entry_name formal_part_opt
Rule 408   entry_name -> simple_name
Rule 409   entry_name -> entry_name ( expression )
Rule 410   delay_stmt -> DELAY expression ;
Rule 411   delay_stmt -> DELAY UNTIL expression ;
Rule 412   select_stmt -> select_wait
Rule 413   select_stmt -> async_select
Rule 414   select_stmt -> timed_entry_call
Rule 415   select_stmt -> cond_entry_call
Rule 416   select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ;
Rule 417   guarded_select_alt -> select_alt
Rule 418   guarded_select_alt -> WHEN condition ARROW select_alt
Rule 419   or_select -> <empty>
Rule 420   or_select -> or_select OR guarded_select_alt
Rule 421   select_alt -> accept_stmt stmts_opt
Rule 422   select_alt -> delay_stmt stmts_opt
Rule 423   select_alt -> TERMINATE ;
Rule 424   delay_or_entry_alt -> delay_stmt stmts_opt
Rule 425   delay_or_entry_alt -> entry_call stmts_opt
Rule 426   async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
Rule 427   timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
Rule 428   cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
Rule 429   stmts_opt -> <empty>
Rule 430   stmts_opt -> statement_s
Rule 431   abort_stmt -> ABORT name_s ;
Rule 432   compilation -> <empty>
Rule 433   compilation -> compilation comp_unit
Rule 434   compilation -> pragma pragma_s
Rule 435   comp_unit -> context_spec private_opt unit pragma_s
Rule 436   comp_unit -> private_opt unit pragma_s
Rule 437   private_opt -> <empty>
Rule 438   private_opt -> PRIVATE
Rule 439   context_spec -> with_clause use_clause_opt
Rule 440   context_spec -> context_spec with_clause use_clause_opt
Rule 441   context_spec -> context_spec pragma
Rule 442   with_clause -> WITH c_name_list ;
Rule 443   use_clause_opt -> <empty>
Rule 444   use_clause_opt -> use_clause_opt use_clause
Rule 445   unit -> pkg_decl
Rule 446   unit -> pkg_body
Rule 447   unit -> subprog_decl
Rule 448   unit -> subprog_body
Rule 449   unit -> subunit
Rule 450   unit -> generic_decl
Rule 451   unit -> rename_unit
Rule 452   subunit -> SEPARATE ( compound_name ) subunit_body
Rule 453   subunit_body -> subprog_body
Rule 454   subunit_body -> pkg_body
Rule 455   subunit_body -> task_body
Rule 456   subunit_body -> prot_body
Rule 457   body_stub -> TASK BODY simple_name IS SEPARATE ;
Rule 458   body_stub -> PACKAGE BODY compound_name IS SEPARATE ;
Rule 459   body_stub -> subprog_spec IS SEPARATE ;
Rule 460   body_stub -> PROTECTED BODY simple_name IS SEPARATE ;
Rule 461   exception_decl -> def_id_s : EXCEPTION ;
Rule 462   except_handler_part -> EXCEPTION exception_handler
Rule 463   except_handler_part -> except_handler_part exception_handler
Rule 464   exception_handler -> WHEN except_choice_s ARROW statement_s
Rule 465   exception_handler -> WHEN IDENTIFIER : except_choice_s ARROW statement_s
Rule 466   except_choice_s -> except_choice
Rule 467   except_choice_s -> except_choice_s | except_choice
Rule 468   except_choice -> name
Rule 469   except_choice -> OTHERS
Rule 470   raise_stmt -> RAISE name_opt ;
Rule 471   requeue_stmt -> REQUEUE name ;
Rule 472   requeue_stmt -> REQUEUE name WITH ABORT ;
Rule 473   generic_decl -> generic_formal_part subprog_spec ;
Rule 474   generic_decl -> generic_formal_part pkg_spec ;
Rule 475   generic_formal_part -> GENERIC
Rule 476   generic_formal_part -> generic_formal_part generic_formal
Rule 477   generic_formal -> param ;
Rule 478   generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ;
Rule 479   generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ;
Rule 480   generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ;
Rule 481   generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ;
Rule 482   generic_formal -> WITH PACKAGE simple_name IS NEW name ;
Rule 483   generic_formal -> use_clause
Rule 484   generic_discrim_part_opt -> <empty>
Rule 485   generic_discrim_part_opt -> discrim_part
Rule 486   generic_discrim_part_opt -> ( LESSMORE )
Rule 487   subp_default -> <empty>
Rule 488   subp_default -> IS name
Rule 489   subp_default -> IS LESSMORE
Rule 490   generic_type_def -> ( LESSMORE )
Rule 491   generic_type_def -> RANGE LESSMORE
Rule 492   generic_type_def -> MOD LESSMORE
Rule 493   generic_type_def -> DELTA LESSMORE
Rule 494   generic_type_def -> DELTA LESSMORE DIGITS LESSMORE
Rule 495   generic_type_def -> DIGITS LESSMORE
Rule 496   generic_type_def -> array_type
Rule 497   generic_type_def -> access_type
Rule 498   generic_type_def -> private_type
Rule 499   generic_type_def -> generic_derived_type
Rule 500   generic_derived_type -> NEW subtype_ind
Rule 501   generic_derived_type -> NEW subtype_ind WITH PRIVATE
Rule 502   generic_derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE
Rule 503   generic_subp_inst -> subprog_spec IS generic_inst
Rule 504   generic_pkg_inst -> PACKAGE compound_name IS generic_inst
Rule 505   generic_inst -> NEW name
Rule 506   rep_spec -> attrib_def
Rule 507   rep_spec -> record_type_spec
Rule 508   rep_spec -> address_spec
Rule 509   attrib_def -> FOR mark USE expression ;
Rule 510   record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
Rule 511   align_opt -> <empty>
Rule 512   align_opt -> AT MOD expression ;
Rule 513   comp_loc_s -> <empty>
Rule 514   comp_loc_s -> comp_loc_s mark AT expression RANGE range ;
Rule 515   address_spec -> FOR mark USE AT expression ;
Rule 516   code_stmt -> qualified ;

Terminals, with rules where they appear

&                    : 227
(                    : 3 39 64 65 82 90 112 170 192 193 194 195 196 244 326 397 399 409 452 481 486 490
)                    : 3 39 64 65 82 90 112 170 192 193 194 195 196 244 326 397 399 409 452 481 486 490
*                    : 230
+                    : 223 225
,                    : 5 25 67 88 92 167 172 197 198 355
-                    : 224 226
.                    : 162 165 177 178 179 180
/                    : 231
:                    : 23 35 110 115 291 329 356 357 461 465
;                    : 2 3 22 23 35 36 50 105 110 111 114 119 266 274 275 276 284 289 301 308 313 314 315 316 317 318 328 337 338 339 340 346 352 353 356 357 359 360 361 362 364 371 372 381 388 393 396 397 400 401 405 406 410 411 416 423 426 427 428 431 442 457 458 459 460 461 470 471 472 473 474 477 478 479 480 481 482 509 510 512 514 515 516
<                    : 214
=                    : 212
>                    : 216
ABORT                : 426 431 472
ABS                  : 236
ABSTRACT             : 59 60 102 318 502
ACCEPT               : 407
ACCESS               : 118 130 131 132 133 134 185 335
ALIASED              : 28 30 86
ALL                  : 132 180
AND                  : 203 206
ARRAY                : 82 83
ARROW                : 7 122 199 288 418 464 465
ASSIGNMENT           : 34 35 275
AT                   : 512 514 515
BASE_FLOAT           : 189
BASE_INTEGER         : 187
BEGIN                : 304
BODY                 : 346 371 388 457 458 460
CASE                 : 119 119 284 285
CHAR                 : 69 168
CONSTANT             : 29 30 35 131
DECLARE              : 303
DELAY                : 410 411
DELTA                : 78 79 184 493 494
DIGITS               : 55 77 79 183 494 495
DO                   : 406
DOTDOT               : 62
ELSE                 : 207 283 428
ELSIF                : 278
END                  : 98 119 276 284 298 301 337 341 346 368 371 375 388 401 406 416 426 427 428 510
ENTRY                : 396 397 398 399
EXCEPTION            : 357 461 462
EXIT                 : 308
FLOAT                : 188
FOR                  : 295 509 510 515
FUNCTION             : 134 320 321 480
GENERIC              : 475
GOTO                 : 315
GREATEREQ            : 217
IDENTIFIER           : 2 26 36 50 68 163 182 273 291 295 373 396 397 398 399 465
IF                   : 276 276
IN                   : 218 219 295 332 334
INTEGER              : 186
IS                   : 41 50 119 285 336 341 346 368 371 375 388 401 457 458 459 460 478 481 482 488 489 503 504
LESSEQ               : 215
LESSLESS             : 273
LESSMORE             : 39 89 481 486 489 490 491 492 493 494 494 495
LIMITED              : 351
LOOP                 : 298 298
MOD                  : 71 232 492 512
MOREMORE             : 273
NEW                  : 56 57 58 59 60 246 247 481 482 500 501 502 505
NOT                  : 219 235
NOTEQUAL             : 213
NuLL                 : 99 105 191 195 196 274
OF                   : 82 83
OR                   : 204 207 420 427
OTHERS               : 127 469
OUT                  : 333 334
PACKAGE              : 341 346 359 361 458 481 482 504
PRAGMA               : 2 3
PRIVATE              : 57 59 343 349 370 377 438 501 502
PROCEDURE            : 133 319 479
PROTECTED            : 136 373 374 388 460
RAISE                : 470
RANGE                : 61 63 64 89 491 514
RECORD               : 98 98 99 195 196 510 510
REM                  : 233
RENAMES              : 363
REQUEUE              : 471 472
RETURN               : 134 313 314 320 480
REVERSE              : 297
SELECT               : 416 416 426 426 427 427 428 428
SEPARATE             : 452 457 458 459 460
STARSTAR             : 237
STRING               : 169 323
SUBTYPE              : 50
TAGGED               : 101 102
TASK                 : 365 366 371 457
TERMINATE            : 423
THEN                 : 206 280 426
TICK                 : 63 64 161 181 245
TYPE                 : 36 353 366 374 478
UNTIL                : 411
USE                  : 352 353 509 510 515
WHEN                 : 122 288 312 398 399 418 464 465
WHILE                : 293
WITH                 : 57 58 59 60 194 195 442 472 479 480 481 482 501 502
XOR                  : 205
error                : 22 111 116 176 266 330
|                    : 124 467

Nonterminals, with rules where they appear

abort_stmt           : 262
accept_hdr           : 405 406
accept_stmt          : 271 421
access_opt           : 115
access_type          : 47 497
adding               : 222
address_spec         : 508
aggregate            : 243
aliased_opt          : 84
align_opt            : 510
allocator            : 240
alternative          : 287
alternative_s        : 284 287
array_type           : 32 45 496
assign_stmt          : 256
async_select         : 413
attrib_def           : 506
attribute            : 158
attribute_id         : 161 181
basic_loop           : 289
block                : 270
block_body           : 301 337 348 371 401
block_decl           : 301
body                 : 149
body_opt             : 346
body_stub            : 21
c_id_opt             : 341 346
c_name_list          : 167 442
case_hdr             : 284
case_stmt            : 268
choice               : 123 124
choice_s             : 122 124 199 288
code_stmt            : 264
comp_assoc           : 174 192
comp_decl            : 106 107 387
comp_decl_s          : 103 107
comp_list            : 98 122
comp_loc_s           : 510 514
comp_unit            : 433
compilation          : 1 433
component_subtype_def : 82 83 110
compound_name        : 165 166 167 319 322 341 345 346 359 361 452 458 504
compound_stmt        : 253
cond_clause          : 277 278
cond_clause_s        : 276 278
cond_entry_call      : 415
cond_part            : 279
condition            : 280 293 312 398 399 418
constr_array_type    : 81
constraint           : 51
context_spec         : 435 440 441
decimal_digits_constraint : 54
decl                 : 143
decl_item            : 141 142 150
decl_item_or_body    : 147 148
decl_item_or_body_s1 : 138 148
decl_item_s          : 341 343
decl_item_s1         : 140 142
decl_part            : 303 337 346 371 401
def_id               : 24 25
def_id_s             : 23 25 35 110 115 329 356 357 461
delay_or_entry_alt   : 426
delay_stmt           : 261 422 424 427
derived_type         : 48
designator           : 300 320 321 480
discrete_range       : 91 92 294 397 399
discrete_with_range  : 126 175
discrim_part         : 38 485
discrim_part_opt     : 36 366 374
discrim_spec         : 113 114
discrim_spec_s       : 112 114
else_opt             : 276 416
entry_body           : 391
entry_body_part      : 398 399
entry_call           : 425 427 428
entry_decl           : 380 395
entry_decl_s         : 368 370 395
entry_name           : 407 409
enum_id              : 66 67
enum_id_s            : 65 67
enumeration_type     : 42
except_choice        : 466 467
except_choice_s      : 464 465 467
except_handler_part  : 307 463
except_handler_part_opt : 305
exception_decl       : 18
exception_handler    : 462 463
exit_stmt            : 257
expression           : 6 7 34 35 55 64 71 77 78 79 79 125 173 194 195 199 201 202 244 275 281 285 314 409 410 411 509 512 514 515
factor               : 228 229
fixed_type           : 76
float_type           : 75
formal_part          : 325
formal_part_opt      : 133 134 319 320 396 397 398 399 407 479 480
generic_decl         : 20 450
generic_derived_type : 499
generic_discrim_part_opt : 478
generic_formal       : 476
generic_formal_part  : 361 362 473 474 476
generic_inst         : 503 504
generic_pkg_inst     : 340
generic_subp_inst    : 317
generic_type_def     : 478
goto_stmt            : 259
guarded_select_alt   : 416 420
handled_stmt_s       : 304 406
id_opt               : 289 301 337 368 371 375 388 401 406
if_stmt              : 267
index                : 87 88
index_s              : 82 88
indexed_comp         : 156
init_opt             : 23 110 115 329
integer_type         : 43
iter_discrete_range_s : 90 92
iter_index_constraint : 83
iter_part            : 294 399
iteration            : 289
label                : 251
label_opt            : 289 301
limited_opt          : 97 349
literal              : 238
logical              : 201
loop_stmt            : 269
mark                 : 115 134 161 162 329 509 510 514 515
membership           : 210 211
mode                 : 329
multiplying          : 229
name                 : 51 52 63 64 89 93 128 170 177 178 179 180 181 211 239 245 246 275 310 315 320 338 354 355 363 468 471 472 480 481 482 488 505
name_opt             : 308 470
name_s               : 352 353 355 431
null_stmt            : 255
number_decl          : 11
object_decl          : 10
object_qualifier_opt : 23 356
object_subtype_def   : 23
operator_symbol      : 159 179
or_select            : 416 420
param                : 327 328 477
param_s              : 326 328
parenthesized_primary : 242 245
pkg_body             : 152 446 454
pkg_decl             : 15 445
pkg_spec             : 339 474
pragma               : 9 146 254 383 434 441
pragma_arg           : 4 5
pragma_arg_s         : 3 5
pragma_s             : 9 98 104 105 107 108 109 109 119 122 284 389 390 394 395 403 434 435 436
primary              : 234 235 236 237 237
private_opt          : 435 436
private_part         : 341
private_type         : 49 498
procedure_call       : 260 404
prot_body            : 154 456
prot_decl            : 17
prot_def             : 373 374
prot_elem_decl       : 385
prot_elem_decl_s     : 377 385
prot_op_body         : 390
prot_op_body_s       : 388 390
prot_op_decl         : 379 386
prot_op_decl_s       : 375 379
prot_opt             : 133 134
prot_private_opt     : 375
prot_spec            : 372
qualified            : 241 247 516
raise_stmt           : 263
range                : 61 94 129 210 514
range_constr_opt     : 55 93
range_constraint     : 53 72 96 128
range_spec           : 70 74 78
range_spec_opt       : 77 79
real_type            : 44
record_def           : 58 60 97
record_type          : 46
record_type_spec     : 507
relation             : 200 201 202
relational           : 209
rename_decl          : 19
rename_unit          : 358 451
renames              : 356 357 359 360 361 362
rep_spec             : 145 382 403
rep_spec_s           : 368 370 403
requeue_stmt         : 265
return_stmt          : 258
reverse_opt          : 294
select_alt           : 417 418
select_stmt          : 272
select_wait          : 412
selected_comp        : 157
short_circuit        : 202
simple_expression    : 62 62 208 209 209 210 211 222
simple_name          : 3 7 119 155 160 162 164 165 177 365 366 371 374 388 408 457 460 478 479 481 482
simple_stmt          : 252
start_symbol         : 0
statement            : 248 249 251
statement_s          : 249 279 283 288 298 305 426 428 430 464 465
stmts_opt            : 421 422 424 425 427 427 428
subp_default         : 479 480
subprog_body         : 151 392 448 453
subprog_decl         : 14 447
subprog_spec         : 316 336 360 362 381 393 459 473 503
subprog_spec_is_push : 318 337
subtype_decl         : 13
subtype_ind          : 31 50 56 57 58 59 60 84 130 131 132 356 500 501 502
subunit              : 449
subunit_body         : 452
tagged_opt           : 97 349
task_body            : 153 455
task_decl            : 16
task_def             : 365 366
task_private_opt     : 368
task_spec            : 364
term                 : 220 221 222 229
timed_entry_call     : 414
type_completion      : 36
type_decl            : 12
type_def             : 41
unary                : 220
unconstr_array_type  : 80
unit                 : 435 436
unlabeled            : 250
use_clause           : 144 444 483
use_clause_opt       : 439 440 444
used_char            : 178 190
value                : 171 172 197 197 198
value_s              : 170 172 194
value_s_2            : 193 198
variant              : 120 121
variant_part         : 104 109
variant_part_opt     : 103
variant_s            : 119 121
when_opt             : 308
with_clause          : 439 440

Parsing method: LALR

state 0

    (0) S' -> . start_symbol
    (1) start_symbol -> . compilation
    (432) compilation -> .
    (433) compilation -> . compilation comp_unit
    (434) compilation -> . pragma pragma_s
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    PRIVATE         reduce using rule 432 (compilation -> .)
    WITH            reduce using rule 432 (compilation -> .)
    PACKAGE         reduce using rule 432 (compilation -> .)
    SEPARATE        reduce using rule 432 (compilation -> .)
    PROCEDURE       reduce using rule 432 (compilation -> .)
    FUNCTION        reduce using rule 432 (compilation -> .)
    GENERIC         reduce using rule 432 (compilation -> .)
    $end            reduce using rule 432 (compilation -> .)
    PRAGMA          shift and go to state 4

    start_symbol                   shift and go to state 1
    compilation                    shift and go to state 3
    pragma                         shift and go to state 2

state 1

    (0) S' -> start_symbol .



state 2

    (434) compilation -> pragma . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    WITH            reduce using rule 8 (pragma_s -> .)
    PACKAGE         reduce using rule 8 (pragma_s -> .)
    SEPARATE        reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)
    GENERIC         reduce using rule 8 (pragma_s -> .)
    $end            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 5

state 3

    (1) start_symbol -> compilation .
    (433) compilation -> compilation . comp_unit
    (435) comp_unit -> . context_spec private_opt unit pragma_s
    (436) comp_unit -> . private_opt unit pragma_s
    (439) context_spec -> . with_clause use_clause_opt
    (440) context_spec -> . context_spec with_clause use_clause_opt
    (441) context_spec -> . context_spec pragma
    (437) private_opt -> .
    (438) private_opt -> . PRIVATE
    (442) with_clause -> . WITH c_name_list ;

    $end            reduce using rule 1 (start_symbol -> compilation .)
    PACKAGE         reduce using rule 437 (private_opt -> .)
    SEPARATE        reduce using rule 437 (private_opt -> .)
    PROCEDURE       reduce using rule 437 (private_opt -> .)
    FUNCTION        reduce using rule 437 (private_opt -> .)
    GENERIC         reduce using rule 437 (private_opt -> .)
    PRIVATE         shift and go to state 7
    WITH            shift and go to state 11

    context_spec                   shift and go to state 6
    with_clause                    shift and go to state 8
    private_opt                    shift and go to state 9
    comp_unit                      shift and go to state 10

state 4

    (2) pragma -> PRAGMA . IDENTIFIER ;
    (3) pragma -> PRAGMA . simple_name ( pragma_arg_s ) ;
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 12

    simple_name                    shift and go to state 13

state 5

    (434) compilation -> pragma pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    PRIVATE         reduce using rule 434 (compilation -> pragma pragma_s .)
    WITH            reduce using rule 434 (compilation -> pragma pragma_s .)
    PACKAGE         reduce using rule 434 (compilation -> pragma pragma_s .)
    SEPARATE        reduce using rule 434 (compilation -> pragma pragma_s .)
    PROCEDURE       reduce using rule 434 (compilation -> pragma pragma_s .)
    FUNCTION        reduce using rule 434 (compilation -> pragma pragma_s .)
    GENERIC         reduce using rule 434 (compilation -> pragma pragma_s .)
    $end            reduce using rule 434 (compilation -> pragma pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 6

    (435) comp_unit -> context_spec . private_opt unit pragma_s
    (440) context_spec -> context_spec . with_clause use_clause_opt
    (441) context_spec -> context_spec . pragma
    (437) private_opt -> .
    (438) private_opt -> . PRIVATE
    (442) with_clause -> . WITH c_name_list ;
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    PACKAGE         reduce using rule 437 (private_opt -> .)
    SEPARATE        reduce using rule 437 (private_opt -> .)
    PROCEDURE       reduce using rule 437 (private_opt -> .)
    FUNCTION        reduce using rule 437 (private_opt -> .)
    GENERIC         reduce using rule 437 (private_opt -> .)
    PRIVATE         shift and go to state 7
    WITH            shift and go to state 11
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 15
    with_clause                    shift and go to state 16
    private_opt                    shift and go to state 17

state 7

    (438) private_opt -> PRIVATE .

    PACKAGE         reduce using rule 438 (private_opt -> PRIVATE .)
    SEPARATE        reduce using rule 438 (private_opt -> PRIVATE .)
    PROCEDURE       reduce using rule 438 (private_opt -> PRIVATE .)
    FUNCTION        reduce using rule 438 (private_opt -> PRIVATE .)
    GENERIC         reduce using rule 438 (private_opt -> PRIVATE .)


state 8

    (439) context_spec -> with_clause . use_clause_opt
    (443) use_clause_opt -> .
    (444) use_clause_opt -> . use_clause_opt use_clause

    USE             reduce using rule 443 (use_clause_opt -> .)
    PRIVATE         reduce using rule 443 (use_clause_opt -> .)
    WITH            reduce using rule 443 (use_clause_opt -> .)
    PRAGMA          reduce using rule 443 (use_clause_opt -> .)
    PACKAGE         reduce using rule 443 (use_clause_opt -> .)
    SEPARATE        reduce using rule 443 (use_clause_opt -> .)
    PROCEDURE       reduce using rule 443 (use_clause_opt -> .)
    FUNCTION        reduce using rule 443 (use_clause_opt -> .)
    GENERIC         reduce using rule 443 (use_clause_opt -> .)

    use_clause_opt                 shift and go to state 18

state 9

    (436) comp_unit -> private_opt . unit pragma_s
    (445) unit -> . pkg_decl
    (446) unit -> . pkg_body
    (447) unit -> . subprog_decl
    (448) unit -> . subprog_body
    (449) unit -> . subunit
    (450) unit -> . generic_decl
    (451) unit -> . rename_unit
    (339) pkg_decl -> . pkg_spec ;
    (340) pkg_decl -> . generic_pkg_inst ;
    (346) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (316) subprog_decl -> . subprog_spec ;
    (317) subprog_decl -> . generic_subp_inst ;
    (318) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (337) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (452) subunit -> . SEPARATE ( compound_name ) subunit_body
    (473) generic_decl -> . generic_formal_part subprog_spec ;
    (474) generic_decl -> . generic_formal_part pkg_spec ;
    (359) rename_unit -> . PACKAGE compound_name renames ;
    (360) rename_unit -> . subprog_spec renames ;
    (361) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (362) rename_unit -> . generic_formal_part subprog_spec renames ;
    (341) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (319) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (320) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (321) subprog_spec -> . FUNCTION designator
    (503) generic_subp_inst -> . subprog_spec IS generic_inst
    (336) subprog_spec_is_push -> . subprog_spec IS
    (475) generic_formal_part -> . GENERIC
    (476) generic_formal_part -> . generic_formal_part generic_formal

    PACKAGE         shift and go to state 28
    SEPARATE        shift and go to state 20
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21

    subprog_body                   shift and go to state 19
    pkg_body                       shift and go to state 22
    unit                           shift and go to state 23
    subprog_spec_is_push           shift and go to state 24
    generic_decl                   shift and go to state 25
    subprog_spec                   shift and go to state 26
    subunit                        shift and go to state 27
    generic_subp_inst              shift and go to state 29
    rename_unit                    shift and go to state 30
    pkg_decl                       shift and go to state 32
    generic_formal_part            shift and go to state 33
    generic_pkg_inst               shift and go to state 34
    subprog_decl                   shift and go to state 35
    pkg_spec                       shift and go to state 37

state 10

    (433) compilation -> compilation comp_unit .

    PRIVATE         reduce using rule 433 (compilation -> compilation comp_unit .)
    WITH            reduce using rule 433 (compilation -> compilation comp_unit .)
    PACKAGE         reduce using rule 433 (compilation -> compilation comp_unit .)
    SEPARATE        reduce using rule 433 (compilation -> compilation comp_unit .)
    PROCEDURE       reduce using rule 433 (compilation -> compilation comp_unit .)
    FUNCTION        reduce using rule 433 (compilation -> compilation comp_unit .)
    GENERIC         reduce using rule 433 (compilation -> compilation comp_unit .)
    $end            reduce using rule 433 (compilation -> compilation comp_unit .)


state 11

    (442) with_clause -> WITH . c_name_list ;
    (166) c_name_list -> . compound_name
    (167) c_name_list -> . c_name_list , compound_name
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    c_name_list                    shift and go to state 38
    compound_name                  shift and go to state 40
    simple_name                    shift and go to state 41

state 12

    (2) pragma -> PRAGMA IDENTIFIER . ;
    (163) simple_name -> IDENTIFIER .

    ;               shift and go to state 42
    (               reduce using rule 163 (simple_name -> IDENTIFIER .)


state 13

    (3) pragma -> PRAGMA simple_name . ( pragma_arg_s ) ;

    (               shift and go to state 43


state 14

    (9) pragma_s -> pragma_s pragma .

    NuLL            reduce using rule 9 (pragma_s -> pragma_s pragma .)
    PRAGMA          reduce using rule 9 (pragma_s -> pragma_s pragma .)
    CASE            reduce using rule 9 (pragma_s -> pragma_s pragma .)
    error           reduce using rule 9 (pragma_s -> pragma_s pragma .)
    IDENTIFIER      reduce using rule 9 (pragma_s -> pragma_s pragma .)
    END             reduce using rule 9 (pragma_s -> pragma_s pragma .)
    WHEN            reduce using rule 9 (pragma_s -> pragma_s pragma .)
    PRIVATE         reduce using rule 9 (pragma_s -> pragma_s pragma .)
    FOR             reduce using rule 9 (pragma_s -> pragma_s pragma .)
    ENTRY           reduce using rule 9 (pragma_s -> pragma_s pragma .)
    PROCEDURE       reduce using rule 9 (pragma_s -> pragma_s pragma .)
    FUNCTION        reduce using rule 9 (pragma_s -> pragma_s pragma .)
    WITH            reduce using rule 9 (pragma_s -> pragma_s pragma .)
    PACKAGE         reduce using rule 9 (pragma_s -> pragma_s pragma .)
    SEPARATE        reduce using rule 9 (pragma_s -> pragma_s pragma .)
    GENERIC         reduce using rule 9 (pragma_s -> pragma_s pragma .)
    $end            reduce using rule 9 (pragma_s -> pragma_s pragma .)


state 15

    (441) context_spec -> context_spec pragma .

    PRIVATE         reduce using rule 441 (context_spec -> context_spec pragma .)
    WITH            reduce using rule 441 (context_spec -> context_spec pragma .)
    PRAGMA          reduce using rule 441 (context_spec -> context_spec pragma .)
    PACKAGE         reduce using rule 441 (context_spec -> context_spec pragma .)
    SEPARATE        reduce using rule 441 (context_spec -> context_spec pragma .)
    PROCEDURE       reduce using rule 441 (context_spec -> context_spec pragma .)
    FUNCTION        reduce using rule 441 (context_spec -> context_spec pragma .)
    GENERIC         reduce using rule 441 (context_spec -> context_spec pragma .)


state 16

    (440) context_spec -> context_spec with_clause . use_clause_opt
    (443) use_clause_opt -> .
    (444) use_clause_opt -> . use_clause_opt use_clause

    USE             reduce using rule 443 (use_clause_opt -> .)
    PRIVATE         reduce using rule 443 (use_clause_opt -> .)
    WITH            reduce using rule 443 (use_clause_opt -> .)
    PRAGMA          reduce using rule 443 (use_clause_opt -> .)
    PACKAGE         reduce using rule 443 (use_clause_opt -> .)
    SEPARATE        reduce using rule 443 (use_clause_opt -> .)
    PROCEDURE       reduce using rule 443 (use_clause_opt -> .)
    FUNCTION        reduce using rule 443 (use_clause_opt -> .)
    GENERIC         reduce using rule 443 (use_clause_opt -> .)

    use_clause_opt                 shift and go to state 44

state 17

    (435) comp_unit -> context_spec private_opt . unit pragma_s
    (445) unit -> . pkg_decl
    (446) unit -> . pkg_body
    (447) unit -> . subprog_decl
    (448) unit -> . subprog_body
    (449) unit -> . subunit
    (450) unit -> . generic_decl
    (451) unit -> . rename_unit
    (339) pkg_decl -> . pkg_spec ;
    (340) pkg_decl -> . generic_pkg_inst ;
    (346) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (316) subprog_decl -> . subprog_spec ;
    (317) subprog_decl -> . generic_subp_inst ;
    (318) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (337) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (452) subunit -> . SEPARATE ( compound_name ) subunit_body
    (473) generic_decl -> . generic_formal_part subprog_spec ;
    (474) generic_decl -> . generic_formal_part pkg_spec ;
    (359) rename_unit -> . PACKAGE compound_name renames ;
    (360) rename_unit -> . subprog_spec renames ;
    (361) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (362) rename_unit -> . generic_formal_part subprog_spec renames ;
    (341) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (319) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (320) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (321) subprog_spec -> . FUNCTION designator
    (503) generic_subp_inst -> . subprog_spec IS generic_inst
    (336) subprog_spec_is_push -> . subprog_spec IS
    (475) generic_formal_part -> . GENERIC
    (476) generic_formal_part -> . generic_formal_part generic_formal

    PACKAGE         shift and go to state 28
    SEPARATE        shift and go to state 20
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21

    subprog_body                   shift and go to state 19
    subprog_decl                   shift and go to state 35
    unit                           shift and go to state 45
    subprog_spec_is_push           shift and go to state 24
    generic_decl                   shift and go to state 25
    subprog_spec                   shift and go to state 26
    subunit                        shift and go to state 27
    generic_subp_inst              shift and go to state 29
    rename_unit                    shift and go to state 30
    pkg_decl                       shift and go to state 32
    generic_formal_part            shift and go to state 33
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 22
    pkg_spec                       shift and go to state 37

state 18

    (439) context_spec -> with_clause use_clause_opt .
    (444) use_clause_opt -> use_clause_opt . use_clause
    (352) use_clause -> . USE name_s ;
    (353) use_clause -> . USE TYPE name_s ;

    PRIVATE         reduce using rule 439 (context_spec -> with_clause use_clause_opt .)
    WITH            reduce using rule 439 (context_spec -> with_clause use_clause_opt .)
    PRAGMA          reduce using rule 439 (context_spec -> with_clause use_clause_opt .)
    PACKAGE         reduce using rule 439 (context_spec -> with_clause use_clause_opt .)
    SEPARATE        reduce using rule 439 (context_spec -> with_clause use_clause_opt .)
    PROCEDURE       reduce using rule 439 (context_spec -> with_clause use_clause_opt .)
    FUNCTION        reduce using rule 439 (context_spec -> with_clause use_clause_opt .)
    GENERIC         reduce using rule 439 (context_spec -> with_clause use_clause_opt .)
    USE             shift and go to state 46

    use_clause                     shift and go to state 47

state 19

    (448) unit -> subprog_body .

    PRAGMA          reduce using rule 448 (unit -> subprog_body .)
    PRIVATE         reduce using rule 448 (unit -> subprog_body .)
    WITH            reduce using rule 448 (unit -> subprog_body .)
    PACKAGE         reduce using rule 448 (unit -> subprog_body .)
    SEPARATE        reduce using rule 448 (unit -> subprog_body .)
    PROCEDURE       reduce using rule 448 (unit -> subprog_body .)
    FUNCTION        reduce using rule 448 (unit -> subprog_body .)
    GENERIC         reduce using rule 448 (unit -> subprog_body .)
    $end            reduce using rule 448 (unit -> subprog_body .)


state 20

    (452) subunit -> SEPARATE . ( compound_name ) subunit_body

    (               shift and go to state 48


state 21

    (475) generic_formal_part -> GENERIC .

    PACKAGE         reduce using rule 475 (generic_formal_part -> GENERIC .)
    PROCEDURE       reduce using rule 475 (generic_formal_part -> GENERIC .)
    FUNCTION        reduce using rule 475 (generic_formal_part -> GENERIC .)
    TYPE            reduce using rule 475 (generic_formal_part -> GENERIC .)
    WITH            reduce using rule 475 (generic_formal_part -> GENERIC .)
    error           reduce using rule 475 (generic_formal_part -> GENERIC .)
    USE             reduce using rule 475 (generic_formal_part -> GENERIC .)
    IDENTIFIER      reduce using rule 475 (generic_formal_part -> GENERIC .)


state 22

    (446) unit -> pkg_body .

    PRAGMA          reduce using rule 446 (unit -> pkg_body .)
    PRIVATE         reduce using rule 446 (unit -> pkg_body .)
    WITH            reduce using rule 446 (unit -> pkg_body .)
    PACKAGE         reduce using rule 446 (unit -> pkg_body .)
    SEPARATE        reduce using rule 446 (unit -> pkg_body .)
    PROCEDURE       reduce using rule 446 (unit -> pkg_body .)
    FUNCTION        reduce using rule 446 (unit -> pkg_body .)
    GENERIC         reduce using rule 446 (unit -> pkg_body .)
    $end            reduce using rule 446 (unit -> pkg_body .)


state 23

    (436) comp_unit -> private_opt unit . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    WITH            reduce using rule 8 (pragma_s -> .)
    PACKAGE         reduce using rule 8 (pragma_s -> .)
    SEPARATE        reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)
    GENERIC         reduce using rule 8 (pragma_s -> .)
    $end            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 49

state 24

    (318) subprog_decl -> subprog_spec_is_push . ABSTRACT ;
    (337) subprog_body -> subprog_spec_is_push . decl_part block_body END id_opt ;
    (137) decl_part -> .
    (138) decl_part -> . decl_item_or_body_s1
    (147) decl_item_or_body_s1 -> . decl_item_or_body
    (148) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (149) decl_item_or_body -> . body
    (150) decl_item_or_body -> . decl_item
    (151) body -> . subprog_body
    (152) body -> . pkg_body
    (153) body -> . task_body
    (154) body -> . prot_body
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (337) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (346) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (371) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (388) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (352) use_clause -> . USE name_s ;
    (353) use_clause -> . USE TYPE name_s ;
    (506) rep_spec -> . attrib_def
    (507) rep_spec -> . record_type_spec
    (508) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (336) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (316) subprog_decl -> . subprog_spec ;
    (317) subprog_decl -> . generic_subp_inst ;
    (318) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (339) pkg_decl -> . pkg_spec ;
    (340) pkg_decl -> . generic_pkg_inst ;
    (364) task_decl -> . task_spec ;
    (372) prot_decl -> . prot_spec ;
    (461) exception_decl -> . def_id_s : EXCEPTION ;
    (356) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (357) rename_decl -> . def_id_s : EXCEPTION renames ;
    (358) rename_decl -> . rename_unit
    (473) generic_decl -> . generic_formal_part subprog_spec ;
    (474) generic_decl -> . generic_formal_part pkg_spec ;
    (457) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (458) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (459) body_stub -> . subprog_spec IS SEPARATE ;
    (460) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (509) attrib_def -> . FOR mark USE expression ;
    (510) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (515) address_spec -> . FOR mark USE AT expression ;
    (319) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (320) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (321) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (503) generic_subp_inst -> . subprog_spec IS generic_inst
    (341) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (365) task_spec -> . TASK simple_name task_def
    (366) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (373) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (374) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (359) rename_unit -> . PACKAGE compound_name renames ;
    (360) rename_unit -> . subprog_spec renames ;
    (361) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (362) rename_unit -> . generic_formal_part subprog_spec renames ;
    (475) generic_formal_part -> . GENERIC
    (476) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    ABSTRACT        shift and go to state 81
    BEGIN           reduce using rule 137 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 54
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 25

    (450) unit -> generic_decl .

    PRAGMA          reduce using rule 450 (unit -> generic_decl .)
    PRIVATE         reduce using rule 450 (unit -> generic_decl .)
    WITH            reduce using rule 450 (unit -> generic_decl .)
    PACKAGE         reduce using rule 450 (unit -> generic_decl .)
    SEPARATE        reduce using rule 450 (unit -> generic_decl .)
    PROCEDURE       reduce using rule 450 (unit -> generic_decl .)
    FUNCTION        reduce using rule 450 (unit -> generic_decl .)
    GENERIC         reduce using rule 450 (unit -> generic_decl .)
    $end            reduce using rule 450 (unit -> generic_decl .)


state 26

    (316) subprog_decl -> subprog_spec . ;
    (360) rename_unit -> subprog_spec . renames ;
    (503) generic_subp_inst -> subprog_spec . IS generic_inst
    (336) subprog_spec_is_push -> subprog_spec . IS
    (363) renames -> . RENAMES name

    ;               shift and go to state 97
    IS              shift and go to state 96
    RENAMES         shift and go to state 95

    renames                        shift and go to state 94

state 27

    (449) unit -> subunit .

    PRAGMA          reduce using rule 449 (unit -> subunit .)
    PRIVATE         reduce using rule 449 (unit -> subunit .)
    WITH            reduce using rule 449 (unit -> subunit .)
    PACKAGE         reduce using rule 449 (unit -> subunit .)
    SEPARATE        reduce using rule 449 (unit -> subunit .)
    PROCEDURE       reduce using rule 449 (unit -> subunit .)
    FUNCTION        reduce using rule 449 (unit -> subunit .)
    GENERIC         reduce using rule 449 (unit -> subunit .)
    $end            reduce using rule 449 (unit -> subunit .)


state 28

    (346) pkg_body -> PACKAGE . BODY compound_name IS decl_part body_opt END c_id_opt ;
    (359) rename_unit -> PACKAGE . compound_name renames ;
    (341) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> PACKAGE . compound_name IS generic_inst
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    BODY            shift and go to state 98
    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 41
    compound_name                  shift and go to state 99

state 29

    (317) subprog_decl -> generic_subp_inst . ;

    ;               shift and go to state 100


state 30

    (451) unit -> rename_unit .

    PRAGMA          reduce using rule 451 (unit -> rename_unit .)
    PRIVATE         reduce using rule 451 (unit -> rename_unit .)
    WITH            reduce using rule 451 (unit -> rename_unit .)
    PACKAGE         reduce using rule 451 (unit -> rename_unit .)
    SEPARATE        reduce using rule 451 (unit -> rename_unit .)
    PROCEDURE       reduce using rule 451 (unit -> rename_unit .)
    FUNCTION        reduce using rule 451 (unit -> rename_unit .)
    GENERIC         reduce using rule 451 (unit -> rename_unit .)
    $end            reduce using rule 451 (unit -> rename_unit .)


state 31

    (319) subprog_spec -> PROCEDURE . compound_name formal_part_opt
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 101
    simple_name                    shift and go to state 41

state 32

    (445) unit -> pkg_decl .

    PRAGMA          reduce using rule 445 (unit -> pkg_decl .)
    PRIVATE         reduce using rule 445 (unit -> pkg_decl .)
    WITH            reduce using rule 445 (unit -> pkg_decl .)
    PACKAGE         reduce using rule 445 (unit -> pkg_decl .)
    SEPARATE        reduce using rule 445 (unit -> pkg_decl .)
    PROCEDURE       reduce using rule 445 (unit -> pkg_decl .)
    FUNCTION        reduce using rule 445 (unit -> pkg_decl .)
    GENERIC         reduce using rule 445 (unit -> pkg_decl .)
    $end            reduce using rule 445 (unit -> pkg_decl .)


state 33

    (473) generic_decl -> generic_formal_part . subprog_spec ;
    (474) generic_decl -> generic_formal_part . pkg_spec ;
    (361) rename_unit -> generic_formal_part . PACKAGE compound_name renames ;
    (362) rename_unit -> generic_formal_part . subprog_spec renames ;
    (476) generic_formal_part -> generic_formal_part . generic_formal
    (319) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (320) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (321) subprog_spec -> . FUNCTION designator
    (341) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (477) generic_formal -> . param ;
    (478) generic_formal -> . TYPE simple_name generic_discrim_part_opt IS generic_type_def ;
    (479) generic_formal -> . WITH PROCEDURE simple_name formal_part_opt subp_default ;
    (480) generic_formal -> . WITH FUNCTION designator formal_part_opt RETURN name subp_default ;
    (481) generic_formal -> . WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ;
    (482) generic_formal -> . WITH PACKAGE simple_name IS NEW name ;
    (483) generic_formal -> . use_clause
    (329) param -> . def_id_s : mode mark init_opt
    (330) param -> . error
    (352) use_clause -> . USE name_s ;
    (353) use_clause -> . USE TYPE name_s ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    PACKAGE         shift and go to state 106
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    TYPE            shift and go to state 111
    WITH            shift and go to state 102
    error           shift and go to state 109
    USE             shift and go to state 46
    IDENTIFIER      shift and go to state 76

    param                          shift and go to state 103
    subprog_spec                   shift and go to state 104
    def_id_s                       shift and go to state 105
    def_id                         shift and go to state 89
    generic_formal                 shift and go to state 107
    use_clause                     shift and go to state 108
    pkg_spec                       shift and go to state 110

state 34

    (340) pkg_decl -> generic_pkg_inst . ;

    ;               shift and go to state 112


state 35

    (447) unit -> subprog_decl .

    PRAGMA          reduce using rule 447 (unit -> subprog_decl .)
    PRIVATE         reduce using rule 447 (unit -> subprog_decl .)
    WITH            reduce using rule 447 (unit -> subprog_decl .)
    PACKAGE         reduce using rule 447 (unit -> subprog_decl .)
    SEPARATE        reduce using rule 447 (unit -> subprog_decl .)
    PROCEDURE       reduce using rule 447 (unit -> subprog_decl .)
    FUNCTION        reduce using rule 447 (unit -> subprog_decl .)
    GENERIC         reduce using rule 447 (unit -> subprog_decl .)
    $end            reduce using rule 447 (unit -> subprog_decl .)


state 36

    (320) subprog_spec -> FUNCTION . designator formal_part_opt RETURN name
    (321) subprog_spec -> FUNCTION . designator
    (322) designator -> . compound_name
    (323) designator -> . STRING
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 114
    designator                     shift and go to state 113
    simple_name                    shift and go to state 41

state 37

    (339) pkg_decl -> pkg_spec . ;

    ;               shift and go to state 116


state 38

    (442) with_clause -> WITH c_name_list . ;
    (167) c_name_list -> c_name_list . , compound_name

    ;               shift and go to state 117
    ,               shift and go to state 118


state 39

    (163) simple_name -> IDENTIFIER .

    TICK            reduce using rule 163 (simple_name -> IDENTIFIER .)
    (               reduce using rule 163 (simple_name -> IDENTIFIER .)
    .               reduce using rule 163 (simple_name -> IDENTIFIER .)
    STARSTAR        reduce using rule 163 (simple_name -> IDENTIFIER .)
    *               reduce using rule 163 (simple_name -> IDENTIFIER .)
    /               reduce using rule 163 (simple_name -> IDENTIFIER .)
    MOD             reduce using rule 163 (simple_name -> IDENTIFIER .)
    REM             reduce using rule 163 (simple_name -> IDENTIFIER .)
    =               reduce using rule 163 (simple_name -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 163 (simple_name -> IDENTIFIER .)
    <               reduce using rule 163 (simple_name -> IDENTIFIER .)
    LESSEQ          reduce using rule 163 (simple_name -> IDENTIFIER .)
    >               reduce using rule 163 (simple_name -> IDENTIFIER .)
    GREATEREQ       reduce using rule 163 (simple_name -> IDENTIFIER .)
    IN              reduce using rule 163 (simple_name -> IDENTIFIER .)
    NOT             reduce using rule 163 (simple_name -> IDENTIFIER .)
    +               reduce using rule 163 (simple_name -> IDENTIFIER .)
    -               reduce using rule 163 (simple_name -> IDENTIFIER .)
    &               reduce using rule 163 (simple_name -> IDENTIFIER .)
    ;               reduce using rule 163 (simple_name -> IDENTIFIER .)
    AND             reduce using rule 163 (simple_name -> IDENTIFIER .)
    OR              reduce using rule 163 (simple_name -> IDENTIFIER .)
    XOR             reduce using rule 163 (simple_name -> IDENTIFIER .)
    USE             reduce using rule 163 (simple_name -> IDENTIFIER .)
    )               reduce using rule 163 (simple_name -> IDENTIFIER .)
    ,               reduce using rule 163 (simple_name -> IDENTIFIER .)
    DOTDOT          reduce using rule 163 (simple_name -> IDENTIFIER .)
    WITH            reduce using rule 163 (simple_name -> IDENTIFIER .)
    ARROW           reduce using rule 163 (simple_name -> IDENTIFIER .)
    |               reduce using rule 163 (simple_name -> IDENTIFIER .)
    IS              reduce using rule 163 (simple_name -> IDENTIFIER .)
    THEN            reduce using rule 163 (simple_name -> IDENTIFIER .)
    LOOP            reduce using rule 163 (simple_name -> IDENTIFIER .)
    RANGE           reduce using rule 163 (simple_name -> IDENTIFIER .)
    DIGITS          reduce using rule 163 (simple_name -> IDENTIFIER .)
    RENAMES         reduce using rule 163 (simple_name -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 163 (simple_name -> IDENTIFIER .)
    RETURN          reduce using rule 163 (simple_name -> IDENTIFIER .)
    DO              reduce using rule 163 (simple_name -> IDENTIFIER .)
    AT              reduce using rule 163 (simple_name -> IDENTIFIER .)
    WHEN            reduce using rule 163 (simple_name -> IDENTIFIER .)


state 40

    (166) c_name_list -> compound_name .
    (165) compound_name -> compound_name . . simple_name

    ;               reduce using rule 166 (c_name_list -> compound_name .)
    ,               reduce using rule 166 (c_name_list -> compound_name .)
    .               shift and go to state 119


state 41

    (164) compound_name -> simple_name .

    .               reduce using rule 164 (compound_name -> simple_name .)
    ;               reduce using rule 164 (compound_name -> simple_name .)
    IS              reduce using rule 164 (compound_name -> simple_name .)
    ,               reduce using rule 164 (compound_name -> simple_name .)
    RENAMES         reduce using rule 164 (compound_name -> simple_name .)
    (               reduce using rule 164 (compound_name -> simple_name .)
    RETURN          reduce using rule 164 (compound_name -> simple_name .)
    )               reduce using rule 164 (compound_name -> simple_name .)


state 42

    (2) pragma -> PRAGMA IDENTIFIER ; .

    LESSLESS        reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    error           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    PRAGMA          reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    NuLL            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    EXIT            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    RETURN          reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    GOTO            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    DELAY           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    ABORT           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    RAISE           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    REQUEUE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    IF              reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    CASE            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    IDENTIFIER      reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    ACCEPT          reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    SELECT          reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    STRING          reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    WHILE           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    DECLARE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    FOR             reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    LOOP            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    BEGIN           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    END             reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    PACKAGE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    TASK            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    PROTECTED       reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    USE             reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    TYPE            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    SUBTYPE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    PROCEDURE       reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    FUNCTION        reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    GENERIC         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    WHEN            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    ENTRY           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    PRIVATE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    OR              reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    ELSE            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    THEN            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    WITH            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    SEPARATE        reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    $end            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    EXCEPTION       reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    ELSIF           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)


state 43

    (3) pragma -> PRAGMA simple_name ( . pragma_arg_s ) ;
    (4) pragma_arg_s -> . pragma_arg
    (5) pragma_arg_s -> . pragma_arg_s , pragma_arg
    (6) pragma_arg -> . expression
    (7) pragma_arg -> . simple_name ARROW expression
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (163) simple_name -> . IDENTIFIER
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 39
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    pragma_arg                     shift and go to state 123
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 131
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    pragma_arg_s                   shift and go to state 139
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    used_char                      shift and go to state 144
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 153

state 44

    (440) context_spec -> context_spec with_clause use_clause_opt .
    (444) use_clause_opt -> use_clause_opt . use_clause
    (352) use_clause -> . USE name_s ;
    (353) use_clause -> . USE TYPE name_s ;

    PRIVATE         reduce using rule 440 (context_spec -> context_spec with_clause use_clause_opt .)
    WITH            reduce using rule 440 (context_spec -> context_spec with_clause use_clause_opt .)
    PRAGMA          reduce using rule 440 (context_spec -> context_spec with_clause use_clause_opt .)
    PACKAGE         reduce using rule 440 (context_spec -> context_spec with_clause use_clause_opt .)
    SEPARATE        reduce using rule 440 (context_spec -> context_spec with_clause use_clause_opt .)
    PROCEDURE       reduce using rule 440 (context_spec -> context_spec with_clause use_clause_opt .)
    FUNCTION        reduce using rule 440 (context_spec -> context_spec with_clause use_clause_opt .)
    GENERIC         reduce using rule 440 (context_spec -> context_spec with_clause use_clause_opt .)
    USE             shift and go to state 46

    use_clause                     shift and go to state 47

state 45

    (435) comp_unit -> context_spec private_opt unit . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    WITH            reduce using rule 8 (pragma_s -> .)
    PACKAGE         reduce using rule 8 (pragma_s -> .)
    SEPARATE        reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)
    GENERIC         reduce using rule 8 (pragma_s -> .)
    $end            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 154

state 46

    (352) use_clause -> USE . name_s ;
    (353) use_clause -> USE . TYPE name_s ;
    (354) name_s -> . name
    (355) name_s -> . name_s , name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    TYPE            shift and go to state 157
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name_s                         shift and go to state 155
    name                           shift and go to state 156
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 47

    (444) use_clause_opt -> use_clause_opt use_clause .

    USE             reduce using rule 444 (use_clause_opt -> use_clause_opt use_clause .)
    PRIVATE         reduce using rule 444 (use_clause_opt -> use_clause_opt use_clause .)
    WITH            reduce using rule 444 (use_clause_opt -> use_clause_opt use_clause .)
    PRAGMA          reduce using rule 444 (use_clause_opt -> use_clause_opt use_clause .)
    PACKAGE         reduce using rule 444 (use_clause_opt -> use_clause_opt use_clause .)
    SEPARATE        reduce using rule 444 (use_clause_opt -> use_clause_opt use_clause .)
    PROCEDURE       reduce using rule 444 (use_clause_opt -> use_clause_opt use_clause .)
    FUNCTION        reduce using rule 444 (use_clause_opt -> use_clause_opt use_clause .)
    GENERIC         reduce using rule 444 (use_clause_opt -> use_clause_opt use_clause .)


state 48

    (452) subunit -> SEPARATE ( . compound_name ) subunit_body
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 159
    simple_name                    shift and go to state 41

state 49

    (436) comp_unit -> private_opt unit pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    PRIVATE         reduce using rule 436 (comp_unit -> private_opt unit pragma_s .)
    WITH            reduce using rule 436 (comp_unit -> private_opt unit pragma_s .)
    PACKAGE         reduce using rule 436 (comp_unit -> private_opt unit pragma_s .)
    SEPARATE        reduce using rule 436 (comp_unit -> private_opt unit pragma_s .)
    PROCEDURE       reduce using rule 436 (comp_unit -> private_opt unit pragma_s .)
    FUNCTION        reduce using rule 436 (comp_unit -> private_opt unit pragma_s .)
    GENERIC         reduce using rule 436 (comp_unit -> private_opt unit pragma_s .)
    $end            reduce using rule 436 (comp_unit -> private_opt unit pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 50

    (143) decl_item -> decl .

    error           reduce using rule 143 (decl_item -> decl .)
    USE             reduce using rule 143 (decl_item -> decl .)
    PRAGMA          reduce using rule 143 (decl_item -> decl .)
    TYPE            reduce using rule 143 (decl_item -> decl .)
    SUBTYPE         reduce using rule 143 (decl_item -> decl .)
    TASK            reduce using rule 143 (decl_item -> decl .)
    PACKAGE         reduce using rule 143 (decl_item -> decl .)
    PROTECTED       reduce using rule 143 (decl_item -> decl .)
    FOR             reduce using rule 143 (decl_item -> decl .)
    PROCEDURE       reduce using rule 143 (decl_item -> decl .)
    FUNCTION        reduce using rule 143 (decl_item -> decl .)
    GENERIC         reduce using rule 143 (decl_item -> decl .)
    IDENTIFIER      reduce using rule 143 (decl_item -> decl .)
    PRIVATE         reduce using rule 143 (decl_item -> decl .)
    END             reduce using rule 143 (decl_item -> decl .)
    BEGIN           reduce using rule 143 (decl_item -> decl .)


state 51

    (388) prot_body -> PROTECTED . BODY simple_name IS prot_op_body_s END id_opt ;
    (460) body_stub -> PROTECTED . BODY simple_name IS SEPARATE ;
    (373) prot_spec -> PROTECTED . IDENTIFIER prot_def
    (374) prot_spec -> PROTECTED . TYPE simple_name discrim_part_opt prot_def

    BODY            shift and go to state 160
    IDENTIFIER      shift and go to state 161
    TYPE            shift and go to state 162


state 52

    (508) rep_spec -> address_spec .

    error           reduce using rule 508 (rep_spec -> address_spec .)
    USE             reduce using rule 508 (rep_spec -> address_spec .)
    PRAGMA          reduce using rule 508 (rep_spec -> address_spec .)
    TYPE            reduce using rule 508 (rep_spec -> address_spec .)
    SUBTYPE         reduce using rule 508 (rep_spec -> address_spec .)
    TASK            reduce using rule 508 (rep_spec -> address_spec .)
    PACKAGE         reduce using rule 508 (rep_spec -> address_spec .)
    PROTECTED       reduce using rule 508 (rep_spec -> address_spec .)
    FOR             reduce using rule 508 (rep_spec -> address_spec .)
    PROCEDURE       reduce using rule 508 (rep_spec -> address_spec .)
    FUNCTION        reduce using rule 508 (rep_spec -> address_spec .)
    GENERIC         reduce using rule 508 (rep_spec -> address_spec .)
    IDENTIFIER      reduce using rule 508 (rep_spec -> address_spec .)
    PRIVATE         reduce using rule 508 (rep_spec -> address_spec .)
    END             reduce using rule 508 (rep_spec -> address_spec .)
    BEGIN           reduce using rule 508 (rep_spec -> address_spec .)
    ENTRY           reduce using rule 508 (rep_spec -> address_spec .)


state 53

    (150) decl_item_or_body -> decl_item .

    PACKAGE         reduce using rule 150 (decl_item_or_body -> decl_item .)
    TASK            reduce using rule 150 (decl_item_or_body -> decl_item .)
    PROTECTED       reduce using rule 150 (decl_item_or_body -> decl_item .)
    error           reduce using rule 150 (decl_item_or_body -> decl_item .)
    USE             reduce using rule 150 (decl_item_or_body -> decl_item .)
    PRAGMA          reduce using rule 150 (decl_item_or_body -> decl_item .)
    TYPE            reduce using rule 150 (decl_item_or_body -> decl_item .)
    SUBTYPE         reduce using rule 150 (decl_item_or_body -> decl_item .)
    FOR             reduce using rule 150 (decl_item_or_body -> decl_item .)
    PROCEDURE       reduce using rule 150 (decl_item_or_body -> decl_item .)
    FUNCTION        reduce using rule 150 (decl_item_or_body -> decl_item .)
    GENERIC         reduce using rule 150 (decl_item_or_body -> decl_item .)
    IDENTIFIER      reduce using rule 150 (decl_item_or_body -> decl_item .)
    BEGIN           reduce using rule 150 (decl_item_or_body -> decl_item .)
    END             reduce using rule 150 (decl_item_or_body -> decl_item .)


state 54

    (337) subprog_body -> subprog_spec_is_push decl_part . block_body END id_opt ;
    (304) block_body -> . BEGIN handled_stmt_s

    BEGIN           shift and go to state 163

    block_body                     shift and go to state 164

state 55

    (17) decl -> prot_decl .

    PACKAGE         reduce using rule 17 (decl -> prot_decl .)
    TASK            reduce using rule 17 (decl -> prot_decl .)
    PROTECTED       reduce using rule 17 (decl -> prot_decl .)
    error           reduce using rule 17 (decl -> prot_decl .)
    USE             reduce using rule 17 (decl -> prot_decl .)
    PRAGMA          reduce using rule 17 (decl -> prot_decl .)
    TYPE            reduce using rule 17 (decl -> prot_decl .)
    SUBTYPE         reduce using rule 17 (decl -> prot_decl .)
    FOR             reduce using rule 17 (decl -> prot_decl .)
    PROCEDURE       reduce using rule 17 (decl -> prot_decl .)
    FUNCTION        reduce using rule 17 (decl -> prot_decl .)
    GENERIC         reduce using rule 17 (decl -> prot_decl .)
    IDENTIFIER      reduce using rule 17 (decl -> prot_decl .)
    BEGIN           reduce using rule 17 (decl -> prot_decl .)
    END             reduce using rule 17 (decl -> prot_decl .)
    PRIVATE         reduce using rule 17 (decl -> prot_decl .)


state 56

    (12) decl -> type_decl .

    PACKAGE         reduce using rule 12 (decl -> type_decl .)
    TASK            reduce using rule 12 (decl -> type_decl .)
    PROTECTED       reduce using rule 12 (decl -> type_decl .)
    error           reduce using rule 12 (decl -> type_decl .)
    USE             reduce using rule 12 (decl -> type_decl .)
    PRAGMA          reduce using rule 12 (decl -> type_decl .)
    TYPE            reduce using rule 12 (decl -> type_decl .)
    SUBTYPE         reduce using rule 12 (decl -> type_decl .)
    FOR             reduce using rule 12 (decl -> type_decl .)
    PROCEDURE       reduce using rule 12 (decl -> type_decl .)
    FUNCTION        reduce using rule 12 (decl -> type_decl .)
    GENERIC         reduce using rule 12 (decl -> type_decl .)
    IDENTIFIER      reduce using rule 12 (decl -> type_decl .)
    BEGIN           reduce using rule 12 (decl -> type_decl .)
    END             reduce using rule 12 (decl -> type_decl .)
    PRIVATE         reduce using rule 12 (decl -> type_decl .)


state 57

    (15) decl -> pkg_decl .

    PACKAGE         reduce using rule 15 (decl -> pkg_decl .)
    TASK            reduce using rule 15 (decl -> pkg_decl .)
    PROTECTED       reduce using rule 15 (decl -> pkg_decl .)
    error           reduce using rule 15 (decl -> pkg_decl .)
    USE             reduce using rule 15 (decl -> pkg_decl .)
    PRAGMA          reduce using rule 15 (decl -> pkg_decl .)
    TYPE            reduce using rule 15 (decl -> pkg_decl .)
    SUBTYPE         reduce using rule 15 (decl -> pkg_decl .)
    FOR             reduce using rule 15 (decl -> pkg_decl .)
    PROCEDURE       reduce using rule 15 (decl -> pkg_decl .)
    FUNCTION        reduce using rule 15 (decl -> pkg_decl .)
    GENERIC         reduce using rule 15 (decl -> pkg_decl .)
    IDENTIFIER      reduce using rule 15 (decl -> pkg_decl .)
    BEGIN           reduce using rule 15 (decl -> pkg_decl .)
    END             reduce using rule 15 (decl -> pkg_decl .)
    PRIVATE         reduce using rule 15 (decl -> pkg_decl .)


state 58

    (14) decl -> subprog_decl .

    PACKAGE         reduce using rule 14 (decl -> subprog_decl .)
    TASK            reduce using rule 14 (decl -> subprog_decl .)
    PROTECTED       reduce using rule 14 (decl -> subprog_decl .)
    error           reduce using rule 14 (decl -> subprog_decl .)
    USE             reduce using rule 14 (decl -> subprog_decl .)
    PRAGMA          reduce using rule 14 (decl -> subprog_decl .)
    TYPE            reduce using rule 14 (decl -> subprog_decl .)
    SUBTYPE         reduce using rule 14 (decl -> subprog_decl .)
    FOR             reduce using rule 14 (decl -> subprog_decl .)
    PROCEDURE       reduce using rule 14 (decl -> subprog_decl .)
    FUNCTION        reduce using rule 14 (decl -> subprog_decl .)
    GENERIC         reduce using rule 14 (decl -> subprog_decl .)
    IDENTIFIER      reduce using rule 14 (decl -> subprog_decl .)
    BEGIN           reduce using rule 14 (decl -> subprog_decl .)
    END             reduce using rule 14 (decl -> subprog_decl .)
    PRIVATE         reduce using rule 14 (decl -> subprog_decl .)


state 59

    (151) body -> subprog_body .

    PACKAGE         reduce using rule 151 (body -> subprog_body .)
    TASK            reduce using rule 151 (body -> subprog_body .)
    PROTECTED       reduce using rule 151 (body -> subprog_body .)
    error           reduce using rule 151 (body -> subprog_body .)
    USE             reduce using rule 151 (body -> subprog_body .)
    PRAGMA          reduce using rule 151 (body -> subprog_body .)
    TYPE            reduce using rule 151 (body -> subprog_body .)
    SUBTYPE         reduce using rule 151 (body -> subprog_body .)
    FOR             reduce using rule 151 (body -> subprog_body .)
    PROCEDURE       reduce using rule 151 (body -> subprog_body .)
    FUNCTION        reduce using rule 151 (body -> subprog_body .)
    GENERIC         reduce using rule 151 (body -> subprog_body .)
    IDENTIFIER      reduce using rule 151 (body -> subprog_body .)
    BEGIN           reduce using rule 151 (body -> subprog_body .)
    END             reduce using rule 151 (body -> subprog_body .)


state 60

    (16) decl -> task_decl .

    PACKAGE         reduce using rule 16 (decl -> task_decl .)
    TASK            reduce using rule 16 (decl -> task_decl .)
    PROTECTED       reduce using rule 16 (decl -> task_decl .)
    error           reduce using rule 16 (decl -> task_decl .)
    USE             reduce using rule 16 (decl -> task_decl .)
    PRAGMA          reduce using rule 16 (decl -> task_decl .)
    TYPE            reduce using rule 16 (decl -> task_decl .)
    SUBTYPE         reduce using rule 16 (decl -> task_decl .)
    FOR             reduce using rule 16 (decl -> task_decl .)
    PROCEDURE       reduce using rule 16 (decl -> task_decl .)
    FUNCTION        reduce using rule 16 (decl -> task_decl .)
    GENERIC         reduce using rule 16 (decl -> task_decl .)
    IDENTIFIER      reduce using rule 16 (decl -> task_decl .)
    BEGIN           reduce using rule 16 (decl -> task_decl .)
    END             reduce using rule 16 (decl -> task_decl .)
    PRIVATE         reduce using rule 16 (decl -> task_decl .)


state 61

    (13) decl -> subtype_decl .

    PACKAGE         reduce using rule 13 (decl -> subtype_decl .)
    TASK            reduce using rule 13 (decl -> subtype_decl .)
    PROTECTED       reduce using rule 13 (decl -> subtype_decl .)
    error           reduce using rule 13 (decl -> subtype_decl .)
    USE             reduce using rule 13 (decl -> subtype_decl .)
    PRAGMA          reduce using rule 13 (decl -> subtype_decl .)
    TYPE            reduce using rule 13 (decl -> subtype_decl .)
    SUBTYPE         reduce using rule 13 (decl -> subtype_decl .)
    FOR             reduce using rule 13 (decl -> subtype_decl .)
    PROCEDURE       reduce using rule 13 (decl -> subtype_decl .)
    FUNCTION        reduce using rule 13 (decl -> subtype_decl .)
    GENERIC         reduce using rule 13 (decl -> subtype_decl .)
    IDENTIFIER      reduce using rule 13 (decl -> subtype_decl .)
    BEGIN           reduce using rule 13 (decl -> subtype_decl .)
    END             reduce using rule 13 (decl -> subtype_decl .)
    PRIVATE         reduce using rule 13 (decl -> subtype_decl .)


state 62

    (149) decl_item_or_body -> body .

    PACKAGE         reduce using rule 149 (decl_item_or_body -> body .)
    TASK            reduce using rule 149 (decl_item_or_body -> body .)
    PROTECTED       reduce using rule 149 (decl_item_or_body -> body .)
    error           reduce using rule 149 (decl_item_or_body -> body .)
    USE             reduce using rule 149 (decl_item_or_body -> body .)
    PRAGMA          reduce using rule 149 (decl_item_or_body -> body .)
    TYPE            reduce using rule 149 (decl_item_or_body -> body .)
    SUBTYPE         reduce using rule 149 (decl_item_or_body -> body .)
    FOR             reduce using rule 149 (decl_item_or_body -> body .)
    PROCEDURE       reduce using rule 149 (decl_item_or_body -> body .)
    FUNCTION        reduce using rule 149 (decl_item_or_body -> body .)
    GENERIC         reduce using rule 149 (decl_item_or_body -> body .)
    IDENTIFIER      reduce using rule 149 (decl_item_or_body -> body .)
    BEGIN           reduce using rule 149 (decl_item_or_body -> body .)
    END             reduce using rule 149 (decl_item_or_body -> body .)


state 63

    (509) attrib_def -> FOR . mark USE expression ;
    (510) record_type_spec -> FOR . mark USE RECORD align_opt comp_loc_s END RECORD ;
    (515) address_spec -> FOR . mark USE AT expression ;
    (160) mark -> . simple_name
    (161) mark -> . mark TICK attribute_id
    (162) mark -> . mark . simple_name
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    mark                           shift and go to state 165
    simple_name                    shift and go to state 166

state 64

    (10) decl -> object_decl .

    PACKAGE         reduce using rule 10 (decl -> object_decl .)
    TASK            reduce using rule 10 (decl -> object_decl .)
    PROTECTED       reduce using rule 10 (decl -> object_decl .)
    error           reduce using rule 10 (decl -> object_decl .)
    USE             reduce using rule 10 (decl -> object_decl .)
    PRAGMA          reduce using rule 10 (decl -> object_decl .)
    TYPE            reduce using rule 10 (decl -> object_decl .)
    SUBTYPE         reduce using rule 10 (decl -> object_decl .)
    FOR             reduce using rule 10 (decl -> object_decl .)
    PROCEDURE       reduce using rule 10 (decl -> object_decl .)
    FUNCTION        reduce using rule 10 (decl -> object_decl .)
    GENERIC         reduce using rule 10 (decl -> object_decl .)
    IDENTIFIER      reduce using rule 10 (decl -> object_decl .)
    BEGIN           reduce using rule 10 (decl -> object_decl .)
    END             reduce using rule 10 (decl -> object_decl .)
    PRIVATE         reduce using rule 10 (decl -> object_decl .)


state 65

    (364) task_decl -> task_spec . ;

    ;               shift and go to state 167


state 66

    (144) decl_item -> use_clause .

    error           reduce using rule 144 (decl_item -> use_clause .)
    USE             reduce using rule 144 (decl_item -> use_clause .)
    PRAGMA          reduce using rule 144 (decl_item -> use_clause .)
    TYPE            reduce using rule 144 (decl_item -> use_clause .)
    SUBTYPE         reduce using rule 144 (decl_item -> use_clause .)
    TASK            reduce using rule 144 (decl_item -> use_clause .)
    PACKAGE         reduce using rule 144 (decl_item -> use_clause .)
    PROTECTED       reduce using rule 144 (decl_item -> use_clause .)
    FOR             reduce using rule 144 (decl_item -> use_clause .)
    PROCEDURE       reduce using rule 144 (decl_item -> use_clause .)
    FUNCTION        reduce using rule 144 (decl_item -> use_clause .)
    GENERIC         reduce using rule 144 (decl_item -> use_clause .)
    IDENTIFIER      reduce using rule 144 (decl_item -> use_clause .)
    PRIVATE         reduce using rule 144 (decl_item -> use_clause .)
    END             reduce using rule 144 (decl_item -> use_clause .)
    BEGIN           reduce using rule 144 (decl_item -> use_clause .)


state 67

    (371) task_body -> TASK . BODY simple_name IS decl_part block_body END id_opt ;
    (457) body_stub -> TASK . BODY simple_name IS SEPARATE ;
    (365) task_spec -> TASK . simple_name task_def
    (366) task_spec -> TASK . TYPE simple_name discrim_part_opt task_def
    (163) simple_name -> . IDENTIFIER

    BODY            shift and go to state 168
    TYPE            shift and go to state 169
    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 170

state 68

    (507) rep_spec -> record_type_spec .

    error           reduce using rule 507 (rep_spec -> record_type_spec .)
    USE             reduce using rule 507 (rep_spec -> record_type_spec .)
    PRAGMA          reduce using rule 507 (rep_spec -> record_type_spec .)
    TYPE            reduce using rule 507 (rep_spec -> record_type_spec .)
    SUBTYPE         reduce using rule 507 (rep_spec -> record_type_spec .)
    TASK            reduce using rule 507 (rep_spec -> record_type_spec .)
    PACKAGE         reduce using rule 507 (rep_spec -> record_type_spec .)
    PROTECTED       reduce using rule 507 (rep_spec -> record_type_spec .)
    FOR             reduce using rule 507 (rep_spec -> record_type_spec .)
    PROCEDURE       reduce using rule 507 (rep_spec -> record_type_spec .)
    FUNCTION        reduce using rule 507 (rep_spec -> record_type_spec .)
    GENERIC         reduce using rule 507 (rep_spec -> record_type_spec .)
    IDENTIFIER      reduce using rule 507 (rep_spec -> record_type_spec .)
    PRIVATE         reduce using rule 507 (rep_spec -> record_type_spec .)
    END             reduce using rule 507 (rep_spec -> record_type_spec .)
    BEGIN           reduce using rule 507 (rep_spec -> record_type_spec .)
    ENTRY           reduce using rule 507 (rep_spec -> record_type_spec .)


state 69

    (20) decl -> generic_decl .

    PACKAGE         reduce using rule 20 (decl -> generic_decl .)
    TASK            reduce using rule 20 (decl -> generic_decl .)
    PROTECTED       reduce using rule 20 (decl -> generic_decl .)
    error           reduce using rule 20 (decl -> generic_decl .)
    USE             reduce using rule 20 (decl -> generic_decl .)
    PRAGMA          reduce using rule 20 (decl -> generic_decl .)
    TYPE            reduce using rule 20 (decl -> generic_decl .)
    SUBTYPE         reduce using rule 20 (decl -> generic_decl .)
    FOR             reduce using rule 20 (decl -> generic_decl .)
    PROCEDURE       reduce using rule 20 (decl -> generic_decl .)
    FUNCTION        reduce using rule 20 (decl -> generic_decl .)
    GENERIC         reduce using rule 20 (decl -> generic_decl .)
    IDENTIFIER      reduce using rule 20 (decl -> generic_decl .)
    BEGIN           reduce using rule 20 (decl -> generic_decl .)
    END             reduce using rule 20 (decl -> generic_decl .)
    PRIVATE         reduce using rule 20 (decl -> generic_decl .)


state 70

    (506) rep_spec -> attrib_def .

    error           reduce using rule 506 (rep_spec -> attrib_def .)
    USE             reduce using rule 506 (rep_spec -> attrib_def .)
    PRAGMA          reduce using rule 506 (rep_spec -> attrib_def .)
    TYPE            reduce using rule 506 (rep_spec -> attrib_def .)
    SUBTYPE         reduce using rule 506 (rep_spec -> attrib_def .)
    TASK            reduce using rule 506 (rep_spec -> attrib_def .)
    PACKAGE         reduce using rule 506 (rep_spec -> attrib_def .)
    PROTECTED       reduce using rule 506 (rep_spec -> attrib_def .)
    FOR             reduce using rule 506 (rep_spec -> attrib_def .)
    PROCEDURE       reduce using rule 506 (rep_spec -> attrib_def .)
    FUNCTION        reduce using rule 506 (rep_spec -> attrib_def .)
    GENERIC         reduce using rule 506 (rep_spec -> attrib_def .)
    IDENTIFIER      reduce using rule 506 (rep_spec -> attrib_def .)
    PRIVATE         reduce using rule 506 (rep_spec -> attrib_def .)
    END             reduce using rule 506 (rep_spec -> attrib_def .)
    BEGIN           reduce using rule 506 (rep_spec -> attrib_def .)
    ENTRY           reduce using rule 506 (rep_spec -> attrib_def .)


state 71

    (138) decl_part -> decl_item_or_body_s1 .
    (148) decl_item_or_body_s1 -> decl_item_or_body_s1 . decl_item_or_body
    (149) decl_item_or_body -> . body
    (150) decl_item_or_body -> . decl_item
    (151) body -> . subprog_body
    (152) body -> . pkg_body
    (153) body -> . task_body
    (154) body -> . prot_body
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (337) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (346) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (371) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (388) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (352) use_clause -> . USE name_s ;
    (353) use_clause -> . USE TYPE name_s ;
    (506) rep_spec -> . attrib_def
    (507) rep_spec -> . record_type_spec
    (508) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (336) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (316) subprog_decl -> . subprog_spec ;
    (317) subprog_decl -> . generic_subp_inst ;
    (318) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (339) pkg_decl -> . pkg_spec ;
    (340) pkg_decl -> . generic_pkg_inst ;
    (364) task_decl -> . task_spec ;
    (372) prot_decl -> . prot_spec ;
    (461) exception_decl -> . def_id_s : EXCEPTION ;
    (356) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (357) rename_decl -> . def_id_s : EXCEPTION renames ;
    (358) rename_decl -> . rename_unit
    (473) generic_decl -> . generic_formal_part subprog_spec ;
    (474) generic_decl -> . generic_formal_part pkg_spec ;
    (457) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (458) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (459) body_stub -> . subprog_spec IS SEPARATE ;
    (460) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (509) attrib_def -> . FOR mark USE expression ;
    (510) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (515) address_spec -> . FOR mark USE AT expression ;
    (319) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (320) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (321) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (503) generic_subp_inst -> . subprog_spec IS generic_inst
    (341) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (365) task_spec -> . TASK simple_name task_def
    (366) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (373) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (374) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (359) rename_unit -> . PACKAGE compound_name renames ;
    (360) rename_unit -> . subprog_spec renames ;
    (361) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (362) rename_unit -> . generic_formal_part subprog_spec renames ;
    (475) generic_formal_part -> . GENERIC
    (476) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 138 (decl_part -> decl_item_or_body_s1 .)
    END             reduce using rule 138 (decl_part -> decl_item_or_body_s1 .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 171
    number_decl                    shift and go to state 93

state 72

    (346) pkg_body -> PACKAGE . BODY compound_name IS decl_part body_opt END c_id_opt ;
    (458) body_stub -> PACKAGE . BODY compound_name IS SEPARATE ;
    (341) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> PACKAGE . compound_name IS generic_inst
    (359) rename_unit -> PACKAGE . compound_name renames ;
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    BODY            shift and go to state 172
    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 41
    compound_name                  shift and go to state 173

state 73

    (21) decl -> body_stub .

    PACKAGE         reduce using rule 21 (decl -> body_stub .)
    TASK            reduce using rule 21 (decl -> body_stub .)
    PROTECTED       reduce using rule 21 (decl -> body_stub .)
    error           reduce using rule 21 (decl -> body_stub .)
    USE             reduce using rule 21 (decl -> body_stub .)
    PRAGMA          reduce using rule 21 (decl -> body_stub .)
    TYPE            reduce using rule 21 (decl -> body_stub .)
    SUBTYPE         reduce using rule 21 (decl -> body_stub .)
    FOR             reduce using rule 21 (decl -> body_stub .)
    PROCEDURE       reduce using rule 21 (decl -> body_stub .)
    FUNCTION        reduce using rule 21 (decl -> body_stub .)
    GENERIC         reduce using rule 21 (decl -> body_stub .)
    IDENTIFIER      reduce using rule 21 (decl -> body_stub .)
    BEGIN           reduce using rule 21 (decl -> body_stub .)
    END             reduce using rule 21 (decl -> body_stub .)
    PRIVATE         reduce using rule 21 (decl -> body_stub .)


state 74

    (146) decl_item -> pragma .

    error           reduce using rule 146 (decl_item -> pragma .)
    USE             reduce using rule 146 (decl_item -> pragma .)
    PRAGMA          reduce using rule 146 (decl_item -> pragma .)
    TYPE            reduce using rule 146 (decl_item -> pragma .)
    SUBTYPE         reduce using rule 146 (decl_item -> pragma .)
    TASK            reduce using rule 146 (decl_item -> pragma .)
    PACKAGE         reduce using rule 146 (decl_item -> pragma .)
    PROTECTED       reduce using rule 146 (decl_item -> pragma .)
    FOR             reduce using rule 146 (decl_item -> pragma .)
    PROCEDURE       reduce using rule 146 (decl_item -> pragma .)
    FUNCTION        reduce using rule 146 (decl_item -> pragma .)
    GENERIC         reduce using rule 146 (decl_item -> pragma .)
    IDENTIFIER      reduce using rule 146 (decl_item -> pragma .)
    PRIVATE         reduce using rule 146 (decl_item -> pragma .)
    END             reduce using rule 146 (decl_item -> pragma .)
    BEGIN           reduce using rule 146 (decl_item -> pragma .)


state 75

    (372) prot_decl -> prot_spec . ;

    ;               shift and go to state 174


state 76

    (26) def_id -> IDENTIFIER .

    :               reduce using rule 26 (def_id -> IDENTIFIER .)
    ,               reduce using rule 26 (def_id -> IDENTIFIER .)


state 77

    (152) body -> pkg_body .

    PACKAGE         reduce using rule 152 (body -> pkg_body .)
    TASK            reduce using rule 152 (body -> pkg_body .)
    PROTECTED       reduce using rule 152 (body -> pkg_body .)
    error           reduce using rule 152 (body -> pkg_body .)
    USE             reduce using rule 152 (body -> pkg_body .)
    PRAGMA          reduce using rule 152 (body -> pkg_body .)
    TYPE            reduce using rule 152 (body -> pkg_body .)
    SUBTYPE         reduce using rule 152 (body -> pkg_body .)
    FOR             reduce using rule 152 (body -> pkg_body .)
    PROCEDURE       reduce using rule 152 (body -> pkg_body .)
    FUNCTION        reduce using rule 152 (body -> pkg_body .)
    GENERIC         reduce using rule 152 (body -> pkg_body .)
    IDENTIFIER      reduce using rule 152 (body -> pkg_body .)
    BEGIN           reduce using rule 152 (body -> pkg_body .)
    END             reduce using rule 152 (body -> pkg_body .)


state 78

    (22) decl -> error . ;

    ;               shift and go to state 175


state 79

    (147) decl_item_or_body_s1 -> decl_item_or_body .

    PACKAGE         reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    TASK            reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    PROTECTED       reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    error           reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    USE             reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    PRAGMA          reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    TYPE            reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    SUBTYPE         reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    FOR             reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    PROCEDURE       reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    FUNCTION        reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    GENERIC         reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    IDENTIFIER      reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    BEGIN           reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)
    END             reduce using rule 147 (decl_item_or_body_s1 -> decl_item_or_body .)


state 80

    (36) type_decl -> TYPE . IDENTIFIER discrim_part_opt type_completion ;

    IDENTIFIER      shift and go to state 176


state 81

    (318) subprog_decl -> subprog_spec_is_push ABSTRACT . ;

    ;               shift and go to state 177


state 82

    (145) decl_item -> rep_spec .

    error           reduce using rule 145 (decl_item -> rep_spec .)
    USE             reduce using rule 145 (decl_item -> rep_spec .)
    PRAGMA          reduce using rule 145 (decl_item -> rep_spec .)
    TYPE            reduce using rule 145 (decl_item -> rep_spec .)
    SUBTYPE         reduce using rule 145 (decl_item -> rep_spec .)
    TASK            reduce using rule 145 (decl_item -> rep_spec .)
    PACKAGE         reduce using rule 145 (decl_item -> rep_spec .)
    PROTECTED       reduce using rule 145 (decl_item -> rep_spec .)
    FOR             reduce using rule 145 (decl_item -> rep_spec .)
    PROCEDURE       reduce using rule 145 (decl_item -> rep_spec .)
    FUNCTION        reduce using rule 145 (decl_item -> rep_spec .)
    GENERIC         reduce using rule 145 (decl_item -> rep_spec .)
    IDENTIFIER      reduce using rule 145 (decl_item -> rep_spec .)
    PRIVATE         reduce using rule 145 (decl_item -> rep_spec .)
    END             reduce using rule 145 (decl_item -> rep_spec .)
    BEGIN           reduce using rule 145 (decl_item -> rep_spec .)


state 83

    (153) body -> task_body .

    PACKAGE         reduce using rule 153 (body -> task_body .)
    TASK            reduce using rule 153 (body -> task_body .)
    PROTECTED       reduce using rule 153 (body -> task_body .)
    error           reduce using rule 153 (body -> task_body .)
    USE             reduce using rule 153 (body -> task_body .)
    PRAGMA          reduce using rule 153 (body -> task_body .)
    TYPE            reduce using rule 153 (body -> task_body .)
    SUBTYPE         reduce using rule 153 (body -> task_body .)
    FOR             reduce using rule 153 (body -> task_body .)
    PROCEDURE       reduce using rule 153 (body -> task_body .)
    FUNCTION        reduce using rule 153 (body -> task_body .)
    GENERIC         reduce using rule 153 (body -> task_body .)
    IDENTIFIER      reduce using rule 153 (body -> task_body .)
    BEGIN           reduce using rule 153 (body -> task_body .)
    END             reduce using rule 153 (body -> task_body .)


state 84

    (50) subtype_decl -> SUBTYPE . IDENTIFIER IS subtype_ind ;

    IDENTIFIER      shift and go to state 178


state 85

    (18) decl -> exception_decl .

    PACKAGE         reduce using rule 18 (decl -> exception_decl .)
    TASK            reduce using rule 18 (decl -> exception_decl .)
    PROTECTED       reduce using rule 18 (decl -> exception_decl .)
    error           reduce using rule 18 (decl -> exception_decl .)
    USE             reduce using rule 18 (decl -> exception_decl .)
    PRAGMA          reduce using rule 18 (decl -> exception_decl .)
    TYPE            reduce using rule 18 (decl -> exception_decl .)
    SUBTYPE         reduce using rule 18 (decl -> exception_decl .)
    FOR             reduce using rule 18 (decl -> exception_decl .)
    PROCEDURE       reduce using rule 18 (decl -> exception_decl .)
    FUNCTION        reduce using rule 18 (decl -> exception_decl .)
    GENERIC         reduce using rule 18 (decl -> exception_decl .)
    IDENTIFIER      reduce using rule 18 (decl -> exception_decl .)
    BEGIN           reduce using rule 18 (decl -> exception_decl .)
    END             reduce using rule 18 (decl -> exception_decl .)
    PRIVATE         reduce using rule 18 (decl -> exception_decl .)


state 86

    (337) subprog_body -> subprog_spec_is_push . decl_part block_body END id_opt ;
    (318) subprog_decl -> subprog_spec_is_push . ABSTRACT ;
    (137) decl_part -> .
    (138) decl_part -> . decl_item_or_body_s1
    (147) decl_item_or_body_s1 -> . decl_item_or_body
    (148) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (149) decl_item_or_body -> . body
    (150) decl_item_or_body -> . decl_item
    (151) body -> . subprog_body
    (152) body -> . pkg_body
    (153) body -> . task_body
    (154) body -> . prot_body
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (337) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (346) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (371) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (388) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (352) use_clause -> . USE name_s ;
    (353) use_clause -> . USE TYPE name_s ;
    (506) rep_spec -> . attrib_def
    (507) rep_spec -> . record_type_spec
    (508) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (336) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (316) subprog_decl -> . subprog_spec ;
    (317) subprog_decl -> . generic_subp_inst ;
    (318) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (339) pkg_decl -> . pkg_spec ;
    (340) pkg_decl -> . generic_pkg_inst ;
    (364) task_decl -> . task_spec ;
    (372) prot_decl -> . prot_spec ;
    (461) exception_decl -> . def_id_s : EXCEPTION ;
    (356) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (357) rename_decl -> . def_id_s : EXCEPTION renames ;
    (358) rename_decl -> . rename_unit
    (473) generic_decl -> . generic_formal_part subprog_spec ;
    (474) generic_decl -> . generic_formal_part pkg_spec ;
    (457) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (458) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (459) body_stub -> . subprog_spec IS SEPARATE ;
    (460) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (509) attrib_def -> . FOR mark USE expression ;
    (510) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (515) address_spec -> . FOR mark USE AT expression ;
    (319) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (320) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (321) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (503) generic_subp_inst -> . subprog_spec IS generic_inst
    (341) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (365) task_spec -> . TASK simple_name task_def
    (366) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (373) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (374) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (359) rename_unit -> . PACKAGE compound_name renames ;
    (360) rename_unit -> . subprog_spec renames ;
    (361) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (362) rename_unit -> . generic_formal_part subprog_spec renames ;
    (475) generic_formal_part -> . GENERIC
    (476) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    ABSTRACT        shift and go to state 81
    BEGIN           reduce using rule 137 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 54
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 87

    (336) subprog_spec_is_push -> subprog_spec . IS
    (316) subprog_decl -> subprog_spec . ;
    (459) body_stub -> subprog_spec . IS SEPARATE ;
    (503) generic_subp_inst -> subprog_spec . IS generic_inst
    (360) rename_unit -> subprog_spec . renames ;
    (363) renames -> . RENAMES name

    IS              shift and go to state 179
    ;               shift and go to state 97
    RENAMES         shift and go to state 95

    renames                        shift and go to state 94

state 88

    (23) object_decl -> def_id_s . : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> def_id_s . : CONSTANT ASSIGNMENT expression ;
    (461) exception_decl -> def_id_s . : EXCEPTION ;
    (356) rename_decl -> def_id_s . : object_qualifier_opt subtype_ind renames ;
    (357) rename_decl -> def_id_s . : EXCEPTION renames ;
    (25) def_id_s -> def_id_s . , def_id

    :               shift and go to state 181
    ,               shift and go to state 180


state 89

    (24) def_id_s -> def_id .

    :               reduce using rule 24 (def_id_s -> def_id .)
    ,               reduce using rule 24 (def_id_s -> def_id .)


state 90

    (19) decl -> rename_decl .

    PACKAGE         reduce using rule 19 (decl -> rename_decl .)
    TASK            reduce using rule 19 (decl -> rename_decl .)
    PROTECTED       reduce using rule 19 (decl -> rename_decl .)
    error           reduce using rule 19 (decl -> rename_decl .)
    USE             reduce using rule 19 (decl -> rename_decl .)
    PRAGMA          reduce using rule 19 (decl -> rename_decl .)
    TYPE            reduce using rule 19 (decl -> rename_decl .)
    SUBTYPE         reduce using rule 19 (decl -> rename_decl .)
    FOR             reduce using rule 19 (decl -> rename_decl .)
    PROCEDURE       reduce using rule 19 (decl -> rename_decl .)
    FUNCTION        reduce using rule 19 (decl -> rename_decl .)
    GENERIC         reduce using rule 19 (decl -> rename_decl .)
    IDENTIFIER      reduce using rule 19 (decl -> rename_decl .)
    BEGIN           reduce using rule 19 (decl -> rename_decl .)
    END             reduce using rule 19 (decl -> rename_decl .)
    PRIVATE         reduce using rule 19 (decl -> rename_decl .)


state 91

    (358) rename_decl -> rename_unit .

    PACKAGE         reduce using rule 358 (rename_decl -> rename_unit .)
    TASK            reduce using rule 358 (rename_decl -> rename_unit .)
    PROTECTED       reduce using rule 358 (rename_decl -> rename_unit .)
    error           reduce using rule 358 (rename_decl -> rename_unit .)
    USE             reduce using rule 358 (rename_decl -> rename_unit .)
    PRAGMA          reduce using rule 358 (rename_decl -> rename_unit .)
    TYPE            reduce using rule 358 (rename_decl -> rename_unit .)
    SUBTYPE         reduce using rule 358 (rename_decl -> rename_unit .)
    FOR             reduce using rule 358 (rename_decl -> rename_unit .)
    PROCEDURE       reduce using rule 358 (rename_decl -> rename_unit .)
    FUNCTION        reduce using rule 358 (rename_decl -> rename_unit .)
    GENERIC         reduce using rule 358 (rename_decl -> rename_unit .)
    IDENTIFIER      reduce using rule 358 (rename_decl -> rename_unit .)
    BEGIN           reduce using rule 358 (rename_decl -> rename_unit .)
    END             reduce using rule 358 (rename_decl -> rename_unit .)
    PRIVATE         reduce using rule 358 (rename_decl -> rename_unit .)


state 92

    (154) body -> prot_body .

    PACKAGE         reduce using rule 154 (body -> prot_body .)
    TASK            reduce using rule 154 (body -> prot_body .)
    PROTECTED       reduce using rule 154 (body -> prot_body .)
    error           reduce using rule 154 (body -> prot_body .)
    USE             reduce using rule 154 (body -> prot_body .)
    PRAGMA          reduce using rule 154 (body -> prot_body .)
    TYPE            reduce using rule 154 (body -> prot_body .)
    SUBTYPE         reduce using rule 154 (body -> prot_body .)
    FOR             reduce using rule 154 (body -> prot_body .)
    PROCEDURE       reduce using rule 154 (body -> prot_body .)
    FUNCTION        reduce using rule 154 (body -> prot_body .)
    GENERIC         reduce using rule 154 (body -> prot_body .)
    IDENTIFIER      reduce using rule 154 (body -> prot_body .)
    BEGIN           reduce using rule 154 (body -> prot_body .)
    END             reduce using rule 154 (body -> prot_body .)


state 93

    (11) decl -> number_decl .

    PACKAGE         reduce using rule 11 (decl -> number_decl .)
    TASK            reduce using rule 11 (decl -> number_decl .)
    PROTECTED       reduce using rule 11 (decl -> number_decl .)
    error           reduce using rule 11 (decl -> number_decl .)
    USE             reduce using rule 11 (decl -> number_decl .)
    PRAGMA          reduce using rule 11 (decl -> number_decl .)
    TYPE            reduce using rule 11 (decl -> number_decl .)
    SUBTYPE         reduce using rule 11 (decl -> number_decl .)
    FOR             reduce using rule 11 (decl -> number_decl .)
    PROCEDURE       reduce using rule 11 (decl -> number_decl .)
    FUNCTION        reduce using rule 11 (decl -> number_decl .)
    GENERIC         reduce using rule 11 (decl -> number_decl .)
    IDENTIFIER      reduce using rule 11 (decl -> number_decl .)
    BEGIN           reduce using rule 11 (decl -> number_decl .)
    END             reduce using rule 11 (decl -> number_decl .)
    PRIVATE         reduce using rule 11 (decl -> number_decl .)


state 94

    (360) rename_unit -> subprog_spec renames . ;

    ;               shift and go to state 182


state 95

    (363) renames -> RENAMES . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 183
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 96

    (503) generic_subp_inst -> subprog_spec IS . generic_inst
    (336) subprog_spec_is_push -> subprog_spec IS .
    (505) generic_inst -> . NEW name

    ABSTRACT        reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    PACKAGE         reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    TASK            reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    PROTECTED       reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    error           reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    USE             reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    PRAGMA          reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    TYPE            reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    SUBTYPE         reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    FOR             reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    PROCEDURE       reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    FUNCTION        reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    GENERIC         reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    IDENTIFIER      reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    BEGIN           reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    NEW             shift and go to state 184

    generic_inst                   shift and go to state 185

state 97

    (316) subprog_decl -> subprog_spec ; .

    PACKAGE         reduce using rule 316 (subprog_decl -> subprog_spec ; .)
    TASK            reduce using rule 316 (subprog_decl -> subprog_spec ; .)
    PROTECTED       reduce using rule 316 (subprog_decl -> subprog_spec ; .)
    error           reduce using rule 316 (subprog_decl -> subprog_spec ; .)
    USE             reduce using rule 316 (subprog_decl -> subprog_spec ; .)
    PRAGMA          reduce using rule 316 (subprog_decl -> subprog_spec ; .)
    TYPE            reduce using rule 316 (subprog_decl -> subprog_spec ; .)
    SUBTYPE         reduce using rule 316 (subprog_decl -> subprog_spec ; .)
    FOR             reduce using rule 316 (subprog_decl -> subprog_spec ; .)
    PROCEDURE       reduce using rule 316 (subprog_decl -> subprog_spec ; .)
    FUNCTION        reduce using rule 316 (subprog_decl -> subprog_spec ; .)
    GENERIC         reduce using rule 316 (subprog_decl -> subprog_spec ; .)
    IDENTIFIER      reduce using rule 316 (subprog_decl -> subprog_spec ; .)
    BEGIN           reduce using rule 316 (subprog_decl -> subprog_spec ; .)
    END             reduce using rule 316 (subprog_decl -> subprog_spec ; .)
    PRIVATE         reduce using rule 316 (subprog_decl -> subprog_spec ; .)
    WITH            reduce using rule 316 (subprog_decl -> subprog_spec ; .)
    SEPARATE        reduce using rule 316 (subprog_decl -> subprog_spec ; .)
    $end            reduce using rule 316 (subprog_decl -> subprog_spec ; .)


state 98

    (346) pkg_body -> PACKAGE BODY . compound_name IS decl_part body_opt END c_id_opt ;
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 186
    simple_name                    shift and go to state 41

state 99

    (359) rename_unit -> PACKAGE compound_name . renames ;
    (341) pkg_spec -> PACKAGE compound_name . IS decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> PACKAGE compound_name . IS generic_inst
    (165) compound_name -> compound_name . . simple_name
    (363) renames -> . RENAMES name

    IS              shift and go to state 188
    .               shift and go to state 119
    RENAMES         shift and go to state 95

    renames                        shift and go to state 187

state 100

    (317) subprog_decl -> generic_subp_inst ; .

    PACKAGE         reduce using rule 317 (subprog_decl -> generic_subp_inst ; .)
    TASK            reduce using rule 317 (subprog_decl -> generic_subp_inst ; .)
    PROTECTED       reduce using rule 317 (subprog_decl -> generic_subp_inst ; .)
    error           reduce using rule 317 (subprog_decl -> generic_subp_inst ; .)
    USE             reduce using rule 317 (subprog_decl -> generic_subp_inst ; .)
    PRAGMA          reduce using rule 317 (subprog_decl -> generic_subp_inst ; .)
    TYPE            reduce using rule 317 (subprog_decl -> generic_subp_inst ; .)
    SUBTYPE         reduce using rule 317 (subprog_decl -> generic_subp_inst ; .)
    FOR             reduce using rule 317 (subprog_decl -> generic_subp_inst ; .)
    PROCEDURE       reduce using rule 317 (subprog_decl -> generic_subp_inst ; .)
    FUNCTION        reduce using rule 317 (subprog_decl -> generic_subp_inst ; .)
    GENERIC         reduce using rule 317 (subprog_decl -> generic_subp_inst ; .)
    IDENTIFIER      reduce using rule 317 (subprog_decl -> generic_subp_inst ; .)
    BEGIN           reduce using rule 317 (subprog_decl -> generic_subp_inst ; .)
    END             reduce using rule 317 (subprog_decl -> generic_subp_inst ; .)
    PRIVATE         reduce using rule 317 (subprog_decl -> generic_subp_inst ; .)
    WITH            reduce using rule 317 (subprog_decl -> generic_subp_inst ; .)
    SEPARATE        reduce using rule 317 (subprog_decl -> generic_subp_inst ; .)
    $end            reduce using rule 317 (subprog_decl -> generic_subp_inst ; .)


state 101

    (319) subprog_spec -> PROCEDURE compound_name . formal_part_opt
    (165) compound_name -> compound_name . . simple_name
    (324) formal_part_opt -> .
    (325) formal_part_opt -> . formal_part
    (326) formal_part -> . ( param_s )

    .               shift and go to state 119
    ;               reduce using rule 324 (formal_part_opt -> .)
    IS              reduce using rule 324 (formal_part_opt -> .)
    RENAMES         reduce using rule 324 (formal_part_opt -> .)
    (               shift and go to state 190

    formal_part                    shift and go to state 189
    formal_part_opt                shift and go to state 191

state 102

    (479) generic_formal -> WITH . PROCEDURE simple_name formal_part_opt subp_default ;
    (480) generic_formal -> WITH . FUNCTION designator formal_part_opt RETURN name subp_default ;
    (481) generic_formal -> WITH . PACKAGE simple_name IS NEW name ( LESSMORE ) ;
    (482) generic_formal -> WITH . PACKAGE simple_name IS NEW name ;

    PROCEDURE       shift and go to state 194
    FUNCTION        shift and go to state 192
    PACKAGE         shift and go to state 193


state 103

    (477) generic_formal -> param . ;

    ;               shift and go to state 195


state 104

    (473) generic_decl -> generic_formal_part subprog_spec . ;
    (362) rename_unit -> generic_formal_part subprog_spec . renames ;
    (363) renames -> . RENAMES name

    ;               shift and go to state 197
    RENAMES         shift and go to state 95

    renames                        shift and go to state 196

state 105

    (329) param -> def_id_s . : mode mark init_opt
    (25) def_id_s -> def_id_s . , def_id

    :               shift and go to state 198
    ,               shift and go to state 180


state 106

    (361) rename_unit -> generic_formal_part PACKAGE . compound_name renames ;
    (341) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 41
    compound_name                  shift and go to state 199

state 107

    (476) generic_formal_part -> generic_formal_part generic_formal .

    PACKAGE         reduce using rule 476 (generic_formal_part -> generic_formal_part generic_formal .)
    PROCEDURE       reduce using rule 476 (generic_formal_part -> generic_formal_part generic_formal .)
    FUNCTION        reduce using rule 476 (generic_formal_part -> generic_formal_part generic_formal .)
    TYPE            reduce using rule 476 (generic_formal_part -> generic_formal_part generic_formal .)
    WITH            reduce using rule 476 (generic_formal_part -> generic_formal_part generic_formal .)
    error           reduce using rule 476 (generic_formal_part -> generic_formal_part generic_formal .)
    USE             reduce using rule 476 (generic_formal_part -> generic_formal_part generic_formal .)
    IDENTIFIER      reduce using rule 476 (generic_formal_part -> generic_formal_part generic_formal .)


state 108

    (483) generic_formal -> use_clause .

    PACKAGE         reduce using rule 483 (generic_formal -> use_clause .)
    PROCEDURE       reduce using rule 483 (generic_formal -> use_clause .)
    FUNCTION        reduce using rule 483 (generic_formal -> use_clause .)
    TYPE            reduce using rule 483 (generic_formal -> use_clause .)
    WITH            reduce using rule 483 (generic_formal -> use_clause .)
    error           reduce using rule 483 (generic_formal -> use_clause .)
    USE             reduce using rule 483 (generic_formal -> use_clause .)
    IDENTIFIER      reduce using rule 483 (generic_formal -> use_clause .)


state 109

    (330) param -> error .

    ;               reduce using rule 330 (param -> error .)
    )               reduce using rule 330 (param -> error .)


state 110

    (474) generic_decl -> generic_formal_part pkg_spec . ;

    ;               shift and go to state 200


state 111

    (478) generic_formal -> TYPE . simple_name generic_discrim_part_opt IS generic_type_def ;
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 201

state 112

    (340) pkg_decl -> generic_pkg_inst ; .

    PACKAGE         reduce using rule 340 (pkg_decl -> generic_pkg_inst ; .)
    TASK            reduce using rule 340 (pkg_decl -> generic_pkg_inst ; .)
    PROTECTED       reduce using rule 340 (pkg_decl -> generic_pkg_inst ; .)
    error           reduce using rule 340 (pkg_decl -> generic_pkg_inst ; .)
    USE             reduce using rule 340 (pkg_decl -> generic_pkg_inst ; .)
    PRAGMA          reduce using rule 340 (pkg_decl -> generic_pkg_inst ; .)
    TYPE            reduce using rule 340 (pkg_decl -> generic_pkg_inst ; .)
    SUBTYPE         reduce using rule 340 (pkg_decl -> generic_pkg_inst ; .)
    FOR             reduce using rule 340 (pkg_decl -> generic_pkg_inst ; .)
    PROCEDURE       reduce using rule 340 (pkg_decl -> generic_pkg_inst ; .)
    FUNCTION        reduce using rule 340 (pkg_decl -> generic_pkg_inst ; .)
    GENERIC         reduce using rule 340 (pkg_decl -> generic_pkg_inst ; .)
    IDENTIFIER      reduce using rule 340 (pkg_decl -> generic_pkg_inst ; .)
    BEGIN           reduce using rule 340 (pkg_decl -> generic_pkg_inst ; .)
    END             reduce using rule 340 (pkg_decl -> generic_pkg_inst ; .)
    PRIVATE         reduce using rule 340 (pkg_decl -> generic_pkg_inst ; .)
    WITH            reduce using rule 340 (pkg_decl -> generic_pkg_inst ; .)
    SEPARATE        reduce using rule 340 (pkg_decl -> generic_pkg_inst ; .)
    $end            reduce using rule 340 (pkg_decl -> generic_pkg_inst ; .)


state 113

    (320) subprog_spec -> FUNCTION designator . formal_part_opt RETURN name
    (321) subprog_spec -> FUNCTION designator .
    (324) formal_part_opt -> .
    (325) formal_part_opt -> . formal_part
    (326) formal_part -> . ( param_s )

    IS              reduce using rule 321 (subprog_spec -> FUNCTION designator .)
    ;               reduce using rule 321 (subprog_spec -> FUNCTION designator .)
    RENAMES         reduce using rule 321 (subprog_spec -> FUNCTION designator .)
    RETURN          reduce using rule 324 (formal_part_opt -> .)
    (               shift and go to state 190

    formal_part                    shift and go to state 189
    formal_part_opt                shift and go to state 202

state 114

    (322) designator -> compound_name .
    (165) compound_name -> compound_name . . simple_name

    (               reduce using rule 322 (designator -> compound_name .)
    RETURN          reduce using rule 322 (designator -> compound_name .)
    ;               reduce using rule 322 (designator -> compound_name .)
    IS              reduce using rule 322 (designator -> compound_name .)
    RENAMES         reduce using rule 322 (designator -> compound_name .)
    .               shift and go to state 119


state 115

    (323) designator -> STRING .

    (               reduce using rule 323 (designator -> STRING .)
    RETURN          reduce using rule 323 (designator -> STRING .)
    ;               reduce using rule 323 (designator -> STRING .)
    IS              reduce using rule 323 (designator -> STRING .)
    RENAMES         reduce using rule 323 (designator -> STRING .)


state 116

    (339) pkg_decl -> pkg_spec ; .

    PACKAGE         reduce using rule 339 (pkg_decl -> pkg_spec ; .)
    TASK            reduce using rule 339 (pkg_decl -> pkg_spec ; .)
    PROTECTED       reduce using rule 339 (pkg_decl -> pkg_spec ; .)
    error           reduce using rule 339 (pkg_decl -> pkg_spec ; .)
    USE             reduce using rule 339 (pkg_decl -> pkg_spec ; .)
    PRAGMA          reduce using rule 339 (pkg_decl -> pkg_spec ; .)
    TYPE            reduce using rule 339 (pkg_decl -> pkg_spec ; .)
    SUBTYPE         reduce using rule 339 (pkg_decl -> pkg_spec ; .)
    FOR             reduce using rule 339 (pkg_decl -> pkg_spec ; .)
    PROCEDURE       reduce using rule 339 (pkg_decl -> pkg_spec ; .)
    FUNCTION        reduce using rule 339 (pkg_decl -> pkg_spec ; .)
    GENERIC         reduce using rule 339 (pkg_decl -> pkg_spec ; .)
    IDENTIFIER      reduce using rule 339 (pkg_decl -> pkg_spec ; .)
    BEGIN           reduce using rule 339 (pkg_decl -> pkg_spec ; .)
    END             reduce using rule 339 (pkg_decl -> pkg_spec ; .)
    PRIVATE         reduce using rule 339 (pkg_decl -> pkg_spec ; .)
    WITH            reduce using rule 339 (pkg_decl -> pkg_spec ; .)
    SEPARATE        reduce using rule 339 (pkg_decl -> pkg_spec ; .)
    $end            reduce using rule 339 (pkg_decl -> pkg_spec ; .)


state 117

    (442) with_clause -> WITH c_name_list ; .

    USE             reduce using rule 442 (with_clause -> WITH c_name_list ; .)
    PRIVATE         reduce using rule 442 (with_clause -> WITH c_name_list ; .)
    WITH            reduce using rule 442 (with_clause -> WITH c_name_list ; .)
    PRAGMA          reduce using rule 442 (with_clause -> WITH c_name_list ; .)
    PACKAGE         reduce using rule 442 (with_clause -> WITH c_name_list ; .)
    SEPARATE        reduce using rule 442 (with_clause -> WITH c_name_list ; .)
    PROCEDURE       reduce using rule 442 (with_clause -> WITH c_name_list ; .)
    FUNCTION        reduce using rule 442 (with_clause -> WITH c_name_list ; .)
    GENERIC         reduce using rule 442 (with_clause -> WITH c_name_list ; .)


state 118

    (167) c_name_list -> c_name_list , . compound_name
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 203
    simple_name                    shift and go to state 41

state 119

    (165) compound_name -> compound_name . . simple_name
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 204

state 120

    (157) name -> selected_comp .

    (               reduce using rule 157 (name -> selected_comp .)
    .               reduce using rule 157 (name -> selected_comp .)
    TICK            reduce using rule 157 (name -> selected_comp .)
    ;               reduce using rule 157 (name -> selected_comp .)
    ASSIGNMENT      reduce using rule 157 (name -> selected_comp .)
    RANGE           reduce using rule 157 (name -> selected_comp .)
    )               reduce using rule 157 (name -> selected_comp .)
    ,               reduce using rule 157 (name -> selected_comp .)
    STARSTAR        reduce using rule 157 (name -> selected_comp .)
    *               reduce using rule 157 (name -> selected_comp .)
    /               reduce using rule 157 (name -> selected_comp .)
    MOD             reduce using rule 157 (name -> selected_comp .)
    REM             reduce using rule 157 (name -> selected_comp .)
    DOTDOT          reduce using rule 157 (name -> selected_comp .)
    +               reduce using rule 157 (name -> selected_comp .)
    -               reduce using rule 157 (name -> selected_comp .)
    &               reduce using rule 157 (name -> selected_comp .)
    =               reduce using rule 157 (name -> selected_comp .)
    NOTEQUAL        reduce using rule 157 (name -> selected_comp .)
    <               reduce using rule 157 (name -> selected_comp .)
    LESSEQ          reduce using rule 157 (name -> selected_comp .)
    >               reduce using rule 157 (name -> selected_comp .)
    GREATEREQ       reduce using rule 157 (name -> selected_comp .)
    IN              reduce using rule 157 (name -> selected_comp .)
    NOT             reduce using rule 157 (name -> selected_comp .)
    AND             reduce using rule 157 (name -> selected_comp .)
    OR              reduce using rule 157 (name -> selected_comp .)
    XOR             reduce using rule 157 (name -> selected_comp .)
    ARROW           reduce using rule 157 (name -> selected_comp .)
    |               reduce using rule 157 (name -> selected_comp .)
    WITH            reduce using rule 157 (name -> selected_comp .)
    IS              reduce using rule 157 (name -> selected_comp .)
    THEN            reduce using rule 157 (name -> selected_comp .)
    LOOP            reduce using rule 157 (name -> selected_comp .)
    DIGITS          reduce using rule 157 (name -> selected_comp .)
    RENAMES         reduce using rule 157 (name -> selected_comp .)
    WHEN            reduce using rule 157 (name -> selected_comp .)


state 121

    (158) name -> attribute .

    (               reduce using rule 158 (name -> attribute .)
    .               reduce using rule 158 (name -> attribute .)
    TICK            reduce using rule 158 (name -> attribute .)
    ;               reduce using rule 158 (name -> attribute .)
    ASSIGNMENT      reduce using rule 158 (name -> attribute .)
    RANGE           reduce using rule 158 (name -> attribute .)
    )               reduce using rule 158 (name -> attribute .)
    ,               reduce using rule 158 (name -> attribute .)
    STARSTAR        reduce using rule 158 (name -> attribute .)
    *               reduce using rule 158 (name -> attribute .)
    /               reduce using rule 158 (name -> attribute .)
    MOD             reduce using rule 158 (name -> attribute .)
    REM             reduce using rule 158 (name -> attribute .)
    DOTDOT          reduce using rule 158 (name -> attribute .)
    +               reduce using rule 158 (name -> attribute .)
    -               reduce using rule 158 (name -> attribute .)
    &               reduce using rule 158 (name -> attribute .)
    =               reduce using rule 158 (name -> attribute .)
    NOTEQUAL        reduce using rule 158 (name -> attribute .)
    <               reduce using rule 158 (name -> attribute .)
    LESSEQ          reduce using rule 158 (name -> attribute .)
    >               reduce using rule 158 (name -> attribute .)
    GREATEREQ       reduce using rule 158 (name -> attribute .)
    IN              reduce using rule 158 (name -> attribute .)
    NOT             reduce using rule 158 (name -> attribute .)
    AND             reduce using rule 158 (name -> attribute .)
    OR              reduce using rule 158 (name -> attribute .)
    XOR             reduce using rule 158 (name -> attribute .)
    ARROW           reduce using rule 158 (name -> attribute .)
    |               reduce using rule 158 (name -> attribute .)
    WITH            reduce using rule 158 (name -> attribute .)
    IS              reduce using rule 158 (name -> attribute .)
    THEN            reduce using rule 158 (name -> attribute .)
    LOOP            reduce using rule 158 (name -> attribute .)
    DIGITS          reduce using rule 158 (name -> attribute .)
    RENAMES         reduce using rule 158 (name -> attribute .)
    WHEN            reduce using rule 158 (name -> attribute .)


state 122

    (234) factor -> primary .
    (237) factor -> primary . STARSTAR primary

    *               reduce using rule 234 (factor -> primary .)
    /               reduce using rule 234 (factor -> primary .)
    MOD             reduce using rule 234 (factor -> primary .)
    REM             reduce using rule 234 (factor -> primary .)
    DOTDOT          reduce using rule 234 (factor -> primary .)
    =               reduce using rule 234 (factor -> primary .)
    NOTEQUAL        reduce using rule 234 (factor -> primary .)
    <               reduce using rule 234 (factor -> primary .)
    LESSEQ          reduce using rule 234 (factor -> primary .)
    >               reduce using rule 234 (factor -> primary .)
    GREATEREQ       reduce using rule 234 (factor -> primary .)
    IN              reduce using rule 234 (factor -> primary .)
    NOT             reduce using rule 234 (factor -> primary .)
    +               reduce using rule 234 (factor -> primary .)
    -               reduce using rule 234 (factor -> primary .)
    &               reduce using rule 234 (factor -> primary .)
    AND             reduce using rule 234 (factor -> primary .)
    OR              reduce using rule 234 (factor -> primary .)
    XOR             reduce using rule 234 (factor -> primary .)
    )               reduce using rule 234 (factor -> primary .)
    ,               reduce using rule 234 (factor -> primary .)
    ARROW           reduce using rule 234 (factor -> primary .)
    |               reduce using rule 234 (factor -> primary .)
    RANGE           reduce using rule 234 (factor -> primary .)
    ;               reduce using rule 234 (factor -> primary .)
    IS              reduce using rule 234 (factor -> primary .)
    WITH            reduce using rule 234 (factor -> primary .)
    THEN            reduce using rule 234 (factor -> primary .)
    LOOP            reduce using rule 234 (factor -> primary .)
    DIGITS          reduce using rule 234 (factor -> primary .)
    RENAMES         reduce using rule 234 (factor -> primary .)
    ASSIGNMENT      reduce using rule 234 (factor -> primary .)
    STARSTAR        shift and go to state 205


state 123

    (4) pragma_arg_s -> pragma_arg .

    )               reduce using rule 4 (pragma_arg_s -> pragma_arg .)
    ,               reduce using rule 4 (pragma_arg_s -> pragma_arg .)


state 124

    (220) simple_expression -> unary . term
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 206
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149

state 125

    (200) expression -> relation .

    AND             reduce using rule 200 (expression -> relation .)
    OR              reduce using rule 200 (expression -> relation .)
    XOR             reduce using rule 200 (expression -> relation .)
    )               reduce using rule 200 (expression -> relation .)
    ,               reduce using rule 200 (expression -> relation .)
    ;               reduce using rule 200 (expression -> relation .)
    DIGITS          reduce using rule 200 (expression -> relation .)
    RANGE           reduce using rule 200 (expression -> relation .)
    THEN            reduce using rule 200 (expression -> relation .)
    ARROW           reduce using rule 200 (expression -> relation .)
    |               reduce using rule 200 (expression -> relation .)
    RENAMES         reduce using rule 200 (expression -> relation .)
    ASSIGNMENT      reduce using rule 200 (expression -> relation .)
    WITH            reduce using rule 200 (expression -> relation .)
    IS              reduce using rule 200 (expression -> relation .)
    LOOP            reduce using rule 200 (expression -> relation .)


state 126

    (189) literal -> BASE_FLOAT .

    STARSTAR        reduce using rule 189 (literal -> BASE_FLOAT .)
    *               reduce using rule 189 (literal -> BASE_FLOAT .)
    /               reduce using rule 189 (literal -> BASE_FLOAT .)
    MOD             reduce using rule 189 (literal -> BASE_FLOAT .)
    REM             reduce using rule 189 (literal -> BASE_FLOAT .)
    =               reduce using rule 189 (literal -> BASE_FLOAT .)
    NOTEQUAL        reduce using rule 189 (literal -> BASE_FLOAT .)
    <               reduce using rule 189 (literal -> BASE_FLOAT .)
    LESSEQ          reduce using rule 189 (literal -> BASE_FLOAT .)
    >               reduce using rule 189 (literal -> BASE_FLOAT .)
    GREATEREQ       reduce using rule 189 (literal -> BASE_FLOAT .)
    IN              reduce using rule 189 (literal -> BASE_FLOAT .)
    NOT             reduce using rule 189 (literal -> BASE_FLOAT .)
    +               reduce using rule 189 (literal -> BASE_FLOAT .)
    -               reduce using rule 189 (literal -> BASE_FLOAT .)
    &               reduce using rule 189 (literal -> BASE_FLOAT .)
    AND             reduce using rule 189 (literal -> BASE_FLOAT .)
    OR              reduce using rule 189 (literal -> BASE_FLOAT .)
    XOR             reduce using rule 189 (literal -> BASE_FLOAT .)
    THEN            reduce using rule 189 (literal -> BASE_FLOAT .)
    DOTDOT          reduce using rule 189 (literal -> BASE_FLOAT .)
    ARROW           reduce using rule 189 (literal -> BASE_FLOAT .)
    |               reduce using rule 189 (literal -> BASE_FLOAT .)
    )               reduce using rule 189 (literal -> BASE_FLOAT .)
    ,               reduce using rule 189 (literal -> BASE_FLOAT .)
    WITH            reduce using rule 189 (literal -> BASE_FLOAT .)
    ;               reduce using rule 189 (literal -> BASE_FLOAT .)
    IS              reduce using rule 189 (literal -> BASE_FLOAT .)
    LOOP            reduce using rule 189 (literal -> BASE_FLOAT .)
    RANGE           reduce using rule 189 (literal -> BASE_FLOAT .)
    DIGITS          reduce using rule 189 (literal -> BASE_FLOAT .)
    RENAMES         reduce using rule 189 (literal -> BASE_FLOAT .)
    ASSIGNMENT      reduce using rule 189 (literal -> BASE_FLOAT .)


state 127

    (246) allocator -> NEW . name
    (247) allocator -> NEW . qualified
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 207
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    qualified                      shift and go to state 208
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 128

    (208) relation -> simple_expression .
    (209) relation -> simple_expression . relational simple_expression
    (210) relation -> simple_expression . membership range
    (211) relation -> simple_expression . membership name
    (222) simple_expression -> simple_expression . adding term
    (212) relational -> . =
    (213) relational -> . NOTEQUAL
    (214) relational -> . <
    (215) relational -> . LESSEQ
    (216) relational -> . >
    (217) relational -> . GREATEREQ
    (218) membership -> . IN
    (219) membership -> . NOT IN
    (225) adding -> . +
    (226) adding -> . -
    (227) adding -> . &

    AND             reduce using rule 208 (relation -> simple_expression .)
    OR              reduce using rule 208 (relation -> simple_expression .)
    XOR             reduce using rule 208 (relation -> simple_expression .)
    )               reduce using rule 208 (relation -> simple_expression .)
    ,               reduce using rule 208 (relation -> simple_expression .)
    ;               reduce using rule 208 (relation -> simple_expression .)
    THEN            reduce using rule 208 (relation -> simple_expression .)
    RANGE           reduce using rule 208 (relation -> simple_expression .)
    RENAMES         reduce using rule 208 (relation -> simple_expression .)
    ASSIGNMENT      reduce using rule 208 (relation -> simple_expression .)
    WITH            reduce using rule 208 (relation -> simple_expression .)
    IS              reduce using rule 208 (relation -> simple_expression .)
    ARROW           reduce using rule 208 (relation -> simple_expression .)
    |               reduce using rule 208 (relation -> simple_expression .)
    LOOP            reduce using rule 208 (relation -> simple_expression .)
    DIGITS          reduce using rule 208 (relation -> simple_expression .)
    =               shift and go to state 220
    NOTEQUAL        shift and go to state 210
    <               shift and go to state 221
    LESSEQ          shift and go to state 216
    >               shift and go to state 222
    GREATEREQ       shift and go to state 215
    IN              shift and go to state 217
    NOT             shift and go to state 218
    +               shift and go to state 211
    -               shift and go to state 213
    &               shift and go to state 212

    adding                         shift and go to state 209
    membership                     shift and go to state 214
    relational                     shift and go to state 219

state 129

    (156) name -> indexed_comp .

    (               reduce using rule 156 (name -> indexed_comp .)
    .               reduce using rule 156 (name -> indexed_comp .)
    TICK            reduce using rule 156 (name -> indexed_comp .)
    ;               reduce using rule 156 (name -> indexed_comp .)
    ASSIGNMENT      reduce using rule 156 (name -> indexed_comp .)
    RANGE           reduce using rule 156 (name -> indexed_comp .)
    )               reduce using rule 156 (name -> indexed_comp .)
    ,               reduce using rule 156 (name -> indexed_comp .)
    STARSTAR        reduce using rule 156 (name -> indexed_comp .)
    *               reduce using rule 156 (name -> indexed_comp .)
    /               reduce using rule 156 (name -> indexed_comp .)
    MOD             reduce using rule 156 (name -> indexed_comp .)
    REM             reduce using rule 156 (name -> indexed_comp .)
    DOTDOT          reduce using rule 156 (name -> indexed_comp .)
    +               reduce using rule 156 (name -> indexed_comp .)
    -               reduce using rule 156 (name -> indexed_comp .)
    &               reduce using rule 156 (name -> indexed_comp .)
    =               reduce using rule 156 (name -> indexed_comp .)
    NOTEQUAL        reduce using rule 156 (name -> indexed_comp .)
    <               reduce using rule 156 (name -> indexed_comp .)
    LESSEQ          reduce using rule 156 (name -> indexed_comp .)
    >               reduce using rule 156 (name -> indexed_comp .)
    GREATEREQ       reduce using rule 156 (name -> indexed_comp .)
    IN              reduce using rule 156 (name -> indexed_comp .)
    NOT             reduce using rule 156 (name -> indexed_comp .)
    AND             reduce using rule 156 (name -> indexed_comp .)
    OR              reduce using rule 156 (name -> indexed_comp .)
    XOR             reduce using rule 156 (name -> indexed_comp .)
    ARROW           reduce using rule 156 (name -> indexed_comp .)
    |               reduce using rule 156 (name -> indexed_comp .)
    WITH            reduce using rule 156 (name -> indexed_comp .)
    IS              reduce using rule 156 (name -> indexed_comp .)
    THEN            reduce using rule 156 (name -> indexed_comp .)
    LOOP            reduce using rule 156 (name -> indexed_comp .)
    DIGITS          reduce using rule 156 (name -> indexed_comp .)
    RENAMES         reduce using rule 156 (name -> indexed_comp .)
    WHEN            reduce using rule 156 (name -> indexed_comp .)


state 130

    (240) primary -> allocator .

    STARSTAR        reduce using rule 240 (primary -> allocator .)
    *               reduce using rule 240 (primary -> allocator .)
    /               reduce using rule 240 (primary -> allocator .)
    MOD             reduce using rule 240 (primary -> allocator .)
    REM             reduce using rule 240 (primary -> allocator .)
    =               reduce using rule 240 (primary -> allocator .)
    NOTEQUAL        reduce using rule 240 (primary -> allocator .)
    <               reduce using rule 240 (primary -> allocator .)
    LESSEQ          reduce using rule 240 (primary -> allocator .)
    >               reduce using rule 240 (primary -> allocator .)
    GREATEREQ       reduce using rule 240 (primary -> allocator .)
    IN              reduce using rule 240 (primary -> allocator .)
    NOT             reduce using rule 240 (primary -> allocator .)
    +               reduce using rule 240 (primary -> allocator .)
    -               reduce using rule 240 (primary -> allocator .)
    &               reduce using rule 240 (primary -> allocator .)
    ;               reduce using rule 240 (primary -> allocator .)
    AND             reduce using rule 240 (primary -> allocator .)
    OR              reduce using rule 240 (primary -> allocator .)
    XOR             reduce using rule 240 (primary -> allocator .)
    IS              reduce using rule 240 (primary -> allocator .)
    )               reduce using rule 240 (primary -> allocator .)
    ,               reduce using rule 240 (primary -> allocator .)
    DOTDOT          reduce using rule 240 (primary -> allocator .)
    ARROW           reduce using rule 240 (primary -> allocator .)
    |               reduce using rule 240 (primary -> allocator .)
    THEN            reduce using rule 240 (primary -> allocator .)
    WITH            reduce using rule 240 (primary -> allocator .)
    LOOP            reduce using rule 240 (primary -> allocator .)
    RANGE           reduce using rule 240 (primary -> allocator .)
    DIGITS          reduce using rule 240 (primary -> allocator .)
    RENAMES         reduce using rule 240 (primary -> allocator .)
    ASSIGNMENT      reduce using rule 240 (primary -> allocator .)


state 131

    (7) pragma_arg -> simple_name . ARROW expression
    (155) name -> simple_name .

    ARROW           shift and go to state 223
    TICK            reduce using rule 155 (name -> simple_name .)
    (               reduce using rule 155 (name -> simple_name .)
    .               reduce using rule 155 (name -> simple_name .)
    STARSTAR        reduce using rule 155 (name -> simple_name .)
    *               reduce using rule 155 (name -> simple_name .)
    /               reduce using rule 155 (name -> simple_name .)
    MOD             reduce using rule 155 (name -> simple_name .)
    REM             reduce using rule 155 (name -> simple_name .)
    =               reduce using rule 155 (name -> simple_name .)
    NOTEQUAL        reduce using rule 155 (name -> simple_name .)
    <               reduce using rule 155 (name -> simple_name .)
    LESSEQ          reduce using rule 155 (name -> simple_name .)
    >               reduce using rule 155 (name -> simple_name .)
    GREATEREQ       reduce using rule 155 (name -> simple_name .)
    IN              reduce using rule 155 (name -> simple_name .)
    NOT             reduce using rule 155 (name -> simple_name .)
    +               reduce using rule 155 (name -> simple_name .)
    -               reduce using rule 155 (name -> simple_name .)
    &               reduce using rule 155 (name -> simple_name .)
    AND             reduce using rule 155 (name -> simple_name .)
    OR              reduce using rule 155 (name -> simple_name .)
    XOR             reduce using rule 155 (name -> simple_name .)
    )               reduce using rule 155 (name -> simple_name .)
    ,               reduce using rule 155 (name -> simple_name .)


state 132

    (244) parenthesized_primary -> ( . expression )
    (192) aggregate -> ( . comp_assoc )
    (193) aggregate -> ( . value_s_2 )
    (194) aggregate -> ( . expression WITH value_s )
    (195) aggregate -> ( . expression WITH NuLL RECORD )
    (196) aggregate -> ( . NuLL RECORD )
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (199) comp_assoc -> . choice_s ARROW expression
    (197) value_s_2 -> . value , value
    (198) value_s_2 -> . value_s_2 , value
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (123) choice_s -> . choice
    (124) choice_s -> . choice_s | choice
    (173) value -> . expression
    (174) value -> . comp_assoc
    (175) value -> . discrete_with_range
    (176) value -> . error
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (125) choice -> . expression
    (126) choice -> . discrete_with_range
    (127) choice -> . OTHERS
    (128) discrete_with_range -> . name range_constraint
    (129) discrete_with_range -> . range
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name TICK RANGE
    (64) range -> . name TICK RANGE ( expression )
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    NuLL            shift and go to state 235
    error           shift and go to state 234
    OTHERS          shift and go to state 224
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 225
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    comp_assoc                     shift and go to state 227
    choice_s                       shift and go to state 226
    choice                         shift and go to state 228
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    value_s_2                      shift and go to state 229
    aggregate                      shift and go to state 143
    discrete_with_range            shift and go to state 230
    term                           shift and go to state 146
    name                           shift and go to state 231
    operator_symbol                shift and go to state 149
    value                          shift and go to state 232
    range                          shift and go to state 233
    expression                     shift and go to state 236

state 133

    (223) unary -> + .

    NOT             reduce using rule 223 (unary -> + .)
    ABS             reduce using rule 223 (unary -> + .)
    INTEGER         reduce using rule 223 (unary -> + .)
    BASE_INTEGER    reduce using rule 223 (unary -> + .)
    FLOAT           reduce using rule 223 (unary -> + .)
    BASE_FLOAT      reduce using rule 223 (unary -> + .)
    NuLL            reduce using rule 223 (unary -> + .)
    NEW             reduce using rule 223 (unary -> + .)
    (               reduce using rule 223 (unary -> + .)
    CHAR            reduce using rule 223 (unary -> + .)
    IDENTIFIER      reduce using rule 223 (unary -> + .)
    STRING          reduce using rule 223 (unary -> + .)


state 134

    (224) unary -> - .

    NOT             reduce using rule 224 (unary -> - .)
    ABS             reduce using rule 224 (unary -> - .)
    INTEGER         reduce using rule 224 (unary -> - .)
    BASE_INTEGER    reduce using rule 224 (unary -> - .)
    FLOAT           reduce using rule 224 (unary -> - .)
    BASE_FLOAT      reduce using rule 224 (unary -> - .)
    NuLL            reduce using rule 224 (unary -> - .)
    NEW             reduce using rule 224 (unary -> - .)
    (               reduce using rule 224 (unary -> - .)
    CHAR            reduce using rule 224 (unary -> - .)
    IDENTIFIER      reduce using rule 224 (unary -> - .)
    STRING          reduce using rule 224 (unary -> - .)


state 135

    (238) primary -> literal .

    STARSTAR        reduce using rule 238 (primary -> literal .)
    *               reduce using rule 238 (primary -> literal .)
    /               reduce using rule 238 (primary -> literal .)
    MOD             reduce using rule 238 (primary -> literal .)
    REM             reduce using rule 238 (primary -> literal .)
    =               reduce using rule 238 (primary -> literal .)
    NOTEQUAL        reduce using rule 238 (primary -> literal .)
    <               reduce using rule 238 (primary -> literal .)
    LESSEQ          reduce using rule 238 (primary -> literal .)
    >               reduce using rule 238 (primary -> literal .)
    GREATEREQ       reduce using rule 238 (primary -> literal .)
    IN              reduce using rule 238 (primary -> literal .)
    NOT             reduce using rule 238 (primary -> literal .)
    +               reduce using rule 238 (primary -> literal .)
    -               reduce using rule 238 (primary -> literal .)
    &               reduce using rule 238 (primary -> literal .)
    ;               reduce using rule 238 (primary -> literal .)
    AND             reduce using rule 238 (primary -> literal .)
    OR              reduce using rule 238 (primary -> literal .)
    XOR             reduce using rule 238 (primary -> literal .)
    IS              reduce using rule 238 (primary -> literal .)
    )               reduce using rule 238 (primary -> literal .)
    ,               reduce using rule 238 (primary -> literal .)
    DOTDOT          reduce using rule 238 (primary -> literal .)
    ARROW           reduce using rule 238 (primary -> literal .)
    |               reduce using rule 238 (primary -> literal .)
    THEN            reduce using rule 238 (primary -> literal .)
    WITH            reduce using rule 238 (primary -> literal .)
    LOOP            reduce using rule 238 (primary -> literal .)
    RANGE           reduce using rule 238 (primary -> literal .)
    DIGITS          reduce using rule 238 (primary -> literal .)
    RENAMES         reduce using rule 238 (primary -> literal .)
    ASSIGNMENT      reduce using rule 238 (primary -> literal .)


state 136

    (187) literal -> BASE_INTEGER .

    STARSTAR        reduce using rule 187 (literal -> BASE_INTEGER .)
    *               reduce using rule 187 (literal -> BASE_INTEGER .)
    /               reduce using rule 187 (literal -> BASE_INTEGER .)
    MOD             reduce using rule 187 (literal -> BASE_INTEGER .)
    REM             reduce using rule 187 (literal -> BASE_INTEGER .)
    =               reduce using rule 187 (literal -> BASE_INTEGER .)
    NOTEQUAL        reduce using rule 187 (literal -> BASE_INTEGER .)
    <               reduce using rule 187 (literal -> BASE_INTEGER .)
    LESSEQ          reduce using rule 187 (literal -> BASE_INTEGER .)
    >               reduce using rule 187 (literal -> BASE_INTEGER .)
    GREATEREQ       reduce using rule 187 (literal -> BASE_INTEGER .)
    IN              reduce using rule 187 (literal -> BASE_INTEGER .)
    NOT             reduce using rule 187 (literal -> BASE_INTEGER .)
    +               reduce using rule 187 (literal -> BASE_INTEGER .)
    -               reduce using rule 187 (literal -> BASE_INTEGER .)
    &               reduce using rule 187 (literal -> BASE_INTEGER .)
    AND             reduce using rule 187 (literal -> BASE_INTEGER .)
    OR              reduce using rule 187 (literal -> BASE_INTEGER .)
    XOR             reduce using rule 187 (literal -> BASE_INTEGER .)
    THEN            reduce using rule 187 (literal -> BASE_INTEGER .)
    DOTDOT          reduce using rule 187 (literal -> BASE_INTEGER .)
    ARROW           reduce using rule 187 (literal -> BASE_INTEGER .)
    |               reduce using rule 187 (literal -> BASE_INTEGER .)
    )               reduce using rule 187 (literal -> BASE_INTEGER .)
    ,               reduce using rule 187 (literal -> BASE_INTEGER .)
    WITH            reduce using rule 187 (literal -> BASE_INTEGER .)
    ;               reduce using rule 187 (literal -> BASE_INTEGER .)
    IS              reduce using rule 187 (literal -> BASE_INTEGER .)
    LOOP            reduce using rule 187 (literal -> BASE_INTEGER .)
    RANGE           reduce using rule 187 (literal -> BASE_INTEGER .)
    DIGITS          reduce using rule 187 (literal -> BASE_INTEGER .)
    RENAMES         reduce using rule 187 (literal -> BASE_INTEGER .)
    ASSIGNMENT      reduce using rule 187 (literal -> BASE_INTEGER .)


state 137

    (228) term -> factor .

    *               reduce using rule 228 (term -> factor .)
    /               reduce using rule 228 (term -> factor .)
    MOD             reduce using rule 228 (term -> factor .)
    REM             reduce using rule 228 (term -> factor .)
    DOTDOT          reduce using rule 228 (term -> factor .)
    +               reduce using rule 228 (term -> factor .)
    -               reduce using rule 228 (term -> factor .)
    &               reduce using rule 228 (term -> factor .)
    =               reduce using rule 228 (term -> factor .)
    NOTEQUAL        reduce using rule 228 (term -> factor .)
    <               reduce using rule 228 (term -> factor .)
    LESSEQ          reduce using rule 228 (term -> factor .)
    >               reduce using rule 228 (term -> factor .)
    GREATEREQ       reduce using rule 228 (term -> factor .)
    IN              reduce using rule 228 (term -> factor .)
    NOT             reduce using rule 228 (term -> factor .)
    AND             reduce using rule 228 (term -> factor .)
    OR              reduce using rule 228 (term -> factor .)
    XOR             reduce using rule 228 (term -> factor .)
    )               reduce using rule 228 (term -> factor .)
    ,               reduce using rule 228 (term -> factor .)
    ARROW           reduce using rule 228 (term -> factor .)
    |               reduce using rule 228 (term -> factor .)
    RANGE           reduce using rule 228 (term -> factor .)
    ;               reduce using rule 228 (term -> factor .)
    THEN            reduce using rule 228 (term -> factor .)
    WITH            reduce using rule 228 (term -> factor .)
    IS              reduce using rule 228 (term -> factor .)
    LOOP            reduce using rule 228 (term -> factor .)
    DIGITS          reduce using rule 228 (term -> factor .)
    RENAMES         reduce using rule 228 (term -> factor .)
    ASSIGNMENT      reduce using rule 228 (term -> factor .)


state 138

    (169) operator_symbol -> STRING .

    TICK            reduce using rule 169 (operator_symbol -> STRING .)
    (               reduce using rule 169 (operator_symbol -> STRING .)
    .               reduce using rule 169 (operator_symbol -> STRING .)
    STARSTAR        reduce using rule 169 (operator_symbol -> STRING .)
    *               reduce using rule 169 (operator_symbol -> STRING .)
    /               reduce using rule 169 (operator_symbol -> STRING .)
    MOD             reduce using rule 169 (operator_symbol -> STRING .)
    REM             reduce using rule 169 (operator_symbol -> STRING .)
    =               reduce using rule 169 (operator_symbol -> STRING .)
    NOTEQUAL        reduce using rule 169 (operator_symbol -> STRING .)
    <               reduce using rule 169 (operator_symbol -> STRING .)
    LESSEQ          reduce using rule 169 (operator_symbol -> STRING .)
    >               reduce using rule 169 (operator_symbol -> STRING .)
    GREATEREQ       reduce using rule 169 (operator_symbol -> STRING .)
    IN              reduce using rule 169 (operator_symbol -> STRING .)
    NOT             reduce using rule 169 (operator_symbol -> STRING .)
    +               reduce using rule 169 (operator_symbol -> STRING .)
    -               reduce using rule 169 (operator_symbol -> STRING .)
    &               reduce using rule 169 (operator_symbol -> STRING .)
    AND             reduce using rule 169 (operator_symbol -> STRING .)
    OR              reduce using rule 169 (operator_symbol -> STRING .)
    XOR             reduce using rule 169 (operator_symbol -> STRING .)
    )               reduce using rule 169 (operator_symbol -> STRING .)
    ,               reduce using rule 169 (operator_symbol -> STRING .)
    WITH            reduce using rule 169 (operator_symbol -> STRING .)
    ARROW           reduce using rule 169 (operator_symbol -> STRING .)
    |               reduce using rule 169 (operator_symbol -> STRING .)
    ;               reduce using rule 169 (operator_symbol -> STRING .)
    IS              reduce using rule 169 (operator_symbol -> STRING .)
    THEN            reduce using rule 169 (operator_symbol -> STRING .)
    LOOP            reduce using rule 169 (operator_symbol -> STRING .)
    RANGE           reduce using rule 169 (operator_symbol -> STRING .)
    DIGITS          reduce using rule 169 (operator_symbol -> STRING .)
    RENAMES         reduce using rule 169 (operator_symbol -> STRING .)
    ASSIGNMENT      reduce using rule 169 (operator_symbol -> STRING .)
    DOTDOT          reduce using rule 169 (operator_symbol -> STRING .)
    WHEN            reduce using rule 169 (operator_symbol -> STRING .)


state 139

    (3) pragma -> PRAGMA simple_name ( pragma_arg_s . ) ;
    (5) pragma_arg_s -> pragma_arg_s . , pragma_arg

    )               shift and go to state 237
    ,               shift and go to state 238


state 140

    (236) factor -> ABS . primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 147
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    primary                        shift and go to state 239
    used_char                      shift and go to state 144
    literal                        shift and go to state 135
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158

state 141

    (242) primary -> parenthesized_primary .

    STARSTAR        reduce using rule 242 (primary -> parenthesized_primary .)
    *               reduce using rule 242 (primary -> parenthesized_primary .)
    /               reduce using rule 242 (primary -> parenthesized_primary .)
    MOD             reduce using rule 242 (primary -> parenthesized_primary .)
    REM             reduce using rule 242 (primary -> parenthesized_primary .)
    =               reduce using rule 242 (primary -> parenthesized_primary .)
    NOTEQUAL        reduce using rule 242 (primary -> parenthesized_primary .)
    <               reduce using rule 242 (primary -> parenthesized_primary .)
    LESSEQ          reduce using rule 242 (primary -> parenthesized_primary .)
    >               reduce using rule 242 (primary -> parenthesized_primary .)
    GREATEREQ       reduce using rule 242 (primary -> parenthesized_primary .)
    IN              reduce using rule 242 (primary -> parenthesized_primary .)
    NOT             reduce using rule 242 (primary -> parenthesized_primary .)
    +               reduce using rule 242 (primary -> parenthesized_primary .)
    -               reduce using rule 242 (primary -> parenthesized_primary .)
    &               reduce using rule 242 (primary -> parenthesized_primary .)
    ;               reduce using rule 242 (primary -> parenthesized_primary .)
    AND             reduce using rule 242 (primary -> parenthesized_primary .)
    OR              reduce using rule 242 (primary -> parenthesized_primary .)
    XOR             reduce using rule 242 (primary -> parenthesized_primary .)
    IS              reduce using rule 242 (primary -> parenthesized_primary .)
    )               reduce using rule 242 (primary -> parenthesized_primary .)
    ,               reduce using rule 242 (primary -> parenthesized_primary .)
    DOTDOT          reduce using rule 242 (primary -> parenthesized_primary .)
    ARROW           reduce using rule 242 (primary -> parenthesized_primary .)
    |               reduce using rule 242 (primary -> parenthesized_primary .)
    THEN            reduce using rule 242 (primary -> parenthesized_primary .)
    WITH            reduce using rule 242 (primary -> parenthesized_primary .)
    LOOP            reduce using rule 242 (primary -> parenthesized_primary .)
    RANGE           reduce using rule 242 (primary -> parenthesized_primary .)
    DIGITS          reduce using rule 242 (primary -> parenthesized_primary .)
    RENAMES         reduce using rule 242 (primary -> parenthesized_primary .)
    ASSIGNMENT      reduce using rule 242 (primary -> parenthesized_primary .)


state 142

    (186) literal -> INTEGER .

    STARSTAR        reduce using rule 186 (literal -> INTEGER .)
    *               reduce using rule 186 (literal -> INTEGER .)
    /               reduce using rule 186 (literal -> INTEGER .)
    MOD             reduce using rule 186 (literal -> INTEGER .)
    REM             reduce using rule 186 (literal -> INTEGER .)
    =               reduce using rule 186 (literal -> INTEGER .)
    NOTEQUAL        reduce using rule 186 (literal -> INTEGER .)
    <               reduce using rule 186 (literal -> INTEGER .)
    LESSEQ          reduce using rule 186 (literal -> INTEGER .)
    >               reduce using rule 186 (literal -> INTEGER .)
    GREATEREQ       reduce using rule 186 (literal -> INTEGER .)
    IN              reduce using rule 186 (literal -> INTEGER .)
    NOT             reduce using rule 186 (literal -> INTEGER .)
    +               reduce using rule 186 (literal -> INTEGER .)
    -               reduce using rule 186 (literal -> INTEGER .)
    &               reduce using rule 186 (literal -> INTEGER .)
    AND             reduce using rule 186 (literal -> INTEGER .)
    OR              reduce using rule 186 (literal -> INTEGER .)
    XOR             reduce using rule 186 (literal -> INTEGER .)
    THEN            reduce using rule 186 (literal -> INTEGER .)
    DOTDOT          reduce using rule 186 (literal -> INTEGER .)
    ARROW           reduce using rule 186 (literal -> INTEGER .)
    |               reduce using rule 186 (literal -> INTEGER .)
    )               reduce using rule 186 (literal -> INTEGER .)
    ,               reduce using rule 186 (literal -> INTEGER .)
    WITH            reduce using rule 186 (literal -> INTEGER .)
    ;               reduce using rule 186 (literal -> INTEGER .)
    IS              reduce using rule 186 (literal -> INTEGER .)
    LOOP            reduce using rule 186 (literal -> INTEGER .)
    RANGE           reduce using rule 186 (literal -> INTEGER .)
    DIGITS          reduce using rule 186 (literal -> INTEGER .)
    RENAMES         reduce using rule 186 (literal -> INTEGER .)
    ASSIGNMENT      reduce using rule 186 (literal -> INTEGER .)


state 143

    (243) parenthesized_primary -> aggregate .

    STARSTAR        reduce using rule 243 (parenthesized_primary -> aggregate .)
    *               reduce using rule 243 (parenthesized_primary -> aggregate .)
    /               reduce using rule 243 (parenthesized_primary -> aggregate .)
    MOD             reduce using rule 243 (parenthesized_primary -> aggregate .)
    REM             reduce using rule 243 (parenthesized_primary -> aggregate .)
    =               reduce using rule 243 (parenthesized_primary -> aggregate .)
    NOTEQUAL        reduce using rule 243 (parenthesized_primary -> aggregate .)
    <               reduce using rule 243 (parenthesized_primary -> aggregate .)
    LESSEQ          reduce using rule 243 (parenthesized_primary -> aggregate .)
    >               reduce using rule 243 (parenthesized_primary -> aggregate .)
    GREATEREQ       reduce using rule 243 (parenthesized_primary -> aggregate .)
    IN              reduce using rule 243 (parenthesized_primary -> aggregate .)
    NOT             reduce using rule 243 (parenthesized_primary -> aggregate .)
    +               reduce using rule 243 (parenthesized_primary -> aggregate .)
    -               reduce using rule 243 (parenthesized_primary -> aggregate .)
    &               reduce using rule 243 (parenthesized_primary -> aggregate .)
    AND             reduce using rule 243 (parenthesized_primary -> aggregate .)
    OR              reduce using rule 243 (parenthesized_primary -> aggregate .)
    XOR             reduce using rule 243 (parenthesized_primary -> aggregate .)
    RANGE           reduce using rule 243 (parenthesized_primary -> aggregate .)
    ;               reduce using rule 243 (parenthesized_primary -> aggregate .)
    THEN            reduce using rule 243 (parenthesized_primary -> aggregate .)
    )               reduce using rule 243 (parenthesized_primary -> aggregate .)
    ,               reduce using rule 243 (parenthesized_primary -> aggregate .)
    DOTDOT          reduce using rule 243 (parenthesized_primary -> aggregate .)
    WITH            reduce using rule 243 (parenthesized_primary -> aggregate .)
    ARROW           reduce using rule 243 (parenthesized_primary -> aggregate .)
    |               reduce using rule 243 (parenthesized_primary -> aggregate .)
    IS              reduce using rule 243 (parenthesized_primary -> aggregate .)
    LOOP            reduce using rule 243 (parenthesized_primary -> aggregate .)
    DIGITS          reduce using rule 243 (parenthesized_primary -> aggregate .)
    RENAMES         reduce using rule 243 (parenthesized_primary -> aggregate .)
    ASSIGNMENT      reduce using rule 243 (parenthesized_primary -> aggregate .)


state 144

    (190) literal -> used_char .

    STARSTAR        reduce using rule 190 (literal -> used_char .)
    *               reduce using rule 190 (literal -> used_char .)
    /               reduce using rule 190 (literal -> used_char .)
    MOD             reduce using rule 190 (literal -> used_char .)
    REM             reduce using rule 190 (literal -> used_char .)
    =               reduce using rule 190 (literal -> used_char .)
    NOTEQUAL        reduce using rule 190 (literal -> used_char .)
    <               reduce using rule 190 (literal -> used_char .)
    LESSEQ          reduce using rule 190 (literal -> used_char .)
    >               reduce using rule 190 (literal -> used_char .)
    GREATEREQ       reduce using rule 190 (literal -> used_char .)
    IN              reduce using rule 190 (literal -> used_char .)
    NOT             reduce using rule 190 (literal -> used_char .)
    +               reduce using rule 190 (literal -> used_char .)
    -               reduce using rule 190 (literal -> used_char .)
    &               reduce using rule 190 (literal -> used_char .)
    AND             reduce using rule 190 (literal -> used_char .)
    OR              reduce using rule 190 (literal -> used_char .)
    XOR             reduce using rule 190 (literal -> used_char .)
    THEN            reduce using rule 190 (literal -> used_char .)
    DOTDOT          reduce using rule 190 (literal -> used_char .)
    ARROW           reduce using rule 190 (literal -> used_char .)
    |               reduce using rule 190 (literal -> used_char .)
    )               reduce using rule 190 (literal -> used_char .)
    ,               reduce using rule 190 (literal -> used_char .)
    WITH            reduce using rule 190 (literal -> used_char .)
    ;               reduce using rule 190 (literal -> used_char .)
    IS              reduce using rule 190 (literal -> used_char .)
    LOOP            reduce using rule 190 (literal -> used_char .)
    RANGE           reduce using rule 190 (literal -> used_char .)
    DIGITS          reduce using rule 190 (literal -> used_char .)
    RENAMES         reduce using rule 190 (literal -> used_char .)
    ASSIGNMENT      reduce using rule 190 (literal -> used_char .)


state 145

    (168) used_char -> CHAR .

    STARSTAR        reduce using rule 168 (used_char -> CHAR .)
    *               reduce using rule 168 (used_char -> CHAR .)
    /               reduce using rule 168 (used_char -> CHAR .)
    MOD             reduce using rule 168 (used_char -> CHAR .)
    REM             reduce using rule 168 (used_char -> CHAR .)
    DOTDOT          reduce using rule 168 (used_char -> CHAR .)
    +               reduce using rule 168 (used_char -> CHAR .)
    -               reduce using rule 168 (used_char -> CHAR .)
    &               reduce using rule 168 (used_char -> CHAR .)
    =               reduce using rule 168 (used_char -> CHAR .)
    NOTEQUAL        reduce using rule 168 (used_char -> CHAR .)
    <               reduce using rule 168 (used_char -> CHAR .)
    LESSEQ          reduce using rule 168 (used_char -> CHAR .)
    >               reduce using rule 168 (used_char -> CHAR .)
    GREATEREQ       reduce using rule 168 (used_char -> CHAR .)
    IN              reduce using rule 168 (used_char -> CHAR .)
    NOT             reduce using rule 168 (used_char -> CHAR .)
    AND             reduce using rule 168 (used_char -> CHAR .)
    OR              reduce using rule 168 (used_char -> CHAR .)
    XOR             reduce using rule 168 (used_char -> CHAR .)
    ARROW           reduce using rule 168 (used_char -> CHAR .)
    |               reduce using rule 168 (used_char -> CHAR .)
    ;               reduce using rule 168 (used_char -> CHAR .)
    IS              reduce using rule 168 (used_char -> CHAR .)
    DIGITS          reduce using rule 168 (used_char -> CHAR .)
    RANGE           reduce using rule 168 (used_char -> CHAR .)
    )               reduce using rule 168 (used_char -> CHAR .)
    ,               reduce using rule 168 (used_char -> CHAR .)
    WITH            reduce using rule 168 (used_char -> CHAR .)
    THEN            reduce using rule 168 (used_char -> CHAR .)
    LOOP            reduce using rule 168 (used_char -> CHAR .)
    RENAMES         reduce using rule 168 (used_char -> CHAR .)
    ASSIGNMENT      reduce using rule 168 (used_char -> CHAR .)
    TICK            reduce using rule 168 (used_char -> CHAR .)
    (               reduce using rule 168 (used_char -> CHAR .)
    .               reduce using rule 168 (used_char -> CHAR .)
    WHEN            reduce using rule 168 (used_char -> CHAR .)


state 146

    (221) simple_expression -> term .
    (229) term -> term . multiplying factor
    (230) multiplying -> . *
    (231) multiplying -> . /
    (232) multiplying -> . MOD
    (233) multiplying -> . REM

    DOTDOT          reduce using rule 221 (simple_expression -> term .)
    +               reduce using rule 221 (simple_expression -> term .)
    -               reduce using rule 221 (simple_expression -> term .)
    &               reduce using rule 221 (simple_expression -> term .)
    =               reduce using rule 221 (simple_expression -> term .)
    NOTEQUAL        reduce using rule 221 (simple_expression -> term .)
    <               reduce using rule 221 (simple_expression -> term .)
    LESSEQ          reduce using rule 221 (simple_expression -> term .)
    >               reduce using rule 221 (simple_expression -> term .)
    GREATEREQ       reduce using rule 221 (simple_expression -> term .)
    IN              reduce using rule 221 (simple_expression -> term .)
    NOT             reduce using rule 221 (simple_expression -> term .)
    AND             reduce using rule 221 (simple_expression -> term .)
    OR              reduce using rule 221 (simple_expression -> term .)
    XOR             reduce using rule 221 (simple_expression -> term .)
    ;               reduce using rule 221 (simple_expression -> term .)
    IS              reduce using rule 221 (simple_expression -> term .)
    RANGE           reduce using rule 221 (simple_expression -> term .)
    )               reduce using rule 221 (simple_expression -> term .)
    ,               reduce using rule 221 (simple_expression -> term .)
    WITH            reduce using rule 221 (simple_expression -> term .)
    ARROW           reduce using rule 221 (simple_expression -> term .)
    |               reduce using rule 221 (simple_expression -> term .)
    THEN            reduce using rule 221 (simple_expression -> term .)
    LOOP            reduce using rule 221 (simple_expression -> term .)
    DIGITS          reduce using rule 221 (simple_expression -> term .)
    RENAMES         reduce using rule 221 (simple_expression -> term .)
    ASSIGNMENT      reduce using rule 221 (simple_expression -> term .)
    *               shift and go to state 242
    /               shift and go to state 243
    MOD             shift and go to state 244
    REM             shift and go to state 240

    multiplying                    shift and go to state 241

state 147

    (239) primary -> name .
    (245) qualified -> name . TICK parenthesized_primary
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id

    STARSTAR        reduce using rule 239 (primary -> name .)
    *               reduce using rule 239 (primary -> name .)
    /               reduce using rule 239 (primary -> name .)
    MOD             reduce using rule 239 (primary -> name .)
    REM             reduce using rule 239 (primary -> name .)
    =               reduce using rule 239 (primary -> name .)
    NOTEQUAL        reduce using rule 239 (primary -> name .)
    <               reduce using rule 239 (primary -> name .)
    LESSEQ          reduce using rule 239 (primary -> name .)
    >               reduce using rule 239 (primary -> name .)
    GREATEREQ       reduce using rule 239 (primary -> name .)
    IN              reduce using rule 239 (primary -> name .)
    NOT             reduce using rule 239 (primary -> name .)
    +               reduce using rule 239 (primary -> name .)
    -               reduce using rule 239 (primary -> name .)
    &               reduce using rule 239 (primary -> name .)
    ;               reduce using rule 239 (primary -> name .)
    AND             reduce using rule 239 (primary -> name .)
    OR              reduce using rule 239 (primary -> name .)
    XOR             reduce using rule 239 (primary -> name .)
    IS              reduce using rule 239 (primary -> name .)
    )               reduce using rule 239 (primary -> name .)
    ,               reduce using rule 239 (primary -> name .)
    THEN            reduce using rule 239 (primary -> name .)
    WITH            reduce using rule 239 (primary -> name .)
    ARROW           reduce using rule 239 (primary -> name .)
    |               reduce using rule 239 (primary -> name .)
    LOOP            reduce using rule 239 (primary -> name .)
    RANGE           reduce using rule 239 (primary -> name .)
    DIGITS          reduce using rule 239 (primary -> name .)
    RENAMES         reduce using rule 239 (primary -> name .)
    ASSIGNMENT      reduce using rule 239 (primary -> name .)
    DOTDOT          reduce using rule 239 (primary -> name .)
    TICK            shift and go to state 247
    (               shift and go to state 245
    .               shift and go to state 246


state 148

    (188) literal -> FLOAT .

    STARSTAR        reduce using rule 188 (literal -> FLOAT .)
    *               reduce using rule 188 (literal -> FLOAT .)
    /               reduce using rule 188 (literal -> FLOAT .)
    MOD             reduce using rule 188 (literal -> FLOAT .)
    REM             reduce using rule 188 (literal -> FLOAT .)
    =               reduce using rule 188 (literal -> FLOAT .)
    NOTEQUAL        reduce using rule 188 (literal -> FLOAT .)
    <               reduce using rule 188 (literal -> FLOAT .)
    LESSEQ          reduce using rule 188 (literal -> FLOAT .)
    >               reduce using rule 188 (literal -> FLOAT .)
    GREATEREQ       reduce using rule 188 (literal -> FLOAT .)
    IN              reduce using rule 188 (literal -> FLOAT .)
    NOT             reduce using rule 188 (literal -> FLOAT .)
    +               reduce using rule 188 (literal -> FLOAT .)
    -               reduce using rule 188 (literal -> FLOAT .)
    &               reduce using rule 188 (literal -> FLOAT .)
    AND             reduce using rule 188 (literal -> FLOAT .)
    OR              reduce using rule 188 (literal -> FLOAT .)
    XOR             reduce using rule 188 (literal -> FLOAT .)
    THEN            reduce using rule 188 (literal -> FLOAT .)
    DOTDOT          reduce using rule 188 (literal -> FLOAT .)
    ARROW           reduce using rule 188 (literal -> FLOAT .)
    |               reduce using rule 188 (literal -> FLOAT .)
    )               reduce using rule 188 (literal -> FLOAT .)
    ,               reduce using rule 188 (literal -> FLOAT .)
    WITH            reduce using rule 188 (literal -> FLOAT .)
    ;               reduce using rule 188 (literal -> FLOAT .)
    IS              reduce using rule 188 (literal -> FLOAT .)
    LOOP            reduce using rule 188 (literal -> FLOAT .)
    RANGE           reduce using rule 188 (literal -> FLOAT .)
    DIGITS          reduce using rule 188 (literal -> FLOAT .)
    RENAMES         reduce using rule 188 (literal -> FLOAT .)
    ASSIGNMENT      reduce using rule 188 (literal -> FLOAT .)


state 149

    (159) name -> operator_symbol .

    (               reduce using rule 159 (name -> operator_symbol .)
    .               reduce using rule 159 (name -> operator_symbol .)
    TICK            reduce using rule 159 (name -> operator_symbol .)
    ;               reduce using rule 159 (name -> operator_symbol .)
    ASSIGNMENT      reduce using rule 159 (name -> operator_symbol .)
    RANGE           reduce using rule 159 (name -> operator_symbol .)
    )               reduce using rule 159 (name -> operator_symbol .)
    ,               reduce using rule 159 (name -> operator_symbol .)
    STARSTAR        reduce using rule 159 (name -> operator_symbol .)
    *               reduce using rule 159 (name -> operator_symbol .)
    /               reduce using rule 159 (name -> operator_symbol .)
    MOD             reduce using rule 159 (name -> operator_symbol .)
    REM             reduce using rule 159 (name -> operator_symbol .)
    DOTDOT          reduce using rule 159 (name -> operator_symbol .)
    +               reduce using rule 159 (name -> operator_symbol .)
    -               reduce using rule 159 (name -> operator_symbol .)
    &               reduce using rule 159 (name -> operator_symbol .)
    =               reduce using rule 159 (name -> operator_symbol .)
    NOTEQUAL        reduce using rule 159 (name -> operator_symbol .)
    <               reduce using rule 159 (name -> operator_symbol .)
    LESSEQ          reduce using rule 159 (name -> operator_symbol .)
    >               reduce using rule 159 (name -> operator_symbol .)
    GREATEREQ       reduce using rule 159 (name -> operator_symbol .)
    IN              reduce using rule 159 (name -> operator_symbol .)
    NOT             reduce using rule 159 (name -> operator_symbol .)
    AND             reduce using rule 159 (name -> operator_symbol .)
    OR              reduce using rule 159 (name -> operator_symbol .)
    XOR             reduce using rule 159 (name -> operator_symbol .)
    ARROW           reduce using rule 159 (name -> operator_symbol .)
    |               reduce using rule 159 (name -> operator_symbol .)
    WITH            reduce using rule 159 (name -> operator_symbol .)
    IS              reduce using rule 159 (name -> operator_symbol .)
    THEN            reduce using rule 159 (name -> operator_symbol .)
    LOOP            reduce using rule 159 (name -> operator_symbol .)
    DIGITS          reduce using rule 159 (name -> operator_symbol .)
    RENAMES         reduce using rule 159 (name -> operator_symbol .)
    WHEN            reduce using rule 159 (name -> operator_symbol .)


state 150

    (241) primary -> qualified .

    STARSTAR        reduce using rule 241 (primary -> qualified .)
    *               reduce using rule 241 (primary -> qualified .)
    /               reduce using rule 241 (primary -> qualified .)
    MOD             reduce using rule 241 (primary -> qualified .)
    REM             reduce using rule 241 (primary -> qualified .)
    =               reduce using rule 241 (primary -> qualified .)
    NOTEQUAL        reduce using rule 241 (primary -> qualified .)
    <               reduce using rule 241 (primary -> qualified .)
    LESSEQ          reduce using rule 241 (primary -> qualified .)
    >               reduce using rule 241 (primary -> qualified .)
    GREATEREQ       reduce using rule 241 (primary -> qualified .)
    IN              reduce using rule 241 (primary -> qualified .)
    NOT             reduce using rule 241 (primary -> qualified .)
    +               reduce using rule 241 (primary -> qualified .)
    -               reduce using rule 241 (primary -> qualified .)
    &               reduce using rule 241 (primary -> qualified .)
    ;               reduce using rule 241 (primary -> qualified .)
    AND             reduce using rule 241 (primary -> qualified .)
    OR              reduce using rule 241 (primary -> qualified .)
    XOR             reduce using rule 241 (primary -> qualified .)
    IS              reduce using rule 241 (primary -> qualified .)
    )               reduce using rule 241 (primary -> qualified .)
    ,               reduce using rule 241 (primary -> qualified .)
    DOTDOT          reduce using rule 241 (primary -> qualified .)
    ARROW           reduce using rule 241 (primary -> qualified .)
    |               reduce using rule 241 (primary -> qualified .)
    THEN            reduce using rule 241 (primary -> qualified .)
    WITH            reduce using rule 241 (primary -> qualified .)
    LOOP            reduce using rule 241 (primary -> qualified .)
    RANGE           reduce using rule 241 (primary -> qualified .)
    DIGITS          reduce using rule 241 (primary -> qualified .)
    RENAMES         reduce using rule 241 (primary -> qualified .)
    ASSIGNMENT      reduce using rule 241 (primary -> qualified .)


state 151

    (235) factor -> NOT . primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 147
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    primary                        shift and go to state 248
    used_char                      shift and go to state 144
    literal                        shift and go to state 135
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158

state 152

    (191) literal -> NuLL .

    STARSTAR        reduce using rule 191 (literal -> NuLL .)
    *               reduce using rule 191 (literal -> NuLL .)
    /               reduce using rule 191 (literal -> NuLL .)
    MOD             reduce using rule 191 (literal -> NuLL .)
    REM             reduce using rule 191 (literal -> NuLL .)
    =               reduce using rule 191 (literal -> NuLL .)
    NOTEQUAL        reduce using rule 191 (literal -> NuLL .)
    <               reduce using rule 191 (literal -> NuLL .)
    LESSEQ          reduce using rule 191 (literal -> NuLL .)
    >               reduce using rule 191 (literal -> NuLL .)
    GREATEREQ       reduce using rule 191 (literal -> NuLL .)
    IN              reduce using rule 191 (literal -> NuLL .)
    NOT             reduce using rule 191 (literal -> NuLL .)
    +               reduce using rule 191 (literal -> NuLL .)
    -               reduce using rule 191 (literal -> NuLL .)
    &               reduce using rule 191 (literal -> NuLL .)
    AND             reduce using rule 191 (literal -> NuLL .)
    OR              reduce using rule 191 (literal -> NuLL .)
    XOR             reduce using rule 191 (literal -> NuLL .)
    THEN            reduce using rule 191 (literal -> NuLL .)
    DOTDOT          reduce using rule 191 (literal -> NuLL .)
    ARROW           reduce using rule 191 (literal -> NuLL .)
    |               reduce using rule 191 (literal -> NuLL .)
    )               reduce using rule 191 (literal -> NuLL .)
    ,               reduce using rule 191 (literal -> NuLL .)
    WITH            reduce using rule 191 (literal -> NuLL .)
    ;               reduce using rule 191 (literal -> NuLL .)
    IS              reduce using rule 191 (literal -> NuLL .)
    LOOP            reduce using rule 191 (literal -> NuLL .)
    RANGE           reduce using rule 191 (literal -> NuLL .)
    DIGITS          reduce using rule 191 (literal -> NuLL .)
    RENAMES         reduce using rule 191 (literal -> NuLL .)
    ASSIGNMENT      reduce using rule 191 (literal -> NuLL .)


state 153

    (6) pragma_arg -> expression .
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE

    )               reduce using rule 6 (pragma_arg -> expression .)
    ,               reduce using rule 6 (pragma_arg -> expression .)
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250

    logical                        shift and go to state 251
    short_circuit                  shift and go to state 252

state 154

    (435) comp_unit -> context_spec private_opt unit pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    PRIVATE         reduce using rule 435 (comp_unit -> context_spec private_opt unit pragma_s .)
    WITH            reduce using rule 435 (comp_unit -> context_spec private_opt unit pragma_s .)
    PACKAGE         reduce using rule 435 (comp_unit -> context_spec private_opt unit pragma_s .)
    SEPARATE        reduce using rule 435 (comp_unit -> context_spec private_opt unit pragma_s .)
    PROCEDURE       reduce using rule 435 (comp_unit -> context_spec private_opt unit pragma_s .)
    FUNCTION        reduce using rule 435 (comp_unit -> context_spec private_opt unit pragma_s .)
    GENERIC         reduce using rule 435 (comp_unit -> context_spec private_opt unit pragma_s .)
    $end            reduce using rule 435 (comp_unit -> context_spec private_opt unit pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 155

    (352) use_clause -> USE name_s . ;
    (355) name_s -> name_s . , name

    ;               shift and go to state 254
    ,               shift and go to state 255


state 156

    (354) name_s -> name .
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id

    ;               reduce using rule 354 (name_s -> name .)
    ,               reduce using rule 354 (name_s -> name .)
    (               shift and go to state 245
    .               shift and go to state 246
    TICK            shift and go to state 256


state 157

    (353) use_clause -> USE TYPE . name_s ;
    (354) name_s -> . name
    (355) name_s -> . name_s , name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name_s                         shift and go to state 257
    name                           shift and go to state 156
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 158

    (155) name -> simple_name .

    (               reduce using rule 155 (name -> simple_name .)
    .               reduce using rule 155 (name -> simple_name .)
    TICK            reduce using rule 155 (name -> simple_name .)
    ;               reduce using rule 155 (name -> simple_name .)
    ASSIGNMENT      reduce using rule 155 (name -> simple_name .)
    RANGE           reduce using rule 155 (name -> simple_name .)
    )               reduce using rule 155 (name -> simple_name .)
    ,               reduce using rule 155 (name -> simple_name .)
    STARSTAR        reduce using rule 155 (name -> simple_name .)
    *               reduce using rule 155 (name -> simple_name .)
    /               reduce using rule 155 (name -> simple_name .)
    MOD             reduce using rule 155 (name -> simple_name .)
    REM             reduce using rule 155 (name -> simple_name .)
    DOTDOT          reduce using rule 155 (name -> simple_name .)
    +               reduce using rule 155 (name -> simple_name .)
    -               reduce using rule 155 (name -> simple_name .)
    &               reduce using rule 155 (name -> simple_name .)
    =               reduce using rule 155 (name -> simple_name .)
    NOTEQUAL        reduce using rule 155 (name -> simple_name .)
    <               reduce using rule 155 (name -> simple_name .)
    LESSEQ          reduce using rule 155 (name -> simple_name .)
    >               reduce using rule 155 (name -> simple_name .)
    GREATEREQ       reduce using rule 155 (name -> simple_name .)
    IN              reduce using rule 155 (name -> simple_name .)
    NOT             reduce using rule 155 (name -> simple_name .)
    AND             reduce using rule 155 (name -> simple_name .)
    OR              reduce using rule 155 (name -> simple_name .)
    XOR             reduce using rule 155 (name -> simple_name .)
    ARROW           reduce using rule 155 (name -> simple_name .)
    |               reduce using rule 155 (name -> simple_name .)
    WITH            reduce using rule 155 (name -> simple_name .)
    IS              reduce using rule 155 (name -> simple_name .)
    THEN            reduce using rule 155 (name -> simple_name .)
    LOOP            reduce using rule 155 (name -> simple_name .)
    DIGITS          reduce using rule 155 (name -> simple_name .)
    RENAMES         reduce using rule 155 (name -> simple_name .)
    WHEN            reduce using rule 155 (name -> simple_name .)


state 159

    (452) subunit -> SEPARATE ( compound_name . ) subunit_body
    (165) compound_name -> compound_name . . simple_name

    )               shift and go to state 258
    .               shift and go to state 119


state 160

    (388) prot_body -> PROTECTED BODY . simple_name IS prot_op_body_s END id_opt ;
    (460) body_stub -> PROTECTED BODY . simple_name IS SEPARATE ;
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 259

state 161

    (373) prot_spec -> PROTECTED IDENTIFIER . prot_def
    (375) prot_def -> . IS prot_op_decl_s prot_private_opt END id_opt

    IS              shift and go to state 260

    prot_def                       shift and go to state 261

state 162

    (374) prot_spec -> PROTECTED TYPE . simple_name discrim_part_opt prot_def
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 262

state 163

    (304) block_body -> BEGIN . handled_stmt_s
    (305) handled_stmt_s -> . statement_s except_handler_part_opt
    (248) statement_s -> . statement
    (249) statement_s -> . statement_s statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    label                          shift and go to state 282
    statement_s                    shift and go to state 303
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    handled_stmt_s                 shift and go to state 289
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    assign_stmt                    shift and go to state 311
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 292
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 164

    (337) subprog_body -> subprog_spec_is_push decl_part block_body . END id_opt ;

    END             shift and go to state 312


state 165

    (509) attrib_def -> FOR mark . USE expression ;
    (510) record_type_spec -> FOR mark . USE RECORD align_opt comp_loc_s END RECORD ;
    (515) address_spec -> FOR mark . USE AT expression ;
    (161) mark -> mark . TICK attribute_id
    (162) mark -> mark . . simple_name

    USE             shift and go to state 313
    TICK            shift and go to state 315
    .               shift and go to state 314


state 166

    (160) mark -> simple_name .

    TICK            reduce using rule 160 (mark -> simple_name .)
    .               reduce using rule 160 (mark -> simple_name .)
    ;               reduce using rule 160 (mark -> simple_name .)
    ASSIGNMENT      reduce using rule 160 (mark -> simple_name .)
    )               reduce using rule 160 (mark -> simple_name .)
    AT              reduce using rule 160 (mark -> simple_name .)
    USE             reduce using rule 160 (mark -> simple_name .)


state 167

    (364) task_decl -> task_spec ; .

    error           reduce using rule 364 (task_decl -> task_spec ; .)
    USE             reduce using rule 364 (task_decl -> task_spec ; .)
    PRAGMA          reduce using rule 364 (task_decl -> task_spec ; .)
    TYPE            reduce using rule 364 (task_decl -> task_spec ; .)
    SUBTYPE         reduce using rule 364 (task_decl -> task_spec ; .)
    TASK            reduce using rule 364 (task_decl -> task_spec ; .)
    PACKAGE         reduce using rule 364 (task_decl -> task_spec ; .)
    PROTECTED       reduce using rule 364 (task_decl -> task_spec ; .)
    FOR             reduce using rule 364 (task_decl -> task_spec ; .)
    PROCEDURE       reduce using rule 364 (task_decl -> task_spec ; .)
    FUNCTION        reduce using rule 364 (task_decl -> task_spec ; .)
    GENERIC         reduce using rule 364 (task_decl -> task_spec ; .)
    IDENTIFIER      reduce using rule 364 (task_decl -> task_spec ; .)
    END             reduce using rule 364 (task_decl -> task_spec ; .)
    BEGIN           reduce using rule 364 (task_decl -> task_spec ; .)
    PRIVATE         reduce using rule 364 (task_decl -> task_spec ; .)


state 168

    (371) task_body -> TASK BODY . simple_name IS decl_part block_body END id_opt ;
    (457) body_stub -> TASK BODY . simple_name IS SEPARATE ;
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 316

state 169

    (366) task_spec -> TASK TYPE . simple_name discrim_part_opt task_def
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 317

state 170

    (365) task_spec -> TASK simple_name . task_def
    (367) task_def -> .
    (368) task_def -> . IS entry_decl_s rep_spec_s task_private_opt END id_opt

    ;               reduce using rule 367 (task_def -> .)
    IS              shift and go to state 318

    task_def                       shift and go to state 319

state 171

    (148) decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .

    PACKAGE         reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    TASK            reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    PROTECTED       reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    error           reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    USE             reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    PRAGMA          reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    TYPE            reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    SUBTYPE         reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    FOR             reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    PROCEDURE       reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    FUNCTION        reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    GENERIC         reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    IDENTIFIER      reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    BEGIN           reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    END             reduce using rule 148 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)


state 172

    (346) pkg_body -> PACKAGE BODY . compound_name IS decl_part body_opt END c_id_opt ;
    (458) body_stub -> PACKAGE BODY . compound_name IS SEPARATE ;
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 320
    simple_name                    shift and go to state 41

state 173

    (341) pkg_spec -> PACKAGE compound_name . IS decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> PACKAGE compound_name . IS generic_inst
    (359) rename_unit -> PACKAGE compound_name . renames ;
    (165) compound_name -> compound_name . . simple_name
    (363) renames -> . RENAMES name

    IS              shift and go to state 188
    .               shift and go to state 119
    RENAMES         shift and go to state 95

    renames                        shift and go to state 187

state 174

    (372) prot_decl -> prot_spec ; .

    PACKAGE         reduce using rule 372 (prot_decl -> prot_spec ; .)
    TASK            reduce using rule 372 (prot_decl -> prot_spec ; .)
    PROTECTED       reduce using rule 372 (prot_decl -> prot_spec ; .)
    error           reduce using rule 372 (prot_decl -> prot_spec ; .)
    USE             reduce using rule 372 (prot_decl -> prot_spec ; .)
    PRAGMA          reduce using rule 372 (prot_decl -> prot_spec ; .)
    TYPE            reduce using rule 372 (prot_decl -> prot_spec ; .)
    SUBTYPE         reduce using rule 372 (prot_decl -> prot_spec ; .)
    FOR             reduce using rule 372 (prot_decl -> prot_spec ; .)
    PROCEDURE       reduce using rule 372 (prot_decl -> prot_spec ; .)
    FUNCTION        reduce using rule 372 (prot_decl -> prot_spec ; .)
    GENERIC         reduce using rule 372 (prot_decl -> prot_spec ; .)
    IDENTIFIER      reduce using rule 372 (prot_decl -> prot_spec ; .)
    BEGIN           reduce using rule 372 (prot_decl -> prot_spec ; .)
    END             reduce using rule 372 (prot_decl -> prot_spec ; .)
    PRIVATE         reduce using rule 372 (prot_decl -> prot_spec ; .)


state 175

    (22) decl -> error ; .

    PACKAGE         reduce using rule 22 (decl -> error ; .)
    TASK            reduce using rule 22 (decl -> error ; .)
    PROTECTED       reduce using rule 22 (decl -> error ; .)
    error           reduce using rule 22 (decl -> error ; .)
    USE             reduce using rule 22 (decl -> error ; .)
    PRAGMA          reduce using rule 22 (decl -> error ; .)
    TYPE            reduce using rule 22 (decl -> error ; .)
    SUBTYPE         reduce using rule 22 (decl -> error ; .)
    FOR             reduce using rule 22 (decl -> error ; .)
    PROCEDURE       reduce using rule 22 (decl -> error ; .)
    FUNCTION        reduce using rule 22 (decl -> error ; .)
    GENERIC         reduce using rule 22 (decl -> error ; .)
    IDENTIFIER      reduce using rule 22 (decl -> error ; .)
    BEGIN           reduce using rule 22 (decl -> error ; .)
    END             reduce using rule 22 (decl -> error ; .)
    PRIVATE         reduce using rule 22 (decl -> error ; .)


state 176

    (36) type_decl -> TYPE IDENTIFIER . discrim_part_opt type_completion ;
    (37) discrim_part_opt -> .
    (38) discrim_part_opt -> . discrim_part
    (39) discrim_part_opt -> . ( LESSMORE )
    (112) discrim_part -> . ( discrim_spec_s )

    IS              reduce using rule 37 (discrim_part_opt -> .)
    ;               reduce using rule 37 (discrim_part_opt -> .)
    (               shift and go to state 321

    discrim_part_opt               shift and go to state 322
    discrim_part                   shift and go to state 323

state 177

    (318) subprog_decl -> subprog_spec_is_push ABSTRACT ; .

    PACKAGE         reduce using rule 318 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    TASK            reduce using rule 318 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    PROTECTED       reduce using rule 318 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    error           reduce using rule 318 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    USE             reduce using rule 318 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    PRAGMA          reduce using rule 318 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    TYPE            reduce using rule 318 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    SUBTYPE         reduce using rule 318 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    FOR             reduce using rule 318 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    PROCEDURE       reduce using rule 318 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    FUNCTION        reduce using rule 318 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    GENERIC         reduce using rule 318 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    IDENTIFIER      reduce using rule 318 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    BEGIN           reduce using rule 318 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    END             reduce using rule 318 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    PRIVATE         reduce using rule 318 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    WITH            reduce using rule 318 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    SEPARATE        reduce using rule 318 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    $end            reduce using rule 318 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)


state 178

    (50) subtype_decl -> SUBTYPE IDENTIFIER . IS subtype_ind ;

    IS              shift and go to state 324


state 179

    (336) subprog_spec_is_push -> subprog_spec IS .
    (459) body_stub -> subprog_spec IS . SEPARATE ;
    (503) generic_subp_inst -> subprog_spec IS . generic_inst
    (505) generic_inst -> . NEW name

    ABSTRACT        reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    PACKAGE         reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    TASK            reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    PROTECTED       reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    error           reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    USE             reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    PRAGMA          reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    TYPE            reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    SUBTYPE         reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    FOR             reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    PROCEDURE       reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    FUNCTION        reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    GENERIC         reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    IDENTIFIER      reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    BEGIN           reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    SEPARATE        shift and go to state 325
    NEW             shift and go to state 184

    generic_inst                   shift and go to state 185

state 180

    (25) def_id_s -> def_id_s , . def_id
    (26) def_id -> . IDENTIFIER

    IDENTIFIER      shift and go to state 76

    def_id                         shift and go to state 326

state 181

    (23) object_decl -> def_id_s : . object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> def_id_s : . CONSTANT ASSIGNMENT expression ;
    (461) exception_decl -> def_id_s : . EXCEPTION ;
    (356) rename_decl -> def_id_s : . object_qualifier_opt subtype_ind renames ;
    (357) rename_decl -> def_id_s : . EXCEPTION renames ;
    (27) object_qualifier_opt -> .
    (28) object_qualifier_opt -> . ALIASED
    (29) object_qualifier_opt -> . CONSTANT
    (30) object_qualifier_opt -> . ALIASED CONSTANT

    CONSTANT        shift and go to state 328
    EXCEPTION       shift and go to state 327
    ARRAY           reduce using rule 27 (object_qualifier_opt -> .)
    IDENTIFIER      reduce using rule 27 (object_qualifier_opt -> .)
    STRING          reduce using rule 27 (object_qualifier_opt -> .)
    ALIASED         shift and go to state 329

    object_qualifier_opt           shift and go to state 330

state 182

    (360) rename_unit -> subprog_spec renames ; .

    PACKAGE         reduce using rule 360 (rename_unit -> subprog_spec renames ; .)
    TASK            reduce using rule 360 (rename_unit -> subprog_spec renames ; .)
    PROTECTED       reduce using rule 360 (rename_unit -> subprog_spec renames ; .)
    error           reduce using rule 360 (rename_unit -> subprog_spec renames ; .)
    USE             reduce using rule 360 (rename_unit -> subprog_spec renames ; .)
    PRAGMA          reduce using rule 360 (rename_unit -> subprog_spec renames ; .)
    TYPE            reduce using rule 360 (rename_unit -> subprog_spec renames ; .)
    SUBTYPE         reduce using rule 360 (rename_unit -> subprog_spec renames ; .)
    FOR             reduce using rule 360 (rename_unit -> subprog_spec renames ; .)
    PROCEDURE       reduce using rule 360 (rename_unit -> subprog_spec renames ; .)
    FUNCTION        reduce using rule 360 (rename_unit -> subprog_spec renames ; .)
    GENERIC         reduce using rule 360 (rename_unit -> subprog_spec renames ; .)
    IDENTIFIER      reduce using rule 360 (rename_unit -> subprog_spec renames ; .)
    BEGIN           reduce using rule 360 (rename_unit -> subprog_spec renames ; .)
    END             reduce using rule 360 (rename_unit -> subprog_spec renames ; .)
    PRIVATE         reduce using rule 360 (rename_unit -> subprog_spec renames ; .)
    WITH            reduce using rule 360 (rename_unit -> subprog_spec renames ; .)
    SEPARATE        reduce using rule 360 (rename_unit -> subprog_spec renames ; .)
    $end            reduce using rule 360 (rename_unit -> subprog_spec renames ; .)


state 183

    (363) renames -> RENAMES name .
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id

    ;               reduce using rule 363 (renames -> RENAMES name .)
    (               shift and go to state 245
    .               shift and go to state 246
    TICK            shift and go to state 256


state 184

    (505) generic_inst -> NEW . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 331
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 185

    (503) generic_subp_inst -> subprog_spec IS generic_inst .

    ;               reduce using rule 503 (generic_subp_inst -> subprog_spec IS generic_inst .)


state 186

    (346) pkg_body -> PACKAGE BODY compound_name . IS decl_part body_opt END c_id_opt ;
    (165) compound_name -> compound_name . . simple_name

    IS              shift and go to state 332
    .               shift and go to state 119


state 187

    (359) rename_unit -> PACKAGE compound_name renames . ;

    ;               shift and go to state 333


state 188

    (341) pkg_spec -> PACKAGE compound_name IS . decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> PACKAGE compound_name IS . generic_inst
    (139) decl_item_s -> .
    (140) decl_item_s -> . decl_item_s1
    (505) generic_inst -> . NEW name
    (141) decl_item_s1 -> . decl_item
    (142) decl_item_s1 -> . decl_item_s1 decl_item
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (352) use_clause -> . USE name_s ;
    (353) use_clause -> . USE TYPE name_s ;
    (506) rep_spec -> . attrib_def
    (507) rep_spec -> . record_type_spec
    (508) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (316) subprog_decl -> . subprog_spec ;
    (317) subprog_decl -> . generic_subp_inst ;
    (318) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (339) pkg_decl -> . pkg_spec ;
    (340) pkg_decl -> . generic_pkg_inst ;
    (364) task_decl -> . task_spec ;
    (372) prot_decl -> . prot_spec ;
    (461) exception_decl -> . def_id_s : EXCEPTION ;
    (356) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (357) rename_decl -> . def_id_s : EXCEPTION renames ;
    (358) rename_decl -> . rename_unit
    (473) generic_decl -> . generic_formal_part subprog_spec ;
    (474) generic_decl -> . generic_formal_part pkg_spec ;
    (457) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (458) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (459) body_stub -> . subprog_spec IS SEPARATE ;
    (460) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (509) attrib_def -> . FOR mark USE expression ;
    (510) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (515) address_spec -> . FOR mark USE AT expression ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (319) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (320) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (321) subprog_spec -> . FUNCTION designator
    (503) generic_subp_inst -> . subprog_spec IS generic_inst
    (336) subprog_spec_is_push -> . subprog_spec IS
    (341) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (365) task_spec -> . TASK simple_name task_def
    (366) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (373) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (374) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (359) rename_unit -> . PACKAGE compound_name renames ;
    (360) rename_unit -> . subprog_spec renames ;
    (361) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (362) rename_unit -> . generic_formal_part subprog_spec renames ;
    (475) generic_formal_part -> . GENERIC
    (476) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    PRIVATE         reduce using rule 139 (decl_item_s -> .)
    END             reduce using rule 139 (decl_item_s -> .)
    NEW             shift and go to state 184
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    TASK            shift and go to state 339
    PACKAGE         shift and go to state 340
    PROTECTED       shift and go to state 336
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    task_decl                      shift and go to state 60
    subtype_decl                   shift and go to state 61
    generic_inst                   shift and go to state 334
    rep_spec                       shift and go to state 82
    decl_item_s1                   shift and go to state 335
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    decl_item                      shift and go to state 337
    subprog_spec_is_push           shift and go to state 341
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 342
    def_id_s                       shift and go to state 88
    task_spec                      shift and go to state 65
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    generic_subp_inst              shift and go to state 29
    def_id                         shift and go to state 89
    rename_decl                    shift and go to state 90
    type_decl                      shift and go to state 56
    rename_unit                    shift and go to state 91
    generic_formal_part            shift and go to state 33
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    subprog_decl                   shift and go to state 58
    decl_item_s                    shift and go to state 338
    pragma                         shift and go to state 74
    pkg_spec                       shift and go to state 37
    number_decl                    shift and go to state 93

state 189

    (325) formal_part_opt -> formal_part .

    WHEN            reduce using rule 325 (formal_part_opt -> formal_part .)
    ;               reduce using rule 325 (formal_part_opt -> formal_part .)
    DO              reduce using rule 325 (formal_part_opt -> formal_part .)
    RETURN          reduce using rule 325 (formal_part_opt -> formal_part .)
    IS              reduce using rule 325 (formal_part_opt -> formal_part .)
    RENAMES         reduce using rule 325 (formal_part_opt -> formal_part .)


state 190

    (326) formal_part -> ( . param_s )
    (327) param_s -> . param
    (328) param_s -> . param_s ; param
    (329) param -> . def_id_s : mode mark init_opt
    (330) param -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    error           shift and go to state 109
    IDENTIFIER      shift and go to state 76

    param_s                        shift and go to state 344
    param                          shift and go to state 343
    def_id                         shift and go to state 89
    def_id_s                       shift and go to state 105

state 191

    (319) subprog_spec -> PROCEDURE compound_name formal_part_opt .

    IS              reduce using rule 319 (subprog_spec -> PROCEDURE compound_name formal_part_opt .)
    ;               reduce using rule 319 (subprog_spec -> PROCEDURE compound_name formal_part_opt .)
    RENAMES         reduce using rule 319 (subprog_spec -> PROCEDURE compound_name formal_part_opt .)


state 192

    (480) generic_formal -> WITH FUNCTION . designator formal_part_opt RETURN name subp_default ;
    (322) designator -> . compound_name
    (323) designator -> . STRING
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 345
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 193

    (481) generic_formal -> WITH PACKAGE . simple_name IS NEW name ( LESSMORE ) ;
    (482) generic_formal -> WITH PACKAGE . simple_name IS NEW name ;
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 346

state 194

    (479) generic_formal -> WITH PROCEDURE . simple_name formal_part_opt subp_default ;
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 347

state 195

    (477) generic_formal -> param ; .

    PACKAGE         reduce using rule 477 (generic_formal -> param ; .)
    PROCEDURE       reduce using rule 477 (generic_formal -> param ; .)
    FUNCTION        reduce using rule 477 (generic_formal -> param ; .)
    TYPE            reduce using rule 477 (generic_formal -> param ; .)
    WITH            reduce using rule 477 (generic_formal -> param ; .)
    error           reduce using rule 477 (generic_formal -> param ; .)
    USE             reduce using rule 477 (generic_formal -> param ; .)
    IDENTIFIER      reduce using rule 477 (generic_formal -> param ; .)


state 196

    (362) rename_unit -> generic_formal_part subprog_spec renames . ;

    ;               shift and go to state 348


state 197

    (473) generic_decl -> generic_formal_part subprog_spec ; .

    PACKAGE         reduce using rule 473 (generic_decl -> generic_formal_part subprog_spec ; .)
    TASK            reduce using rule 473 (generic_decl -> generic_formal_part subprog_spec ; .)
    PROTECTED       reduce using rule 473 (generic_decl -> generic_formal_part subprog_spec ; .)
    error           reduce using rule 473 (generic_decl -> generic_formal_part subprog_spec ; .)
    USE             reduce using rule 473 (generic_decl -> generic_formal_part subprog_spec ; .)
    PRAGMA          reduce using rule 473 (generic_decl -> generic_formal_part subprog_spec ; .)
    TYPE            reduce using rule 473 (generic_decl -> generic_formal_part subprog_spec ; .)
    SUBTYPE         reduce using rule 473 (generic_decl -> generic_formal_part subprog_spec ; .)
    FOR             reduce using rule 473 (generic_decl -> generic_formal_part subprog_spec ; .)
    PROCEDURE       reduce using rule 473 (generic_decl -> generic_formal_part subprog_spec ; .)
    FUNCTION        reduce using rule 473 (generic_decl -> generic_formal_part subprog_spec ; .)
    GENERIC         reduce using rule 473 (generic_decl -> generic_formal_part subprog_spec ; .)
    IDENTIFIER      reduce using rule 473 (generic_decl -> generic_formal_part subprog_spec ; .)
    BEGIN           reduce using rule 473 (generic_decl -> generic_formal_part subprog_spec ; .)
    END             reduce using rule 473 (generic_decl -> generic_formal_part subprog_spec ; .)
    PRIVATE         reduce using rule 473 (generic_decl -> generic_formal_part subprog_spec ; .)
    WITH            reduce using rule 473 (generic_decl -> generic_formal_part subprog_spec ; .)
    SEPARATE        reduce using rule 473 (generic_decl -> generic_formal_part subprog_spec ; .)
    $end            reduce using rule 473 (generic_decl -> generic_formal_part subprog_spec ; .)


state 198

    (329) param -> def_id_s : . mode mark init_opt
    (331) mode -> .
    (332) mode -> . IN
    (333) mode -> . OUT
    (334) mode -> . IN OUT
    (335) mode -> . ACCESS

    IDENTIFIER      reduce using rule 331 (mode -> .)
    IN              shift and go to state 351
    OUT             shift and go to state 350
    ACCESS          shift and go to state 349

    mode                           shift and go to state 352

state 199

    (361) rename_unit -> generic_formal_part PACKAGE compound_name . renames ;
    (341) pkg_spec -> PACKAGE compound_name . IS decl_item_s private_part END c_id_opt
    (165) compound_name -> compound_name . . simple_name
    (363) renames -> . RENAMES name

    IS              shift and go to state 354
    .               shift and go to state 119
    RENAMES         shift and go to state 95

    renames                        shift and go to state 353

state 200

    (474) generic_decl -> generic_formal_part pkg_spec ; .

    PACKAGE         reduce using rule 474 (generic_decl -> generic_formal_part pkg_spec ; .)
    TASK            reduce using rule 474 (generic_decl -> generic_formal_part pkg_spec ; .)
    PROTECTED       reduce using rule 474 (generic_decl -> generic_formal_part pkg_spec ; .)
    error           reduce using rule 474 (generic_decl -> generic_formal_part pkg_spec ; .)
    USE             reduce using rule 474 (generic_decl -> generic_formal_part pkg_spec ; .)
    PRAGMA          reduce using rule 474 (generic_decl -> generic_formal_part pkg_spec ; .)
    TYPE            reduce using rule 474 (generic_decl -> generic_formal_part pkg_spec ; .)
    SUBTYPE         reduce using rule 474 (generic_decl -> generic_formal_part pkg_spec ; .)
    FOR             reduce using rule 474 (generic_decl -> generic_formal_part pkg_spec ; .)
    PROCEDURE       reduce using rule 474 (generic_decl -> generic_formal_part pkg_spec ; .)
    FUNCTION        reduce using rule 474 (generic_decl -> generic_formal_part pkg_spec ; .)
    GENERIC         reduce using rule 474 (generic_decl -> generic_formal_part pkg_spec ; .)
    IDENTIFIER      reduce using rule 474 (generic_decl -> generic_formal_part pkg_spec ; .)
    BEGIN           reduce using rule 474 (generic_decl -> generic_formal_part pkg_spec ; .)
    END             reduce using rule 474 (generic_decl -> generic_formal_part pkg_spec ; .)
    PRIVATE         reduce using rule 474 (generic_decl -> generic_formal_part pkg_spec ; .)
    WITH            reduce using rule 474 (generic_decl -> generic_formal_part pkg_spec ; .)
    SEPARATE        reduce using rule 474 (generic_decl -> generic_formal_part pkg_spec ; .)
    $end            reduce using rule 474 (generic_decl -> generic_formal_part pkg_spec ; .)


state 201

    (478) generic_formal -> TYPE simple_name . generic_discrim_part_opt IS generic_type_def ;
    (484) generic_discrim_part_opt -> .
    (485) generic_discrim_part_opt -> . discrim_part
    (486) generic_discrim_part_opt -> . ( LESSMORE )
    (112) discrim_part -> . ( discrim_spec_s )

    IS              reduce using rule 484 (generic_discrim_part_opt -> .)
    (               shift and go to state 356

    generic_discrim_part_opt       shift and go to state 355
    discrim_part                   shift and go to state 357

state 202

    (320) subprog_spec -> FUNCTION designator formal_part_opt . RETURN name

    RETURN          shift and go to state 358


state 203

    (167) c_name_list -> c_name_list , compound_name .
    (165) compound_name -> compound_name . . simple_name

    ;               reduce using rule 167 (c_name_list -> c_name_list , compound_name .)
    ,               reduce using rule 167 (c_name_list -> c_name_list , compound_name .)
    .               shift and go to state 119


state 204

    (165) compound_name -> compound_name . simple_name .

    .               reduce using rule 165 (compound_name -> compound_name . simple_name .)
    ;               reduce using rule 165 (compound_name -> compound_name . simple_name .)
    IS              reduce using rule 165 (compound_name -> compound_name . simple_name .)
    ,               reduce using rule 165 (compound_name -> compound_name . simple_name .)
    RENAMES         reduce using rule 165 (compound_name -> compound_name . simple_name .)
    (               reduce using rule 165 (compound_name -> compound_name . simple_name .)
    RETURN          reduce using rule 165 (compound_name -> compound_name . simple_name .)
    )               reduce using rule 165 (compound_name -> compound_name . simple_name .)


state 205

    (237) factor -> primary STARSTAR . primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 147
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    primary                        shift and go to state 359
    used_char                      shift and go to state 144
    literal                        shift and go to state 135
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158

state 206

    (220) simple_expression -> unary term .
    (229) term -> term . multiplying factor
    (230) multiplying -> . *
    (231) multiplying -> . /
    (232) multiplying -> . MOD
    (233) multiplying -> . REM

    DOTDOT          reduce using rule 220 (simple_expression -> unary term .)
    +               reduce using rule 220 (simple_expression -> unary term .)
    -               reduce using rule 220 (simple_expression -> unary term .)
    &               reduce using rule 220 (simple_expression -> unary term .)
    =               reduce using rule 220 (simple_expression -> unary term .)
    NOTEQUAL        reduce using rule 220 (simple_expression -> unary term .)
    <               reduce using rule 220 (simple_expression -> unary term .)
    LESSEQ          reduce using rule 220 (simple_expression -> unary term .)
    >               reduce using rule 220 (simple_expression -> unary term .)
    GREATEREQ       reduce using rule 220 (simple_expression -> unary term .)
    IN              reduce using rule 220 (simple_expression -> unary term .)
    NOT             reduce using rule 220 (simple_expression -> unary term .)
    AND             reduce using rule 220 (simple_expression -> unary term .)
    OR              reduce using rule 220 (simple_expression -> unary term .)
    XOR             reduce using rule 220 (simple_expression -> unary term .)
    ;               reduce using rule 220 (simple_expression -> unary term .)
    IS              reduce using rule 220 (simple_expression -> unary term .)
    RANGE           reduce using rule 220 (simple_expression -> unary term .)
    )               reduce using rule 220 (simple_expression -> unary term .)
    ,               reduce using rule 220 (simple_expression -> unary term .)
    WITH            reduce using rule 220 (simple_expression -> unary term .)
    ARROW           reduce using rule 220 (simple_expression -> unary term .)
    |               reduce using rule 220 (simple_expression -> unary term .)
    THEN            reduce using rule 220 (simple_expression -> unary term .)
    LOOP            reduce using rule 220 (simple_expression -> unary term .)
    DIGITS          reduce using rule 220 (simple_expression -> unary term .)
    RENAMES         reduce using rule 220 (simple_expression -> unary term .)
    ASSIGNMENT      reduce using rule 220 (simple_expression -> unary term .)
    *               shift and go to state 242
    /               shift and go to state 243
    MOD             shift and go to state 244
    REM             shift and go to state 240

    multiplying                    shift and go to state 241

state 207

    (246) allocator -> NEW name .
    (245) qualified -> name . TICK parenthesized_primary
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id

    STARSTAR        reduce using rule 246 (allocator -> NEW name .)
    *               reduce using rule 246 (allocator -> NEW name .)
    /               reduce using rule 246 (allocator -> NEW name .)
    MOD             reduce using rule 246 (allocator -> NEW name .)
    REM             reduce using rule 246 (allocator -> NEW name .)
    =               reduce using rule 246 (allocator -> NEW name .)
    NOTEQUAL        reduce using rule 246 (allocator -> NEW name .)
    <               reduce using rule 246 (allocator -> NEW name .)
    LESSEQ          reduce using rule 246 (allocator -> NEW name .)
    >               reduce using rule 246 (allocator -> NEW name .)
    GREATEREQ       reduce using rule 246 (allocator -> NEW name .)
    IN              reduce using rule 246 (allocator -> NEW name .)
    NOT             reduce using rule 246 (allocator -> NEW name .)
    +               reduce using rule 246 (allocator -> NEW name .)
    -               reduce using rule 246 (allocator -> NEW name .)
    &               reduce using rule 246 (allocator -> NEW name .)
    AND             reduce using rule 246 (allocator -> NEW name .)
    OR              reduce using rule 246 (allocator -> NEW name .)
    XOR             reduce using rule 246 (allocator -> NEW name .)
    )               reduce using rule 246 (allocator -> NEW name .)
    ,               reduce using rule 246 (allocator -> NEW name .)
    ;               reduce using rule 246 (allocator -> NEW name .)
    DOTDOT          reduce using rule 246 (allocator -> NEW name .)
    WITH            reduce using rule 246 (allocator -> NEW name .)
    ARROW           reduce using rule 246 (allocator -> NEW name .)
    |               reduce using rule 246 (allocator -> NEW name .)
    IS              reduce using rule 246 (allocator -> NEW name .)
    THEN            reduce using rule 246 (allocator -> NEW name .)
    LOOP            reduce using rule 246 (allocator -> NEW name .)
    RANGE           reduce using rule 246 (allocator -> NEW name .)
    DIGITS          reduce using rule 246 (allocator -> NEW name .)
    RENAMES         reduce using rule 246 (allocator -> NEW name .)
    ASSIGNMENT      reduce using rule 246 (allocator -> NEW name .)
    TICK            shift and go to state 247
    (               shift and go to state 245
    .               shift and go to state 246


state 208

    (247) allocator -> NEW qualified .

    STARSTAR        reduce using rule 247 (allocator -> NEW qualified .)
    *               reduce using rule 247 (allocator -> NEW qualified .)
    /               reduce using rule 247 (allocator -> NEW qualified .)
    MOD             reduce using rule 247 (allocator -> NEW qualified .)
    REM             reduce using rule 247 (allocator -> NEW qualified .)
    =               reduce using rule 247 (allocator -> NEW qualified .)
    NOTEQUAL        reduce using rule 247 (allocator -> NEW qualified .)
    <               reduce using rule 247 (allocator -> NEW qualified .)
    LESSEQ          reduce using rule 247 (allocator -> NEW qualified .)
    >               reduce using rule 247 (allocator -> NEW qualified .)
    GREATEREQ       reduce using rule 247 (allocator -> NEW qualified .)
    IN              reduce using rule 247 (allocator -> NEW qualified .)
    NOT             reduce using rule 247 (allocator -> NEW qualified .)
    +               reduce using rule 247 (allocator -> NEW qualified .)
    -               reduce using rule 247 (allocator -> NEW qualified .)
    &               reduce using rule 247 (allocator -> NEW qualified .)
    AND             reduce using rule 247 (allocator -> NEW qualified .)
    OR              reduce using rule 247 (allocator -> NEW qualified .)
    XOR             reduce using rule 247 (allocator -> NEW qualified .)
    )               reduce using rule 247 (allocator -> NEW qualified .)
    ,               reduce using rule 247 (allocator -> NEW qualified .)
    ;               reduce using rule 247 (allocator -> NEW qualified .)
    DOTDOT          reduce using rule 247 (allocator -> NEW qualified .)
    WITH            reduce using rule 247 (allocator -> NEW qualified .)
    ARROW           reduce using rule 247 (allocator -> NEW qualified .)
    |               reduce using rule 247 (allocator -> NEW qualified .)
    IS              reduce using rule 247 (allocator -> NEW qualified .)
    THEN            reduce using rule 247 (allocator -> NEW qualified .)
    LOOP            reduce using rule 247 (allocator -> NEW qualified .)
    RANGE           reduce using rule 247 (allocator -> NEW qualified .)
    DIGITS          reduce using rule 247 (allocator -> NEW qualified .)
    RENAMES         reduce using rule 247 (allocator -> NEW qualified .)
    ASSIGNMENT      reduce using rule 247 (allocator -> NEW qualified .)


state 209

    (222) simple_expression -> simple_expression adding . term
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 360
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149

state 210

    (213) relational -> NOTEQUAL .

    +               reduce using rule 213 (relational -> NOTEQUAL .)
    -               reduce using rule 213 (relational -> NOTEQUAL .)
    NOT             reduce using rule 213 (relational -> NOTEQUAL .)
    ABS             reduce using rule 213 (relational -> NOTEQUAL .)
    INTEGER         reduce using rule 213 (relational -> NOTEQUAL .)
    BASE_INTEGER    reduce using rule 213 (relational -> NOTEQUAL .)
    FLOAT           reduce using rule 213 (relational -> NOTEQUAL .)
    BASE_FLOAT      reduce using rule 213 (relational -> NOTEQUAL .)
    NuLL            reduce using rule 213 (relational -> NOTEQUAL .)
    NEW             reduce using rule 213 (relational -> NOTEQUAL .)
    (               reduce using rule 213 (relational -> NOTEQUAL .)
    CHAR            reduce using rule 213 (relational -> NOTEQUAL .)
    IDENTIFIER      reduce using rule 213 (relational -> NOTEQUAL .)
    STRING          reduce using rule 213 (relational -> NOTEQUAL .)


state 211

    (225) adding -> + .

    NOT             reduce using rule 225 (adding -> + .)
    ABS             reduce using rule 225 (adding -> + .)
    INTEGER         reduce using rule 225 (adding -> + .)
    BASE_INTEGER    reduce using rule 225 (adding -> + .)
    FLOAT           reduce using rule 225 (adding -> + .)
    BASE_FLOAT      reduce using rule 225 (adding -> + .)
    NuLL            reduce using rule 225 (adding -> + .)
    NEW             reduce using rule 225 (adding -> + .)
    (               reduce using rule 225 (adding -> + .)
    CHAR            reduce using rule 225 (adding -> + .)
    IDENTIFIER      reduce using rule 225 (adding -> + .)
    STRING          reduce using rule 225 (adding -> + .)


state 212

    (227) adding -> & .

    NOT             reduce using rule 227 (adding -> & .)
    ABS             reduce using rule 227 (adding -> & .)
    INTEGER         reduce using rule 227 (adding -> & .)
    BASE_INTEGER    reduce using rule 227 (adding -> & .)
    FLOAT           reduce using rule 227 (adding -> & .)
    BASE_FLOAT      reduce using rule 227 (adding -> & .)
    NuLL            reduce using rule 227 (adding -> & .)
    NEW             reduce using rule 227 (adding -> & .)
    (               reduce using rule 227 (adding -> & .)
    CHAR            reduce using rule 227 (adding -> & .)
    IDENTIFIER      reduce using rule 227 (adding -> & .)
    STRING          reduce using rule 227 (adding -> & .)


state 213

    (226) adding -> - .

    NOT             reduce using rule 226 (adding -> - .)
    ABS             reduce using rule 226 (adding -> - .)
    INTEGER         reduce using rule 226 (adding -> - .)
    BASE_INTEGER    reduce using rule 226 (adding -> - .)
    FLOAT           reduce using rule 226 (adding -> - .)
    BASE_FLOAT      reduce using rule 226 (adding -> - .)
    NuLL            reduce using rule 226 (adding -> - .)
    NEW             reduce using rule 226 (adding -> - .)
    (               reduce using rule 226 (adding -> - .)
    CHAR            reduce using rule 226 (adding -> - .)
    IDENTIFIER      reduce using rule 226 (adding -> - .)
    STRING          reduce using rule 226 (adding -> - .)


state 214

    (210) relation -> simple_expression membership . range
    (211) relation -> simple_expression membership . name
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name TICK RANGE
    (64) range -> . name TICK RANGE ( expression )
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    simple_expression              shift and go to state 361
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 362
    operator_symbol                shift and go to state 149
    range                          shift and go to state 363

state 215

    (217) relational -> GREATEREQ .

    +               reduce using rule 217 (relational -> GREATEREQ .)
    -               reduce using rule 217 (relational -> GREATEREQ .)
    NOT             reduce using rule 217 (relational -> GREATEREQ .)
    ABS             reduce using rule 217 (relational -> GREATEREQ .)
    INTEGER         reduce using rule 217 (relational -> GREATEREQ .)
    BASE_INTEGER    reduce using rule 217 (relational -> GREATEREQ .)
    FLOAT           reduce using rule 217 (relational -> GREATEREQ .)
    BASE_FLOAT      reduce using rule 217 (relational -> GREATEREQ .)
    NuLL            reduce using rule 217 (relational -> GREATEREQ .)
    NEW             reduce using rule 217 (relational -> GREATEREQ .)
    (               reduce using rule 217 (relational -> GREATEREQ .)
    CHAR            reduce using rule 217 (relational -> GREATEREQ .)
    IDENTIFIER      reduce using rule 217 (relational -> GREATEREQ .)
    STRING          reduce using rule 217 (relational -> GREATEREQ .)


state 216

    (215) relational -> LESSEQ .

    +               reduce using rule 215 (relational -> LESSEQ .)
    -               reduce using rule 215 (relational -> LESSEQ .)
    NOT             reduce using rule 215 (relational -> LESSEQ .)
    ABS             reduce using rule 215 (relational -> LESSEQ .)
    INTEGER         reduce using rule 215 (relational -> LESSEQ .)
    BASE_INTEGER    reduce using rule 215 (relational -> LESSEQ .)
    FLOAT           reduce using rule 215 (relational -> LESSEQ .)
    BASE_FLOAT      reduce using rule 215 (relational -> LESSEQ .)
    NuLL            reduce using rule 215 (relational -> LESSEQ .)
    NEW             reduce using rule 215 (relational -> LESSEQ .)
    (               reduce using rule 215 (relational -> LESSEQ .)
    CHAR            reduce using rule 215 (relational -> LESSEQ .)
    IDENTIFIER      reduce using rule 215 (relational -> LESSEQ .)
    STRING          reduce using rule 215 (relational -> LESSEQ .)


state 217

    (218) membership -> IN .

    IDENTIFIER      reduce using rule 218 (membership -> IN .)
    STRING          reduce using rule 218 (membership -> IN .)
    +               reduce using rule 218 (membership -> IN .)
    -               reduce using rule 218 (membership -> IN .)
    NOT             reduce using rule 218 (membership -> IN .)
    ABS             reduce using rule 218 (membership -> IN .)
    INTEGER         reduce using rule 218 (membership -> IN .)
    BASE_INTEGER    reduce using rule 218 (membership -> IN .)
    FLOAT           reduce using rule 218 (membership -> IN .)
    BASE_FLOAT      reduce using rule 218 (membership -> IN .)
    NuLL            reduce using rule 218 (membership -> IN .)
    NEW             reduce using rule 218 (membership -> IN .)
    (               reduce using rule 218 (membership -> IN .)
    CHAR            reduce using rule 218 (membership -> IN .)


state 218

    (219) membership -> NOT . IN

    IN              shift and go to state 364


state 219

    (209) relation -> simple_expression relational . simple_expression
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    simple_expression              shift and go to state 365
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149

state 220

    (212) relational -> = .

    +               reduce using rule 212 (relational -> = .)
    -               reduce using rule 212 (relational -> = .)
    NOT             reduce using rule 212 (relational -> = .)
    ABS             reduce using rule 212 (relational -> = .)
    INTEGER         reduce using rule 212 (relational -> = .)
    BASE_INTEGER    reduce using rule 212 (relational -> = .)
    FLOAT           reduce using rule 212 (relational -> = .)
    BASE_FLOAT      reduce using rule 212 (relational -> = .)
    NuLL            reduce using rule 212 (relational -> = .)
    NEW             reduce using rule 212 (relational -> = .)
    (               reduce using rule 212 (relational -> = .)
    CHAR            reduce using rule 212 (relational -> = .)
    IDENTIFIER      reduce using rule 212 (relational -> = .)
    STRING          reduce using rule 212 (relational -> = .)


state 221

    (214) relational -> < .

    +               reduce using rule 214 (relational -> < .)
    -               reduce using rule 214 (relational -> < .)
    NOT             reduce using rule 214 (relational -> < .)
    ABS             reduce using rule 214 (relational -> < .)
    INTEGER         reduce using rule 214 (relational -> < .)
    BASE_INTEGER    reduce using rule 214 (relational -> < .)
    FLOAT           reduce using rule 214 (relational -> < .)
    BASE_FLOAT      reduce using rule 214 (relational -> < .)
    NuLL            reduce using rule 214 (relational -> < .)
    NEW             reduce using rule 214 (relational -> < .)
    (               reduce using rule 214 (relational -> < .)
    CHAR            reduce using rule 214 (relational -> < .)
    IDENTIFIER      reduce using rule 214 (relational -> < .)
    STRING          reduce using rule 214 (relational -> < .)


state 222

    (216) relational -> > .

    +               reduce using rule 216 (relational -> > .)
    -               reduce using rule 216 (relational -> > .)
    NOT             reduce using rule 216 (relational -> > .)
    ABS             reduce using rule 216 (relational -> > .)
    INTEGER         reduce using rule 216 (relational -> > .)
    BASE_INTEGER    reduce using rule 216 (relational -> > .)
    FLOAT           reduce using rule 216 (relational -> > .)
    BASE_FLOAT      reduce using rule 216 (relational -> > .)
    NuLL            reduce using rule 216 (relational -> > .)
    NEW             reduce using rule 216 (relational -> > .)
    (               reduce using rule 216 (relational -> > .)
    CHAR            reduce using rule 216 (relational -> > .)
    IDENTIFIER      reduce using rule 216 (relational -> > .)
    STRING          reduce using rule 216 (relational -> > .)


state 223

    (7) pragma_arg -> simple_name ARROW . expression
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 366

state 224

    (127) choice -> OTHERS .

    ARROW           reduce using rule 127 (choice -> OTHERS .)
    |               reduce using rule 127 (choice -> OTHERS .)


state 225

    (208) relation -> simple_expression .
    (209) relation -> simple_expression . relational simple_expression
    (210) relation -> simple_expression . membership range
    (211) relation -> simple_expression . membership name
    (222) simple_expression -> simple_expression . adding term
    (62) range -> simple_expression . DOTDOT simple_expression
    (212) relational -> . =
    (213) relational -> . NOTEQUAL
    (214) relational -> . <
    (215) relational -> . LESSEQ
    (216) relational -> . >
    (217) relational -> . GREATEREQ
    (218) membership -> . IN
    (219) membership -> . NOT IN
    (225) adding -> . +
    (226) adding -> . -
    (227) adding -> . &

    )               reduce using rule 208 (relation -> simple_expression .)
    WITH            reduce using rule 208 (relation -> simple_expression .)
    AND             reduce using rule 208 (relation -> simple_expression .)
    OR              reduce using rule 208 (relation -> simple_expression .)
    XOR             reduce using rule 208 (relation -> simple_expression .)
    ,               reduce using rule 208 (relation -> simple_expression .)
    ARROW           reduce using rule 208 (relation -> simple_expression .)
    |               reduce using rule 208 (relation -> simple_expression .)
    DOTDOT          shift and go to state 367
    =               shift and go to state 220
    NOTEQUAL        shift and go to state 210
    <               shift and go to state 221
    LESSEQ          shift and go to state 216
    >               shift and go to state 222
    GREATEREQ       shift and go to state 215
    IN              shift and go to state 217
    NOT             shift and go to state 218
    +               shift and go to state 211
    -               shift and go to state 213
    &               shift and go to state 212

    adding                         shift and go to state 209
    membership                     shift and go to state 214
    relational                     shift and go to state 219

state 226

    (199) comp_assoc -> choice_s . ARROW expression
    (124) choice_s -> choice_s . | choice

    ARROW           shift and go to state 369
    |               shift and go to state 368


state 227

    (192) aggregate -> ( comp_assoc . )
    (174) value -> comp_assoc .

    )               shift and go to state 370
    ,               reduce using rule 174 (value -> comp_assoc .)


state 228

    (123) choice_s -> choice .

    ARROW           reduce using rule 123 (choice_s -> choice .)
    |               reduce using rule 123 (choice_s -> choice .)


state 229

    (193) aggregate -> ( value_s_2 . )
    (198) value_s_2 -> value_s_2 . , value

    )               shift and go to state 371
    ,               shift and go to state 372


state 230

    (175) value -> discrete_with_range .
    (126) choice -> discrete_with_range .

    )               reduce using rule 175 (value -> discrete_with_range .)
    ,               reduce using rule 175 (value -> discrete_with_range .)
    ARROW           reduce using rule 126 (choice -> discrete_with_range .)
    |               reduce using rule 126 (choice -> discrete_with_range .)


state 231

    (128) discrete_with_range -> name . range_constraint
    (63) range -> name . TICK RANGE
    (64) range -> name . TICK RANGE ( expression )
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id
    (239) primary -> name .
    (245) qualified -> name . TICK parenthesized_primary
    (61) range_constraint -> . RANGE range

    TICK            shift and go to state 375
    (               shift and go to state 245
    .               shift and go to state 246
    STARSTAR        reduce using rule 239 (primary -> name .)
    *               reduce using rule 239 (primary -> name .)
    /               reduce using rule 239 (primary -> name .)
    MOD             reduce using rule 239 (primary -> name .)
    REM             reduce using rule 239 (primary -> name .)
    DOTDOT          reduce using rule 239 (primary -> name .)
    =               reduce using rule 239 (primary -> name .)
    NOTEQUAL        reduce using rule 239 (primary -> name .)
    <               reduce using rule 239 (primary -> name .)
    LESSEQ          reduce using rule 239 (primary -> name .)
    >               reduce using rule 239 (primary -> name .)
    GREATEREQ       reduce using rule 239 (primary -> name .)
    IN              reduce using rule 239 (primary -> name .)
    NOT             reduce using rule 239 (primary -> name .)
    +               reduce using rule 239 (primary -> name .)
    -               reduce using rule 239 (primary -> name .)
    &               reduce using rule 239 (primary -> name .)
    AND             reduce using rule 239 (primary -> name .)
    OR              reduce using rule 239 (primary -> name .)
    XOR             reduce using rule 239 (primary -> name .)
    ARROW           reduce using rule 239 (primary -> name .)
    |               reduce using rule 239 (primary -> name .)
    )               reduce using rule 239 (primary -> name .)
    ,               reduce using rule 239 (primary -> name .)
    WITH            reduce using rule 239 (primary -> name .)
    RANGE           shift and go to state 373

    range_constraint               shift and go to state 374

state 232

    (197) value_s_2 -> value . , value

    ,               shift and go to state 376


state 233

    (129) discrete_with_range -> range .

    ARROW           reduce using rule 129 (discrete_with_range -> range .)
    |               reduce using rule 129 (discrete_with_range -> range .)
    )               reduce using rule 129 (discrete_with_range -> range .)
    ,               reduce using rule 129 (discrete_with_range -> range .)


state 234

    (176) value -> error .

    )               reduce using rule 176 (value -> error .)
    ,               reduce using rule 176 (value -> error .)


state 235

    (196) aggregate -> ( NuLL . RECORD )
    (191) literal -> NuLL .

    RECORD          shift and go to state 377
    STARSTAR        reduce using rule 191 (literal -> NuLL .)
    *               reduce using rule 191 (literal -> NuLL .)
    /               reduce using rule 191 (literal -> NuLL .)
    MOD             reduce using rule 191 (literal -> NuLL .)
    REM             reduce using rule 191 (literal -> NuLL .)
    DOTDOT          reduce using rule 191 (literal -> NuLL .)
    =               reduce using rule 191 (literal -> NuLL .)
    NOTEQUAL        reduce using rule 191 (literal -> NuLL .)
    <               reduce using rule 191 (literal -> NuLL .)
    LESSEQ          reduce using rule 191 (literal -> NuLL .)
    >               reduce using rule 191 (literal -> NuLL .)
    GREATEREQ       reduce using rule 191 (literal -> NuLL .)
    IN              reduce using rule 191 (literal -> NuLL .)
    NOT             reduce using rule 191 (literal -> NuLL .)
    +               reduce using rule 191 (literal -> NuLL .)
    -               reduce using rule 191 (literal -> NuLL .)
    &               reduce using rule 191 (literal -> NuLL .)
    )               reduce using rule 191 (literal -> NuLL .)
    WITH            reduce using rule 191 (literal -> NuLL .)
    AND             reduce using rule 191 (literal -> NuLL .)
    OR              reduce using rule 191 (literal -> NuLL .)
    XOR             reduce using rule 191 (literal -> NuLL .)
    ,               reduce using rule 191 (literal -> NuLL .)
    ARROW           reduce using rule 191 (literal -> NuLL .)
    |               reduce using rule 191 (literal -> NuLL .)


state 236

    (244) parenthesized_primary -> ( expression . )
    (194) aggregate -> ( expression . WITH value_s )
    (195) aggregate -> ( expression . WITH NuLL RECORD )
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (173) value -> expression .
    (125) choice -> expression .
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE

    )               shift and go to state 378
    WITH            shift and go to state 379
    ,               reduce using rule 173 (value -> expression .)
    ARROW           reduce using rule 125 (choice -> expression .)
    |               reduce using rule 125 (choice -> expression .)
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250

    logical                        shift and go to state 251
    short_circuit                  shift and go to state 252

state 237

    (3) pragma -> PRAGMA simple_name ( pragma_arg_s ) . ;

    ;               shift and go to state 380


state 238

    (5) pragma_arg_s -> pragma_arg_s , . pragma_arg
    (6) pragma_arg -> . expression
    (7) pragma_arg -> . simple_name ARROW expression
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (163) simple_name -> . IDENTIFIER
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 39
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    pragma_arg                     shift and go to state 381
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 131
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    used_char                      shift and go to state 144
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 153

state 239

    (236) factor -> ABS primary .

    *               reduce using rule 236 (factor -> ABS primary .)
    /               reduce using rule 236 (factor -> ABS primary .)
    MOD             reduce using rule 236 (factor -> ABS primary .)
    REM             reduce using rule 236 (factor -> ABS primary .)
    DOTDOT          reduce using rule 236 (factor -> ABS primary .)
    =               reduce using rule 236 (factor -> ABS primary .)
    NOTEQUAL        reduce using rule 236 (factor -> ABS primary .)
    <               reduce using rule 236 (factor -> ABS primary .)
    LESSEQ          reduce using rule 236 (factor -> ABS primary .)
    >               reduce using rule 236 (factor -> ABS primary .)
    GREATEREQ       reduce using rule 236 (factor -> ABS primary .)
    IN              reduce using rule 236 (factor -> ABS primary .)
    NOT             reduce using rule 236 (factor -> ABS primary .)
    +               reduce using rule 236 (factor -> ABS primary .)
    -               reduce using rule 236 (factor -> ABS primary .)
    &               reduce using rule 236 (factor -> ABS primary .)
    AND             reduce using rule 236 (factor -> ABS primary .)
    OR              reduce using rule 236 (factor -> ABS primary .)
    XOR             reduce using rule 236 (factor -> ABS primary .)
    )               reduce using rule 236 (factor -> ABS primary .)
    ,               reduce using rule 236 (factor -> ABS primary .)
    ARROW           reduce using rule 236 (factor -> ABS primary .)
    |               reduce using rule 236 (factor -> ABS primary .)
    RANGE           reduce using rule 236 (factor -> ABS primary .)
    ;               reduce using rule 236 (factor -> ABS primary .)
    IS              reduce using rule 236 (factor -> ABS primary .)
    WITH            reduce using rule 236 (factor -> ABS primary .)
    THEN            reduce using rule 236 (factor -> ABS primary .)
    LOOP            reduce using rule 236 (factor -> ABS primary .)
    DIGITS          reduce using rule 236 (factor -> ABS primary .)
    RENAMES         reduce using rule 236 (factor -> ABS primary .)
    ASSIGNMENT      reduce using rule 236 (factor -> ABS primary .)


state 240

    (233) multiplying -> REM .

    NOT             reduce using rule 233 (multiplying -> REM .)
    ABS             reduce using rule 233 (multiplying -> REM .)
    INTEGER         reduce using rule 233 (multiplying -> REM .)
    BASE_INTEGER    reduce using rule 233 (multiplying -> REM .)
    FLOAT           reduce using rule 233 (multiplying -> REM .)
    BASE_FLOAT      reduce using rule 233 (multiplying -> REM .)
    NuLL            reduce using rule 233 (multiplying -> REM .)
    NEW             reduce using rule 233 (multiplying -> REM .)
    (               reduce using rule 233 (multiplying -> REM .)
    CHAR            reduce using rule 233 (multiplying -> REM .)
    IDENTIFIER      reduce using rule 233 (multiplying -> REM .)
    STRING          reduce using rule 233 (multiplying -> REM .)


state 241

    (229) term -> term multiplying . factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 147
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    literal                        shift and go to state 135
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    factor                         shift and go to state 382
    aggregate                      shift and go to state 143
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158

state 242

    (230) multiplying -> * .

    NOT             reduce using rule 230 (multiplying -> * .)
    ABS             reduce using rule 230 (multiplying -> * .)
    INTEGER         reduce using rule 230 (multiplying -> * .)
    BASE_INTEGER    reduce using rule 230 (multiplying -> * .)
    FLOAT           reduce using rule 230 (multiplying -> * .)
    BASE_FLOAT      reduce using rule 230 (multiplying -> * .)
    NuLL            reduce using rule 230 (multiplying -> * .)
    NEW             reduce using rule 230 (multiplying -> * .)
    (               reduce using rule 230 (multiplying -> * .)
    CHAR            reduce using rule 230 (multiplying -> * .)
    IDENTIFIER      reduce using rule 230 (multiplying -> * .)
    STRING          reduce using rule 230 (multiplying -> * .)


state 243

    (231) multiplying -> / .

    NOT             reduce using rule 231 (multiplying -> / .)
    ABS             reduce using rule 231 (multiplying -> / .)
    INTEGER         reduce using rule 231 (multiplying -> / .)
    BASE_INTEGER    reduce using rule 231 (multiplying -> / .)
    FLOAT           reduce using rule 231 (multiplying -> / .)
    BASE_FLOAT      reduce using rule 231 (multiplying -> / .)
    NuLL            reduce using rule 231 (multiplying -> / .)
    NEW             reduce using rule 231 (multiplying -> / .)
    (               reduce using rule 231 (multiplying -> / .)
    CHAR            reduce using rule 231 (multiplying -> / .)
    IDENTIFIER      reduce using rule 231 (multiplying -> / .)
    STRING          reduce using rule 231 (multiplying -> / .)


state 244

    (232) multiplying -> MOD .

    NOT             reduce using rule 232 (multiplying -> MOD .)
    ABS             reduce using rule 232 (multiplying -> MOD .)
    INTEGER         reduce using rule 232 (multiplying -> MOD .)
    BASE_INTEGER    reduce using rule 232 (multiplying -> MOD .)
    FLOAT           reduce using rule 232 (multiplying -> MOD .)
    BASE_FLOAT      reduce using rule 232 (multiplying -> MOD .)
    NuLL            reduce using rule 232 (multiplying -> MOD .)
    NEW             reduce using rule 232 (multiplying -> MOD .)
    (               reduce using rule 232 (multiplying -> MOD .)
    CHAR            reduce using rule 232 (multiplying -> MOD .)
    IDENTIFIER      reduce using rule 232 (multiplying -> MOD .)
    STRING          reduce using rule 232 (multiplying -> MOD .)


state 245

    (170) indexed_comp -> name ( . value_s )
    (171) value_s -> . value
    (172) value_s -> . value_s , value
    (173) value -> . expression
    (174) value -> . comp_assoc
    (175) value -> . discrete_with_range
    (176) value -> . error
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (199) comp_assoc -> . choice_s ARROW expression
    (128) discrete_with_range -> . name range_constraint
    (129) discrete_with_range -> . range
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (123) choice_s -> . choice
    (124) choice_s -> . choice_s | choice
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name TICK RANGE
    (64) range -> . name TICK RANGE ( expression )
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (125) choice -> . expression
    (126) choice -> . discrete_with_range
    (127) choice -> . OTHERS
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 234
    OTHERS          shift and go to state 224
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    value_s                        shift and go to state 383
    simple_expression              shift and go to state 384
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    choice_s                       shift and go to state 226
    comp_assoc                     shift and go to state 385
    factor                         shift and go to state 137
    choice                         shift and go to state 228
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    discrete_with_range            shift and go to state 230
    term                           shift and go to state 146
    name                           shift and go to state 231
    operator_symbol                shift and go to state 149
    value                          shift and go to state 386
    range                          shift and go to state 233
    expression                     shift and go to state 387

state 246

    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (163) simple_name -> . IDENTIFIER
    (168) used_char -> . CHAR
    (169) operator_symbol -> . STRING

    ALL             shift and go to state 388
    IDENTIFIER      shift and go to state 39
    CHAR            shift and go to state 145
    STRING          shift and go to state 138

    used_char                      shift and go to state 390
    operator_symbol                shift and go to state 389
    simple_name                    shift and go to state 391

state 247

    (245) qualified -> name TICK . parenthesized_primary
    (181) attribute -> name TICK . attribute_id
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (182) attribute_id -> . IDENTIFIER
    (183) attribute_id -> . DIGITS
    (184) attribute_id -> . DELTA
    (185) attribute_id -> . ACCESS
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    (               shift and go to state 132
    IDENTIFIER      shift and go to state 393
    DIGITS          shift and go to state 392
    DELTA           shift and go to state 396
    ACCESS          shift and go to state 394

    attribute_id                   shift and go to state 395
    aggregate                      shift and go to state 143
    parenthesized_primary          shift and go to state 397

state 248

    (235) factor -> NOT primary .

    *               reduce using rule 235 (factor -> NOT primary .)
    /               reduce using rule 235 (factor -> NOT primary .)
    MOD             reduce using rule 235 (factor -> NOT primary .)
    REM             reduce using rule 235 (factor -> NOT primary .)
    DOTDOT          reduce using rule 235 (factor -> NOT primary .)
    =               reduce using rule 235 (factor -> NOT primary .)
    NOTEQUAL        reduce using rule 235 (factor -> NOT primary .)
    <               reduce using rule 235 (factor -> NOT primary .)
    LESSEQ          reduce using rule 235 (factor -> NOT primary .)
    >               reduce using rule 235 (factor -> NOT primary .)
    GREATEREQ       reduce using rule 235 (factor -> NOT primary .)
    IN              reduce using rule 235 (factor -> NOT primary .)
    NOT             reduce using rule 235 (factor -> NOT primary .)
    +               reduce using rule 235 (factor -> NOT primary .)
    -               reduce using rule 235 (factor -> NOT primary .)
    &               reduce using rule 235 (factor -> NOT primary .)
    AND             reduce using rule 235 (factor -> NOT primary .)
    OR              reduce using rule 235 (factor -> NOT primary .)
    XOR             reduce using rule 235 (factor -> NOT primary .)
    )               reduce using rule 235 (factor -> NOT primary .)
    ,               reduce using rule 235 (factor -> NOT primary .)
    ARROW           reduce using rule 235 (factor -> NOT primary .)
    |               reduce using rule 235 (factor -> NOT primary .)
    RANGE           reduce using rule 235 (factor -> NOT primary .)
    ;               reduce using rule 235 (factor -> NOT primary .)
    IS              reduce using rule 235 (factor -> NOT primary .)
    WITH            reduce using rule 235 (factor -> NOT primary .)
    THEN            reduce using rule 235 (factor -> NOT primary .)
    LOOP            reduce using rule 235 (factor -> NOT primary .)
    DIGITS          reduce using rule 235 (factor -> NOT primary .)
    RENAMES         reduce using rule 235 (factor -> NOT primary .)
    ASSIGNMENT      reduce using rule 235 (factor -> NOT primary .)


state 249

    (203) logical -> AND .
    (206) short_circuit -> AND . THEN

    +               reduce using rule 203 (logical -> AND .)
    -               reduce using rule 203 (logical -> AND .)
    NOT             reduce using rule 203 (logical -> AND .)
    ABS             reduce using rule 203 (logical -> AND .)
    INTEGER         reduce using rule 203 (logical -> AND .)
    BASE_INTEGER    reduce using rule 203 (logical -> AND .)
    FLOAT           reduce using rule 203 (logical -> AND .)
    BASE_FLOAT      reduce using rule 203 (logical -> AND .)
    NuLL            reduce using rule 203 (logical -> AND .)
    NEW             reduce using rule 203 (logical -> AND .)
    (               reduce using rule 203 (logical -> AND .)
    CHAR            reduce using rule 203 (logical -> AND .)
    IDENTIFIER      reduce using rule 203 (logical -> AND .)
    STRING          reduce using rule 203 (logical -> AND .)
    THEN            shift and go to state 398


state 250

    (205) logical -> XOR .

    +               reduce using rule 205 (logical -> XOR .)
    -               reduce using rule 205 (logical -> XOR .)
    NOT             reduce using rule 205 (logical -> XOR .)
    ABS             reduce using rule 205 (logical -> XOR .)
    INTEGER         reduce using rule 205 (logical -> XOR .)
    BASE_INTEGER    reduce using rule 205 (logical -> XOR .)
    FLOAT           reduce using rule 205 (logical -> XOR .)
    BASE_FLOAT      reduce using rule 205 (logical -> XOR .)
    NuLL            reduce using rule 205 (logical -> XOR .)
    NEW             reduce using rule 205 (logical -> XOR .)
    (               reduce using rule 205 (logical -> XOR .)
    CHAR            reduce using rule 205 (logical -> XOR .)
    IDENTIFIER      reduce using rule 205 (logical -> XOR .)
    STRING          reduce using rule 205 (logical -> XOR .)


state 251

    (201) expression -> expression logical . relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 399
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149

state 252

    (202) expression -> expression short_circuit . relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 400
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149

state 253

    (204) logical -> OR .
    (207) short_circuit -> OR . ELSE

    +               reduce using rule 204 (logical -> OR .)
    -               reduce using rule 204 (logical -> OR .)
    NOT             reduce using rule 204 (logical -> OR .)
    ABS             reduce using rule 204 (logical -> OR .)
    INTEGER         reduce using rule 204 (logical -> OR .)
    BASE_INTEGER    reduce using rule 204 (logical -> OR .)
    FLOAT           reduce using rule 204 (logical -> OR .)
    BASE_FLOAT      reduce using rule 204 (logical -> OR .)
    NuLL            reduce using rule 204 (logical -> OR .)
    NEW             reduce using rule 204 (logical -> OR .)
    (               reduce using rule 204 (logical -> OR .)
    CHAR            reduce using rule 204 (logical -> OR .)
    IDENTIFIER      reduce using rule 204 (logical -> OR .)
    STRING          reduce using rule 204 (logical -> OR .)
    ELSE            shift and go to state 401


state 254

    (352) use_clause -> USE name_s ; .

    PACKAGE         reduce using rule 352 (use_clause -> USE name_s ; .)
    TASK            reduce using rule 352 (use_clause -> USE name_s ; .)
    PROTECTED       reduce using rule 352 (use_clause -> USE name_s ; .)
    error           reduce using rule 352 (use_clause -> USE name_s ; .)
    USE             reduce using rule 352 (use_clause -> USE name_s ; .)
    PRAGMA          reduce using rule 352 (use_clause -> USE name_s ; .)
    TYPE            reduce using rule 352 (use_clause -> USE name_s ; .)
    SUBTYPE         reduce using rule 352 (use_clause -> USE name_s ; .)
    FOR             reduce using rule 352 (use_clause -> USE name_s ; .)
    PROCEDURE       reduce using rule 352 (use_clause -> USE name_s ; .)
    FUNCTION        reduce using rule 352 (use_clause -> USE name_s ; .)
    GENERIC         reduce using rule 352 (use_clause -> USE name_s ; .)
    IDENTIFIER      reduce using rule 352 (use_clause -> USE name_s ; .)
    BEGIN           reduce using rule 352 (use_clause -> USE name_s ; .)
    END             reduce using rule 352 (use_clause -> USE name_s ; .)
    PRIVATE         reduce using rule 352 (use_clause -> USE name_s ; .)
    WITH            reduce using rule 352 (use_clause -> USE name_s ; .)
    SEPARATE        reduce using rule 352 (use_clause -> USE name_s ; .)


state 255

    (355) name_s -> name_s , . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 402
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 256

    (181) attribute -> name TICK . attribute_id
    (182) attribute_id -> . IDENTIFIER
    (183) attribute_id -> . DIGITS
    (184) attribute_id -> . DELTA
    (185) attribute_id -> . ACCESS

    IDENTIFIER      shift and go to state 393
    DIGITS          shift and go to state 392
    DELTA           shift and go to state 396
    ACCESS          shift and go to state 394

    attribute_id                   shift and go to state 395

state 257

    (353) use_clause -> USE TYPE name_s . ;
    (355) name_s -> name_s . , name

    ;               shift and go to state 403
    ,               shift and go to state 255


state 258

    (452) subunit -> SEPARATE ( compound_name ) . subunit_body
    (453) subunit_body -> . subprog_body
    (454) subunit_body -> . pkg_body
    (455) subunit_body -> . task_body
    (456) subunit_body -> . prot_body
    (337) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (346) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (371) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (388) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (336) subprog_spec_is_push -> . subprog_spec IS
    (319) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (320) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (321) subprog_spec -> . FUNCTION designator

    PACKAGE         shift and go to state 411
    TASK            shift and go to state 408
    PROTECTED       shift and go to state 406
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36

    subprog_body                   shift and go to state 404
    subprog_spec_is_push           shift and go to state 409
    prot_body                      shift and go to state 412
    pkg_body                       shift and go to state 413
    task_body                      shift and go to state 405
    subprog_spec                   shift and go to state 410
    subunit_body                   shift and go to state 407

state 259

    (388) prot_body -> PROTECTED BODY simple_name . IS prot_op_body_s END id_opt ;
    (460) body_stub -> PROTECTED BODY simple_name . IS SEPARATE ;

    IS              shift and go to state 414


state 260

    (375) prot_def -> IS . prot_op_decl_s prot_private_opt END id_opt
    (378) prot_op_decl_s -> .
    (379) prot_op_decl_s -> . prot_op_decl_s prot_op_decl

    PRIVATE         reduce using rule 378 (prot_op_decl_s -> .)
    ENTRY           reduce using rule 378 (prot_op_decl_s -> .)
    PROCEDURE       reduce using rule 378 (prot_op_decl_s -> .)
    FUNCTION        reduce using rule 378 (prot_op_decl_s -> .)
    PRAGMA          reduce using rule 378 (prot_op_decl_s -> .)
    FOR             reduce using rule 378 (prot_op_decl_s -> .)
    END             reduce using rule 378 (prot_op_decl_s -> .)

    prot_op_decl_s                 shift and go to state 415

state 261

    (373) prot_spec -> PROTECTED IDENTIFIER prot_def .

    ;               reduce using rule 373 (prot_spec -> PROTECTED IDENTIFIER prot_def .)


state 262

    (374) prot_spec -> PROTECTED TYPE simple_name . discrim_part_opt prot_def
    (37) discrim_part_opt -> .
    (38) discrim_part_opt -> . discrim_part
    (39) discrim_part_opt -> . ( LESSMORE )
    (112) discrim_part -> . ( discrim_spec_s )

    IS              reduce using rule 37 (discrim_part_opt -> .)
    (               shift and go to state 321

    discrim_part_opt               shift and go to state 416
    discrim_part                   shift and go to state 323

state 263

    (410) delay_stmt -> DELAY . expression ;
    (411) delay_stmt -> DELAY . UNTIL expression ;
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    UNTIL           shift and go to state 417
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 418

state 264

    (413) select_stmt -> async_select .

    END             reduce using rule 413 (select_stmt -> async_select .)
    LESSLESS        reduce using rule 413 (select_stmt -> async_select .)
    error           reduce using rule 413 (select_stmt -> async_select .)
    PRAGMA          reduce using rule 413 (select_stmt -> async_select .)
    NuLL            reduce using rule 413 (select_stmt -> async_select .)
    EXIT            reduce using rule 413 (select_stmt -> async_select .)
    RETURN          reduce using rule 413 (select_stmt -> async_select .)
    GOTO            reduce using rule 413 (select_stmt -> async_select .)
    DELAY           reduce using rule 413 (select_stmt -> async_select .)
    ABORT           reduce using rule 413 (select_stmt -> async_select .)
    RAISE           reduce using rule 413 (select_stmt -> async_select .)
    REQUEUE         reduce using rule 413 (select_stmt -> async_select .)
    IF              reduce using rule 413 (select_stmt -> async_select .)
    CASE            reduce using rule 413 (select_stmt -> async_select .)
    IDENTIFIER      reduce using rule 413 (select_stmt -> async_select .)
    ACCEPT          reduce using rule 413 (select_stmt -> async_select .)
    SELECT          reduce using rule 413 (select_stmt -> async_select .)
    STRING          reduce using rule 413 (select_stmt -> async_select .)
    WHILE           reduce using rule 413 (select_stmt -> async_select .)
    DECLARE         reduce using rule 413 (select_stmt -> async_select .)
    FOR             reduce using rule 413 (select_stmt -> async_select .)
    LOOP            reduce using rule 413 (select_stmt -> async_select .)
    BEGIN           reduce using rule 413 (select_stmt -> async_select .)
    WHEN            reduce using rule 413 (select_stmt -> async_select .)
    ELSIF           reduce using rule 413 (select_stmt -> async_select .)
    ELSE            reduce using rule 413 (select_stmt -> async_select .)
    THEN            reduce using rule 413 (select_stmt -> async_select .)
    OR              reduce using rule 413 (select_stmt -> async_select .)
    EXCEPTION       reduce using rule 413 (select_stmt -> async_select .)


state 265

    (272) compound_stmt -> select_stmt .

    END             reduce using rule 272 (compound_stmt -> select_stmt .)
    LESSLESS        reduce using rule 272 (compound_stmt -> select_stmt .)
    error           reduce using rule 272 (compound_stmt -> select_stmt .)
    PRAGMA          reduce using rule 272 (compound_stmt -> select_stmt .)
    NuLL            reduce using rule 272 (compound_stmt -> select_stmt .)
    EXIT            reduce using rule 272 (compound_stmt -> select_stmt .)
    RETURN          reduce using rule 272 (compound_stmt -> select_stmt .)
    GOTO            reduce using rule 272 (compound_stmt -> select_stmt .)
    DELAY           reduce using rule 272 (compound_stmt -> select_stmt .)
    ABORT           reduce using rule 272 (compound_stmt -> select_stmt .)
    RAISE           reduce using rule 272 (compound_stmt -> select_stmt .)
    REQUEUE         reduce using rule 272 (compound_stmt -> select_stmt .)
    IF              reduce using rule 272 (compound_stmt -> select_stmt .)
    CASE            reduce using rule 272 (compound_stmt -> select_stmt .)
    IDENTIFIER      reduce using rule 272 (compound_stmt -> select_stmt .)
    ACCEPT          reduce using rule 272 (compound_stmt -> select_stmt .)
    SELECT          reduce using rule 272 (compound_stmt -> select_stmt .)
    STRING          reduce using rule 272 (compound_stmt -> select_stmt .)
    WHILE           reduce using rule 272 (compound_stmt -> select_stmt .)
    DECLARE         reduce using rule 272 (compound_stmt -> select_stmt .)
    FOR             reduce using rule 272 (compound_stmt -> select_stmt .)
    LOOP            reduce using rule 272 (compound_stmt -> select_stmt .)
    BEGIN           reduce using rule 272 (compound_stmt -> select_stmt .)
    ELSIF           reduce using rule 272 (compound_stmt -> select_stmt .)
    ELSE            reduce using rule 272 (compound_stmt -> select_stmt .)
    OR              reduce using rule 272 (compound_stmt -> select_stmt .)
    WHEN            reduce using rule 272 (compound_stmt -> select_stmt .)
    THEN            reduce using rule 272 (compound_stmt -> select_stmt .)
    EXCEPTION       reduce using rule 272 (compound_stmt -> select_stmt .)


state 266

    (289) loop_stmt -> label_opt . iteration basic_loop id_opt ;
    (301) block -> label_opt . block_decl block_body END id_opt ;
    (292) iteration -> .
    (293) iteration -> . WHILE condition
    (294) iteration -> . iter_part reverse_opt discrete_range
    (302) block_decl -> .
    (303) block_decl -> . DECLARE decl_part
    (295) iter_part -> . FOR IDENTIFIER IN

    LOOP            reduce using rule 292 (iteration -> .)
    WHILE           shift and go to state 423
    BEGIN           reduce using rule 302 (block_decl -> .)
    DECLARE         shift and go to state 424
    FOR             shift and go to state 420

    iter_part                      shift and go to state 419
    block_decl                     shift and go to state 421
    iteration                      shift and go to state 422

state 267

    (315) goto_stmt -> GOTO . name ;
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 425
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 268

    (252) unlabeled -> simple_stmt .

    END             reduce using rule 252 (unlabeled -> simple_stmt .)
    LESSLESS        reduce using rule 252 (unlabeled -> simple_stmt .)
    error           reduce using rule 252 (unlabeled -> simple_stmt .)
    PRAGMA          reduce using rule 252 (unlabeled -> simple_stmt .)
    NuLL            reduce using rule 252 (unlabeled -> simple_stmt .)
    EXIT            reduce using rule 252 (unlabeled -> simple_stmt .)
    RETURN          reduce using rule 252 (unlabeled -> simple_stmt .)
    GOTO            reduce using rule 252 (unlabeled -> simple_stmt .)
    DELAY           reduce using rule 252 (unlabeled -> simple_stmt .)
    ABORT           reduce using rule 252 (unlabeled -> simple_stmt .)
    RAISE           reduce using rule 252 (unlabeled -> simple_stmt .)
    REQUEUE         reduce using rule 252 (unlabeled -> simple_stmt .)
    IF              reduce using rule 252 (unlabeled -> simple_stmt .)
    CASE            reduce using rule 252 (unlabeled -> simple_stmt .)
    IDENTIFIER      reduce using rule 252 (unlabeled -> simple_stmt .)
    ACCEPT          reduce using rule 252 (unlabeled -> simple_stmt .)
    SELECT          reduce using rule 252 (unlabeled -> simple_stmt .)
    STRING          reduce using rule 252 (unlabeled -> simple_stmt .)
    WHILE           reduce using rule 252 (unlabeled -> simple_stmt .)
    DECLARE         reduce using rule 252 (unlabeled -> simple_stmt .)
    FOR             reduce using rule 252 (unlabeled -> simple_stmt .)
    LOOP            reduce using rule 252 (unlabeled -> simple_stmt .)
    BEGIN           reduce using rule 252 (unlabeled -> simple_stmt .)
    EXCEPTION       reduce using rule 252 (unlabeled -> simple_stmt .)
    WHEN            reduce using rule 252 (unlabeled -> simple_stmt .)
    OR              reduce using rule 252 (unlabeled -> simple_stmt .)
    ELSE            reduce using rule 252 (unlabeled -> simple_stmt .)
    THEN            reduce using rule 252 (unlabeled -> simple_stmt .)
    ELSIF           reduce using rule 252 (unlabeled -> simple_stmt .)


state 269

    (269) compound_stmt -> loop_stmt .

    END             reduce using rule 269 (compound_stmt -> loop_stmt .)
    LESSLESS        reduce using rule 269 (compound_stmt -> loop_stmt .)
    error           reduce using rule 269 (compound_stmt -> loop_stmt .)
    PRAGMA          reduce using rule 269 (compound_stmt -> loop_stmt .)
    NuLL            reduce using rule 269 (compound_stmt -> loop_stmt .)
    EXIT            reduce using rule 269 (compound_stmt -> loop_stmt .)
    RETURN          reduce using rule 269 (compound_stmt -> loop_stmt .)
    GOTO            reduce using rule 269 (compound_stmt -> loop_stmt .)
    DELAY           reduce using rule 269 (compound_stmt -> loop_stmt .)
    ABORT           reduce using rule 269 (compound_stmt -> loop_stmt .)
    RAISE           reduce using rule 269 (compound_stmt -> loop_stmt .)
    REQUEUE         reduce using rule 269 (compound_stmt -> loop_stmt .)
    IF              reduce using rule 269 (compound_stmt -> loop_stmt .)
    CASE            reduce using rule 269 (compound_stmt -> loop_stmt .)
    IDENTIFIER      reduce using rule 269 (compound_stmt -> loop_stmt .)
    ACCEPT          reduce using rule 269 (compound_stmt -> loop_stmt .)
    SELECT          reduce using rule 269 (compound_stmt -> loop_stmt .)
    STRING          reduce using rule 269 (compound_stmt -> loop_stmt .)
    WHILE           reduce using rule 269 (compound_stmt -> loop_stmt .)
    DECLARE         reduce using rule 269 (compound_stmt -> loop_stmt .)
    FOR             reduce using rule 269 (compound_stmt -> loop_stmt .)
    LOOP            reduce using rule 269 (compound_stmt -> loop_stmt .)
    BEGIN           reduce using rule 269 (compound_stmt -> loop_stmt .)
    ELSIF           reduce using rule 269 (compound_stmt -> loop_stmt .)
    ELSE            reduce using rule 269 (compound_stmt -> loop_stmt .)
    OR              reduce using rule 269 (compound_stmt -> loop_stmt .)
    WHEN            reduce using rule 269 (compound_stmt -> loop_stmt .)
    THEN            reduce using rule 269 (compound_stmt -> loop_stmt .)
    EXCEPTION       reduce using rule 269 (compound_stmt -> loop_stmt .)


state 270

    (516) code_stmt -> qualified . ;

    ;               shift and go to state 426


state 271

    (267) compound_stmt -> if_stmt .

    END             reduce using rule 267 (compound_stmt -> if_stmt .)
    LESSLESS        reduce using rule 267 (compound_stmt -> if_stmt .)
    error           reduce using rule 267 (compound_stmt -> if_stmt .)
    PRAGMA          reduce using rule 267 (compound_stmt -> if_stmt .)
    NuLL            reduce using rule 267 (compound_stmt -> if_stmt .)
    EXIT            reduce using rule 267 (compound_stmt -> if_stmt .)
    RETURN          reduce using rule 267 (compound_stmt -> if_stmt .)
    GOTO            reduce using rule 267 (compound_stmt -> if_stmt .)
    DELAY           reduce using rule 267 (compound_stmt -> if_stmt .)
    ABORT           reduce using rule 267 (compound_stmt -> if_stmt .)
    RAISE           reduce using rule 267 (compound_stmt -> if_stmt .)
    REQUEUE         reduce using rule 267 (compound_stmt -> if_stmt .)
    IF              reduce using rule 267 (compound_stmt -> if_stmt .)
    CASE            reduce using rule 267 (compound_stmt -> if_stmt .)
    IDENTIFIER      reduce using rule 267 (compound_stmt -> if_stmt .)
    ACCEPT          reduce using rule 267 (compound_stmt -> if_stmt .)
    SELECT          reduce using rule 267 (compound_stmt -> if_stmt .)
    STRING          reduce using rule 267 (compound_stmt -> if_stmt .)
    WHILE           reduce using rule 267 (compound_stmt -> if_stmt .)
    DECLARE         reduce using rule 267 (compound_stmt -> if_stmt .)
    FOR             reduce using rule 267 (compound_stmt -> if_stmt .)
    LOOP            reduce using rule 267 (compound_stmt -> if_stmt .)
    BEGIN           reduce using rule 267 (compound_stmt -> if_stmt .)
    ELSIF           reduce using rule 267 (compound_stmt -> if_stmt .)
    ELSE            reduce using rule 267 (compound_stmt -> if_stmt .)
    OR              reduce using rule 267 (compound_stmt -> if_stmt .)
    WHEN            reduce using rule 267 (compound_stmt -> if_stmt .)
    THEN            reduce using rule 267 (compound_stmt -> if_stmt .)
    EXCEPTION       reduce using rule 267 (compound_stmt -> if_stmt .)


state 272

    (275) assign_stmt -> name . ASSIGNMENT expression ;
    (338) procedure_call -> name . ;
    (245) qualified -> name . TICK parenthesized_primary
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id

    ASSIGNMENT      shift and go to state 427
    ;               shift and go to state 428
    TICK            shift and go to state 247
    (               shift and go to state 245
    .               shift and go to state 246


state 273

    (431) abort_stmt -> ABORT . name_s ;
    (354) name_s -> . name
    (355) name_s -> . name_s , name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name_s                         shift and go to state 429
    name                           shift and go to state 156
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 274

    (274) null_stmt -> NuLL . ;

    ;               shift and go to state 430


state 275

    (273) label -> LESSLESS . IDENTIFIER MOREMORE

    IDENTIFIER      shift and go to state 431


state 276

    (271) compound_stmt -> accept_stmt .

    END             reduce using rule 271 (compound_stmt -> accept_stmt .)
    LESSLESS        reduce using rule 271 (compound_stmt -> accept_stmt .)
    error           reduce using rule 271 (compound_stmt -> accept_stmt .)
    PRAGMA          reduce using rule 271 (compound_stmt -> accept_stmt .)
    NuLL            reduce using rule 271 (compound_stmt -> accept_stmt .)
    EXIT            reduce using rule 271 (compound_stmt -> accept_stmt .)
    RETURN          reduce using rule 271 (compound_stmt -> accept_stmt .)
    GOTO            reduce using rule 271 (compound_stmt -> accept_stmt .)
    DELAY           reduce using rule 271 (compound_stmt -> accept_stmt .)
    ABORT           reduce using rule 271 (compound_stmt -> accept_stmt .)
    RAISE           reduce using rule 271 (compound_stmt -> accept_stmt .)
    REQUEUE         reduce using rule 271 (compound_stmt -> accept_stmt .)
    IF              reduce using rule 271 (compound_stmt -> accept_stmt .)
    CASE            reduce using rule 271 (compound_stmt -> accept_stmt .)
    IDENTIFIER      reduce using rule 271 (compound_stmt -> accept_stmt .)
    ACCEPT          reduce using rule 271 (compound_stmt -> accept_stmt .)
    SELECT          reduce using rule 271 (compound_stmt -> accept_stmt .)
    STRING          reduce using rule 271 (compound_stmt -> accept_stmt .)
    WHILE           reduce using rule 271 (compound_stmt -> accept_stmt .)
    DECLARE         reduce using rule 271 (compound_stmt -> accept_stmt .)
    FOR             reduce using rule 271 (compound_stmt -> accept_stmt .)
    LOOP            reduce using rule 271 (compound_stmt -> accept_stmt .)
    BEGIN           reduce using rule 271 (compound_stmt -> accept_stmt .)
    ELSIF           reduce using rule 271 (compound_stmt -> accept_stmt .)
    ELSE            reduce using rule 271 (compound_stmt -> accept_stmt .)
    OR              reduce using rule 271 (compound_stmt -> accept_stmt .)
    WHEN            reduce using rule 271 (compound_stmt -> accept_stmt .)
    THEN            reduce using rule 271 (compound_stmt -> accept_stmt .)
    EXCEPTION       reduce using rule 271 (compound_stmt -> accept_stmt .)


state 277

    (313) return_stmt -> RETURN . ;
    (314) return_stmt -> RETURN . expression ;
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    ;               shift and go to state 432
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 433

state 278

    (407) accept_hdr -> ACCEPT . entry_name formal_part_opt
    (408) entry_name -> . simple_name
    (409) entry_name -> . entry_name ( expression )
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    entry_name                     shift and go to state 434
    simple_name                    shift and go to state 435

state 279

    (260) simple_stmt -> procedure_call .

    LESSLESS        reduce using rule 260 (simple_stmt -> procedure_call .)
    error           reduce using rule 260 (simple_stmt -> procedure_call .)
    PRAGMA          reduce using rule 260 (simple_stmt -> procedure_call .)
    NuLL            reduce using rule 260 (simple_stmt -> procedure_call .)
    EXIT            reduce using rule 260 (simple_stmt -> procedure_call .)
    RETURN          reduce using rule 260 (simple_stmt -> procedure_call .)
    GOTO            reduce using rule 260 (simple_stmt -> procedure_call .)
    DELAY           reduce using rule 260 (simple_stmt -> procedure_call .)
    ABORT           reduce using rule 260 (simple_stmt -> procedure_call .)
    RAISE           reduce using rule 260 (simple_stmt -> procedure_call .)
    REQUEUE         reduce using rule 260 (simple_stmt -> procedure_call .)
    IF              reduce using rule 260 (simple_stmt -> procedure_call .)
    CASE            reduce using rule 260 (simple_stmt -> procedure_call .)
    IDENTIFIER      reduce using rule 260 (simple_stmt -> procedure_call .)
    ACCEPT          reduce using rule 260 (simple_stmt -> procedure_call .)
    SELECT          reduce using rule 260 (simple_stmt -> procedure_call .)
    STRING          reduce using rule 260 (simple_stmt -> procedure_call .)
    WHILE           reduce using rule 260 (simple_stmt -> procedure_call .)
    DECLARE         reduce using rule 260 (simple_stmt -> procedure_call .)
    FOR             reduce using rule 260 (simple_stmt -> procedure_call .)
    LOOP            reduce using rule 260 (simple_stmt -> procedure_call .)
    BEGIN           reduce using rule 260 (simple_stmt -> procedure_call .)
    OR              reduce using rule 260 (simple_stmt -> procedure_call .)
    ELSE            reduce using rule 260 (simple_stmt -> procedure_call .)
    END             reduce using rule 260 (simple_stmt -> procedure_call .)
    EXCEPTION       reduce using rule 260 (simple_stmt -> procedure_call .)
    THEN            reduce using rule 260 (simple_stmt -> procedure_call .)
    ELSIF           reduce using rule 260 (simple_stmt -> procedure_call .)
    WHEN            reduce using rule 260 (simple_stmt -> procedure_call .)


state 280

    (416) select_wait -> SELECT . guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> SELECT . delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> SELECT . entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> SELECT . entry_call stmts_opt ELSE statement_s END SELECT ;
    (417) guarded_select_alt -> . select_alt
    (418) guarded_select_alt -> . WHEN condition ARROW select_alt
    (424) delay_or_entry_alt -> . delay_stmt stmts_opt
    (425) delay_or_entry_alt -> . entry_call stmts_opt
    (404) entry_call -> . procedure_call
    (421) select_alt -> . accept_stmt stmts_opt
    (422) select_alt -> . delay_stmt stmts_opt
    (423) select_alt -> . TERMINATE ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (338) procedure_call -> . name ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    WHEN            shift and go to state 440
    TERMINATE       shift and go to state 445
    DELAY           shift and go to state 263
    ACCEPT          shift and go to state 278
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    accept_stmt                    shift and go to state 436
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    entry_call                     shift and go to state 437
    delay_or_entry_alt             shift and go to state 439
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158
    guarded_select_alt             shift and go to state 441
    select_alt                     shift and go to state 442
    delay_stmt                     shift and go to state 443
    accept_hdr                     shift and go to state 295
    name                           shift and go to state 444
    operator_symbol                shift and go to state 149
    procedure_call                 shift and go to state 438

state 281

    (268) compound_stmt -> case_stmt .

    END             reduce using rule 268 (compound_stmt -> case_stmt .)
    LESSLESS        reduce using rule 268 (compound_stmt -> case_stmt .)
    error           reduce using rule 268 (compound_stmt -> case_stmt .)
    PRAGMA          reduce using rule 268 (compound_stmt -> case_stmt .)
    NuLL            reduce using rule 268 (compound_stmt -> case_stmt .)
    EXIT            reduce using rule 268 (compound_stmt -> case_stmt .)
    RETURN          reduce using rule 268 (compound_stmt -> case_stmt .)
    GOTO            reduce using rule 268 (compound_stmt -> case_stmt .)
    DELAY           reduce using rule 268 (compound_stmt -> case_stmt .)
    ABORT           reduce using rule 268 (compound_stmt -> case_stmt .)
    RAISE           reduce using rule 268 (compound_stmt -> case_stmt .)
    REQUEUE         reduce using rule 268 (compound_stmt -> case_stmt .)
    IF              reduce using rule 268 (compound_stmt -> case_stmt .)
    CASE            reduce using rule 268 (compound_stmt -> case_stmt .)
    IDENTIFIER      reduce using rule 268 (compound_stmt -> case_stmt .)
    ACCEPT          reduce using rule 268 (compound_stmt -> case_stmt .)
    SELECT          reduce using rule 268 (compound_stmt -> case_stmt .)
    STRING          reduce using rule 268 (compound_stmt -> case_stmt .)
    WHILE           reduce using rule 268 (compound_stmt -> case_stmt .)
    DECLARE         reduce using rule 268 (compound_stmt -> case_stmt .)
    FOR             reduce using rule 268 (compound_stmt -> case_stmt .)
    LOOP            reduce using rule 268 (compound_stmt -> case_stmt .)
    BEGIN           reduce using rule 268 (compound_stmt -> case_stmt .)
    ELSIF           reduce using rule 268 (compound_stmt -> case_stmt .)
    ELSE            reduce using rule 268 (compound_stmt -> case_stmt .)
    OR              reduce using rule 268 (compound_stmt -> case_stmt .)
    WHEN            reduce using rule 268 (compound_stmt -> case_stmt .)
    THEN            reduce using rule 268 (compound_stmt -> case_stmt .)
    EXCEPTION       reduce using rule 268 (compound_stmt -> case_stmt .)


state 282

    (251) statement -> label . statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    accept_hdr                     shift and go to state 295
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 446
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 283

    (253) unlabeled -> compound_stmt .

    END             reduce using rule 253 (unlabeled -> compound_stmt .)
    LESSLESS        reduce using rule 253 (unlabeled -> compound_stmt .)
    error           reduce using rule 253 (unlabeled -> compound_stmt .)
    PRAGMA          reduce using rule 253 (unlabeled -> compound_stmt .)
    NuLL            reduce using rule 253 (unlabeled -> compound_stmt .)
    EXIT            reduce using rule 253 (unlabeled -> compound_stmt .)
    RETURN          reduce using rule 253 (unlabeled -> compound_stmt .)
    GOTO            reduce using rule 253 (unlabeled -> compound_stmt .)
    DELAY           reduce using rule 253 (unlabeled -> compound_stmt .)
    ABORT           reduce using rule 253 (unlabeled -> compound_stmt .)
    RAISE           reduce using rule 253 (unlabeled -> compound_stmt .)
    REQUEUE         reduce using rule 253 (unlabeled -> compound_stmt .)
    IF              reduce using rule 253 (unlabeled -> compound_stmt .)
    CASE            reduce using rule 253 (unlabeled -> compound_stmt .)
    IDENTIFIER      reduce using rule 253 (unlabeled -> compound_stmt .)
    ACCEPT          reduce using rule 253 (unlabeled -> compound_stmt .)
    SELECT          reduce using rule 253 (unlabeled -> compound_stmt .)
    STRING          reduce using rule 253 (unlabeled -> compound_stmt .)
    WHILE           reduce using rule 253 (unlabeled -> compound_stmt .)
    DECLARE         reduce using rule 253 (unlabeled -> compound_stmt .)
    FOR             reduce using rule 253 (unlabeled -> compound_stmt .)
    LOOP            reduce using rule 253 (unlabeled -> compound_stmt .)
    BEGIN           reduce using rule 253 (unlabeled -> compound_stmt .)
    EXCEPTION       reduce using rule 253 (unlabeled -> compound_stmt .)
    WHEN            reduce using rule 253 (unlabeled -> compound_stmt .)
    OR              reduce using rule 253 (unlabeled -> compound_stmt .)
    ELSE            reduce using rule 253 (unlabeled -> compound_stmt .)
    THEN            reduce using rule 253 (unlabeled -> compound_stmt .)
    ELSIF           reduce using rule 253 (unlabeled -> compound_stmt .)


state 284

    (259) simple_stmt -> goto_stmt .

    LESSLESS        reduce using rule 259 (simple_stmt -> goto_stmt .)
    error           reduce using rule 259 (simple_stmt -> goto_stmt .)
    PRAGMA          reduce using rule 259 (simple_stmt -> goto_stmt .)
    NuLL            reduce using rule 259 (simple_stmt -> goto_stmt .)
    EXIT            reduce using rule 259 (simple_stmt -> goto_stmt .)
    RETURN          reduce using rule 259 (simple_stmt -> goto_stmt .)
    GOTO            reduce using rule 259 (simple_stmt -> goto_stmt .)
    DELAY           reduce using rule 259 (simple_stmt -> goto_stmt .)
    ABORT           reduce using rule 259 (simple_stmt -> goto_stmt .)
    RAISE           reduce using rule 259 (simple_stmt -> goto_stmt .)
    REQUEUE         reduce using rule 259 (simple_stmt -> goto_stmt .)
    IF              reduce using rule 259 (simple_stmt -> goto_stmt .)
    CASE            reduce using rule 259 (simple_stmt -> goto_stmt .)
    IDENTIFIER      reduce using rule 259 (simple_stmt -> goto_stmt .)
    ACCEPT          reduce using rule 259 (simple_stmt -> goto_stmt .)
    SELECT          reduce using rule 259 (simple_stmt -> goto_stmt .)
    STRING          reduce using rule 259 (simple_stmt -> goto_stmt .)
    WHILE           reduce using rule 259 (simple_stmt -> goto_stmt .)
    DECLARE         reduce using rule 259 (simple_stmt -> goto_stmt .)
    FOR             reduce using rule 259 (simple_stmt -> goto_stmt .)
    LOOP            reduce using rule 259 (simple_stmt -> goto_stmt .)
    BEGIN           reduce using rule 259 (simple_stmt -> goto_stmt .)
    OR              reduce using rule 259 (simple_stmt -> goto_stmt .)
    ELSE            reduce using rule 259 (simple_stmt -> goto_stmt .)
    END             reduce using rule 259 (simple_stmt -> goto_stmt .)
    EXCEPTION       reduce using rule 259 (simple_stmt -> goto_stmt .)
    THEN            reduce using rule 259 (simple_stmt -> goto_stmt .)
    ELSIF           reduce using rule 259 (simple_stmt -> goto_stmt .)
    WHEN            reduce using rule 259 (simple_stmt -> goto_stmt .)


state 285

    (284) case_stmt -> case_hdr . pragma_s alternative_s END CASE ;
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 447

state 286

    (270) compound_stmt -> block .

    END             reduce using rule 270 (compound_stmt -> block .)
    LESSLESS        reduce using rule 270 (compound_stmt -> block .)
    error           reduce using rule 270 (compound_stmt -> block .)
    PRAGMA          reduce using rule 270 (compound_stmt -> block .)
    NuLL            reduce using rule 270 (compound_stmt -> block .)
    EXIT            reduce using rule 270 (compound_stmt -> block .)
    RETURN          reduce using rule 270 (compound_stmt -> block .)
    GOTO            reduce using rule 270 (compound_stmt -> block .)
    DELAY           reduce using rule 270 (compound_stmt -> block .)
    ABORT           reduce using rule 270 (compound_stmt -> block .)
    RAISE           reduce using rule 270 (compound_stmt -> block .)
    REQUEUE         reduce using rule 270 (compound_stmt -> block .)
    IF              reduce using rule 270 (compound_stmt -> block .)
    CASE            reduce using rule 270 (compound_stmt -> block .)
    IDENTIFIER      reduce using rule 270 (compound_stmt -> block .)
    ACCEPT          reduce using rule 270 (compound_stmt -> block .)
    SELECT          reduce using rule 270 (compound_stmt -> block .)
    STRING          reduce using rule 270 (compound_stmt -> block .)
    WHILE           reduce using rule 270 (compound_stmt -> block .)
    DECLARE         reduce using rule 270 (compound_stmt -> block .)
    FOR             reduce using rule 270 (compound_stmt -> block .)
    LOOP            reduce using rule 270 (compound_stmt -> block .)
    BEGIN           reduce using rule 270 (compound_stmt -> block .)
    ELSIF           reduce using rule 270 (compound_stmt -> block .)
    ELSE            reduce using rule 270 (compound_stmt -> block .)
    OR              reduce using rule 270 (compound_stmt -> block .)
    WHEN            reduce using rule 270 (compound_stmt -> block .)
    THEN            reduce using rule 270 (compound_stmt -> block .)
    EXCEPTION       reduce using rule 270 (compound_stmt -> block .)


state 287

    (470) raise_stmt -> RAISE . name_opt ;
    (309) name_opt -> .
    (310) name_opt -> . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    ;               reduce using rule 309 (name_opt -> .)
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 448
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    name_opt                       shift and go to state 449
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 288

    (258) simple_stmt -> return_stmt .

    LESSLESS        reduce using rule 258 (simple_stmt -> return_stmt .)
    error           reduce using rule 258 (simple_stmt -> return_stmt .)
    PRAGMA          reduce using rule 258 (simple_stmt -> return_stmt .)
    NuLL            reduce using rule 258 (simple_stmt -> return_stmt .)
    EXIT            reduce using rule 258 (simple_stmt -> return_stmt .)
    RETURN          reduce using rule 258 (simple_stmt -> return_stmt .)
    GOTO            reduce using rule 258 (simple_stmt -> return_stmt .)
    DELAY           reduce using rule 258 (simple_stmt -> return_stmt .)
    ABORT           reduce using rule 258 (simple_stmt -> return_stmt .)
    RAISE           reduce using rule 258 (simple_stmt -> return_stmt .)
    REQUEUE         reduce using rule 258 (simple_stmt -> return_stmt .)
    IF              reduce using rule 258 (simple_stmt -> return_stmt .)
    CASE            reduce using rule 258 (simple_stmt -> return_stmt .)
    IDENTIFIER      reduce using rule 258 (simple_stmt -> return_stmt .)
    ACCEPT          reduce using rule 258 (simple_stmt -> return_stmt .)
    SELECT          reduce using rule 258 (simple_stmt -> return_stmt .)
    STRING          reduce using rule 258 (simple_stmt -> return_stmt .)
    WHILE           reduce using rule 258 (simple_stmt -> return_stmt .)
    DECLARE         reduce using rule 258 (simple_stmt -> return_stmt .)
    FOR             reduce using rule 258 (simple_stmt -> return_stmt .)
    LOOP            reduce using rule 258 (simple_stmt -> return_stmt .)
    BEGIN           reduce using rule 258 (simple_stmt -> return_stmt .)
    OR              reduce using rule 258 (simple_stmt -> return_stmt .)
    ELSE            reduce using rule 258 (simple_stmt -> return_stmt .)
    END             reduce using rule 258 (simple_stmt -> return_stmt .)
    EXCEPTION       reduce using rule 258 (simple_stmt -> return_stmt .)
    THEN            reduce using rule 258 (simple_stmt -> return_stmt .)
    ELSIF           reduce using rule 258 (simple_stmt -> return_stmt .)
    WHEN            reduce using rule 258 (simple_stmt -> return_stmt .)


state 289

    (304) block_body -> BEGIN handled_stmt_s .

    END             reduce using rule 304 (block_body -> BEGIN handled_stmt_s .)


state 290

    (285) case_hdr -> CASE . expression IS
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 450

state 291

    (471) requeue_stmt -> REQUEUE . name ;
    (472) requeue_stmt -> REQUEUE . name WITH ABORT ;
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 451
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 292

    (248) statement_s -> statement .

    END             reduce using rule 248 (statement_s -> statement .)
    LESSLESS        reduce using rule 248 (statement_s -> statement .)
    error           reduce using rule 248 (statement_s -> statement .)
    PRAGMA          reduce using rule 248 (statement_s -> statement .)
    NuLL            reduce using rule 248 (statement_s -> statement .)
    EXIT            reduce using rule 248 (statement_s -> statement .)
    RETURN          reduce using rule 248 (statement_s -> statement .)
    GOTO            reduce using rule 248 (statement_s -> statement .)
    DELAY           reduce using rule 248 (statement_s -> statement .)
    ABORT           reduce using rule 248 (statement_s -> statement .)
    RAISE           reduce using rule 248 (statement_s -> statement .)
    REQUEUE         reduce using rule 248 (statement_s -> statement .)
    IF              reduce using rule 248 (statement_s -> statement .)
    CASE            reduce using rule 248 (statement_s -> statement .)
    IDENTIFIER      reduce using rule 248 (statement_s -> statement .)
    ACCEPT          reduce using rule 248 (statement_s -> statement .)
    SELECT          reduce using rule 248 (statement_s -> statement .)
    STRING          reduce using rule 248 (statement_s -> statement .)
    WHILE           reduce using rule 248 (statement_s -> statement .)
    DECLARE         reduce using rule 248 (statement_s -> statement .)
    FOR             reduce using rule 248 (statement_s -> statement .)
    LOOP            reduce using rule 248 (statement_s -> statement .)
    BEGIN           reduce using rule 248 (statement_s -> statement .)
    OR              reduce using rule 248 (statement_s -> statement .)
    ELSE            reduce using rule 248 (statement_s -> statement .)
    THEN            reduce using rule 248 (statement_s -> statement .)
    WHEN            reduce using rule 248 (statement_s -> statement .)
    ELSIF           reduce using rule 248 (statement_s -> statement .)
    EXCEPTION       reduce using rule 248 (statement_s -> statement .)


state 293

    (291) label_opt -> IDENTIFIER . :
    (163) simple_name -> IDENTIFIER .

    :               shift and go to state 452
    ASSIGNMENT      reduce using rule 163 (simple_name -> IDENTIFIER .)
    ;               reduce using rule 163 (simple_name -> IDENTIFIER .)
    TICK            reduce using rule 163 (simple_name -> IDENTIFIER .)
    (               reduce using rule 163 (simple_name -> IDENTIFIER .)
    .               reduce using rule 163 (simple_name -> IDENTIFIER .)


state 294

    (261) simple_stmt -> delay_stmt .

    LESSLESS        reduce using rule 261 (simple_stmt -> delay_stmt .)
    error           reduce using rule 261 (simple_stmt -> delay_stmt .)
    PRAGMA          reduce using rule 261 (simple_stmt -> delay_stmt .)
    NuLL            reduce using rule 261 (simple_stmt -> delay_stmt .)
    EXIT            reduce using rule 261 (simple_stmt -> delay_stmt .)
    RETURN          reduce using rule 261 (simple_stmt -> delay_stmt .)
    GOTO            reduce using rule 261 (simple_stmt -> delay_stmt .)
    DELAY           reduce using rule 261 (simple_stmt -> delay_stmt .)
    ABORT           reduce using rule 261 (simple_stmt -> delay_stmt .)
    RAISE           reduce using rule 261 (simple_stmt -> delay_stmt .)
    REQUEUE         reduce using rule 261 (simple_stmt -> delay_stmt .)
    IF              reduce using rule 261 (simple_stmt -> delay_stmt .)
    CASE            reduce using rule 261 (simple_stmt -> delay_stmt .)
    IDENTIFIER      reduce using rule 261 (simple_stmt -> delay_stmt .)
    ACCEPT          reduce using rule 261 (simple_stmt -> delay_stmt .)
    SELECT          reduce using rule 261 (simple_stmt -> delay_stmt .)
    STRING          reduce using rule 261 (simple_stmt -> delay_stmt .)
    WHILE           reduce using rule 261 (simple_stmt -> delay_stmt .)
    DECLARE         reduce using rule 261 (simple_stmt -> delay_stmt .)
    FOR             reduce using rule 261 (simple_stmt -> delay_stmt .)
    LOOP            reduce using rule 261 (simple_stmt -> delay_stmt .)
    BEGIN           reduce using rule 261 (simple_stmt -> delay_stmt .)
    OR              reduce using rule 261 (simple_stmt -> delay_stmt .)
    ELSE            reduce using rule 261 (simple_stmt -> delay_stmt .)
    END             reduce using rule 261 (simple_stmt -> delay_stmt .)
    EXCEPTION       reduce using rule 261 (simple_stmt -> delay_stmt .)
    THEN            reduce using rule 261 (simple_stmt -> delay_stmt .)
    ELSIF           reduce using rule 261 (simple_stmt -> delay_stmt .)
    WHEN            reduce using rule 261 (simple_stmt -> delay_stmt .)


state 295

    (405) accept_stmt -> accept_hdr . ;
    (406) accept_stmt -> accept_hdr . DO handled_stmt_s END id_opt ;

    ;               shift and go to state 454
    DO              shift and go to state 453


state 296

    (254) unlabeled -> pragma .

    END             reduce using rule 254 (unlabeled -> pragma .)
    LESSLESS        reduce using rule 254 (unlabeled -> pragma .)
    error           reduce using rule 254 (unlabeled -> pragma .)
    PRAGMA          reduce using rule 254 (unlabeled -> pragma .)
    NuLL            reduce using rule 254 (unlabeled -> pragma .)
    EXIT            reduce using rule 254 (unlabeled -> pragma .)
    RETURN          reduce using rule 254 (unlabeled -> pragma .)
    GOTO            reduce using rule 254 (unlabeled -> pragma .)
    DELAY           reduce using rule 254 (unlabeled -> pragma .)
    ABORT           reduce using rule 254 (unlabeled -> pragma .)
    RAISE           reduce using rule 254 (unlabeled -> pragma .)
    REQUEUE         reduce using rule 254 (unlabeled -> pragma .)
    IF              reduce using rule 254 (unlabeled -> pragma .)
    CASE            reduce using rule 254 (unlabeled -> pragma .)
    IDENTIFIER      reduce using rule 254 (unlabeled -> pragma .)
    ACCEPT          reduce using rule 254 (unlabeled -> pragma .)
    SELECT          reduce using rule 254 (unlabeled -> pragma .)
    STRING          reduce using rule 254 (unlabeled -> pragma .)
    WHILE           reduce using rule 254 (unlabeled -> pragma .)
    DECLARE         reduce using rule 254 (unlabeled -> pragma .)
    FOR             reduce using rule 254 (unlabeled -> pragma .)
    LOOP            reduce using rule 254 (unlabeled -> pragma .)
    BEGIN           reduce using rule 254 (unlabeled -> pragma .)
    EXCEPTION       reduce using rule 254 (unlabeled -> pragma .)
    WHEN            reduce using rule 254 (unlabeled -> pragma .)
    OR              reduce using rule 254 (unlabeled -> pragma .)
    ELSE            reduce using rule 254 (unlabeled -> pragma .)
    THEN            reduce using rule 254 (unlabeled -> pragma .)
    ELSIF           reduce using rule 254 (unlabeled -> pragma .)


state 297

    (265) simple_stmt -> requeue_stmt .

    LESSLESS        reduce using rule 265 (simple_stmt -> requeue_stmt .)
    error           reduce using rule 265 (simple_stmt -> requeue_stmt .)
    PRAGMA          reduce using rule 265 (simple_stmt -> requeue_stmt .)
    NuLL            reduce using rule 265 (simple_stmt -> requeue_stmt .)
    EXIT            reduce using rule 265 (simple_stmt -> requeue_stmt .)
    RETURN          reduce using rule 265 (simple_stmt -> requeue_stmt .)
    GOTO            reduce using rule 265 (simple_stmt -> requeue_stmt .)
    DELAY           reduce using rule 265 (simple_stmt -> requeue_stmt .)
    ABORT           reduce using rule 265 (simple_stmt -> requeue_stmt .)
    RAISE           reduce using rule 265 (simple_stmt -> requeue_stmt .)
    REQUEUE         reduce using rule 265 (simple_stmt -> requeue_stmt .)
    IF              reduce using rule 265 (simple_stmt -> requeue_stmt .)
    CASE            reduce using rule 265 (simple_stmt -> requeue_stmt .)
    IDENTIFIER      reduce using rule 265 (simple_stmt -> requeue_stmt .)
    ACCEPT          reduce using rule 265 (simple_stmt -> requeue_stmt .)
    SELECT          reduce using rule 265 (simple_stmt -> requeue_stmt .)
    STRING          reduce using rule 265 (simple_stmt -> requeue_stmt .)
    WHILE           reduce using rule 265 (simple_stmt -> requeue_stmt .)
    DECLARE         reduce using rule 265 (simple_stmt -> requeue_stmt .)
    FOR             reduce using rule 265 (simple_stmt -> requeue_stmt .)
    LOOP            reduce using rule 265 (simple_stmt -> requeue_stmt .)
    BEGIN           reduce using rule 265 (simple_stmt -> requeue_stmt .)
    OR              reduce using rule 265 (simple_stmt -> requeue_stmt .)
    ELSE            reduce using rule 265 (simple_stmt -> requeue_stmt .)
    END             reduce using rule 265 (simple_stmt -> requeue_stmt .)
    EXCEPTION       reduce using rule 265 (simple_stmt -> requeue_stmt .)
    THEN            reduce using rule 265 (simple_stmt -> requeue_stmt .)
    ELSIF           reduce using rule 265 (simple_stmt -> requeue_stmt .)
    WHEN            reduce using rule 265 (simple_stmt -> requeue_stmt .)


state 298

    (263) simple_stmt -> raise_stmt .

    LESSLESS        reduce using rule 263 (simple_stmt -> raise_stmt .)
    error           reduce using rule 263 (simple_stmt -> raise_stmt .)
    PRAGMA          reduce using rule 263 (simple_stmt -> raise_stmt .)
    NuLL            reduce using rule 263 (simple_stmt -> raise_stmt .)
    EXIT            reduce using rule 263 (simple_stmt -> raise_stmt .)
    RETURN          reduce using rule 263 (simple_stmt -> raise_stmt .)
    GOTO            reduce using rule 263 (simple_stmt -> raise_stmt .)
    DELAY           reduce using rule 263 (simple_stmt -> raise_stmt .)
    ABORT           reduce using rule 263 (simple_stmt -> raise_stmt .)
    RAISE           reduce using rule 263 (simple_stmt -> raise_stmt .)
    REQUEUE         reduce using rule 263 (simple_stmt -> raise_stmt .)
    IF              reduce using rule 263 (simple_stmt -> raise_stmt .)
    CASE            reduce using rule 263 (simple_stmt -> raise_stmt .)
    IDENTIFIER      reduce using rule 263 (simple_stmt -> raise_stmt .)
    ACCEPT          reduce using rule 263 (simple_stmt -> raise_stmt .)
    SELECT          reduce using rule 263 (simple_stmt -> raise_stmt .)
    STRING          reduce using rule 263 (simple_stmt -> raise_stmt .)
    WHILE           reduce using rule 263 (simple_stmt -> raise_stmt .)
    DECLARE         reduce using rule 263 (simple_stmt -> raise_stmt .)
    FOR             reduce using rule 263 (simple_stmt -> raise_stmt .)
    LOOP            reduce using rule 263 (simple_stmt -> raise_stmt .)
    BEGIN           reduce using rule 263 (simple_stmt -> raise_stmt .)
    OR              reduce using rule 263 (simple_stmt -> raise_stmt .)
    ELSE            reduce using rule 263 (simple_stmt -> raise_stmt .)
    END             reduce using rule 263 (simple_stmt -> raise_stmt .)
    EXCEPTION       reduce using rule 263 (simple_stmt -> raise_stmt .)
    THEN            reduce using rule 263 (simple_stmt -> raise_stmt .)
    ELSIF           reduce using rule 263 (simple_stmt -> raise_stmt .)
    WHEN            reduce using rule 263 (simple_stmt -> raise_stmt .)


state 299

    (414) select_stmt -> timed_entry_call .

    END             reduce using rule 414 (select_stmt -> timed_entry_call .)
    LESSLESS        reduce using rule 414 (select_stmt -> timed_entry_call .)
    error           reduce using rule 414 (select_stmt -> timed_entry_call .)
    PRAGMA          reduce using rule 414 (select_stmt -> timed_entry_call .)
    NuLL            reduce using rule 414 (select_stmt -> timed_entry_call .)
    EXIT            reduce using rule 414 (select_stmt -> timed_entry_call .)
    RETURN          reduce using rule 414 (select_stmt -> timed_entry_call .)
    GOTO            reduce using rule 414 (select_stmt -> timed_entry_call .)
    DELAY           reduce using rule 414 (select_stmt -> timed_entry_call .)
    ABORT           reduce using rule 414 (select_stmt -> timed_entry_call .)
    RAISE           reduce using rule 414 (select_stmt -> timed_entry_call .)
    REQUEUE         reduce using rule 414 (select_stmt -> timed_entry_call .)
    IF              reduce using rule 414 (select_stmt -> timed_entry_call .)
    CASE            reduce using rule 414 (select_stmt -> timed_entry_call .)
    IDENTIFIER      reduce using rule 414 (select_stmt -> timed_entry_call .)
    ACCEPT          reduce using rule 414 (select_stmt -> timed_entry_call .)
    SELECT          reduce using rule 414 (select_stmt -> timed_entry_call .)
    STRING          reduce using rule 414 (select_stmt -> timed_entry_call .)
    WHILE           reduce using rule 414 (select_stmt -> timed_entry_call .)
    DECLARE         reduce using rule 414 (select_stmt -> timed_entry_call .)
    FOR             reduce using rule 414 (select_stmt -> timed_entry_call .)
    LOOP            reduce using rule 414 (select_stmt -> timed_entry_call .)
    BEGIN           reduce using rule 414 (select_stmt -> timed_entry_call .)
    WHEN            reduce using rule 414 (select_stmt -> timed_entry_call .)
    ELSIF           reduce using rule 414 (select_stmt -> timed_entry_call .)
    ELSE            reduce using rule 414 (select_stmt -> timed_entry_call .)
    THEN            reduce using rule 414 (select_stmt -> timed_entry_call .)
    OR              reduce using rule 414 (select_stmt -> timed_entry_call .)
    EXCEPTION       reduce using rule 414 (select_stmt -> timed_entry_call .)


state 300

    (308) exit_stmt -> EXIT . name_opt when_opt ;
    (309) name_opt -> .
    (310) name_opt -> . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    WHEN            reduce using rule 309 (name_opt -> .)
    ;               reduce using rule 309 (name_opt -> .)
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 448
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    name_opt                       shift and go to state 455
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 301

    (266) simple_stmt -> error . ;

    ;               shift and go to state 456


state 302

    (262) simple_stmt -> abort_stmt .

    LESSLESS        reduce using rule 262 (simple_stmt -> abort_stmt .)
    error           reduce using rule 262 (simple_stmt -> abort_stmt .)
    PRAGMA          reduce using rule 262 (simple_stmt -> abort_stmt .)
    NuLL            reduce using rule 262 (simple_stmt -> abort_stmt .)
    EXIT            reduce using rule 262 (simple_stmt -> abort_stmt .)
    RETURN          reduce using rule 262 (simple_stmt -> abort_stmt .)
    GOTO            reduce using rule 262 (simple_stmt -> abort_stmt .)
    DELAY           reduce using rule 262 (simple_stmt -> abort_stmt .)
    ABORT           reduce using rule 262 (simple_stmt -> abort_stmt .)
    RAISE           reduce using rule 262 (simple_stmt -> abort_stmt .)
    REQUEUE         reduce using rule 262 (simple_stmt -> abort_stmt .)
    IF              reduce using rule 262 (simple_stmt -> abort_stmt .)
    CASE            reduce using rule 262 (simple_stmt -> abort_stmt .)
    IDENTIFIER      reduce using rule 262 (simple_stmt -> abort_stmt .)
    ACCEPT          reduce using rule 262 (simple_stmt -> abort_stmt .)
    SELECT          reduce using rule 262 (simple_stmt -> abort_stmt .)
    STRING          reduce using rule 262 (simple_stmt -> abort_stmt .)
    WHILE           reduce using rule 262 (simple_stmt -> abort_stmt .)
    DECLARE         reduce using rule 262 (simple_stmt -> abort_stmt .)
    FOR             reduce using rule 262 (simple_stmt -> abort_stmt .)
    LOOP            reduce using rule 262 (simple_stmt -> abort_stmt .)
    BEGIN           reduce using rule 262 (simple_stmt -> abort_stmt .)
    OR              reduce using rule 262 (simple_stmt -> abort_stmt .)
    ELSE            reduce using rule 262 (simple_stmt -> abort_stmt .)
    END             reduce using rule 262 (simple_stmt -> abort_stmt .)
    EXCEPTION       reduce using rule 262 (simple_stmt -> abort_stmt .)
    THEN            reduce using rule 262 (simple_stmt -> abort_stmt .)
    ELSIF           reduce using rule 262 (simple_stmt -> abort_stmt .)
    WHEN            reduce using rule 262 (simple_stmt -> abort_stmt .)


state 303

    (305) handled_stmt_s -> statement_s . except_handler_part_opt
    (249) statement_s -> statement_s . statement
    (306) except_handler_part_opt -> .
    (307) except_handler_part_opt -> . except_handler_part
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (462) except_handler_part -> . EXCEPTION exception_handler
    (463) except_handler_part -> . except_handler_part exception_handler
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    END             reduce using rule 306 (except_handler_part_opt -> .)
    EXCEPTION       shift and go to state 460
    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    except_handler_part_opt        shift and go to state 458
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 459
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    except_handler_part            shift and go to state 457
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    label_opt                      shift and go to state 266
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 304

    (264) simple_stmt -> code_stmt .

    LESSLESS        reduce using rule 264 (simple_stmt -> code_stmt .)
    error           reduce using rule 264 (simple_stmt -> code_stmt .)
    PRAGMA          reduce using rule 264 (simple_stmt -> code_stmt .)
    NuLL            reduce using rule 264 (simple_stmt -> code_stmt .)
    EXIT            reduce using rule 264 (simple_stmt -> code_stmt .)
    RETURN          reduce using rule 264 (simple_stmt -> code_stmt .)
    GOTO            reduce using rule 264 (simple_stmt -> code_stmt .)
    DELAY           reduce using rule 264 (simple_stmt -> code_stmt .)
    ABORT           reduce using rule 264 (simple_stmt -> code_stmt .)
    RAISE           reduce using rule 264 (simple_stmt -> code_stmt .)
    REQUEUE         reduce using rule 264 (simple_stmt -> code_stmt .)
    IF              reduce using rule 264 (simple_stmt -> code_stmt .)
    CASE            reduce using rule 264 (simple_stmt -> code_stmt .)
    IDENTIFIER      reduce using rule 264 (simple_stmt -> code_stmt .)
    ACCEPT          reduce using rule 264 (simple_stmt -> code_stmt .)
    SELECT          reduce using rule 264 (simple_stmt -> code_stmt .)
    STRING          reduce using rule 264 (simple_stmt -> code_stmt .)
    WHILE           reduce using rule 264 (simple_stmt -> code_stmt .)
    DECLARE         reduce using rule 264 (simple_stmt -> code_stmt .)
    FOR             reduce using rule 264 (simple_stmt -> code_stmt .)
    LOOP            reduce using rule 264 (simple_stmt -> code_stmt .)
    BEGIN           reduce using rule 264 (simple_stmt -> code_stmt .)
    OR              reduce using rule 264 (simple_stmt -> code_stmt .)
    ELSE            reduce using rule 264 (simple_stmt -> code_stmt .)
    END             reduce using rule 264 (simple_stmt -> code_stmt .)
    EXCEPTION       reduce using rule 264 (simple_stmt -> code_stmt .)
    THEN            reduce using rule 264 (simple_stmt -> code_stmt .)
    ELSIF           reduce using rule 264 (simple_stmt -> code_stmt .)
    WHEN            reduce using rule 264 (simple_stmt -> code_stmt .)


state 305

    (250) statement -> unlabeled .

    LESSLESS        reduce using rule 250 (statement -> unlabeled .)
    error           reduce using rule 250 (statement -> unlabeled .)
    PRAGMA          reduce using rule 250 (statement -> unlabeled .)
    NuLL            reduce using rule 250 (statement -> unlabeled .)
    EXIT            reduce using rule 250 (statement -> unlabeled .)
    RETURN          reduce using rule 250 (statement -> unlabeled .)
    GOTO            reduce using rule 250 (statement -> unlabeled .)
    DELAY           reduce using rule 250 (statement -> unlabeled .)
    ABORT           reduce using rule 250 (statement -> unlabeled .)
    RAISE           reduce using rule 250 (statement -> unlabeled .)
    REQUEUE         reduce using rule 250 (statement -> unlabeled .)
    IF              reduce using rule 250 (statement -> unlabeled .)
    CASE            reduce using rule 250 (statement -> unlabeled .)
    IDENTIFIER      reduce using rule 250 (statement -> unlabeled .)
    ACCEPT          reduce using rule 250 (statement -> unlabeled .)
    SELECT          reduce using rule 250 (statement -> unlabeled .)
    STRING          reduce using rule 250 (statement -> unlabeled .)
    WHILE           reduce using rule 250 (statement -> unlabeled .)
    DECLARE         reduce using rule 250 (statement -> unlabeled .)
    FOR             reduce using rule 250 (statement -> unlabeled .)
    LOOP            reduce using rule 250 (statement -> unlabeled .)
    BEGIN           reduce using rule 250 (statement -> unlabeled .)
    OR              reduce using rule 250 (statement -> unlabeled .)
    ELSE            reduce using rule 250 (statement -> unlabeled .)
    END             reduce using rule 250 (statement -> unlabeled .)
    THEN            reduce using rule 250 (statement -> unlabeled .)
    EXCEPTION       reduce using rule 250 (statement -> unlabeled .)
    ELSIF           reduce using rule 250 (statement -> unlabeled .)
    WHEN            reduce using rule 250 (statement -> unlabeled .)


state 306

    (257) simple_stmt -> exit_stmt .

    LESSLESS        reduce using rule 257 (simple_stmt -> exit_stmt .)
    error           reduce using rule 257 (simple_stmt -> exit_stmt .)
    PRAGMA          reduce using rule 257 (simple_stmt -> exit_stmt .)
    NuLL            reduce using rule 257 (simple_stmt -> exit_stmt .)
    EXIT            reduce using rule 257 (simple_stmt -> exit_stmt .)
    RETURN          reduce using rule 257 (simple_stmt -> exit_stmt .)
    GOTO            reduce using rule 257 (simple_stmt -> exit_stmt .)
    DELAY           reduce using rule 257 (simple_stmt -> exit_stmt .)
    ABORT           reduce using rule 257 (simple_stmt -> exit_stmt .)
    RAISE           reduce using rule 257 (simple_stmt -> exit_stmt .)
    REQUEUE         reduce using rule 257 (simple_stmt -> exit_stmt .)
    IF              reduce using rule 257 (simple_stmt -> exit_stmt .)
    CASE            reduce using rule 257 (simple_stmt -> exit_stmt .)
    IDENTIFIER      reduce using rule 257 (simple_stmt -> exit_stmt .)
    ACCEPT          reduce using rule 257 (simple_stmt -> exit_stmt .)
    SELECT          reduce using rule 257 (simple_stmt -> exit_stmt .)
    STRING          reduce using rule 257 (simple_stmt -> exit_stmt .)
    WHILE           reduce using rule 257 (simple_stmt -> exit_stmt .)
    DECLARE         reduce using rule 257 (simple_stmt -> exit_stmt .)
    FOR             reduce using rule 257 (simple_stmt -> exit_stmt .)
    LOOP            reduce using rule 257 (simple_stmt -> exit_stmt .)
    BEGIN           reduce using rule 257 (simple_stmt -> exit_stmt .)
    OR              reduce using rule 257 (simple_stmt -> exit_stmt .)
    ELSE            reduce using rule 257 (simple_stmt -> exit_stmt .)
    END             reduce using rule 257 (simple_stmt -> exit_stmt .)
    EXCEPTION       reduce using rule 257 (simple_stmt -> exit_stmt .)
    THEN            reduce using rule 257 (simple_stmt -> exit_stmt .)
    ELSIF           reduce using rule 257 (simple_stmt -> exit_stmt .)
    WHEN            reduce using rule 257 (simple_stmt -> exit_stmt .)


state 307

    (412) select_stmt -> select_wait .

    END             reduce using rule 412 (select_stmt -> select_wait .)
    LESSLESS        reduce using rule 412 (select_stmt -> select_wait .)
    error           reduce using rule 412 (select_stmt -> select_wait .)
    PRAGMA          reduce using rule 412 (select_stmt -> select_wait .)
    NuLL            reduce using rule 412 (select_stmt -> select_wait .)
    EXIT            reduce using rule 412 (select_stmt -> select_wait .)
    RETURN          reduce using rule 412 (select_stmt -> select_wait .)
    GOTO            reduce using rule 412 (select_stmt -> select_wait .)
    DELAY           reduce using rule 412 (select_stmt -> select_wait .)
    ABORT           reduce using rule 412 (select_stmt -> select_wait .)
    RAISE           reduce using rule 412 (select_stmt -> select_wait .)
    REQUEUE         reduce using rule 412 (select_stmt -> select_wait .)
    IF              reduce using rule 412 (select_stmt -> select_wait .)
    CASE            reduce using rule 412 (select_stmt -> select_wait .)
    IDENTIFIER      reduce using rule 412 (select_stmt -> select_wait .)
    ACCEPT          reduce using rule 412 (select_stmt -> select_wait .)
    SELECT          reduce using rule 412 (select_stmt -> select_wait .)
    STRING          reduce using rule 412 (select_stmt -> select_wait .)
    WHILE           reduce using rule 412 (select_stmt -> select_wait .)
    DECLARE         reduce using rule 412 (select_stmt -> select_wait .)
    FOR             reduce using rule 412 (select_stmt -> select_wait .)
    LOOP            reduce using rule 412 (select_stmt -> select_wait .)
    BEGIN           reduce using rule 412 (select_stmt -> select_wait .)
    WHEN            reduce using rule 412 (select_stmt -> select_wait .)
    ELSIF           reduce using rule 412 (select_stmt -> select_wait .)
    ELSE            reduce using rule 412 (select_stmt -> select_wait .)
    THEN            reduce using rule 412 (select_stmt -> select_wait .)
    OR              reduce using rule 412 (select_stmt -> select_wait .)
    EXCEPTION       reduce using rule 412 (select_stmt -> select_wait .)


state 308

    (276) if_stmt -> IF . cond_clause_s else_opt END IF ;
    (277) cond_clause_s -> . cond_clause
    (278) cond_clause_s -> . cond_clause_s ELSIF cond_clause
    (279) cond_clause -> . cond_part statement_s
    (280) cond_part -> . condition THEN
    (281) condition -> . expression
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    cond_clause_s                  shift and go to state 461
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158
    cond_clause                    shift and go to state 462
    cond_part                      shift and go to state 463
    literal                        shift and go to state 135
    allocator                      shift and go to state 130
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    condition                      shift and go to state 464
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 465

state 309

    (415) select_stmt -> cond_entry_call .

    END             reduce using rule 415 (select_stmt -> cond_entry_call .)
    LESSLESS        reduce using rule 415 (select_stmt -> cond_entry_call .)
    error           reduce using rule 415 (select_stmt -> cond_entry_call .)
    PRAGMA          reduce using rule 415 (select_stmt -> cond_entry_call .)
    NuLL            reduce using rule 415 (select_stmt -> cond_entry_call .)
    EXIT            reduce using rule 415 (select_stmt -> cond_entry_call .)
    RETURN          reduce using rule 415 (select_stmt -> cond_entry_call .)
    GOTO            reduce using rule 415 (select_stmt -> cond_entry_call .)
    DELAY           reduce using rule 415 (select_stmt -> cond_entry_call .)
    ABORT           reduce using rule 415 (select_stmt -> cond_entry_call .)
    RAISE           reduce using rule 415 (select_stmt -> cond_entry_call .)
    REQUEUE         reduce using rule 415 (select_stmt -> cond_entry_call .)
    IF              reduce using rule 415 (select_stmt -> cond_entry_call .)
    CASE            reduce using rule 415 (select_stmt -> cond_entry_call .)
    IDENTIFIER      reduce using rule 415 (select_stmt -> cond_entry_call .)
    ACCEPT          reduce using rule 415 (select_stmt -> cond_entry_call .)
    SELECT          reduce using rule 415 (select_stmt -> cond_entry_call .)
    STRING          reduce using rule 415 (select_stmt -> cond_entry_call .)
    WHILE           reduce using rule 415 (select_stmt -> cond_entry_call .)
    DECLARE         reduce using rule 415 (select_stmt -> cond_entry_call .)
    FOR             reduce using rule 415 (select_stmt -> cond_entry_call .)
    LOOP            reduce using rule 415 (select_stmt -> cond_entry_call .)
    BEGIN           reduce using rule 415 (select_stmt -> cond_entry_call .)
    WHEN            reduce using rule 415 (select_stmt -> cond_entry_call .)
    ELSIF           reduce using rule 415 (select_stmt -> cond_entry_call .)
    ELSE            reduce using rule 415 (select_stmt -> cond_entry_call .)
    THEN            reduce using rule 415 (select_stmt -> cond_entry_call .)
    OR              reduce using rule 415 (select_stmt -> cond_entry_call .)
    EXCEPTION       reduce using rule 415 (select_stmt -> cond_entry_call .)


state 310

    (255) simple_stmt -> null_stmt .

    LESSLESS        reduce using rule 255 (simple_stmt -> null_stmt .)
    error           reduce using rule 255 (simple_stmt -> null_stmt .)
    PRAGMA          reduce using rule 255 (simple_stmt -> null_stmt .)
    NuLL            reduce using rule 255 (simple_stmt -> null_stmt .)
    EXIT            reduce using rule 255 (simple_stmt -> null_stmt .)
    RETURN          reduce using rule 255 (simple_stmt -> null_stmt .)
    GOTO            reduce using rule 255 (simple_stmt -> null_stmt .)
    DELAY           reduce using rule 255 (simple_stmt -> null_stmt .)
    ABORT           reduce using rule 255 (simple_stmt -> null_stmt .)
    RAISE           reduce using rule 255 (simple_stmt -> null_stmt .)
    REQUEUE         reduce using rule 255 (simple_stmt -> null_stmt .)
    IF              reduce using rule 255 (simple_stmt -> null_stmt .)
    CASE            reduce using rule 255 (simple_stmt -> null_stmt .)
    IDENTIFIER      reduce using rule 255 (simple_stmt -> null_stmt .)
    ACCEPT          reduce using rule 255 (simple_stmt -> null_stmt .)
    SELECT          reduce using rule 255 (simple_stmt -> null_stmt .)
    STRING          reduce using rule 255 (simple_stmt -> null_stmt .)
    WHILE           reduce using rule 255 (simple_stmt -> null_stmt .)
    DECLARE         reduce using rule 255 (simple_stmt -> null_stmt .)
    FOR             reduce using rule 255 (simple_stmt -> null_stmt .)
    LOOP            reduce using rule 255 (simple_stmt -> null_stmt .)
    BEGIN           reduce using rule 255 (simple_stmt -> null_stmt .)
    OR              reduce using rule 255 (simple_stmt -> null_stmt .)
    ELSE            reduce using rule 255 (simple_stmt -> null_stmt .)
    END             reduce using rule 255 (simple_stmt -> null_stmt .)
    EXCEPTION       reduce using rule 255 (simple_stmt -> null_stmt .)
    THEN            reduce using rule 255 (simple_stmt -> null_stmt .)
    ELSIF           reduce using rule 255 (simple_stmt -> null_stmt .)
    WHEN            reduce using rule 255 (simple_stmt -> null_stmt .)


state 311

    (256) simple_stmt -> assign_stmt .

    LESSLESS        reduce using rule 256 (simple_stmt -> assign_stmt .)
    error           reduce using rule 256 (simple_stmt -> assign_stmt .)
    PRAGMA          reduce using rule 256 (simple_stmt -> assign_stmt .)
    NuLL            reduce using rule 256 (simple_stmt -> assign_stmt .)
    EXIT            reduce using rule 256 (simple_stmt -> assign_stmt .)
    RETURN          reduce using rule 256 (simple_stmt -> assign_stmt .)
    GOTO            reduce using rule 256 (simple_stmt -> assign_stmt .)
    DELAY           reduce using rule 256 (simple_stmt -> assign_stmt .)
    ABORT           reduce using rule 256 (simple_stmt -> assign_stmt .)
    RAISE           reduce using rule 256 (simple_stmt -> assign_stmt .)
    REQUEUE         reduce using rule 256 (simple_stmt -> assign_stmt .)
    IF              reduce using rule 256 (simple_stmt -> assign_stmt .)
    CASE            reduce using rule 256 (simple_stmt -> assign_stmt .)
    IDENTIFIER      reduce using rule 256 (simple_stmt -> assign_stmt .)
    ACCEPT          reduce using rule 256 (simple_stmt -> assign_stmt .)
    SELECT          reduce using rule 256 (simple_stmt -> assign_stmt .)
    STRING          reduce using rule 256 (simple_stmt -> assign_stmt .)
    WHILE           reduce using rule 256 (simple_stmt -> assign_stmt .)
    DECLARE         reduce using rule 256 (simple_stmt -> assign_stmt .)
    FOR             reduce using rule 256 (simple_stmt -> assign_stmt .)
    LOOP            reduce using rule 256 (simple_stmt -> assign_stmt .)
    BEGIN           reduce using rule 256 (simple_stmt -> assign_stmt .)
    OR              reduce using rule 256 (simple_stmt -> assign_stmt .)
    ELSE            reduce using rule 256 (simple_stmt -> assign_stmt .)
    END             reduce using rule 256 (simple_stmt -> assign_stmt .)
    EXCEPTION       reduce using rule 256 (simple_stmt -> assign_stmt .)
    THEN            reduce using rule 256 (simple_stmt -> assign_stmt .)
    ELSIF           reduce using rule 256 (simple_stmt -> assign_stmt .)
    WHEN            reduce using rule 256 (simple_stmt -> assign_stmt .)


state 312

    (337) subprog_body -> subprog_spec_is_push decl_part block_body END . id_opt ;
    (299) id_opt -> .
    (300) id_opt -> . designator
    (322) designator -> . compound_name
    (323) designator -> . STRING
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    ;               reduce using rule 299 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 466
    id_opt                         shift and go to state 467
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 313

    (509) attrib_def -> FOR mark USE . expression ;
    (510) record_type_spec -> FOR mark USE . RECORD align_opt comp_loc_s END RECORD ;
    (515) address_spec -> FOR mark USE . AT expression ;
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    RECORD          shift and go to state 468
    AT              shift and go to state 469
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 470

state 314

    (162) mark -> mark . . simple_name
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 471

state 315

    (161) mark -> mark TICK . attribute_id
    (182) attribute_id -> . IDENTIFIER
    (183) attribute_id -> . DIGITS
    (184) attribute_id -> . DELTA
    (185) attribute_id -> . ACCESS

    IDENTIFIER      shift and go to state 393
    DIGITS          shift and go to state 392
    DELTA           shift and go to state 396
    ACCESS          shift and go to state 394

    attribute_id                   shift and go to state 472

state 316

    (371) task_body -> TASK BODY simple_name . IS decl_part block_body END id_opt ;
    (457) body_stub -> TASK BODY simple_name . IS SEPARATE ;

    IS              shift and go to state 473


state 317

    (366) task_spec -> TASK TYPE simple_name . discrim_part_opt task_def
    (37) discrim_part_opt -> .
    (38) discrim_part_opt -> . discrim_part
    (39) discrim_part_opt -> . ( LESSMORE )
    (112) discrim_part -> . ( discrim_spec_s )

    IS              reduce using rule 37 (discrim_part_opt -> .)
    ;               reduce using rule 37 (discrim_part_opt -> .)
    (               shift and go to state 321

    discrim_part_opt               shift and go to state 474
    discrim_part                   shift and go to state 323

state 318

    (368) task_def -> IS . entry_decl_s rep_spec_s task_private_opt END id_opt
    (394) entry_decl_s -> . pragma_s
    (395) entry_decl_s -> . entry_decl_s entry_decl pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    FOR             reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)

    entry_decl_s                   shift and go to state 475
    pragma_s                       shift and go to state 476

state 319

    (365) task_spec -> TASK simple_name task_def .

    ;               reduce using rule 365 (task_spec -> TASK simple_name task_def .)


state 320

    (346) pkg_body -> PACKAGE BODY compound_name . IS decl_part body_opt END c_id_opt ;
    (458) body_stub -> PACKAGE BODY compound_name . IS SEPARATE ;
    (165) compound_name -> compound_name . . simple_name

    IS              shift and go to state 477
    .               shift and go to state 119


state 321

    (39) discrim_part_opt -> ( . LESSMORE )
    (112) discrim_part -> ( . discrim_spec_s )
    (113) discrim_spec_s -> . discrim_spec
    (114) discrim_spec_s -> . discrim_spec_s ; discrim_spec
    (115) discrim_spec -> . def_id_s : access_opt mark init_opt
    (116) discrim_spec -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    LESSMORE        shift and go to state 482
    error           shift and go to state 478
    IDENTIFIER      shift and go to state 76

    discrim_spec                   shift and go to state 481
    discrim_spec_s                 shift and go to state 479
    def_id                         shift and go to state 89
    def_id_s                       shift and go to state 480

state 322

    (36) type_decl -> TYPE IDENTIFIER discrim_part_opt . type_completion ;
    (40) type_completion -> .
    (41) type_completion -> . IS type_def

    ;               reduce using rule 40 (type_completion -> .)
    IS              shift and go to state 483

    type_completion                shift and go to state 484

state 323

    (38) discrim_part_opt -> discrim_part .

    IS              reduce using rule 38 (discrim_part_opt -> discrim_part .)
    ;               reduce using rule 38 (discrim_part_opt -> discrim_part .)


state 324

    (50) subtype_decl -> SUBTYPE IDENTIFIER IS . subtype_ind ;
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 485
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    subtype_ind                    shift and go to state 486
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 325

    (459) body_stub -> subprog_spec IS SEPARATE . ;

    ;               shift and go to state 487


state 326

    (25) def_id_s -> def_id_s , def_id .

    :               reduce using rule 25 (def_id_s -> def_id_s , def_id .)
    ,               reduce using rule 25 (def_id_s -> def_id_s , def_id .)


state 327

    (461) exception_decl -> def_id_s : EXCEPTION . ;
    (357) rename_decl -> def_id_s : EXCEPTION . renames ;
    (363) renames -> . RENAMES name

    ;               shift and go to state 489
    RENAMES         shift and go to state 95

    renames                        shift and go to state 488

state 328

    (35) number_decl -> def_id_s : CONSTANT . ASSIGNMENT expression ;
    (29) object_qualifier_opt -> CONSTANT .

    ASSIGNMENT      shift and go to state 490
    ARRAY           reduce using rule 29 (object_qualifier_opt -> CONSTANT .)
    IDENTIFIER      reduce using rule 29 (object_qualifier_opt -> CONSTANT .)
    STRING          reduce using rule 29 (object_qualifier_opt -> CONSTANT .)


state 329

    (28) object_qualifier_opt -> ALIASED .
    (30) object_qualifier_opt -> ALIASED . CONSTANT

    ARRAY           reduce using rule 28 (object_qualifier_opt -> ALIASED .)
    IDENTIFIER      reduce using rule 28 (object_qualifier_opt -> ALIASED .)
    STRING          reduce using rule 28 (object_qualifier_opt -> ALIASED .)
    CONSTANT        shift and go to state 491


state 330

    (23) object_decl -> def_id_s : object_qualifier_opt . object_subtype_def init_opt ;
    (356) rename_decl -> def_id_s : object_qualifier_opt . subtype_ind renames ;
    (31) object_subtype_def -> . subtype_ind
    (32) object_subtype_def -> . array_type
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (80) array_type -> . unconstr_array_type
    (81) array_type -> . constr_array_type
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (82) unconstr_array_type -> . ARRAY ( index_s ) OF component_subtype_def
    (83) constr_array_type -> . ARRAY iter_index_constraint OF component_subtype_def
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    ARRAY           shift and go to state 493
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158
    array_type                     shift and go to state 492
    name                           shift and go to state 485
    object_subtype_def             shift and go to state 494
    constr_array_type              shift and go to state 495
    operator_symbol                shift and go to state 149
    subtype_ind                    shift and go to state 496
    unconstr_array_type            shift and go to state 497

state 331

    (505) generic_inst -> NEW name .
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id

    ;               reduce using rule 505 (generic_inst -> NEW name .)
    (               shift and go to state 245
    .               shift and go to state 246
    TICK            shift and go to state 256


state 332

    (346) pkg_body -> PACKAGE BODY compound_name IS . decl_part body_opt END c_id_opt ;
    (137) decl_part -> .
    (138) decl_part -> . decl_item_or_body_s1
    (147) decl_item_or_body_s1 -> . decl_item_or_body
    (148) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (149) decl_item_or_body -> . body
    (150) decl_item_or_body -> . decl_item
    (151) body -> . subprog_body
    (152) body -> . pkg_body
    (153) body -> . task_body
    (154) body -> . prot_body
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (337) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (346) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (371) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (388) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (352) use_clause -> . USE name_s ;
    (353) use_clause -> . USE TYPE name_s ;
    (506) rep_spec -> . attrib_def
    (507) rep_spec -> . record_type_spec
    (508) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (336) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (316) subprog_decl -> . subprog_spec ;
    (317) subprog_decl -> . generic_subp_inst ;
    (318) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (339) pkg_decl -> . pkg_spec ;
    (340) pkg_decl -> . generic_pkg_inst ;
    (364) task_decl -> . task_spec ;
    (372) prot_decl -> . prot_spec ;
    (461) exception_decl -> . def_id_s : EXCEPTION ;
    (356) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (357) rename_decl -> . def_id_s : EXCEPTION renames ;
    (358) rename_decl -> . rename_unit
    (473) generic_decl -> . generic_formal_part subprog_spec ;
    (474) generic_decl -> . generic_formal_part pkg_spec ;
    (457) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (458) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (459) body_stub -> . subprog_spec IS SEPARATE ;
    (460) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (509) attrib_def -> . FOR mark USE expression ;
    (510) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (515) address_spec -> . FOR mark USE AT expression ;
    (319) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (320) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (321) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (503) generic_subp_inst -> . subprog_spec IS generic_inst
    (341) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (365) task_spec -> . TASK simple_name task_def
    (366) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (373) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (374) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (359) rename_unit -> . PACKAGE compound_name renames ;
    (360) rename_unit -> . subprog_spec renames ;
    (361) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (362) rename_unit -> . generic_formal_part subprog_spec renames ;
    (475) generic_formal_part -> . GENERIC
    (476) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 137 (decl_part -> .)
    END             reduce using rule 137 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 498
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 333

    (359) rename_unit -> PACKAGE compound_name renames ; .

    PACKAGE         reduce using rule 359 (rename_unit -> PACKAGE compound_name renames ; .)
    TASK            reduce using rule 359 (rename_unit -> PACKAGE compound_name renames ; .)
    PROTECTED       reduce using rule 359 (rename_unit -> PACKAGE compound_name renames ; .)
    error           reduce using rule 359 (rename_unit -> PACKAGE compound_name renames ; .)
    USE             reduce using rule 359 (rename_unit -> PACKAGE compound_name renames ; .)
    PRAGMA          reduce using rule 359 (rename_unit -> PACKAGE compound_name renames ; .)
    TYPE            reduce using rule 359 (rename_unit -> PACKAGE compound_name renames ; .)
    SUBTYPE         reduce using rule 359 (rename_unit -> PACKAGE compound_name renames ; .)
    FOR             reduce using rule 359 (rename_unit -> PACKAGE compound_name renames ; .)
    PROCEDURE       reduce using rule 359 (rename_unit -> PACKAGE compound_name renames ; .)
    FUNCTION        reduce using rule 359 (rename_unit -> PACKAGE compound_name renames ; .)
    GENERIC         reduce using rule 359 (rename_unit -> PACKAGE compound_name renames ; .)
    IDENTIFIER      reduce using rule 359 (rename_unit -> PACKAGE compound_name renames ; .)
    BEGIN           reduce using rule 359 (rename_unit -> PACKAGE compound_name renames ; .)
    END             reduce using rule 359 (rename_unit -> PACKAGE compound_name renames ; .)
    PRIVATE         reduce using rule 359 (rename_unit -> PACKAGE compound_name renames ; .)
    WITH            reduce using rule 359 (rename_unit -> PACKAGE compound_name renames ; .)
    SEPARATE        reduce using rule 359 (rename_unit -> PACKAGE compound_name renames ; .)
    $end            reduce using rule 359 (rename_unit -> PACKAGE compound_name renames ; .)


state 334

    (504) generic_pkg_inst -> PACKAGE compound_name IS generic_inst .

    ;               reduce using rule 504 (generic_pkg_inst -> PACKAGE compound_name IS generic_inst .)


state 335

    (140) decl_item_s -> decl_item_s1 .
    (142) decl_item_s1 -> decl_item_s1 . decl_item
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (352) use_clause -> . USE name_s ;
    (353) use_clause -> . USE TYPE name_s ;
    (506) rep_spec -> . attrib_def
    (507) rep_spec -> . record_type_spec
    (508) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (316) subprog_decl -> . subprog_spec ;
    (317) subprog_decl -> . generic_subp_inst ;
    (318) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (339) pkg_decl -> . pkg_spec ;
    (340) pkg_decl -> . generic_pkg_inst ;
    (364) task_decl -> . task_spec ;
    (372) prot_decl -> . prot_spec ;
    (461) exception_decl -> . def_id_s : EXCEPTION ;
    (356) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (357) rename_decl -> . def_id_s : EXCEPTION renames ;
    (358) rename_decl -> . rename_unit
    (473) generic_decl -> . generic_formal_part subprog_spec ;
    (474) generic_decl -> . generic_formal_part pkg_spec ;
    (457) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (458) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (459) body_stub -> . subprog_spec IS SEPARATE ;
    (460) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (509) attrib_def -> . FOR mark USE expression ;
    (510) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (515) address_spec -> . FOR mark USE AT expression ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (319) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (320) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (321) subprog_spec -> . FUNCTION designator
    (503) generic_subp_inst -> . subprog_spec IS generic_inst
    (336) subprog_spec_is_push -> . subprog_spec IS
    (341) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (365) task_spec -> . TASK simple_name task_def
    (366) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (373) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (374) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (359) rename_unit -> . PACKAGE compound_name renames ;
    (360) rename_unit -> . subprog_spec renames ;
    (361) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (362) rename_unit -> . generic_formal_part subprog_spec renames ;
    (475) generic_formal_part -> . GENERIC
    (476) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    END             reduce using rule 140 (decl_item_s -> decl_item_s1 .)
    PRIVATE         reduce using rule 140 (decl_item_s -> decl_item_s1 .)
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    TASK            shift and go to state 339
    PACKAGE         shift and go to state 340
    PROTECTED       shift and go to state 336
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    task_decl                      shift and go to state 60
    subtype_decl                   shift and go to state 61
    rep_spec                       shift and go to state 82
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    decl_item                      shift and go to state 499
    subprog_spec_is_push           shift and go to state 341
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 342
    def_id_s                       shift and go to state 88
    task_spec                      shift and go to state 65
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    generic_subp_inst              shift and go to state 29
    def_id                         shift and go to state 89
    rename_decl                    shift and go to state 90
    type_decl                      shift and go to state 56
    rename_unit                    shift and go to state 91
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    subprog_decl                   shift and go to state 58
    pragma                         shift and go to state 74
    pkg_spec                       shift and go to state 37
    number_decl                    shift and go to state 93

state 336

    (460) body_stub -> PROTECTED . BODY simple_name IS SEPARATE ;
    (373) prot_spec -> PROTECTED . IDENTIFIER prot_def
    (374) prot_spec -> PROTECTED . TYPE simple_name discrim_part_opt prot_def

    BODY            shift and go to state 500
    IDENTIFIER      shift and go to state 161
    TYPE            shift and go to state 162


state 337

    (141) decl_item_s1 -> decl_item .

    error           reduce using rule 141 (decl_item_s1 -> decl_item .)
    USE             reduce using rule 141 (decl_item_s1 -> decl_item .)
    PRAGMA          reduce using rule 141 (decl_item_s1 -> decl_item .)
    TYPE            reduce using rule 141 (decl_item_s1 -> decl_item .)
    SUBTYPE         reduce using rule 141 (decl_item_s1 -> decl_item .)
    TASK            reduce using rule 141 (decl_item_s1 -> decl_item .)
    PACKAGE         reduce using rule 141 (decl_item_s1 -> decl_item .)
    PROTECTED       reduce using rule 141 (decl_item_s1 -> decl_item .)
    FOR             reduce using rule 141 (decl_item_s1 -> decl_item .)
    PROCEDURE       reduce using rule 141 (decl_item_s1 -> decl_item .)
    FUNCTION        reduce using rule 141 (decl_item_s1 -> decl_item .)
    GENERIC         reduce using rule 141 (decl_item_s1 -> decl_item .)
    IDENTIFIER      reduce using rule 141 (decl_item_s1 -> decl_item .)
    END             reduce using rule 141 (decl_item_s1 -> decl_item .)
    PRIVATE         reduce using rule 141 (decl_item_s1 -> decl_item .)


state 338

    (341) pkg_spec -> PACKAGE compound_name IS decl_item_s . private_part END c_id_opt
    (342) private_part -> .
    (343) private_part -> . PRIVATE decl_item_s

    END             reduce using rule 342 (private_part -> .)
    PRIVATE         shift and go to state 501

    private_part                   shift and go to state 502

state 339

    (457) body_stub -> TASK . BODY simple_name IS SEPARATE ;
    (365) task_spec -> TASK . simple_name task_def
    (366) task_spec -> TASK . TYPE simple_name discrim_part_opt task_def
    (163) simple_name -> . IDENTIFIER

    BODY            shift and go to state 503
    TYPE            shift and go to state 169
    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 170

state 340

    (458) body_stub -> PACKAGE . BODY compound_name IS SEPARATE ;
    (341) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> PACKAGE . compound_name IS generic_inst
    (359) rename_unit -> PACKAGE . compound_name renames ;
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    BODY            shift and go to state 504
    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 41
    compound_name                  shift and go to state 173

state 341

    (318) subprog_decl -> subprog_spec_is_push . ABSTRACT ;

    ABSTRACT        shift and go to state 81


state 342

    (316) subprog_decl -> subprog_spec . ;
    (459) body_stub -> subprog_spec . IS SEPARATE ;
    (503) generic_subp_inst -> subprog_spec . IS generic_inst
    (336) subprog_spec_is_push -> subprog_spec . IS
    (360) rename_unit -> subprog_spec . renames ;
    (363) renames -> . RENAMES name

    ;               shift and go to state 97
    IS              shift and go to state 505
    RENAMES         shift and go to state 95

    renames                        shift and go to state 94

state 343

    (327) param_s -> param .

    )               reduce using rule 327 (param_s -> param .)
    ;               reduce using rule 327 (param_s -> param .)


state 344

    (326) formal_part -> ( param_s . )
    (328) param_s -> param_s . ; param

    )               shift and go to state 506
    ;               shift and go to state 507


state 345

    (480) generic_formal -> WITH FUNCTION designator . formal_part_opt RETURN name subp_default ;
    (324) formal_part_opt -> .
    (325) formal_part_opt -> . formal_part
    (326) formal_part -> . ( param_s )

    RETURN          reduce using rule 324 (formal_part_opt -> .)
    (               shift and go to state 190

    formal_part                    shift and go to state 189
    formal_part_opt                shift and go to state 508

state 346

    (481) generic_formal -> WITH PACKAGE simple_name . IS NEW name ( LESSMORE ) ;
    (482) generic_formal -> WITH PACKAGE simple_name . IS NEW name ;

    IS              shift and go to state 509


state 347

    (479) generic_formal -> WITH PROCEDURE simple_name . formal_part_opt subp_default ;
    (324) formal_part_opt -> .
    (325) formal_part_opt -> . formal_part
    (326) formal_part -> . ( param_s )

    IS              reduce using rule 324 (formal_part_opt -> .)
    ;               reduce using rule 324 (formal_part_opt -> .)
    (               shift and go to state 190

    formal_part                    shift and go to state 189
    formal_part_opt                shift and go to state 510

state 348

    (362) rename_unit -> generic_formal_part subprog_spec renames ; .

    PACKAGE         reduce using rule 362 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    TASK            reduce using rule 362 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    PROTECTED       reduce using rule 362 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    error           reduce using rule 362 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    USE             reduce using rule 362 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    PRAGMA          reduce using rule 362 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    TYPE            reduce using rule 362 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    SUBTYPE         reduce using rule 362 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    FOR             reduce using rule 362 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    PROCEDURE       reduce using rule 362 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    FUNCTION        reduce using rule 362 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    GENERIC         reduce using rule 362 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    IDENTIFIER      reduce using rule 362 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    BEGIN           reduce using rule 362 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    END             reduce using rule 362 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    PRIVATE         reduce using rule 362 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    WITH            reduce using rule 362 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    SEPARATE        reduce using rule 362 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    $end            reduce using rule 362 (rename_unit -> generic_formal_part subprog_spec renames ; .)


state 349

    (335) mode -> ACCESS .

    IDENTIFIER      reduce using rule 335 (mode -> ACCESS .)


state 350

    (333) mode -> OUT .

    IDENTIFIER      reduce using rule 333 (mode -> OUT .)


state 351

    (332) mode -> IN .
    (334) mode -> IN . OUT

    IDENTIFIER      reduce using rule 332 (mode -> IN .)
    OUT             shift and go to state 511


state 352

    (329) param -> def_id_s : mode . mark init_opt
    (160) mark -> . simple_name
    (161) mark -> . mark TICK attribute_id
    (162) mark -> . mark . simple_name
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    mark                           shift and go to state 512
    simple_name                    shift and go to state 166

state 353

    (361) rename_unit -> generic_formal_part PACKAGE compound_name renames . ;

    ;               shift and go to state 513


state 354

    (341) pkg_spec -> PACKAGE compound_name IS . decl_item_s private_part END c_id_opt
    (139) decl_item_s -> .
    (140) decl_item_s -> . decl_item_s1
    (141) decl_item_s1 -> . decl_item
    (142) decl_item_s1 -> . decl_item_s1 decl_item
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (352) use_clause -> . USE name_s ;
    (353) use_clause -> . USE TYPE name_s ;
    (506) rep_spec -> . attrib_def
    (507) rep_spec -> . record_type_spec
    (508) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (316) subprog_decl -> . subprog_spec ;
    (317) subprog_decl -> . generic_subp_inst ;
    (318) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (339) pkg_decl -> . pkg_spec ;
    (340) pkg_decl -> . generic_pkg_inst ;
    (364) task_decl -> . task_spec ;
    (372) prot_decl -> . prot_spec ;
    (461) exception_decl -> . def_id_s : EXCEPTION ;
    (356) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (357) rename_decl -> . def_id_s : EXCEPTION renames ;
    (358) rename_decl -> . rename_unit
    (473) generic_decl -> . generic_formal_part subprog_spec ;
    (474) generic_decl -> . generic_formal_part pkg_spec ;
    (457) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (458) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (459) body_stub -> . subprog_spec IS SEPARATE ;
    (460) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (509) attrib_def -> . FOR mark USE expression ;
    (510) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (515) address_spec -> . FOR mark USE AT expression ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (319) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (320) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (321) subprog_spec -> . FUNCTION designator
    (503) generic_subp_inst -> . subprog_spec IS generic_inst
    (336) subprog_spec_is_push -> . subprog_spec IS
    (341) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (365) task_spec -> . TASK simple_name task_def
    (366) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (373) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (374) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (359) rename_unit -> . PACKAGE compound_name renames ;
    (360) rename_unit -> . subprog_spec renames ;
    (361) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (362) rename_unit -> . generic_formal_part subprog_spec renames ;
    (475) generic_formal_part -> . GENERIC
    (476) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    PRIVATE         reduce using rule 139 (decl_item_s -> .)
    END             reduce using rule 139 (decl_item_s -> .)
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    TASK            shift and go to state 339
    PACKAGE         shift and go to state 340
    PROTECTED       shift and go to state 336
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    task_decl                      shift and go to state 60
    subtype_decl                   shift and go to state 61
    rep_spec                       shift and go to state 82
    decl_item_s1                   shift and go to state 335
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 341
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 342
    def_id_s                       shift and go to state 88
    decl_item                      shift and go to state 337
    task_spec                      shift and go to state 65
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    generic_subp_inst              shift and go to state 29
    def_id                         shift and go to state 89
    rename_decl                    shift and go to state 90
    type_decl                      shift and go to state 56
    rename_unit                    shift and go to state 91
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    subprog_decl                   shift and go to state 58
    decl_item_s                    shift and go to state 338
    pragma                         shift and go to state 74
    pkg_spec                       shift and go to state 37
    number_decl                    shift and go to state 93

state 355

    (478) generic_formal -> TYPE simple_name generic_discrim_part_opt . IS generic_type_def ;

    IS              shift and go to state 514


state 356

    (486) generic_discrim_part_opt -> ( . LESSMORE )
    (112) discrim_part -> ( . discrim_spec_s )
    (113) discrim_spec_s -> . discrim_spec
    (114) discrim_spec_s -> . discrim_spec_s ; discrim_spec
    (115) discrim_spec -> . def_id_s : access_opt mark init_opt
    (116) discrim_spec -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    LESSMORE        shift and go to state 515
    error           shift and go to state 478
    IDENTIFIER      shift and go to state 76

    discrim_spec                   shift and go to state 481
    discrim_spec_s                 shift and go to state 479
    def_id                         shift and go to state 89
    def_id_s                       shift and go to state 480

state 357

    (485) generic_discrim_part_opt -> discrim_part .

    IS              reduce using rule 485 (generic_discrim_part_opt -> discrim_part .)


state 358

    (320) subprog_spec -> FUNCTION designator formal_part_opt RETURN . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 516
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    indexed_comp                   shift and go to state 129
    operator_symbol                shift and go to state 149
    simple_name                    shift and go to state 158

state 359

    (237) factor -> primary STARSTAR primary .

    *               reduce using rule 237 (factor -> primary STARSTAR primary .)
    /               reduce using rule 237 (factor -> primary STARSTAR primary .)
    MOD             reduce using rule 237 (factor -> primary STARSTAR primary .)
    REM             reduce using rule 237 (factor -> primary STARSTAR primary .)
    DOTDOT          reduce using rule 237 (factor -> primary STARSTAR primary .)
    =               reduce using rule 237 (factor -> primary STARSTAR primary .)
    NOTEQUAL        reduce using rule 237 (factor -> primary STARSTAR primary .)
    <               reduce using rule 237 (factor -> primary STARSTAR primary .)
    LESSEQ          reduce using rule 237 (factor -> primary STARSTAR primary .)
    >               reduce using rule 237 (factor -> primary STARSTAR primary .)
    GREATEREQ       reduce using rule 237 (factor -> primary STARSTAR primary .)
    IN              reduce using rule 237 (factor -> primary STARSTAR primary .)
    NOT             reduce using rule 237 (factor -> primary STARSTAR primary .)
    +               reduce using rule 237 (factor -> primary STARSTAR primary .)
    -               reduce using rule 237 (factor -> primary STARSTAR primary .)
    &               reduce using rule 237 (factor -> primary STARSTAR primary .)
    AND             reduce using rule 237 (factor -> primary STARSTAR primary .)
    OR              reduce using rule 237 (factor -> primary STARSTAR primary .)
    XOR             reduce using rule 237 (factor -> primary STARSTAR primary .)
    )               reduce using rule 237 (factor -> primary STARSTAR primary .)
    ,               reduce using rule 237 (factor -> primary STARSTAR primary .)
    ARROW           reduce using rule 237 (factor -> primary STARSTAR primary .)
    |               reduce using rule 237 (factor -> primary STARSTAR primary .)
    RANGE           reduce using rule 237 (factor -> primary STARSTAR primary .)
    ;               reduce using rule 237 (factor -> primary STARSTAR primary .)
    IS              reduce using rule 237 (factor -> primary STARSTAR primary .)
    WITH            reduce using rule 237 (factor -> primary STARSTAR primary .)
    THEN            reduce using rule 237 (factor -> primary STARSTAR primary .)
    LOOP            reduce using rule 237 (factor -> primary STARSTAR primary .)
    DIGITS          reduce using rule 237 (factor -> primary STARSTAR primary .)
    RENAMES         reduce using rule 237 (factor -> primary STARSTAR primary .)
    ASSIGNMENT      reduce using rule 237 (factor -> primary STARSTAR primary .)


state 360

    (222) simple_expression -> simple_expression adding term .
    (229) term -> term . multiplying factor
    (230) multiplying -> . *
    (231) multiplying -> . /
    (232) multiplying -> . MOD
    (233) multiplying -> . REM

    DOTDOT          reduce using rule 222 (simple_expression -> simple_expression adding term .)
    +               reduce using rule 222 (simple_expression -> simple_expression adding term .)
    -               reduce using rule 222 (simple_expression -> simple_expression adding term .)
    &               reduce using rule 222 (simple_expression -> simple_expression adding term .)
    =               reduce using rule 222 (simple_expression -> simple_expression adding term .)
    NOTEQUAL        reduce using rule 222 (simple_expression -> simple_expression adding term .)
    <               reduce using rule 222 (simple_expression -> simple_expression adding term .)
    LESSEQ          reduce using rule 222 (simple_expression -> simple_expression adding term .)
    >               reduce using rule 222 (simple_expression -> simple_expression adding term .)
    GREATEREQ       reduce using rule 222 (simple_expression -> simple_expression adding term .)
    IN              reduce using rule 222 (simple_expression -> simple_expression adding term .)
    NOT             reduce using rule 222 (simple_expression -> simple_expression adding term .)
    AND             reduce using rule 222 (simple_expression -> simple_expression adding term .)
    OR              reduce using rule 222 (simple_expression -> simple_expression adding term .)
    XOR             reduce using rule 222 (simple_expression -> simple_expression adding term .)
    ;               reduce using rule 222 (simple_expression -> simple_expression adding term .)
    IS              reduce using rule 222 (simple_expression -> simple_expression adding term .)
    RANGE           reduce using rule 222 (simple_expression -> simple_expression adding term .)
    )               reduce using rule 222 (simple_expression -> simple_expression adding term .)
    ,               reduce using rule 222 (simple_expression -> simple_expression adding term .)
    WITH            reduce using rule 222 (simple_expression -> simple_expression adding term .)
    ARROW           reduce using rule 222 (simple_expression -> simple_expression adding term .)
    |               reduce using rule 222 (simple_expression -> simple_expression adding term .)
    THEN            reduce using rule 222 (simple_expression -> simple_expression adding term .)
    LOOP            reduce using rule 222 (simple_expression -> simple_expression adding term .)
    DIGITS          reduce using rule 222 (simple_expression -> simple_expression adding term .)
    RENAMES         reduce using rule 222 (simple_expression -> simple_expression adding term .)
    ASSIGNMENT      reduce using rule 222 (simple_expression -> simple_expression adding term .)
    *               shift and go to state 242
    /               shift and go to state 243
    MOD             shift and go to state 244
    REM             shift and go to state 240

    multiplying                    shift and go to state 241

state 361

    (62) range -> simple_expression . DOTDOT simple_expression
    (222) simple_expression -> simple_expression . adding term
    (225) adding -> . +
    (226) adding -> . -
    (227) adding -> . &

    DOTDOT          shift and go to state 367
    +               shift and go to state 211
    -               shift and go to state 213
    &               shift and go to state 212

    adding                         shift and go to state 209

state 362

    (211) relation -> simple_expression membership name .
    (63) range -> name . TICK RANGE
    (64) range -> name . TICK RANGE ( expression )
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id
    (239) primary -> name .
    (245) qualified -> name . TICK parenthesized_primary

    AND             reduce using rule 211 (relation -> simple_expression membership name .)
    OR              reduce using rule 211 (relation -> simple_expression membership name .)
    XOR             reduce using rule 211 (relation -> simple_expression membership name .)
    )               reduce using rule 211 (relation -> simple_expression membership name .)
    ,               reduce using rule 211 (relation -> simple_expression membership name .)
    ARROW           reduce using rule 211 (relation -> simple_expression membership name .)
    |               reduce using rule 211 (relation -> simple_expression membership name .)
    ;               reduce using rule 211 (relation -> simple_expression membership name .)
    THEN            reduce using rule 211 (relation -> simple_expression membership name .)
    RANGE           reduce using rule 211 (relation -> simple_expression membership name .)
    RENAMES         reduce using rule 211 (relation -> simple_expression membership name .)
    ASSIGNMENT      reduce using rule 211 (relation -> simple_expression membership name .)
    WITH            reduce using rule 211 (relation -> simple_expression membership name .)
    IS              reduce using rule 211 (relation -> simple_expression membership name .)
    LOOP            reduce using rule 211 (relation -> simple_expression membership name .)
    DIGITS          reduce using rule 211 (relation -> simple_expression membership name .)
    TICK            shift and go to state 375
    (               shift and go to state 245
    .               shift and go to state 246
    STARSTAR        reduce using rule 239 (primary -> name .)
    *               reduce using rule 239 (primary -> name .)
    /               reduce using rule 239 (primary -> name .)
    MOD             reduce using rule 239 (primary -> name .)
    REM             reduce using rule 239 (primary -> name .)
    DOTDOT          reduce using rule 239 (primary -> name .)
    +               reduce using rule 239 (primary -> name .)
    -               reduce using rule 239 (primary -> name .)
    &               reduce using rule 239 (primary -> name .)


state 363

    (210) relation -> simple_expression membership range .

    AND             reduce using rule 210 (relation -> simple_expression membership range .)
    OR              reduce using rule 210 (relation -> simple_expression membership range .)
    XOR             reduce using rule 210 (relation -> simple_expression membership range .)
    )               reduce using rule 210 (relation -> simple_expression membership range .)
    ,               reduce using rule 210 (relation -> simple_expression membership range .)
    ARROW           reduce using rule 210 (relation -> simple_expression membership range .)
    |               reduce using rule 210 (relation -> simple_expression membership range .)
    ;               reduce using rule 210 (relation -> simple_expression membership range .)
    THEN            reduce using rule 210 (relation -> simple_expression membership range .)
    RANGE           reduce using rule 210 (relation -> simple_expression membership range .)
    RENAMES         reduce using rule 210 (relation -> simple_expression membership range .)
    ASSIGNMENT      reduce using rule 210 (relation -> simple_expression membership range .)
    WITH            reduce using rule 210 (relation -> simple_expression membership range .)
    IS              reduce using rule 210 (relation -> simple_expression membership range .)
    LOOP            reduce using rule 210 (relation -> simple_expression membership range .)
    DIGITS          reduce using rule 210 (relation -> simple_expression membership range .)


state 364

    (219) membership -> NOT IN .

    IDENTIFIER      reduce using rule 219 (membership -> NOT IN .)
    STRING          reduce using rule 219 (membership -> NOT IN .)
    +               reduce using rule 219 (membership -> NOT IN .)
    -               reduce using rule 219 (membership -> NOT IN .)
    NOT             reduce using rule 219 (membership -> NOT IN .)
    ABS             reduce using rule 219 (membership -> NOT IN .)
    INTEGER         reduce using rule 219 (membership -> NOT IN .)
    BASE_INTEGER    reduce using rule 219 (membership -> NOT IN .)
    FLOAT           reduce using rule 219 (membership -> NOT IN .)
    BASE_FLOAT      reduce using rule 219 (membership -> NOT IN .)
    NuLL            reduce using rule 219 (membership -> NOT IN .)
    NEW             reduce using rule 219 (membership -> NOT IN .)
    (               reduce using rule 219 (membership -> NOT IN .)
    CHAR            reduce using rule 219 (membership -> NOT IN .)


state 365

    (209) relation -> simple_expression relational simple_expression .
    (222) simple_expression -> simple_expression . adding term
    (225) adding -> . +
    (226) adding -> . -
    (227) adding -> . &

    AND             reduce using rule 209 (relation -> simple_expression relational simple_expression .)
    OR              reduce using rule 209 (relation -> simple_expression relational simple_expression .)
    XOR             reduce using rule 209 (relation -> simple_expression relational simple_expression .)
    )               reduce using rule 209 (relation -> simple_expression relational simple_expression .)
    ,               reduce using rule 209 (relation -> simple_expression relational simple_expression .)
    ARROW           reduce using rule 209 (relation -> simple_expression relational simple_expression .)
    |               reduce using rule 209 (relation -> simple_expression relational simple_expression .)
    ;               reduce using rule 209 (relation -> simple_expression relational simple_expression .)
    THEN            reduce using rule 209 (relation -> simple_expression relational simple_expression .)
    RANGE           reduce using rule 209 (relation -> simple_expression relational simple_expression .)
    RENAMES         reduce using rule 209 (relation -> simple_expression relational simple_expression .)
    ASSIGNMENT      reduce using rule 209 (relation -> simple_expression relational simple_expression .)
    WITH            reduce using rule 209 (relation -> simple_expression relational simple_expression .)
    IS              reduce using rule 209 (relation -> simple_expression relational simple_expression .)
    LOOP            reduce using rule 209 (relation -> simple_expression relational simple_expression .)
    DIGITS          reduce using rule 209 (relation -> simple_expression relational simple_expression .)
    +               shift and go to state 211
    -               shift and go to state 213
    &               shift and go to state 212

    adding                         shift and go to state 209

state 366

    (7) pragma_arg -> simple_name ARROW expression .
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE

    )               reduce using rule 7 (pragma_arg -> simple_name ARROW expression .)
    ,               reduce using rule 7 (pragma_arg -> simple_name ARROW expression .)
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250

    short_circuit                  shift and go to state 252
    logical                        shift and go to state 251

state 367

    (62) range -> simple_expression DOTDOT . simple_expression
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    simple_expression              shift and go to state 517
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149

state 368

    (124) choice_s -> choice_s | . choice
    (125) choice -> . expression
    (126) choice -> . discrete_with_range
    (127) choice -> . OTHERS
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (128) discrete_with_range -> . name range_constraint
    (129) discrete_with_range -> . range
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name TICK RANGE
    (64) range -> . name TICK RANGE ( expression )
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    OTHERS          shift and go to state 224
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 384
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    choice                         shift and go to state 518
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    discrete_with_range            shift and go to state 519
    term                           shift and go to state 146
    name                           shift and go to state 231
    operator_symbol                shift and go to state 149
    range                          shift and go to state 233
    expression                     shift and go to state 520

state 369

    (199) comp_assoc -> choice_s ARROW . expression
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 521

state 370

    (192) aggregate -> ( comp_assoc ) .

    STARSTAR        reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    *               reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    /               reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    MOD             reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    REM             reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    DOTDOT          reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    =               reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    NOTEQUAL        reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    <               reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    LESSEQ          reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    >               reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    GREATEREQ       reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    IN              reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    NOT             reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    +               reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    -               reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    &               reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    AND             reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    OR              reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    XOR             reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    )               reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    ,               reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    ARROW           reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    |               reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    ;               reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    WITH            reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    IS              reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    THEN            reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    LOOP            reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    RANGE           reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    DIGITS          reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    RENAMES         reduce using rule 192 (aggregate -> ( comp_assoc ) .)
    ASSIGNMENT      reduce using rule 192 (aggregate -> ( comp_assoc ) .)


state 371

    (193) aggregate -> ( value_s_2 ) .

    STARSTAR        reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    *               reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    /               reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    MOD             reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    REM             reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    DOTDOT          reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    =               reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    NOTEQUAL        reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    <               reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    LESSEQ          reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    >               reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    GREATEREQ       reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    IN              reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    NOT             reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    +               reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    -               reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    &               reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    AND             reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    OR              reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    XOR             reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    )               reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    ,               reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    ARROW           reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    |               reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    ;               reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    WITH            reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    IS              reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    THEN            reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    LOOP            reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    RANGE           reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    DIGITS          reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    RENAMES         reduce using rule 193 (aggregate -> ( value_s_2 ) .)
    ASSIGNMENT      reduce using rule 193 (aggregate -> ( value_s_2 ) .)


state 372

    (198) value_s_2 -> value_s_2 , . value
    (173) value -> . expression
    (174) value -> . comp_assoc
    (175) value -> . discrete_with_range
    (176) value -> . error
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (199) comp_assoc -> . choice_s ARROW expression
    (128) discrete_with_range -> . name range_constraint
    (129) discrete_with_range -> . range
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (123) choice_s -> . choice
    (124) choice_s -> . choice_s | choice
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name TICK RANGE
    (64) range -> . name TICK RANGE ( expression )
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (125) choice -> . expression
    (126) choice -> . discrete_with_range
    (127) choice -> . OTHERS
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 234
    OTHERS          shift and go to state 224
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 384
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    choice_s                       shift and go to state 226
    comp_assoc                     shift and go to state 385
    factor                         shift and go to state 137
    choice                         shift and go to state 228
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    discrete_with_range            shift and go to state 230
    term                           shift and go to state 146
    name                           shift and go to state 231
    operator_symbol                shift and go to state 149
    value                          shift and go to state 522
    range                          shift and go to state 233
    expression                     shift and go to state 387

state 373

    (61) range_constraint -> RANGE . range
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name TICK RANGE
    (64) range -> . name TICK RANGE ( expression )
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    simple_expression              shift and go to state 361
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 523
    operator_symbol                shift and go to state 149
    range                          shift and go to state 524

state 374

    (128) discrete_with_range -> name range_constraint .

    ARROW           reduce using rule 128 (discrete_with_range -> name range_constraint .)
    |               reduce using rule 128 (discrete_with_range -> name range_constraint .)
    )               reduce using rule 128 (discrete_with_range -> name range_constraint .)
    ,               reduce using rule 128 (discrete_with_range -> name range_constraint .)


state 375

    (63) range -> name TICK . RANGE
    (64) range -> name TICK . RANGE ( expression )
    (181) attribute -> name TICK . attribute_id
    (245) qualified -> name TICK . parenthesized_primary
    (182) attribute_id -> . IDENTIFIER
    (183) attribute_id -> . DIGITS
    (184) attribute_id -> . DELTA
    (185) attribute_id -> . ACCESS
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    RANGE           shift and go to state 525
    IDENTIFIER      shift and go to state 393
    DIGITS          shift and go to state 392
    DELTA           shift and go to state 396
    ACCESS          shift and go to state 394
    (               shift and go to state 132

    attribute_id                   shift and go to state 395
    aggregate                      shift and go to state 143
    parenthesized_primary          shift and go to state 397

state 376

    (197) value_s_2 -> value , . value
    (173) value -> . expression
    (174) value -> . comp_assoc
    (175) value -> . discrete_with_range
    (176) value -> . error
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (199) comp_assoc -> . choice_s ARROW expression
    (128) discrete_with_range -> . name range_constraint
    (129) discrete_with_range -> . range
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (123) choice_s -> . choice
    (124) choice_s -> . choice_s | choice
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name TICK RANGE
    (64) range -> . name TICK RANGE ( expression )
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (125) choice -> . expression
    (126) choice -> . discrete_with_range
    (127) choice -> . OTHERS
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 234
    OTHERS          shift and go to state 224
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 384
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    choice_s                       shift and go to state 226
    comp_assoc                     shift and go to state 385
    factor                         shift and go to state 137
    choice                         shift and go to state 228
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    discrete_with_range            shift and go to state 230
    term                           shift and go to state 146
    name                           shift and go to state 231
    operator_symbol                shift and go to state 149
    value                          shift and go to state 526
    range                          shift and go to state 233
    expression                     shift and go to state 387

state 377

    (196) aggregate -> ( NuLL RECORD . )

    )               shift and go to state 527


state 378

    (244) parenthesized_primary -> ( expression ) .

    STARSTAR        reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    *               reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    /               reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    MOD             reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    REM             reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    =               reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    NOTEQUAL        reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    <               reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    LESSEQ          reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    >               reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    GREATEREQ       reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    IN              reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    NOT             reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    +               reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    -               reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    &               reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    AND             reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    OR              reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    XOR             reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    RANGE           reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    ;               reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    THEN            reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    )               reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    ,               reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    DOTDOT          reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    WITH            reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    ARROW           reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    |               reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    IS              reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    LOOP            reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    DIGITS          reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    RENAMES         reduce using rule 244 (parenthesized_primary -> ( expression ) .)
    ASSIGNMENT      reduce using rule 244 (parenthesized_primary -> ( expression ) .)


state 379

    (194) aggregate -> ( expression WITH . value_s )
    (195) aggregate -> ( expression WITH . NuLL RECORD )
    (171) value_s -> . value
    (172) value_s -> . value_s , value
    (173) value -> . expression
    (174) value -> . comp_assoc
    (175) value -> . discrete_with_range
    (176) value -> . error
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (199) comp_assoc -> . choice_s ARROW expression
    (128) discrete_with_range -> . name range_constraint
    (129) discrete_with_range -> . range
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (123) choice_s -> . choice
    (124) choice_s -> . choice_s | choice
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name TICK RANGE
    (64) range -> . name TICK RANGE ( expression )
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (125) choice -> . expression
    (126) choice -> . discrete_with_range
    (127) choice -> . OTHERS
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    NuLL            shift and go to state 529
    error           shift and go to state 234
    OTHERS          shift and go to state 224
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    value_s                        shift and go to state 528
    simple_expression              shift and go to state 384
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    choice_s                       shift and go to state 226
    comp_assoc                     shift and go to state 385
    factor                         shift and go to state 137
    choice                         shift and go to state 228
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    discrete_with_range            shift and go to state 230
    term                           shift and go to state 146
    name                           shift and go to state 231
    operator_symbol                shift and go to state 149
    value                          shift and go to state 386
    range                          shift and go to state 233
    expression                     shift and go to state 387

state 380

    (3) pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .

    LESSLESS        reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    error           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    PRAGMA          reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    NuLL            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    EXIT            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    RETURN          reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    GOTO            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    DELAY           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    ABORT           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    RAISE           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    REQUEUE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    IF              reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    CASE            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    IDENTIFIER      reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    ACCEPT          reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    SELECT          reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    STRING          reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    WHILE           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    DECLARE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    FOR             reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    LOOP            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    BEGIN           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    END             reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    PACKAGE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    TASK            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    PROTECTED       reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    USE             reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    TYPE            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    SUBTYPE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    PROCEDURE       reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    FUNCTION        reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    GENERIC         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    WHEN            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    ENTRY           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    PRIVATE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    OR              reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    ELSE            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    THEN            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    WITH            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    SEPARATE        reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    $end            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    EXCEPTION       reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    ELSIF           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)


state 381

    (5) pragma_arg_s -> pragma_arg_s , pragma_arg .

    )               reduce using rule 5 (pragma_arg_s -> pragma_arg_s , pragma_arg .)
    ,               reduce using rule 5 (pragma_arg_s -> pragma_arg_s , pragma_arg .)


state 382

    (229) term -> term multiplying factor .

    *               reduce using rule 229 (term -> term multiplying factor .)
    /               reduce using rule 229 (term -> term multiplying factor .)
    MOD             reduce using rule 229 (term -> term multiplying factor .)
    REM             reduce using rule 229 (term -> term multiplying factor .)
    DOTDOT          reduce using rule 229 (term -> term multiplying factor .)
    +               reduce using rule 229 (term -> term multiplying factor .)
    -               reduce using rule 229 (term -> term multiplying factor .)
    &               reduce using rule 229 (term -> term multiplying factor .)
    =               reduce using rule 229 (term -> term multiplying factor .)
    NOTEQUAL        reduce using rule 229 (term -> term multiplying factor .)
    <               reduce using rule 229 (term -> term multiplying factor .)
    LESSEQ          reduce using rule 229 (term -> term multiplying factor .)
    >               reduce using rule 229 (term -> term multiplying factor .)
    GREATEREQ       reduce using rule 229 (term -> term multiplying factor .)
    IN              reduce using rule 229 (term -> term multiplying factor .)
    NOT             reduce using rule 229 (term -> term multiplying factor .)
    AND             reduce using rule 229 (term -> term multiplying factor .)
    OR              reduce using rule 229 (term -> term multiplying factor .)
    XOR             reduce using rule 229 (term -> term multiplying factor .)
    )               reduce using rule 229 (term -> term multiplying factor .)
    ,               reduce using rule 229 (term -> term multiplying factor .)
    ARROW           reduce using rule 229 (term -> term multiplying factor .)
    |               reduce using rule 229 (term -> term multiplying factor .)
    RANGE           reduce using rule 229 (term -> term multiplying factor .)
    ;               reduce using rule 229 (term -> term multiplying factor .)
    THEN            reduce using rule 229 (term -> term multiplying factor .)
    WITH            reduce using rule 229 (term -> term multiplying factor .)
    IS              reduce using rule 229 (term -> term multiplying factor .)
    LOOP            reduce using rule 229 (term -> term multiplying factor .)
    DIGITS          reduce using rule 229 (term -> term multiplying factor .)
    RENAMES         reduce using rule 229 (term -> term multiplying factor .)
    ASSIGNMENT      reduce using rule 229 (term -> term multiplying factor .)


state 383

    (170) indexed_comp -> name ( value_s . )
    (172) value_s -> value_s . , value

    )               shift and go to state 530
    ,               shift and go to state 531


state 384

    (208) relation -> simple_expression .
    (209) relation -> simple_expression . relational simple_expression
    (210) relation -> simple_expression . membership range
    (211) relation -> simple_expression . membership name
    (62) range -> simple_expression . DOTDOT simple_expression
    (222) simple_expression -> simple_expression . adding term
    (212) relational -> . =
    (213) relational -> . NOTEQUAL
    (214) relational -> . <
    (215) relational -> . LESSEQ
    (216) relational -> . >
    (217) relational -> . GREATEREQ
    (218) membership -> . IN
    (219) membership -> . NOT IN
    (225) adding -> . +
    (226) adding -> . -
    (227) adding -> . &

    AND             reduce using rule 208 (relation -> simple_expression .)
    OR              reduce using rule 208 (relation -> simple_expression .)
    XOR             reduce using rule 208 (relation -> simple_expression .)
    ARROW           reduce using rule 208 (relation -> simple_expression .)
    |               reduce using rule 208 (relation -> simple_expression .)
    )               reduce using rule 208 (relation -> simple_expression .)
    ,               reduce using rule 208 (relation -> simple_expression .)
    DOTDOT          shift and go to state 367
    =               shift and go to state 220
    NOTEQUAL        shift and go to state 210
    <               shift and go to state 221
    LESSEQ          shift and go to state 216
    >               shift and go to state 222
    GREATEREQ       shift and go to state 215
    IN              shift and go to state 217
    NOT             shift and go to state 218
    +               shift and go to state 211
    -               shift and go to state 213
    &               shift and go to state 212

    adding                         shift and go to state 209
    membership                     shift and go to state 214
    relational                     shift and go to state 219

state 385

    (174) value -> comp_assoc .

    )               reduce using rule 174 (value -> comp_assoc .)
    ,               reduce using rule 174 (value -> comp_assoc .)


state 386

    (171) value_s -> value .

    )               reduce using rule 171 (value_s -> value .)
    ,               reduce using rule 171 (value_s -> value .)


state 387

    (173) value -> expression .
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (125) choice -> expression .
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE

    )               reduce using rule 173 (value -> expression .)
    ,               reduce using rule 173 (value -> expression .)
    ARROW           reduce using rule 125 (choice -> expression .)
    |               reduce using rule 125 (choice -> expression .)
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250

    logical                        shift and go to state 251
    short_circuit                  shift and go to state 252

state 388

    (180) selected_comp -> name . ALL .

    TICK            reduce using rule 180 (selected_comp -> name . ALL .)
    (               reduce using rule 180 (selected_comp -> name . ALL .)
    .               reduce using rule 180 (selected_comp -> name . ALL .)
    STARSTAR        reduce using rule 180 (selected_comp -> name . ALL .)
    *               reduce using rule 180 (selected_comp -> name . ALL .)
    /               reduce using rule 180 (selected_comp -> name . ALL .)
    MOD             reduce using rule 180 (selected_comp -> name . ALL .)
    REM             reduce using rule 180 (selected_comp -> name . ALL .)
    =               reduce using rule 180 (selected_comp -> name . ALL .)
    NOTEQUAL        reduce using rule 180 (selected_comp -> name . ALL .)
    <               reduce using rule 180 (selected_comp -> name . ALL .)
    LESSEQ          reduce using rule 180 (selected_comp -> name . ALL .)
    >               reduce using rule 180 (selected_comp -> name . ALL .)
    GREATEREQ       reduce using rule 180 (selected_comp -> name . ALL .)
    IN              reduce using rule 180 (selected_comp -> name . ALL .)
    NOT             reduce using rule 180 (selected_comp -> name . ALL .)
    +               reduce using rule 180 (selected_comp -> name . ALL .)
    -               reduce using rule 180 (selected_comp -> name . ALL .)
    &               reduce using rule 180 (selected_comp -> name . ALL .)
    AND             reduce using rule 180 (selected_comp -> name . ALL .)
    OR              reduce using rule 180 (selected_comp -> name . ALL .)
    XOR             reduce using rule 180 (selected_comp -> name . ALL .)
    THEN            reduce using rule 180 (selected_comp -> name . ALL .)
    )               reduce using rule 180 (selected_comp -> name . ALL .)
    ,               reduce using rule 180 (selected_comp -> name . ALL .)
    DOTDOT          reduce using rule 180 (selected_comp -> name . ALL .)
    WITH            reduce using rule 180 (selected_comp -> name . ALL .)
    ARROW           reduce using rule 180 (selected_comp -> name . ALL .)
    |               reduce using rule 180 (selected_comp -> name . ALL .)
    ;               reduce using rule 180 (selected_comp -> name . ALL .)
    IS              reduce using rule 180 (selected_comp -> name . ALL .)
    LOOP            reduce using rule 180 (selected_comp -> name . ALL .)
    RANGE           reduce using rule 180 (selected_comp -> name . ALL .)
    DIGITS          reduce using rule 180 (selected_comp -> name . ALL .)
    RENAMES         reduce using rule 180 (selected_comp -> name . ALL .)
    ASSIGNMENT      reduce using rule 180 (selected_comp -> name . ALL .)
    WHEN            reduce using rule 180 (selected_comp -> name . ALL .)


state 389

    (179) selected_comp -> name . operator_symbol .

    TICK            reduce using rule 179 (selected_comp -> name . operator_symbol .)
    (               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    .               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    STARSTAR        reduce using rule 179 (selected_comp -> name . operator_symbol .)
    *               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    /               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    MOD             reduce using rule 179 (selected_comp -> name . operator_symbol .)
    REM             reduce using rule 179 (selected_comp -> name . operator_symbol .)
    =               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    NOTEQUAL        reduce using rule 179 (selected_comp -> name . operator_symbol .)
    <               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    LESSEQ          reduce using rule 179 (selected_comp -> name . operator_symbol .)
    >               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    GREATEREQ       reduce using rule 179 (selected_comp -> name . operator_symbol .)
    IN              reduce using rule 179 (selected_comp -> name . operator_symbol .)
    NOT             reduce using rule 179 (selected_comp -> name . operator_symbol .)
    +               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    -               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    &               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    AND             reduce using rule 179 (selected_comp -> name . operator_symbol .)
    OR              reduce using rule 179 (selected_comp -> name . operator_symbol .)
    XOR             reduce using rule 179 (selected_comp -> name . operator_symbol .)
    THEN            reduce using rule 179 (selected_comp -> name . operator_symbol .)
    )               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    ,               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    DOTDOT          reduce using rule 179 (selected_comp -> name . operator_symbol .)
    WITH            reduce using rule 179 (selected_comp -> name . operator_symbol .)
    ARROW           reduce using rule 179 (selected_comp -> name . operator_symbol .)
    |               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    ;               reduce using rule 179 (selected_comp -> name . operator_symbol .)
    IS              reduce using rule 179 (selected_comp -> name . operator_symbol .)
    LOOP            reduce using rule 179 (selected_comp -> name . operator_symbol .)
    RANGE           reduce using rule 179 (selected_comp -> name . operator_symbol .)
    DIGITS          reduce using rule 179 (selected_comp -> name . operator_symbol .)
    RENAMES         reduce using rule 179 (selected_comp -> name . operator_symbol .)
    ASSIGNMENT      reduce using rule 179 (selected_comp -> name . operator_symbol .)
    WHEN            reduce using rule 179 (selected_comp -> name . operator_symbol .)


state 390

    (178) selected_comp -> name . used_char .

    TICK            reduce using rule 178 (selected_comp -> name . used_char .)
    (               reduce using rule 178 (selected_comp -> name . used_char .)
    .               reduce using rule 178 (selected_comp -> name . used_char .)
    STARSTAR        reduce using rule 178 (selected_comp -> name . used_char .)
    *               reduce using rule 178 (selected_comp -> name . used_char .)
    /               reduce using rule 178 (selected_comp -> name . used_char .)
    MOD             reduce using rule 178 (selected_comp -> name . used_char .)
    REM             reduce using rule 178 (selected_comp -> name . used_char .)
    =               reduce using rule 178 (selected_comp -> name . used_char .)
    NOTEQUAL        reduce using rule 178 (selected_comp -> name . used_char .)
    <               reduce using rule 178 (selected_comp -> name . used_char .)
    LESSEQ          reduce using rule 178 (selected_comp -> name . used_char .)
    >               reduce using rule 178 (selected_comp -> name . used_char .)
    GREATEREQ       reduce using rule 178 (selected_comp -> name . used_char .)
    IN              reduce using rule 178 (selected_comp -> name . used_char .)
    NOT             reduce using rule 178 (selected_comp -> name . used_char .)
    +               reduce using rule 178 (selected_comp -> name . used_char .)
    -               reduce using rule 178 (selected_comp -> name . used_char .)
    &               reduce using rule 178 (selected_comp -> name . used_char .)
    AND             reduce using rule 178 (selected_comp -> name . used_char .)
    OR              reduce using rule 178 (selected_comp -> name . used_char .)
    XOR             reduce using rule 178 (selected_comp -> name . used_char .)
    THEN            reduce using rule 178 (selected_comp -> name . used_char .)
    )               reduce using rule 178 (selected_comp -> name . used_char .)
    ,               reduce using rule 178 (selected_comp -> name . used_char .)
    DOTDOT          reduce using rule 178 (selected_comp -> name . used_char .)
    WITH            reduce using rule 178 (selected_comp -> name . used_char .)
    ARROW           reduce using rule 178 (selected_comp -> name . used_char .)
    |               reduce using rule 178 (selected_comp -> name . used_char .)
    ;               reduce using rule 178 (selected_comp -> name . used_char .)
    IS              reduce using rule 178 (selected_comp -> name . used_char .)
    LOOP            reduce using rule 178 (selected_comp -> name . used_char .)
    RANGE           reduce using rule 178 (selected_comp -> name . used_char .)
    DIGITS          reduce using rule 178 (selected_comp -> name . used_char .)
    RENAMES         reduce using rule 178 (selected_comp -> name . used_char .)
    ASSIGNMENT      reduce using rule 178 (selected_comp -> name . used_char .)
    WHEN            reduce using rule 178 (selected_comp -> name . used_char .)


state 391

    (177) selected_comp -> name . simple_name .

    TICK            reduce using rule 177 (selected_comp -> name . simple_name .)
    (               reduce using rule 177 (selected_comp -> name . simple_name .)
    .               reduce using rule 177 (selected_comp -> name . simple_name .)
    STARSTAR        reduce using rule 177 (selected_comp -> name . simple_name .)
    *               reduce using rule 177 (selected_comp -> name . simple_name .)
    /               reduce using rule 177 (selected_comp -> name . simple_name .)
    MOD             reduce using rule 177 (selected_comp -> name . simple_name .)
    REM             reduce using rule 177 (selected_comp -> name . simple_name .)
    =               reduce using rule 177 (selected_comp -> name . simple_name .)
    NOTEQUAL        reduce using rule 177 (selected_comp -> name . simple_name .)
    <               reduce using rule 177 (selected_comp -> name . simple_name .)
    LESSEQ          reduce using rule 177 (selected_comp -> name . simple_name .)
    >               reduce using rule 177 (selected_comp -> name . simple_name .)
    GREATEREQ       reduce using rule 177 (selected_comp -> name . simple_name .)
    IN              reduce using rule 177 (selected_comp -> name . simple_name .)
    NOT             reduce using rule 177 (selected_comp -> name . simple_name .)
    +               reduce using rule 177 (selected_comp -> name . simple_name .)
    -               reduce using rule 177 (selected_comp -> name . simple_name .)
    &               reduce using rule 177 (selected_comp -> name . simple_name .)
    AND             reduce using rule 177 (selected_comp -> name . simple_name .)
    OR              reduce using rule 177 (selected_comp -> name . simple_name .)
    XOR             reduce using rule 177 (selected_comp -> name . simple_name .)
    THEN            reduce using rule 177 (selected_comp -> name . simple_name .)
    )               reduce using rule 177 (selected_comp -> name . simple_name .)
    ,               reduce using rule 177 (selected_comp -> name . simple_name .)
    DOTDOT          reduce using rule 177 (selected_comp -> name . simple_name .)
    WITH            reduce using rule 177 (selected_comp -> name . simple_name .)
    ARROW           reduce using rule 177 (selected_comp -> name . simple_name .)
    |               reduce using rule 177 (selected_comp -> name . simple_name .)
    ;               reduce using rule 177 (selected_comp -> name . simple_name .)
    IS              reduce using rule 177 (selected_comp -> name . simple_name .)
    LOOP            reduce using rule 177 (selected_comp -> name . simple_name .)
    RANGE           reduce using rule 177 (selected_comp -> name . simple_name .)
    DIGITS          reduce using rule 177 (selected_comp -> name . simple_name .)
    RENAMES         reduce using rule 177 (selected_comp -> name . simple_name .)
    ASSIGNMENT      reduce using rule 177 (selected_comp -> name . simple_name .)
    WHEN            reduce using rule 177 (selected_comp -> name . simple_name .)


state 392

    (183) attribute_id -> DIGITS .

    (               reduce using rule 183 (attribute_id -> DIGITS .)
    .               reduce using rule 183 (attribute_id -> DIGITS .)
    TICK            reduce using rule 183 (attribute_id -> DIGITS .)
    ;               reduce using rule 183 (attribute_id -> DIGITS .)
    ,               reduce using rule 183 (attribute_id -> DIGITS .)
    WITH            reduce using rule 183 (attribute_id -> DIGITS .)
    WHEN            reduce using rule 183 (attribute_id -> DIGITS .)
    RANGE           reduce using rule 183 (attribute_id -> DIGITS .)
    DIGITS          reduce using rule 183 (attribute_id -> DIGITS .)
    RENAMES         reduce using rule 183 (attribute_id -> DIGITS .)
    ASSIGNMENT      reduce using rule 183 (attribute_id -> DIGITS .)
    IS              reduce using rule 183 (attribute_id -> DIGITS .)
    ARROW           reduce using rule 183 (attribute_id -> DIGITS .)
    |               reduce using rule 183 (attribute_id -> DIGITS .)
    STARSTAR        reduce using rule 183 (attribute_id -> DIGITS .)
    *               reduce using rule 183 (attribute_id -> DIGITS .)
    /               reduce using rule 183 (attribute_id -> DIGITS .)
    MOD             reduce using rule 183 (attribute_id -> DIGITS .)
    REM             reduce using rule 183 (attribute_id -> DIGITS .)
    =               reduce using rule 183 (attribute_id -> DIGITS .)
    NOTEQUAL        reduce using rule 183 (attribute_id -> DIGITS .)
    <               reduce using rule 183 (attribute_id -> DIGITS .)
    LESSEQ          reduce using rule 183 (attribute_id -> DIGITS .)
    >               reduce using rule 183 (attribute_id -> DIGITS .)
    GREATEREQ       reduce using rule 183 (attribute_id -> DIGITS .)
    IN              reduce using rule 183 (attribute_id -> DIGITS .)
    NOT             reduce using rule 183 (attribute_id -> DIGITS .)
    +               reduce using rule 183 (attribute_id -> DIGITS .)
    -               reduce using rule 183 (attribute_id -> DIGITS .)
    &               reduce using rule 183 (attribute_id -> DIGITS .)
    AND             reduce using rule 183 (attribute_id -> DIGITS .)
    OR              reduce using rule 183 (attribute_id -> DIGITS .)
    XOR             reduce using rule 183 (attribute_id -> DIGITS .)
    )               reduce using rule 183 (attribute_id -> DIGITS .)
    DOTDOT          reduce using rule 183 (attribute_id -> DIGITS .)
    THEN            reduce using rule 183 (attribute_id -> DIGITS .)
    LOOP            reduce using rule 183 (attribute_id -> DIGITS .)
    USE             reduce using rule 183 (attribute_id -> DIGITS .)
    AT              reduce using rule 183 (attribute_id -> DIGITS .)


state 393

    (182) attribute_id -> IDENTIFIER .

    (               reduce using rule 182 (attribute_id -> IDENTIFIER .)
    .               reduce using rule 182 (attribute_id -> IDENTIFIER .)
    TICK            reduce using rule 182 (attribute_id -> IDENTIFIER .)
    ;               reduce using rule 182 (attribute_id -> IDENTIFIER .)
    ,               reduce using rule 182 (attribute_id -> IDENTIFIER .)
    WITH            reduce using rule 182 (attribute_id -> IDENTIFIER .)
    WHEN            reduce using rule 182 (attribute_id -> IDENTIFIER .)
    RANGE           reduce using rule 182 (attribute_id -> IDENTIFIER .)
    DIGITS          reduce using rule 182 (attribute_id -> IDENTIFIER .)
    RENAMES         reduce using rule 182 (attribute_id -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 182 (attribute_id -> IDENTIFIER .)
    IS              reduce using rule 182 (attribute_id -> IDENTIFIER .)
    ARROW           reduce using rule 182 (attribute_id -> IDENTIFIER .)
    |               reduce using rule 182 (attribute_id -> IDENTIFIER .)
    STARSTAR        reduce using rule 182 (attribute_id -> IDENTIFIER .)
    *               reduce using rule 182 (attribute_id -> IDENTIFIER .)
    /               reduce using rule 182 (attribute_id -> IDENTIFIER .)
    MOD             reduce using rule 182 (attribute_id -> IDENTIFIER .)
    REM             reduce using rule 182 (attribute_id -> IDENTIFIER .)
    =               reduce using rule 182 (attribute_id -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 182 (attribute_id -> IDENTIFIER .)
    <               reduce using rule 182 (attribute_id -> IDENTIFIER .)
    LESSEQ          reduce using rule 182 (attribute_id -> IDENTIFIER .)
    >               reduce using rule 182 (attribute_id -> IDENTIFIER .)
    GREATEREQ       reduce using rule 182 (attribute_id -> IDENTIFIER .)
    IN              reduce using rule 182 (attribute_id -> IDENTIFIER .)
    NOT             reduce using rule 182 (attribute_id -> IDENTIFIER .)
    +               reduce using rule 182 (attribute_id -> IDENTIFIER .)
    -               reduce using rule 182 (attribute_id -> IDENTIFIER .)
    &               reduce using rule 182 (attribute_id -> IDENTIFIER .)
    AND             reduce using rule 182 (attribute_id -> IDENTIFIER .)
    OR              reduce using rule 182 (attribute_id -> IDENTIFIER .)
    XOR             reduce using rule 182 (attribute_id -> IDENTIFIER .)
    )               reduce using rule 182 (attribute_id -> IDENTIFIER .)
    DOTDOT          reduce using rule 182 (attribute_id -> IDENTIFIER .)
    THEN            reduce using rule 182 (attribute_id -> IDENTIFIER .)
    LOOP            reduce using rule 182 (attribute_id -> IDENTIFIER .)
    USE             reduce using rule 182 (attribute_id -> IDENTIFIER .)
    AT              reduce using rule 182 (attribute_id -> IDENTIFIER .)


state 394

    (185) attribute_id -> ACCESS .

    (               reduce using rule 185 (attribute_id -> ACCESS .)
    .               reduce using rule 185 (attribute_id -> ACCESS .)
    TICK            reduce using rule 185 (attribute_id -> ACCESS .)
    ;               reduce using rule 185 (attribute_id -> ACCESS .)
    ,               reduce using rule 185 (attribute_id -> ACCESS .)
    WITH            reduce using rule 185 (attribute_id -> ACCESS .)
    WHEN            reduce using rule 185 (attribute_id -> ACCESS .)
    RANGE           reduce using rule 185 (attribute_id -> ACCESS .)
    DIGITS          reduce using rule 185 (attribute_id -> ACCESS .)
    RENAMES         reduce using rule 185 (attribute_id -> ACCESS .)
    ASSIGNMENT      reduce using rule 185 (attribute_id -> ACCESS .)
    IS              reduce using rule 185 (attribute_id -> ACCESS .)
    ARROW           reduce using rule 185 (attribute_id -> ACCESS .)
    |               reduce using rule 185 (attribute_id -> ACCESS .)
    STARSTAR        reduce using rule 185 (attribute_id -> ACCESS .)
    *               reduce using rule 185 (attribute_id -> ACCESS .)
    /               reduce using rule 185 (attribute_id -> ACCESS .)
    MOD             reduce using rule 185 (attribute_id -> ACCESS .)
    REM             reduce using rule 185 (attribute_id -> ACCESS .)
    =               reduce using rule 185 (attribute_id -> ACCESS .)
    NOTEQUAL        reduce using rule 185 (attribute_id -> ACCESS .)
    <               reduce using rule 185 (attribute_id -> ACCESS .)
    LESSEQ          reduce using rule 185 (attribute_id -> ACCESS .)
    >               reduce using rule 185 (attribute_id -> ACCESS .)
    GREATEREQ       reduce using rule 185 (attribute_id -> ACCESS .)
    IN              reduce using rule 185 (attribute_id -> ACCESS .)
    NOT             reduce using rule 185 (attribute_id -> ACCESS .)
    +               reduce using rule 185 (attribute_id -> ACCESS .)
    -               reduce using rule 185 (attribute_id -> ACCESS .)
    &               reduce using rule 185 (attribute_id -> ACCESS .)
    AND             reduce using rule 185 (attribute_id -> ACCESS .)
    OR              reduce using rule 185 (attribute_id -> ACCESS .)
    XOR             reduce using rule 185 (attribute_id -> ACCESS .)
    )               reduce using rule 185 (attribute_id -> ACCESS .)
    DOTDOT          reduce using rule 185 (attribute_id -> ACCESS .)
    THEN            reduce using rule 185 (attribute_id -> ACCESS .)
    LOOP            reduce using rule 185 (attribute_id -> ACCESS .)
    USE             reduce using rule 185 (attribute_id -> ACCESS .)
    AT              reduce using rule 185 (attribute_id -> ACCESS .)


state 395

    (181) attribute -> name TICK attribute_id .

    TICK            reduce using rule 181 (attribute -> name TICK attribute_id .)
    (               reduce using rule 181 (attribute -> name TICK attribute_id .)
    .               reduce using rule 181 (attribute -> name TICK attribute_id .)
    RANGE           reduce using rule 181 (attribute -> name TICK attribute_id .)
    STARSTAR        reduce using rule 181 (attribute -> name TICK attribute_id .)
    *               reduce using rule 181 (attribute -> name TICK attribute_id .)
    /               reduce using rule 181 (attribute -> name TICK attribute_id .)
    MOD             reduce using rule 181 (attribute -> name TICK attribute_id .)
    REM             reduce using rule 181 (attribute -> name TICK attribute_id .)
    DOTDOT          reduce using rule 181 (attribute -> name TICK attribute_id .)
    =               reduce using rule 181 (attribute -> name TICK attribute_id .)
    NOTEQUAL        reduce using rule 181 (attribute -> name TICK attribute_id .)
    <               reduce using rule 181 (attribute -> name TICK attribute_id .)
    LESSEQ          reduce using rule 181 (attribute -> name TICK attribute_id .)
    >               reduce using rule 181 (attribute -> name TICK attribute_id .)
    GREATEREQ       reduce using rule 181 (attribute -> name TICK attribute_id .)
    IN              reduce using rule 181 (attribute -> name TICK attribute_id .)
    NOT             reduce using rule 181 (attribute -> name TICK attribute_id .)
    +               reduce using rule 181 (attribute -> name TICK attribute_id .)
    -               reduce using rule 181 (attribute -> name TICK attribute_id .)
    &               reduce using rule 181 (attribute -> name TICK attribute_id .)
    AND             reduce using rule 181 (attribute -> name TICK attribute_id .)
    OR              reduce using rule 181 (attribute -> name TICK attribute_id .)
    XOR             reduce using rule 181 (attribute -> name TICK attribute_id .)
    )               reduce using rule 181 (attribute -> name TICK attribute_id .)
    ,               reduce using rule 181 (attribute -> name TICK attribute_id .)
    ARROW           reduce using rule 181 (attribute -> name TICK attribute_id .)
    |               reduce using rule 181 (attribute -> name TICK attribute_id .)
    ;               reduce using rule 181 (attribute -> name TICK attribute_id .)
    WITH            reduce using rule 181 (attribute -> name TICK attribute_id .)
    DIGITS          reduce using rule 181 (attribute -> name TICK attribute_id .)
    IS              reduce using rule 181 (attribute -> name TICK attribute_id .)
    THEN            reduce using rule 181 (attribute -> name TICK attribute_id .)
    LOOP            reduce using rule 181 (attribute -> name TICK attribute_id .)
    RENAMES         reduce using rule 181 (attribute -> name TICK attribute_id .)
    ASSIGNMENT      reduce using rule 181 (attribute -> name TICK attribute_id .)
    WHEN            reduce using rule 181 (attribute -> name TICK attribute_id .)


state 396

    (184) attribute_id -> DELTA .

    (               reduce using rule 184 (attribute_id -> DELTA .)
    .               reduce using rule 184 (attribute_id -> DELTA .)
    TICK            reduce using rule 184 (attribute_id -> DELTA .)
    ;               reduce using rule 184 (attribute_id -> DELTA .)
    ,               reduce using rule 184 (attribute_id -> DELTA .)
    WITH            reduce using rule 184 (attribute_id -> DELTA .)
    WHEN            reduce using rule 184 (attribute_id -> DELTA .)
    RANGE           reduce using rule 184 (attribute_id -> DELTA .)
    DIGITS          reduce using rule 184 (attribute_id -> DELTA .)
    RENAMES         reduce using rule 184 (attribute_id -> DELTA .)
    ASSIGNMENT      reduce using rule 184 (attribute_id -> DELTA .)
    IS              reduce using rule 184 (attribute_id -> DELTA .)
    ARROW           reduce using rule 184 (attribute_id -> DELTA .)
    |               reduce using rule 184 (attribute_id -> DELTA .)
    STARSTAR        reduce using rule 184 (attribute_id -> DELTA .)
    *               reduce using rule 184 (attribute_id -> DELTA .)
    /               reduce using rule 184 (attribute_id -> DELTA .)
    MOD             reduce using rule 184 (attribute_id -> DELTA .)
    REM             reduce using rule 184 (attribute_id -> DELTA .)
    =               reduce using rule 184 (attribute_id -> DELTA .)
    NOTEQUAL        reduce using rule 184 (attribute_id -> DELTA .)
    <               reduce using rule 184 (attribute_id -> DELTA .)
    LESSEQ          reduce using rule 184 (attribute_id -> DELTA .)
    >               reduce using rule 184 (attribute_id -> DELTA .)
    GREATEREQ       reduce using rule 184 (attribute_id -> DELTA .)
    IN              reduce using rule 184 (attribute_id -> DELTA .)
    NOT             reduce using rule 184 (attribute_id -> DELTA .)
    +               reduce using rule 184 (attribute_id -> DELTA .)
    -               reduce using rule 184 (attribute_id -> DELTA .)
    &               reduce using rule 184 (attribute_id -> DELTA .)
    AND             reduce using rule 184 (attribute_id -> DELTA .)
    OR              reduce using rule 184 (attribute_id -> DELTA .)
    XOR             reduce using rule 184 (attribute_id -> DELTA .)
    )               reduce using rule 184 (attribute_id -> DELTA .)
    DOTDOT          reduce using rule 184 (attribute_id -> DELTA .)
    THEN            reduce using rule 184 (attribute_id -> DELTA .)
    LOOP            reduce using rule 184 (attribute_id -> DELTA .)
    USE             reduce using rule 184 (attribute_id -> DELTA .)
    AT              reduce using rule 184 (attribute_id -> DELTA .)


state 397

    (245) qualified -> name TICK parenthesized_primary .

    STARSTAR        reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    *               reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    /               reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    MOD             reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    REM             reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    =               reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    NOTEQUAL        reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    <               reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    LESSEQ          reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    >               reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    GREATEREQ       reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    IN              reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    NOT             reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    +               reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    -               reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    &               reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    AND             reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    OR              reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    XOR             reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    RANGE           reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    ;               reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    )               reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    ,               reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    DOTDOT          reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    WITH            reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    ARROW           reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    |               reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    IS              reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    THEN            reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    LOOP            reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    DIGITS          reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    RENAMES         reduce using rule 245 (qualified -> name TICK parenthesized_primary .)
    ASSIGNMENT      reduce using rule 245 (qualified -> name TICK parenthesized_primary .)


state 398

    (206) short_circuit -> AND THEN .

    +               reduce using rule 206 (short_circuit -> AND THEN .)
    -               reduce using rule 206 (short_circuit -> AND THEN .)
    NOT             reduce using rule 206 (short_circuit -> AND THEN .)
    ABS             reduce using rule 206 (short_circuit -> AND THEN .)
    INTEGER         reduce using rule 206 (short_circuit -> AND THEN .)
    BASE_INTEGER    reduce using rule 206 (short_circuit -> AND THEN .)
    FLOAT           reduce using rule 206 (short_circuit -> AND THEN .)
    BASE_FLOAT      reduce using rule 206 (short_circuit -> AND THEN .)
    NuLL            reduce using rule 206 (short_circuit -> AND THEN .)
    NEW             reduce using rule 206 (short_circuit -> AND THEN .)
    (               reduce using rule 206 (short_circuit -> AND THEN .)
    CHAR            reduce using rule 206 (short_circuit -> AND THEN .)
    IDENTIFIER      reduce using rule 206 (short_circuit -> AND THEN .)
    STRING          reduce using rule 206 (short_circuit -> AND THEN .)


state 399

    (201) expression -> expression logical relation .

    AND             reduce using rule 201 (expression -> expression logical relation .)
    OR              reduce using rule 201 (expression -> expression logical relation .)
    XOR             reduce using rule 201 (expression -> expression logical relation .)
    )               reduce using rule 201 (expression -> expression logical relation .)
    ,               reduce using rule 201 (expression -> expression logical relation .)
    ;               reduce using rule 201 (expression -> expression logical relation .)
    DIGITS          reduce using rule 201 (expression -> expression logical relation .)
    RANGE           reduce using rule 201 (expression -> expression logical relation .)
    THEN            reduce using rule 201 (expression -> expression logical relation .)
    ARROW           reduce using rule 201 (expression -> expression logical relation .)
    |               reduce using rule 201 (expression -> expression logical relation .)
    RENAMES         reduce using rule 201 (expression -> expression logical relation .)
    ASSIGNMENT      reduce using rule 201 (expression -> expression logical relation .)
    WITH            reduce using rule 201 (expression -> expression logical relation .)
    IS              reduce using rule 201 (expression -> expression logical relation .)
    LOOP            reduce using rule 201 (expression -> expression logical relation .)


state 400

    (202) expression -> expression short_circuit relation .

    AND             reduce using rule 202 (expression -> expression short_circuit relation .)
    OR              reduce using rule 202 (expression -> expression short_circuit relation .)
    XOR             reduce using rule 202 (expression -> expression short_circuit relation .)
    )               reduce using rule 202 (expression -> expression short_circuit relation .)
    ,               reduce using rule 202 (expression -> expression short_circuit relation .)
    ;               reduce using rule 202 (expression -> expression short_circuit relation .)
    DIGITS          reduce using rule 202 (expression -> expression short_circuit relation .)
    RANGE           reduce using rule 202 (expression -> expression short_circuit relation .)
    THEN            reduce using rule 202 (expression -> expression short_circuit relation .)
    ARROW           reduce using rule 202 (expression -> expression short_circuit relation .)
    |               reduce using rule 202 (expression -> expression short_circuit relation .)
    RENAMES         reduce using rule 202 (expression -> expression short_circuit relation .)
    ASSIGNMENT      reduce using rule 202 (expression -> expression short_circuit relation .)
    WITH            reduce using rule 202 (expression -> expression short_circuit relation .)
    IS              reduce using rule 202 (expression -> expression short_circuit relation .)
    LOOP            reduce using rule 202 (expression -> expression short_circuit relation .)


state 401

    (207) short_circuit -> OR ELSE .

    +               reduce using rule 207 (short_circuit -> OR ELSE .)
    -               reduce using rule 207 (short_circuit -> OR ELSE .)
    NOT             reduce using rule 207 (short_circuit -> OR ELSE .)
    ABS             reduce using rule 207 (short_circuit -> OR ELSE .)
    INTEGER         reduce using rule 207 (short_circuit -> OR ELSE .)
    BASE_INTEGER    reduce using rule 207 (short_circuit -> OR ELSE .)
    FLOAT           reduce using rule 207 (short_circuit -> OR ELSE .)
    BASE_FLOAT      reduce using rule 207 (short_circuit -> OR ELSE .)
    NuLL            reduce using rule 207 (short_circuit -> OR ELSE .)
    NEW             reduce using rule 207 (short_circuit -> OR ELSE .)
    (               reduce using rule 207 (short_circuit -> OR ELSE .)
    CHAR            reduce using rule 207 (short_circuit -> OR ELSE .)
    IDENTIFIER      reduce using rule 207 (short_circuit -> OR ELSE .)
    STRING          reduce using rule 207 (short_circuit -> OR ELSE .)


state 402

    (355) name_s -> name_s , name .
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id

    ;               reduce using rule 355 (name_s -> name_s , name .)
    ,               reduce using rule 355 (name_s -> name_s , name .)
    (               shift and go to state 245
    .               shift and go to state 246
    TICK            shift and go to state 256


state 403

    (353) use_clause -> USE TYPE name_s ; .

    PACKAGE         reduce using rule 353 (use_clause -> USE TYPE name_s ; .)
    TASK            reduce using rule 353 (use_clause -> USE TYPE name_s ; .)
    PROTECTED       reduce using rule 353 (use_clause -> USE TYPE name_s ; .)
    error           reduce using rule 353 (use_clause -> USE TYPE name_s ; .)
    USE             reduce using rule 353 (use_clause -> USE TYPE name_s ; .)
    PRAGMA          reduce using rule 353 (use_clause -> USE TYPE name_s ; .)
    TYPE            reduce using rule 353 (use_clause -> USE TYPE name_s ; .)
    SUBTYPE         reduce using rule 353 (use_clause -> USE TYPE name_s ; .)
    FOR             reduce using rule 353 (use_clause -> USE TYPE name_s ; .)
    PROCEDURE       reduce using rule 353 (use_clause -> USE TYPE name_s ; .)
    FUNCTION        reduce using rule 353 (use_clause -> USE TYPE name_s ; .)
    GENERIC         reduce using rule 353 (use_clause -> USE TYPE name_s ; .)
    IDENTIFIER      reduce using rule 353 (use_clause -> USE TYPE name_s ; .)
    BEGIN           reduce using rule 353 (use_clause -> USE TYPE name_s ; .)
    END             reduce using rule 353 (use_clause -> USE TYPE name_s ; .)
    PRIVATE         reduce using rule 353 (use_clause -> USE TYPE name_s ; .)
    WITH            reduce using rule 353 (use_clause -> USE TYPE name_s ; .)
    SEPARATE        reduce using rule 353 (use_clause -> USE TYPE name_s ; .)


state 404

    (453) subunit_body -> subprog_body .

    PRAGMA          reduce using rule 453 (subunit_body -> subprog_body .)
    PRIVATE         reduce using rule 453 (subunit_body -> subprog_body .)
    WITH            reduce using rule 453 (subunit_body -> subprog_body .)
    PACKAGE         reduce using rule 453 (subunit_body -> subprog_body .)
    SEPARATE        reduce using rule 453 (subunit_body -> subprog_body .)
    PROCEDURE       reduce using rule 453 (subunit_body -> subprog_body .)
    FUNCTION        reduce using rule 453 (subunit_body -> subprog_body .)
    GENERIC         reduce using rule 453 (subunit_body -> subprog_body .)
    $end            reduce using rule 453 (subunit_body -> subprog_body .)


state 405

    (455) subunit_body -> task_body .

    PRAGMA          reduce using rule 455 (subunit_body -> task_body .)
    PRIVATE         reduce using rule 455 (subunit_body -> task_body .)
    WITH            reduce using rule 455 (subunit_body -> task_body .)
    PACKAGE         reduce using rule 455 (subunit_body -> task_body .)
    SEPARATE        reduce using rule 455 (subunit_body -> task_body .)
    PROCEDURE       reduce using rule 455 (subunit_body -> task_body .)
    FUNCTION        reduce using rule 455 (subunit_body -> task_body .)
    GENERIC         reduce using rule 455 (subunit_body -> task_body .)
    $end            reduce using rule 455 (subunit_body -> task_body .)


state 406

    (388) prot_body -> PROTECTED . BODY simple_name IS prot_op_body_s END id_opt ;

    BODY            shift and go to state 532


state 407

    (452) subunit -> SEPARATE ( compound_name ) subunit_body .

    PRAGMA          reduce using rule 452 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    PRIVATE         reduce using rule 452 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    WITH            reduce using rule 452 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    PACKAGE         reduce using rule 452 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    SEPARATE        reduce using rule 452 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    PROCEDURE       reduce using rule 452 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    FUNCTION        reduce using rule 452 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    GENERIC         reduce using rule 452 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    $end            reduce using rule 452 (subunit -> SEPARATE ( compound_name ) subunit_body .)


state 408

    (371) task_body -> TASK . BODY simple_name IS decl_part block_body END id_opt ;

    BODY            shift and go to state 533


state 409

    (337) subprog_body -> subprog_spec_is_push . decl_part block_body END id_opt ;
    (137) decl_part -> .
    (138) decl_part -> . decl_item_or_body_s1
    (147) decl_item_or_body_s1 -> . decl_item_or_body
    (148) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (149) decl_item_or_body -> . body
    (150) decl_item_or_body -> . decl_item
    (151) body -> . subprog_body
    (152) body -> . pkg_body
    (153) body -> . task_body
    (154) body -> . prot_body
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (337) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (346) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (371) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (388) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (352) use_clause -> . USE name_s ;
    (353) use_clause -> . USE TYPE name_s ;
    (506) rep_spec -> . attrib_def
    (507) rep_spec -> . record_type_spec
    (508) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (336) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (316) subprog_decl -> . subprog_spec ;
    (317) subprog_decl -> . generic_subp_inst ;
    (318) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (339) pkg_decl -> . pkg_spec ;
    (340) pkg_decl -> . generic_pkg_inst ;
    (364) task_decl -> . task_spec ;
    (372) prot_decl -> . prot_spec ;
    (461) exception_decl -> . def_id_s : EXCEPTION ;
    (356) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (357) rename_decl -> . def_id_s : EXCEPTION renames ;
    (358) rename_decl -> . rename_unit
    (473) generic_decl -> . generic_formal_part subprog_spec ;
    (474) generic_decl -> . generic_formal_part pkg_spec ;
    (457) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (458) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (459) body_stub -> . subprog_spec IS SEPARATE ;
    (460) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (509) attrib_def -> . FOR mark USE expression ;
    (510) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (515) address_spec -> . FOR mark USE AT expression ;
    (319) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (320) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (321) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (503) generic_subp_inst -> . subprog_spec IS generic_inst
    (341) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (365) task_spec -> . TASK simple_name task_def
    (366) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (373) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (374) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (359) rename_unit -> . PACKAGE compound_name renames ;
    (360) rename_unit -> . subprog_spec renames ;
    (361) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (362) rename_unit -> . generic_formal_part subprog_spec renames ;
    (475) generic_formal_part -> . GENERIC
    (476) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 137 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 54
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 410

    (336) subprog_spec_is_push -> subprog_spec . IS

    IS              shift and go to state 534


state 411

    (346) pkg_body -> PACKAGE . BODY compound_name IS decl_part body_opt END c_id_opt ;

    BODY            shift and go to state 98


state 412

    (456) subunit_body -> prot_body .

    PRAGMA          reduce using rule 456 (subunit_body -> prot_body .)
    PRIVATE         reduce using rule 456 (subunit_body -> prot_body .)
    WITH            reduce using rule 456 (subunit_body -> prot_body .)
    PACKAGE         reduce using rule 456 (subunit_body -> prot_body .)
    SEPARATE        reduce using rule 456 (subunit_body -> prot_body .)
    PROCEDURE       reduce using rule 456 (subunit_body -> prot_body .)
    FUNCTION        reduce using rule 456 (subunit_body -> prot_body .)
    GENERIC         reduce using rule 456 (subunit_body -> prot_body .)
    $end            reduce using rule 456 (subunit_body -> prot_body .)


state 413

    (454) subunit_body -> pkg_body .

    PRAGMA          reduce using rule 454 (subunit_body -> pkg_body .)
    PRIVATE         reduce using rule 454 (subunit_body -> pkg_body .)
    WITH            reduce using rule 454 (subunit_body -> pkg_body .)
    PACKAGE         reduce using rule 454 (subunit_body -> pkg_body .)
    SEPARATE        reduce using rule 454 (subunit_body -> pkg_body .)
    PROCEDURE       reduce using rule 454 (subunit_body -> pkg_body .)
    FUNCTION        reduce using rule 454 (subunit_body -> pkg_body .)
    GENERIC         reduce using rule 454 (subunit_body -> pkg_body .)
    $end            reduce using rule 454 (subunit_body -> pkg_body .)


state 414

    (388) prot_body -> PROTECTED BODY simple_name IS . prot_op_body_s END id_opt ;
    (460) body_stub -> PROTECTED BODY simple_name IS . SEPARATE ;
    (389) prot_op_body_s -> . pragma_s
    (390) prot_op_body_s -> . prot_op_body_s prot_op_body pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    SEPARATE        shift and go to state 535
    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)

    prot_op_body_s                 shift and go to state 536
    pragma_s                       shift and go to state 537

state 415

    (375) prot_def -> IS prot_op_decl_s . prot_private_opt END id_opt
    (379) prot_op_decl_s -> prot_op_decl_s . prot_op_decl
    (376) prot_private_opt -> .
    (377) prot_private_opt -> . PRIVATE prot_elem_decl_s
    (380) prot_op_decl -> . entry_decl
    (381) prot_op_decl -> . subprog_spec ;
    (382) prot_op_decl -> . rep_spec
    (383) prot_op_decl -> . pragma
    (396) entry_decl -> . ENTRY IDENTIFIER formal_part_opt ;
    (397) entry_decl -> . ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ;
    (319) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (320) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (321) subprog_spec -> . FUNCTION designator
    (506) rep_spec -> . attrib_def
    (507) rep_spec -> . record_type_spec
    (508) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (509) attrib_def -> . FOR mark USE expression ;
    (510) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (515) address_spec -> . FOR mark USE AT expression ;

    END             reduce using rule 376 (prot_private_opt -> .)
    PRIVATE         shift and go to state 540
    ENTRY           shift and go to state 544
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    PRAGMA          shift and go to state 4
    FOR             shift and go to state 63

    rep_spec                       shift and go to state 538
    entry_decl                     shift and go to state 539
    address_spec                   shift and go to state 52
    record_type_spec               shift and go to state 68
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 541
    prot_private_opt               shift and go to state 542
    pragma                         shift and go to state 543
    prot_op_decl                   shift and go to state 545

state 416

    (374) prot_spec -> PROTECTED TYPE simple_name discrim_part_opt . prot_def
    (375) prot_def -> . IS prot_op_decl_s prot_private_opt END id_opt

    IS              shift and go to state 260

    prot_def                       shift and go to state 546

state 417

    (411) delay_stmt -> DELAY UNTIL . expression ;
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 547

state 418

    (410) delay_stmt -> DELAY expression . ;
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE

    ;               shift and go to state 548
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250

    logical                        shift and go to state 251
    short_circuit                  shift and go to state 252

state 419

    (294) iteration -> iter_part . reverse_opt discrete_range
    (296) reverse_opt -> .
    (297) reverse_opt -> . REVERSE

    IDENTIFIER      reduce using rule 296 (reverse_opt -> .)
    STRING          reduce using rule 296 (reverse_opt -> .)
    +               reduce using rule 296 (reverse_opt -> .)
    -               reduce using rule 296 (reverse_opt -> .)
    NOT             reduce using rule 296 (reverse_opt -> .)
    ABS             reduce using rule 296 (reverse_opt -> .)
    INTEGER         reduce using rule 296 (reverse_opt -> .)
    BASE_INTEGER    reduce using rule 296 (reverse_opt -> .)
    FLOAT           reduce using rule 296 (reverse_opt -> .)
    BASE_FLOAT      reduce using rule 296 (reverse_opt -> .)
    NuLL            reduce using rule 296 (reverse_opt -> .)
    NEW             reduce using rule 296 (reverse_opt -> .)
    (               reduce using rule 296 (reverse_opt -> .)
    CHAR            reduce using rule 296 (reverse_opt -> .)
    REVERSE         shift and go to state 550

    reverse_opt                    shift and go to state 549

state 420

    (295) iter_part -> FOR . IDENTIFIER IN

    IDENTIFIER      shift and go to state 551


state 421

    (301) block -> label_opt block_decl . block_body END id_opt ;
    (304) block_body -> . BEGIN handled_stmt_s

    BEGIN           shift and go to state 163

    block_body                     shift and go to state 552

state 422

    (289) loop_stmt -> label_opt iteration . basic_loop id_opt ;
    (298) basic_loop -> . LOOP statement_s END LOOP

    LOOP            shift and go to state 554

    basic_loop                     shift and go to state 553

state 423

    (293) iteration -> WHILE . condition
    (281) condition -> . expression
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    condition                      shift and go to state 555
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 465

state 424

    (303) block_decl -> DECLARE . decl_part
    (137) decl_part -> .
    (138) decl_part -> . decl_item_or_body_s1
    (147) decl_item_or_body_s1 -> . decl_item_or_body
    (148) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (149) decl_item_or_body -> . body
    (150) decl_item_or_body -> . decl_item
    (151) body -> . subprog_body
    (152) body -> . pkg_body
    (153) body -> . task_body
    (154) body -> . prot_body
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (337) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (346) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (371) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (388) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (352) use_clause -> . USE name_s ;
    (353) use_clause -> . USE TYPE name_s ;
    (506) rep_spec -> . attrib_def
    (507) rep_spec -> . record_type_spec
    (508) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (336) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (316) subprog_decl -> . subprog_spec ;
    (317) subprog_decl -> . generic_subp_inst ;
    (318) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (339) pkg_decl -> . pkg_spec ;
    (340) pkg_decl -> . generic_pkg_inst ;
    (364) task_decl -> . task_spec ;
    (372) prot_decl -> . prot_spec ;
    (461) exception_decl -> . def_id_s : EXCEPTION ;
    (356) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (357) rename_decl -> . def_id_s : EXCEPTION renames ;
    (358) rename_decl -> . rename_unit
    (473) generic_decl -> . generic_formal_part subprog_spec ;
    (474) generic_decl -> . generic_formal_part pkg_spec ;
    (457) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (458) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (459) body_stub -> . subprog_spec IS SEPARATE ;
    (460) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (509) attrib_def -> . FOR mark USE expression ;
    (510) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (515) address_spec -> . FOR mark USE AT expression ;
    (319) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (320) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (321) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (503) generic_subp_inst -> . subprog_spec IS generic_inst
    (341) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (365) task_spec -> . TASK simple_name task_def
    (366) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (373) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (374) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (359) rename_unit -> . PACKAGE compound_name renames ;
    (360) rename_unit -> . subprog_spec renames ;
    (361) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (362) rename_unit -> . generic_formal_part subprog_spec renames ;
    (475) generic_formal_part -> . GENERIC
    (476) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 137 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 556
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 425

    (315) goto_stmt -> GOTO name . ;
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id

    ;               shift and go to state 557
    (               shift and go to state 245
    .               shift and go to state 246
    TICK            shift and go to state 256


state 426

    (516) code_stmt -> qualified ; .

    LESSLESS        reduce using rule 516 (code_stmt -> qualified ; .)
    error           reduce using rule 516 (code_stmt -> qualified ; .)
    PRAGMA          reduce using rule 516 (code_stmt -> qualified ; .)
    NuLL            reduce using rule 516 (code_stmt -> qualified ; .)
    EXIT            reduce using rule 516 (code_stmt -> qualified ; .)
    RETURN          reduce using rule 516 (code_stmt -> qualified ; .)
    GOTO            reduce using rule 516 (code_stmt -> qualified ; .)
    DELAY           reduce using rule 516 (code_stmt -> qualified ; .)
    ABORT           reduce using rule 516 (code_stmt -> qualified ; .)
    RAISE           reduce using rule 516 (code_stmt -> qualified ; .)
    REQUEUE         reduce using rule 516 (code_stmt -> qualified ; .)
    IF              reduce using rule 516 (code_stmt -> qualified ; .)
    CASE            reduce using rule 516 (code_stmt -> qualified ; .)
    IDENTIFIER      reduce using rule 516 (code_stmt -> qualified ; .)
    ACCEPT          reduce using rule 516 (code_stmt -> qualified ; .)
    SELECT          reduce using rule 516 (code_stmt -> qualified ; .)
    STRING          reduce using rule 516 (code_stmt -> qualified ; .)
    WHILE           reduce using rule 516 (code_stmt -> qualified ; .)
    DECLARE         reduce using rule 516 (code_stmt -> qualified ; .)
    FOR             reduce using rule 516 (code_stmt -> qualified ; .)
    LOOP            reduce using rule 516 (code_stmt -> qualified ; .)
    BEGIN           reduce using rule 516 (code_stmt -> qualified ; .)
    OR              reduce using rule 516 (code_stmt -> qualified ; .)
    ELSE            reduce using rule 516 (code_stmt -> qualified ; .)
    END             reduce using rule 516 (code_stmt -> qualified ; .)
    WHEN            reduce using rule 516 (code_stmt -> qualified ; .)
    EXCEPTION       reduce using rule 516 (code_stmt -> qualified ; .)
    THEN            reduce using rule 516 (code_stmt -> qualified ; .)
    ELSIF           reduce using rule 516 (code_stmt -> qualified ; .)


state 427

    (275) assign_stmt -> name ASSIGNMENT . expression ;
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 558

state 428

    (338) procedure_call -> name ; .

    END             reduce using rule 338 (procedure_call -> name ; .)
    LESSLESS        reduce using rule 338 (procedure_call -> name ; .)
    error           reduce using rule 338 (procedure_call -> name ; .)
    PRAGMA          reduce using rule 338 (procedure_call -> name ; .)
    NuLL            reduce using rule 338 (procedure_call -> name ; .)
    EXIT            reduce using rule 338 (procedure_call -> name ; .)
    RETURN          reduce using rule 338 (procedure_call -> name ; .)
    GOTO            reduce using rule 338 (procedure_call -> name ; .)
    DELAY           reduce using rule 338 (procedure_call -> name ; .)
    ABORT           reduce using rule 338 (procedure_call -> name ; .)
    RAISE           reduce using rule 338 (procedure_call -> name ; .)
    REQUEUE         reduce using rule 338 (procedure_call -> name ; .)
    IF              reduce using rule 338 (procedure_call -> name ; .)
    CASE            reduce using rule 338 (procedure_call -> name ; .)
    IDENTIFIER      reduce using rule 338 (procedure_call -> name ; .)
    ACCEPT          reduce using rule 338 (procedure_call -> name ; .)
    SELECT          reduce using rule 338 (procedure_call -> name ; .)
    STRING          reduce using rule 338 (procedure_call -> name ; .)
    WHILE           reduce using rule 338 (procedure_call -> name ; .)
    DECLARE         reduce using rule 338 (procedure_call -> name ; .)
    FOR             reduce using rule 338 (procedure_call -> name ; .)
    LOOP            reduce using rule 338 (procedure_call -> name ; .)
    BEGIN           reduce using rule 338 (procedure_call -> name ; .)
    WHEN            reduce using rule 338 (procedure_call -> name ; .)
    EXCEPTION       reduce using rule 338 (procedure_call -> name ; .)
    OR              reduce using rule 338 (procedure_call -> name ; .)
    ELSE            reduce using rule 338 (procedure_call -> name ; .)
    THEN            reduce using rule 338 (procedure_call -> name ; .)
    ELSIF           reduce using rule 338 (procedure_call -> name ; .)


state 429

    (431) abort_stmt -> ABORT name_s . ;
    (355) name_s -> name_s . , name

    ;               shift and go to state 559
    ,               shift and go to state 255


state 430

    (274) null_stmt -> NuLL ; .

    END             reduce using rule 274 (null_stmt -> NuLL ; .)
    LESSLESS        reduce using rule 274 (null_stmt -> NuLL ; .)
    error           reduce using rule 274 (null_stmt -> NuLL ; .)
    PRAGMA          reduce using rule 274 (null_stmt -> NuLL ; .)
    NuLL            reduce using rule 274 (null_stmt -> NuLL ; .)
    EXIT            reduce using rule 274 (null_stmt -> NuLL ; .)
    RETURN          reduce using rule 274 (null_stmt -> NuLL ; .)
    GOTO            reduce using rule 274 (null_stmt -> NuLL ; .)
    DELAY           reduce using rule 274 (null_stmt -> NuLL ; .)
    ABORT           reduce using rule 274 (null_stmt -> NuLL ; .)
    RAISE           reduce using rule 274 (null_stmt -> NuLL ; .)
    REQUEUE         reduce using rule 274 (null_stmt -> NuLL ; .)
    IF              reduce using rule 274 (null_stmt -> NuLL ; .)
    CASE            reduce using rule 274 (null_stmt -> NuLL ; .)
    IDENTIFIER      reduce using rule 274 (null_stmt -> NuLL ; .)
    ACCEPT          reduce using rule 274 (null_stmt -> NuLL ; .)
    SELECT          reduce using rule 274 (null_stmt -> NuLL ; .)
    STRING          reduce using rule 274 (null_stmt -> NuLL ; .)
    WHILE           reduce using rule 274 (null_stmt -> NuLL ; .)
    DECLARE         reduce using rule 274 (null_stmt -> NuLL ; .)
    FOR             reduce using rule 274 (null_stmt -> NuLL ; .)
    LOOP            reduce using rule 274 (null_stmt -> NuLL ; .)
    BEGIN           reduce using rule 274 (null_stmt -> NuLL ; .)
    OR              reduce using rule 274 (null_stmt -> NuLL ; .)
    ELSE            reduce using rule 274 (null_stmt -> NuLL ; .)
    EXCEPTION       reduce using rule 274 (null_stmt -> NuLL ; .)
    THEN            reduce using rule 274 (null_stmt -> NuLL ; .)
    ELSIF           reduce using rule 274 (null_stmt -> NuLL ; .)
    WHEN            reduce using rule 274 (null_stmt -> NuLL ; .)


state 431

    (273) label -> LESSLESS IDENTIFIER . MOREMORE

    MOREMORE        shift and go to state 560


state 432

    (313) return_stmt -> RETURN ; .

    LESSLESS        reduce using rule 313 (return_stmt -> RETURN ; .)
    error           reduce using rule 313 (return_stmt -> RETURN ; .)
    PRAGMA          reduce using rule 313 (return_stmt -> RETURN ; .)
    NuLL            reduce using rule 313 (return_stmt -> RETURN ; .)
    EXIT            reduce using rule 313 (return_stmt -> RETURN ; .)
    RETURN          reduce using rule 313 (return_stmt -> RETURN ; .)
    GOTO            reduce using rule 313 (return_stmt -> RETURN ; .)
    DELAY           reduce using rule 313 (return_stmt -> RETURN ; .)
    ABORT           reduce using rule 313 (return_stmt -> RETURN ; .)
    RAISE           reduce using rule 313 (return_stmt -> RETURN ; .)
    REQUEUE         reduce using rule 313 (return_stmt -> RETURN ; .)
    IF              reduce using rule 313 (return_stmt -> RETURN ; .)
    CASE            reduce using rule 313 (return_stmt -> RETURN ; .)
    IDENTIFIER      reduce using rule 313 (return_stmt -> RETURN ; .)
    ACCEPT          reduce using rule 313 (return_stmt -> RETURN ; .)
    SELECT          reduce using rule 313 (return_stmt -> RETURN ; .)
    STRING          reduce using rule 313 (return_stmt -> RETURN ; .)
    WHILE           reduce using rule 313 (return_stmt -> RETURN ; .)
    DECLARE         reduce using rule 313 (return_stmt -> RETURN ; .)
    FOR             reduce using rule 313 (return_stmt -> RETURN ; .)
    LOOP            reduce using rule 313 (return_stmt -> RETURN ; .)
    BEGIN           reduce using rule 313 (return_stmt -> RETURN ; .)
    END             reduce using rule 313 (return_stmt -> RETURN ; .)
    THEN            reduce using rule 313 (return_stmt -> RETURN ; .)
    OR              reduce using rule 313 (return_stmt -> RETURN ; .)
    ELSE            reduce using rule 313 (return_stmt -> RETURN ; .)
    WHEN            reduce using rule 313 (return_stmt -> RETURN ; .)
    ELSIF           reduce using rule 313 (return_stmt -> RETURN ; .)
    EXCEPTION       reduce using rule 313 (return_stmt -> RETURN ; .)


state 433

    (314) return_stmt -> RETURN expression . ;
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE

    ;               shift and go to state 561
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250

    logical                        shift and go to state 251
    short_circuit                  shift and go to state 252

state 434

    (407) accept_hdr -> ACCEPT entry_name . formal_part_opt
    (409) entry_name -> entry_name . ( expression )
    (324) formal_part_opt -> .
    (325) formal_part_opt -> . formal_part
    (326) formal_part -> . ( param_s )

    (               shift and go to state 562
    ;               reduce using rule 324 (formal_part_opt -> .)
    DO              reduce using rule 324 (formal_part_opt -> .)

    formal_part                    shift and go to state 189
    formal_part_opt                shift and go to state 563

state 435

    (408) entry_name -> simple_name .

    (               reduce using rule 408 (entry_name -> simple_name .)
    ;               reduce using rule 408 (entry_name -> simple_name .)
    DO              reduce using rule 408 (entry_name -> simple_name .)


state 436

    (421) select_alt -> accept_stmt . stmts_opt
    (429) stmts_opt -> .
    (430) stmts_opt -> . statement_s
    (248) statement_s -> . statement
    (249) statement_s -> . statement_s statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    OR              reduce using rule 429 (stmts_opt -> .)
    ELSE            reduce using rule 429 (stmts_opt -> .)
    END             reduce using rule 429 (stmts_opt -> .)
    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    statement_s                    shift and go to state 565
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 292
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    stmts_opt                      shift and go to state 564
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 437

    (427) timed_entry_call -> SELECT entry_call . stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> SELECT entry_call . stmts_opt ELSE statement_s END SELECT ;
    (425) delay_or_entry_alt -> entry_call . stmts_opt
    (429) stmts_opt -> .
    (430) stmts_opt -> . statement_s
    (248) statement_s -> . statement
    (249) statement_s -> . statement_s statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    OR              reduce using rule 429 (stmts_opt -> .)
    ELSE            reduce using rule 429 (stmts_opt -> .)
    THEN            reduce using rule 429 (stmts_opt -> .)
    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    statement_s                    shift and go to state 565
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 292
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    stmts_opt                      shift and go to state 566
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 438

    (404) entry_call -> procedure_call .

    LESSLESS        reduce using rule 404 (entry_call -> procedure_call .)
    error           reduce using rule 404 (entry_call -> procedure_call .)
    PRAGMA          reduce using rule 404 (entry_call -> procedure_call .)
    NuLL            reduce using rule 404 (entry_call -> procedure_call .)
    EXIT            reduce using rule 404 (entry_call -> procedure_call .)
    RETURN          reduce using rule 404 (entry_call -> procedure_call .)
    GOTO            reduce using rule 404 (entry_call -> procedure_call .)
    DELAY           reduce using rule 404 (entry_call -> procedure_call .)
    ABORT           reduce using rule 404 (entry_call -> procedure_call .)
    RAISE           reduce using rule 404 (entry_call -> procedure_call .)
    REQUEUE         reduce using rule 404 (entry_call -> procedure_call .)
    IF              reduce using rule 404 (entry_call -> procedure_call .)
    CASE            reduce using rule 404 (entry_call -> procedure_call .)
    IDENTIFIER      reduce using rule 404 (entry_call -> procedure_call .)
    ACCEPT          reduce using rule 404 (entry_call -> procedure_call .)
    SELECT          reduce using rule 404 (entry_call -> procedure_call .)
    STRING          reduce using rule 404 (entry_call -> procedure_call .)
    OR              reduce using rule 404 (entry_call -> procedure_call .)
    ELSE            reduce using rule 404 (entry_call -> procedure_call .)
    WHILE           reduce using rule 404 (entry_call -> procedure_call .)
    DECLARE         reduce using rule 404 (entry_call -> procedure_call .)
    FOR             reduce using rule 404 (entry_call -> procedure_call .)
    LOOP            reduce using rule 404 (entry_call -> procedure_call .)
    BEGIN           reduce using rule 404 (entry_call -> procedure_call .)
    THEN            reduce using rule 404 (entry_call -> procedure_call .)


state 439

    (426) async_select -> SELECT delay_or_entry_alt . THEN ABORT statement_s END SELECT ;

    THEN            shift and go to state 567


state 440

    (418) guarded_select_alt -> WHEN . condition ARROW select_alt
    (281) condition -> . expression
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    condition                      shift and go to state 568
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 465

state 441

    (416) select_wait -> SELECT guarded_select_alt . or_select else_opt END SELECT ;
    (419) or_select -> .
    (420) or_select -> . or_select OR guarded_select_alt

    OR              reduce using rule 419 (or_select -> .)
    ELSE            reduce using rule 419 (or_select -> .)
    END             reduce using rule 419 (or_select -> .)

    or_select                      shift and go to state 569

state 442

    (417) guarded_select_alt -> select_alt .

    OR              reduce using rule 417 (guarded_select_alt -> select_alt .)
    ELSE            reduce using rule 417 (guarded_select_alt -> select_alt .)
    END             reduce using rule 417 (guarded_select_alt -> select_alt .)


state 443

    (424) delay_or_entry_alt -> delay_stmt . stmts_opt
    (422) select_alt -> delay_stmt . stmts_opt
    (429) stmts_opt -> .
    (430) stmts_opt -> . statement_s
    (248) statement_s -> . statement
    (249) statement_s -> . statement_s statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    THEN            reduce using rule 429 (stmts_opt -> .)
    OR              reduce using rule 429 (stmts_opt -> .)
    ELSE            reduce using rule 429 (stmts_opt -> .)
    END             reduce using rule 429 (stmts_opt -> .)
    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    statement_s                    shift and go to state 565
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 292
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    stmts_opt                      shift and go to state 570
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 444

    (338) procedure_call -> name . ;
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id

    ;               shift and go to state 428
    (               shift and go to state 245
    .               shift and go to state 246
    TICK            shift and go to state 256


state 445

    (423) select_alt -> TERMINATE . ;

    ;               shift and go to state 571


state 446

    (251) statement -> label statement .

    LESSLESS        reduce using rule 251 (statement -> label statement .)
    error           reduce using rule 251 (statement -> label statement .)
    PRAGMA          reduce using rule 251 (statement -> label statement .)
    NuLL            reduce using rule 251 (statement -> label statement .)
    EXIT            reduce using rule 251 (statement -> label statement .)
    RETURN          reduce using rule 251 (statement -> label statement .)
    GOTO            reduce using rule 251 (statement -> label statement .)
    DELAY           reduce using rule 251 (statement -> label statement .)
    ABORT           reduce using rule 251 (statement -> label statement .)
    RAISE           reduce using rule 251 (statement -> label statement .)
    REQUEUE         reduce using rule 251 (statement -> label statement .)
    IF              reduce using rule 251 (statement -> label statement .)
    CASE            reduce using rule 251 (statement -> label statement .)
    IDENTIFIER      reduce using rule 251 (statement -> label statement .)
    ACCEPT          reduce using rule 251 (statement -> label statement .)
    SELECT          reduce using rule 251 (statement -> label statement .)
    STRING          reduce using rule 251 (statement -> label statement .)
    WHILE           reduce using rule 251 (statement -> label statement .)
    DECLARE         reduce using rule 251 (statement -> label statement .)
    FOR             reduce using rule 251 (statement -> label statement .)
    LOOP            reduce using rule 251 (statement -> label statement .)
    BEGIN           reduce using rule 251 (statement -> label statement .)
    OR              reduce using rule 251 (statement -> label statement .)
    ELSE            reduce using rule 251 (statement -> label statement .)
    END             reduce using rule 251 (statement -> label statement .)
    THEN            reduce using rule 251 (statement -> label statement .)
    EXCEPTION       reduce using rule 251 (statement -> label statement .)
    ELSIF           reduce using rule 251 (statement -> label statement .)
    WHEN            reduce using rule 251 (statement -> label statement .)


state 447

    (284) case_stmt -> case_hdr pragma_s . alternative_s END CASE ;
    (9) pragma_s -> pragma_s . pragma
    (286) alternative_s -> .
    (287) alternative_s -> . alternative_s alternative
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 286 (alternative_s -> .)
    WHEN            reduce using rule 286 (alternative_s -> .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14
    alternative_s                  shift and go to state 572

state 448

    (310) name_opt -> name .
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id

    ;               reduce using rule 310 (name_opt -> name .)
    WHEN            reduce using rule 310 (name_opt -> name .)
    (               shift and go to state 245
    .               shift and go to state 246
    TICK            shift and go to state 256


state 449

    (470) raise_stmt -> RAISE name_opt . ;

    ;               shift and go to state 573


state 450

    (285) case_hdr -> CASE expression . IS
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE

    IS              shift and go to state 574
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250

    logical                        shift and go to state 251
    short_circuit                  shift and go to state 252

state 451

    (471) requeue_stmt -> REQUEUE name . ;
    (472) requeue_stmt -> REQUEUE name . WITH ABORT ;
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id

    ;               shift and go to state 575
    WITH            shift and go to state 576
    (               shift and go to state 245
    .               shift and go to state 246
    TICK            shift and go to state 256


state 452

    (291) label_opt -> IDENTIFIER : .

    WHILE           reduce using rule 291 (label_opt -> IDENTIFIER : .)
    DECLARE         reduce using rule 291 (label_opt -> IDENTIFIER : .)
    FOR             reduce using rule 291 (label_opt -> IDENTIFIER : .)
    LOOP            reduce using rule 291 (label_opt -> IDENTIFIER : .)
    BEGIN           reduce using rule 291 (label_opt -> IDENTIFIER : .)


state 453

    (406) accept_stmt -> accept_hdr DO . handled_stmt_s END id_opt ;
    (305) handled_stmt_s -> . statement_s except_handler_part_opt
    (248) statement_s -> . statement
    (249) statement_s -> . statement_s statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    label                          shift and go to state 282
    statement_s                    shift and go to state 303
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    handled_stmt_s                 shift and go to state 577
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    assign_stmt                    shift and go to state 311
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 292
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    accept_hdr                     shift and go to state 295
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    qualified                      shift and go to state 270
    label_opt                      shift and go to state 266
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 454

    (405) accept_stmt -> accept_hdr ; .

    END             reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    LESSLESS        reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    error           reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    PRAGMA          reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    NuLL            reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    EXIT            reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    RETURN          reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    GOTO            reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    DELAY           reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    ABORT           reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    RAISE           reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    REQUEUE         reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    IF              reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    CASE            reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    IDENTIFIER      reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    ACCEPT          reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    SELECT          reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    STRING          reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    WHILE           reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    DECLARE         reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    FOR             reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    LOOP            reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    BEGIN           reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    WHEN            reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    ELSIF           reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    ELSE            reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    OR              reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    THEN            reduce using rule 405 (accept_stmt -> accept_hdr ; .)
    EXCEPTION       reduce using rule 405 (accept_stmt -> accept_hdr ; .)


state 455

    (308) exit_stmt -> EXIT name_opt . when_opt ;
    (311) when_opt -> .
    (312) when_opt -> . WHEN condition

    ;               reduce using rule 311 (when_opt -> .)
    WHEN            shift and go to state 579

    when_opt                       shift and go to state 578

state 456

    (266) simple_stmt -> error ; .

    LESSLESS        reduce using rule 266 (simple_stmt -> error ; .)
    error           reduce using rule 266 (simple_stmt -> error ; .)
    PRAGMA          reduce using rule 266 (simple_stmt -> error ; .)
    NuLL            reduce using rule 266 (simple_stmt -> error ; .)
    EXIT            reduce using rule 266 (simple_stmt -> error ; .)
    RETURN          reduce using rule 266 (simple_stmt -> error ; .)
    GOTO            reduce using rule 266 (simple_stmt -> error ; .)
    DELAY           reduce using rule 266 (simple_stmt -> error ; .)
    ABORT           reduce using rule 266 (simple_stmt -> error ; .)
    RAISE           reduce using rule 266 (simple_stmt -> error ; .)
    REQUEUE         reduce using rule 266 (simple_stmt -> error ; .)
    IF              reduce using rule 266 (simple_stmt -> error ; .)
    CASE            reduce using rule 266 (simple_stmt -> error ; .)
    IDENTIFIER      reduce using rule 266 (simple_stmt -> error ; .)
    ACCEPT          reduce using rule 266 (simple_stmt -> error ; .)
    SELECT          reduce using rule 266 (simple_stmt -> error ; .)
    STRING          reduce using rule 266 (simple_stmt -> error ; .)
    WHILE           reduce using rule 266 (simple_stmt -> error ; .)
    DECLARE         reduce using rule 266 (simple_stmt -> error ; .)
    FOR             reduce using rule 266 (simple_stmt -> error ; .)
    LOOP            reduce using rule 266 (simple_stmt -> error ; .)
    BEGIN           reduce using rule 266 (simple_stmt -> error ; .)
    OR              reduce using rule 266 (simple_stmt -> error ; .)
    ELSE            reduce using rule 266 (simple_stmt -> error ; .)
    END             reduce using rule 266 (simple_stmt -> error ; .)
    EXCEPTION       reduce using rule 266 (simple_stmt -> error ; .)
    THEN            reduce using rule 266 (simple_stmt -> error ; .)
    ELSIF           reduce using rule 266 (simple_stmt -> error ; .)
    WHEN            reduce using rule 266 (simple_stmt -> error ; .)


state 457

    (307) except_handler_part_opt -> except_handler_part .
    (463) except_handler_part -> except_handler_part . exception_handler
    (464) exception_handler -> . WHEN except_choice_s ARROW statement_s
    (465) exception_handler -> . WHEN IDENTIFIER : except_choice_s ARROW statement_s

    END             reduce using rule 307 (except_handler_part_opt -> except_handler_part .)
    WHEN            shift and go to state 581

    exception_handler              shift and go to state 580

state 458

    (305) handled_stmt_s -> statement_s except_handler_part_opt .

    END             reduce using rule 305 (handled_stmt_s -> statement_s except_handler_part_opt .)


state 459

    (249) statement_s -> statement_s statement .

    END             reduce using rule 249 (statement_s -> statement_s statement .)
    LESSLESS        reduce using rule 249 (statement_s -> statement_s statement .)
    error           reduce using rule 249 (statement_s -> statement_s statement .)
    PRAGMA          reduce using rule 249 (statement_s -> statement_s statement .)
    NuLL            reduce using rule 249 (statement_s -> statement_s statement .)
    EXIT            reduce using rule 249 (statement_s -> statement_s statement .)
    RETURN          reduce using rule 249 (statement_s -> statement_s statement .)
    GOTO            reduce using rule 249 (statement_s -> statement_s statement .)
    DELAY           reduce using rule 249 (statement_s -> statement_s statement .)
    ABORT           reduce using rule 249 (statement_s -> statement_s statement .)
    RAISE           reduce using rule 249 (statement_s -> statement_s statement .)
    REQUEUE         reduce using rule 249 (statement_s -> statement_s statement .)
    IF              reduce using rule 249 (statement_s -> statement_s statement .)
    CASE            reduce using rule 249 (statement_s -> statement_s statement .)
    IDENTIFIER      reduce using rule 249 (statement_s -> statement_s statement .)
    ACCEPT          reduce using rule 249 (statement_s -> statement_s statement .)
    SELECT          reduce using rule 249 (statement_s -> statement_s statement .)
    STRING          reduce using rule 249 (statement_s -> statement_s statement .)
    WHILE           reduce using rule 249 (statement_s -> statement_s statement .)
    DECLARE         reduce using rule 249 (statement_s -> statement_s statement .)
    FOR             reduce using rule 249 (statement_s -> statement_s statement .)
    LOOP            reduce using rule 249 (statement_s -> statement_s statement .)
    BEGIN           reduce using rule 249 (statement_s -> statement_s statement .)
    OR              reduce using rule 249 (statement_s -> statement_s statement .)
    ELSE            reduce using rule 249 (statement_s -> statement_s statement .)
    THEN            reduce using rule 249 (statement_s -> statement_s statement .)
    WHEN            reduce using rule 249 (statement_s -> statement_s statement .)
    ELSIF           reduce using rule 249 (statement_s -> statement_s statement .)
    EXCEPTION       reduce using rule 249 (statement_s -> statement_s statement .)


state 460

    (462) except_handler_part -> EXCEPTION . exception_handler
    (464) exception_handler -> . WHEN except_choice_s ARROW statement_s
    (465) exception_handler -> . WHEN IDENTIFIER : except_choice_s ARROW statement_s

    WHEN            shift and go to state 581

    exception_handler              shift and go to state 582

state 461

    (276) if_stmt -> IF cond_clause_s . else_opt END IF ;
    (278) cond_clause_s -> cond_clause_s . ELSIF cond_clause
    (282) else_opt -> .
    (283) else_opt -> . ELSE statement_s

    ELSIF           shift and go to state 585
    END             reduce using rule 282 (else_opt -> .)
    ELSE            shift and go to state 583

    else_opt                       shift and go to state 584

state 462

    (277) cond_clause_s -> cond_clause .

    ELSIF           reduce using rule 277 (cond_clause_s -> cond_clause .)
    ELSE            reduce using rule 277 (cond_clause_s -> cond_clause .)
    END             reduce using rule 277 (cond_clause_s -> cond_clause .)


state 463

    (279) cond_clause -> cond_part . statement_s
    (248) statement_s -> . statement
    (249) statement_s -> . statement_s statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    statement_s                    shift and go to state 586
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 292
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 464

    (280) cond_part -> condition . THEN

    THEN            shift and go to state 587


state 465

    (281) condition -> expression .
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE

    ;               reduce using rule 281 (condition -> expression .)
    LOOP            reduce using rule 281 (condition -> expression .)
    IS              reduce using rule 281 (condition -> expression .)
    ARROW           reduce using rule 281 (condition -> expression .)
    THEN            reduce using rule 281 (condition -> expression .)
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250

    logical                        shift and go to state 251
    short_circuit                  shift and go to state 252

state 466

    (300) id_opt -> designator .

    ;               reduce using rule 300 (id_opt -> designator .)


state 467

    (337) subprog_body -> subprog_spec_is_push decl_part block_body END id_opt . ;

    ;               shift and go to state 588


state 468

    (510) record_type_spec -> FOR mark USE RECORD . align_opt comp_loc_s END RECORD ;
    (511) align_opt -> .
    (512) align_opt -> . AT MOD expression ;

    END             reduce using rule 511 (align_opt -> .)
    IDENTIFIER      reduce using rule 511 (align_opt -> .)
    AT              shift and go to state 590

    align_opt                      shift and go to state 589

state 469

    (515) address_spec -> FOR mark USE AT . expression ;
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 591

state 470

    (509) attrib_def -> FOR mark USE expression . ;
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE

    ;               shift and go to state 592
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250

    short_circuit                  shift and go to state 252
    logical                        shift and go to state 251

state 471

    (162) mark -> mark . simple_name .

    TICK            reduce using rule 162 (mark -> mark . simple_name .)
    .               reduce using rule 162 (mark -> mark . simple_name .)
    ;               reduce using rule 162 (mark -> mark . simple_name .)
    ASSIGNMENT      reduce using rule 162 (mark -> mark . simple_name .)
    )               reduce using rule 162 (mark -> mark . simple_name .)
    AT              reduce using rule 162 (mark -> mark . simple_name .)
    USE             reduce using rule 162 (mark -> mark . simple_name .)


state 472

    (161) mark -> mark TICK attribute_id .

    TICK            reduce using rule 161 (mark -> mark TICK attribute_id .)
    .               reduce using rule 161 (mark -> mark TICK attribute_id .)
    ;               reduce using rule 161 (mark -> mark TICK attribute_id .)
    ASSIGNMENT      reduce using rule 161 (mark -> mark TICK attribute_id .)
    )               reduce using rule 161 (mark -> mark TICK attribute_id .)
    AT              reduce using rule 161 (mark -> mark TICK attribute_id .)
    USE             reduce using rule 161 (mark -> mark TICK attribute_id .)


state 473

    (371) task_body -> TASK BODY simple_name IS . decl_part block_body END id_opt ;
    (457) body_stub -> TASK BODY simple_name IS . SEPARATE ;
    (137) decl_part -> .
    (138) decl_part -> . decl_item_or_body_s1
    (147) decl_item_or_body_s1 -> . decl_item_or_body
    (148) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (149) decl_item_or_body -> . body
    (150) decl_item_or_body -> . decl_item
    (151) body -> . subprog_body
    (152) body -> . pkg_body
    (153) body -> . task_body
    (154) body -> . prot_body
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (337) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (346) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (371) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (388) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (352) use_clause -> . USE name_s ;
    (353) use_clause -> . USE TYPE name_s ;
    (506) rep_spec -> . attrib_def
    (507) rep_spec -> . record_type_spec
    (508) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (336) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (316) subprog_decl -> . subprog_spec ;
    (317) subprog_decl -> . generic_subp_inst ;
    (318) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (339) pkg_decl -> . pkg_spec ;
    (340) pkg_decl -> . generic_pkg_inst ;
    (364) task_decl -> . task_spec ;
    (372) prot_decl -> . prot_spec ;
    (461) exception_decl -> . def_id_s : EXCEPTION ;
    (356) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (357) rename_decl -> . def_id_s : EXCEPTION renames ;
    (358) rename_decl -> . rename_unit
    (473) generic_decl -> . generic_formal_part subprog_spec ;
    (474) generic_decl -> . generic_formal_part pkg_spec ;
    (457) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (458) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (459) body_stub -> . subprog_spec IS SEPARATE ;
    (460) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (509) attrib_def -> . FOR mark USE expression ;
    (510) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (515) address_spec -> . FOR mark USE AT expression ;
    (319) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (320) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (321) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (503) generic_subp_inst -> . subprog_spec IS generic_inst
    (341) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (365) task_spec -> . TASK simple_name task_def
    (366) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (373) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (374) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (359) rename_unit -> . PACKAGE compound_name renames ;
    (360) rename_unit -> . subprog_spec renames ;
    (361) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (362) rename_unit -> . generic_formal_part subprog_spec renames ;
    (475) generic_formal_part -> . GENERIC
    (476) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    SEPARATE        shift and go to state 593
    BEGIN           reduce using rule 137 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    decl_item                      shift and go to state 53
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 594
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 474

    (366) task_spec -> TASK TYPE simple_name discrim_part_opt . task_def
    (367) task_def -> .
    (368) task_def -> . IS entry_decl_s rep_spec_s task_private_opt END id_opt

    ;               reduce using rule 367 (task_def -> .)
    IS              shift and go to state 318

    task_def                       shift and go to state 595

state 475

    (368) task_def -> IS entry_decl_s . rep_spec_s task_private_opt END id_opt
    (395) entry_decl_s -> entry_decl_s . entry_decl pragma_s
    (402) rep_spec_s -> .
    (403) rep_spec_s -> . rep_spec_s rep_spec pragma_s
    (396) entry_decl -> . ENTRY IDENTIFIER formal_part_opt ;
    (397) entry_decl -> . ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ;

    PRIVATE         reduce using rule 402 (rep_spec_s -> .)
    FOR             reduce using rule 402 (rep_spec_s -> .)
    END             reduce using rule 402 (rep_spec_s -> .)
    ENTRY           shift and go to state 544

    rep_spec_s                     shift and go to state 596
    entry_decl                     shift and go to state 597

state 476

    (394) entry_decl_s -> pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    ENTRY           reduce using rule 394 (entry_decl_s -> pragma_s .)
    FOR             reduce using rule 394 (entry_decl_s -> pragma_s .)
    END             reduce using rule 394 (entry_decl_s -> pragma_s .)
    PRIVATE         reduce using rule 394 (entry_decl_s -> pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 477

    (346) pkg_body -> PACKAGE BODY compound_name IS . decl_part body_opt END c_id_opt ;
    (458) body_stub -> PACKAGE BODY compound_name IS . SEPARATE ;
    (137) decl_part -> .
    (138) decl_part -> . decl_item_or_body_s1
    (147) decl_item_or_body_s1 -> . decl_item_or_body
    (148) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (149) decl_item_or_body -> . body
    (150) decl_item_or_body -> . decl_item
    (151) body -> . subprog_body
    (152) body -> . pkg_body
    (153) body -> . task_body
    (154) body -> . prot_body
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (337) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (346) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (371) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (388) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (352) use_clause -> . USE name_s ;
    (353) use_clause -> . USE TYPE name_s ;
    (506) rep_spec -> . attrib_def
    (507) rep_spec -> . record_type_spec
    (508) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (336) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (316) subprog_decl -> . subprog_spec ;
    (317) subprog_decl -> . generic_subp_inst ;
    (318) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (339) pkg_decl -> . pkg_spec ;
    (340) pkg_decl -> . generic_pkg_inst ;
    (364) task_decl -> . task_spec ;
    (372) prot_decl -> . prot_spec ;
    (461) exception_decl -> . def_id_s : EXCEPTION ;
    (356) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (357) rename_decl -> . def_id_s : EXCEPTION renames ;
    (358) rename_decl -> . rename_unit
    (473) generic_decl -> . generic_formal_part subprog_spec ;
    (474) generic_decl -> . generic_formal_part pkg_spec ;
    (457) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (458) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (459) body_stub -> . subprog_spec IS SEPARATE ;
    (460) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (509) attrib_def -> . FOR mark USE expression ;
    (510) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (515) address_spec -> . FOR mark USE AT expression ;
    (319) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (320) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (321) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (503) generic_subp_inst -> . subprog_spec IS generic_inst
    (341) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (365) task_spec -> . TASK simple_name task_def
    (366) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (373) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (374) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (359) rename_unit -> . PACKAGE compound_name renames ;
    (360) rename_unit -> . subprog_spec renames ;
    (361) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (362) rename_unit -> . generic_formal_part subprog_spec renames ;
    (475) generic_formal_part -> . GENERIC
    (476) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    SEPARATE        shift and go to state 598
    BEGIN           reduce using rule 137 (decl_part -> .)
    END             reduce using rule 137 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 498
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 478

    (116) discrim_spec -> error .

    )               reduce using rule 116 (discrim_spec -> error .)
    ;               reduce using rule 116 (discrim_spec -> error .)


state 479

    (112) discrim_part -> ( discrim_spec_s . )
    (114) discrim_spec_s -> discrim_spec_s . ; discrim_spec

    )               shift and go to state 599
    ;               shift and go to state 600


state 480

    (115) discrim_spec -> def_id_s . : access_opt mark init_opt
    (25) def_id_s -> def_id_s . , def_id

    :               shift and go to state 601
    ,               shift and go to state 180


state 481

    (113) discrim_spec_s -> discrim_spec .

    )               reduce using rule 113 (discrim_spec_s -> discrim_spec .)
    ;               reduce using rule 113 (discrim_spec_s -> discrim_spec .)


state 482

    (39) discrim_part_opt -> ( LESSMORE . )

    )               shift and go to state 602


state 483

    (41) type_completion -> IS . type_def
    (42) type_def -> . enumeration_type
    (43) type_def -> . integer_type
    (44) type_def -> . real_type
    (45) type_def -> . array_type
    (46) type_def -> . record_type
    (47) type_def -> . access_type
    (48) type_def -> . derived_type
    (49) type_def -> . private_type
    (65) enumeration_type -> . ( enum_id_s )
    (70) integer_type -> . range_spec
    (71) integer_type -> . MOD expression
    (75) real_type -> . float_type
    (76) real_type -> . fixed_type
    (80) array_type -> . unconstr_array_type
    (81) array_type -> . constr_array_type
    (97) record_type -> . tagged_opt limited_opt record_def
    (130) access_type -> . ACCESS subtype_ind
    (131) access_type -> . ACCESS CONSTANT subtype_ind
    (132) access_type -> . ACCESS ALL subtype_ind
    (133) access_type -> . ACCESS prot_opt PROCEDURE formal_part_opt
    (134) access_type -> . ACCESS prot_opt FUNCTION formal_part_opt RETURN mark
    (56) derived_type -> . NEW subtype_ind
    (57) derived_type -> . NEW subtype_ind WITH PRIVATE
    (58) derived_type -> . NEW subtype_ind WITH record_def
    (59) derived_type -> . ABSTRACT NEW subtype_ind WITH PRIVATE
    (60) derived_type -> . ABSTRACT NEW subtype_ind WITH record_def
    (349) private_type -> . tagged_opt limited_opt PRIVATE
    (72) range_spec -> . range_constraint
    (77) float_type -> . DIGITS expression range_spec_opt
    (78) fixed_type -> . DELTA expression range_spec
    (79) fixed_type -> . DELTA expression DIGITS expression range_spec_opt
    (82) unconstr_array_type -> . ARRAY ( index_s ) OF component_subtype_def
    (83) constr_array_type -> . ARRAY iter_index_constraint OF component_subtype_def
    (100) tagged_opt -> .
    (101) tagged_opt -> . TAGGED
    (102) tagged_opt -> . ABSTRACT TAGGED
    (61) range_constraint -> . RANGE range

    (               shift and go to state 612
    MOD             shift and go to state 624
    ACCESS          shift and go to state 620
    NEW             shift and go to state 608
    ABSTRACT        shift and go to state 603
    DIGITS          shift and go to state 613
    DELTA           shift and go to state 615
    ARRAY           shift and go to state 493
    LIMITED         reduce using rule 100 (tagged_opt -> .)
    PRIVATE         reduce using rule 100 (tagged_opt -> .)
    RECORD          reduce using rule 100 (tagged_opt -> .)
    NuLL            reduce using rule 100 (tagged_opt -> .)
    TAGGED          shift and go to state 614
    RANGE           shift and go to state 373

    access_type                    shift and go to state 605
    record_type                    shift and go to state 606
    real_type                      shift and go to state 607
    range_constraint               shift and go to state 604
    enumeration_type               shift and go to state 609
    private_type                   shift and go to state 610
    float_type                     shift and go to state 611
    tagged_opt                     shift and go to state 621
    integer_type                   shift and go to state 616
    array_type                     shift and go to state 617
    range_spec                     shift and go to state 618
    type_def                       shift and go to state 619
    constr_array_type              shift and go to state 495
    derived_type                   shift and go to state 622
    fixed_type                     shift and go to state 623
    unconstr_array_type            shift and go to state 497

state 484

    (36) type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion . ;

    ;               shift and go to state 625


state 485

    (51) subtype_ind -> name . constraint
    (52) subtype_ind -> name .
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id
    (53) constraint -> . range_constraint
    (54) constraint -> . decimal_digits_constraint
    (61) range_constraint -> . RANGE range
    (55) decimal_digits_constraint -> . DIGITS expression range_constr_opt

    ;               reduce using rule 52 (subtype_ind -> name .)
    WITH            reduce using rule 52 (subtype_ind -> name .)
    RENAMES         reduce using rule 52 (subtype_ind -> name .)
    ASSIGNMENT      reduce using rule 52 (subtype_ind -> name .)
    (               shift and go to state 245
    .               shift and go to state 246
    TICK            shift and go to state 256
    RANGE           shift and go to state 373
    DIGITS          shift and go to state 626

    constraint                     shift and go to state 627
    range_constraint               shift and go to state 628
    decimal_digits_constraint      shift and go to state 629

state 486

    (50) subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind . ;

    ;               shift and go to state 630


state 487

    (459) body_stub -> subprog_spec IS SEPARATE ; .

    PACKAGE         reduce using rule 459 (body_stub -> subprog_spec IS SEPARATE ; .)
    TASK            reduce using rule 459 (body_stub -> subprog_spec IS SEPARATE ; .)
    PROTECTED       reduce using rule 459 (body_stub -> subprog_spec IS SEPARATE ; .)
    error           reduce using rule 459 (body_stub -> subprog_spec IS SEPARATE ; .)
    USE             reduce using rule 459 (body_stub -> subprog_spec IS SEPARATE ; .)
    PRAGMA          reduce using rule 459 (body_stub -> subprog_spec IS SEPARATE ; .)
    TYPE            reduce using rule 459 (body_stub -> subprog_spec IS SEPARATE ; .)
    SUBTYPE         reduce using rule 459 (body_stub -> subprog_spec IS SEPARATE ; .)
    FOR             reduce using rule 459 (body_stub -> subprog_spec IS SEPARATE ; .)
    PROCEDURE       reduce using rule 459 (body_stub -> subprog_spec IS SEPARATE ; .)
    FUNCTION        reduce using rule 459 (body_stub -> subprog_spec IS SEPARATE ; .)
    GENERIC         reduce using rule 459 (body_stub -> subprog_spec IS SEPARATE ; .)
    IDENTIFIER      reduce using rule 459 (body_stub -> subprog_spec IS SEPARATE ; .)
    BEGIN           reduce using rule 459 (body_stub -> subprog_spec IS SEPARATE ; .)
    PRIVATE         reduce using rule 459 (body_stub -> subprog_spec IS SEPARATE ; .)
    END             reduce using rule 459 (body_stub -> subprog_spec IS SEPARATE ; .)


state 488

    (357) rename_decl -> def_id_s : EXCEPTION renames . ;

    ;               shift and go to state 631


state 489

    (461) exception_decl -> def_id_s : EXCEPTION ; .

    error           reduce using rule 461 (exception_decl -> def_id_s : EXCEPTION ; .)
    USE             reduce using rule 461 (exception_decl -> def_id_s : EXCEPTION ; .)
    PRAGMA          reduce using rule 461 (exception_decl -> def_id_s : EXCEPTION ; .)
    TYPE            reduce using rule 461 (exception_decl -> def_id_s : EXCEPTION ; .)
    SUBTYPE         reduce using rule 461 (exception_decl -> def_id_s : EXCEPTION ; .)
    TASK            reduce using rule 461 (exception_decl -> def_id_s : EXCEPTION ; .)
    PACKAGE         reduce using rule 461 (exception_decl -> def_id_s : EXCEPTION ; .)
    PROTECTED       reduce using rule 461 (exception_decl -> def_id_s : EXCEPTION ; .)
    FOR             reduce using rule 461 (exception_decl -> def_id_s : EXCEPTION ; .)
    PROCEDURE       reduce using rule 461 (exception_decl -> def_id_s : EXCEPTION ; .)
    FUNCTION        reduce using rule 461 (exception_decl -> def_id_s : EXCEPTION ; .)
    GENERIC         reduce using rule 461 (exception_decl -> def_id_s : EXCEPTION ; .)
    IDENTIFIER      reduce using rule 461 (exception_decl -> def_id_s : EXCEPTION ; .)
    PRIVATE         reduce using rule 461 (exception_decl -> def_id_s : EXCEPTION ; .)
    END             reduce using rule 461 (exception_decl -> def_id_s : EXCEPTION ; .)
    BEGIN           reduce using rule 461 (exception_decl -> def_id_s : EXCEPTION ; .)


state 490

    (35) number_decl -> def_id_s : CONSTANT ASSIGNMENT . expression ;
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 632

state 491

    (30) object_qualifier_opt -> ALIASED CONSTANT .

    ARRAY           reduce using rule 30 (object_qualifier_opt -> ALIASED CONSTANT .)
    IDENTIFIER      reduce using rule 30 (object_qualifier_opt -> ALIASED CONSTANT .)
    STRING          reduce using rule 30 (object_qualifier_opt -> ALIASED CONSTANT .)


state 492

    (32) object_subtype_def -> array_type .

    ASSIGNMENT      reduce using rule 32 (object_subtype_def -> array_type .)
    ;               reduce using rule 32 (object_subtype_def -> array_type .)


state 493

    (82) unconstr_array_type -> ARRAY . ( index_s ) OF component_subtype_def
    (83) constr_array_type -> ARRAY . iter_index_constraint OF component_subtype_def
    (90) iter_index_constraint -> . ( iter_discrete_range_s )

    (               shift and go to state 633

    iter_index_constraint          shift and go to state 634

state 494

    (23) object_decl -> def_id_s : object_qualifier_opt object_subtype_def . init_opt ;
    (33) init_opt -> .
    (34) init_opt -> . ASSIGNMENT expression

    ;               reduce using rule 33 (init_opt -> .)
    ASSIGNMENT      shift and go to state 635

    init_opt                       shift and go to state 636

state 495

    (81) array_type -> constr_array_type .

    ASSIGNMENT      reduce using rule 81 (array_type -> constr_array_type .)
    ;               reduce using rule 81 (array_type -> constr_array_type .)


state 496

    (356) rename_decl -> def_id_s : object_qualifier_opt subtype_ind . renames ;
    (31) object_subtype_def -> subtype_ind .
    (363) renames -> . RENAMES name

    ASSIGNMENT      reduce using rule 31 (object_subtype_def -> subtype_ind .)
    ;               reduce using rule 31 (object_subtype_def -> subtype_ind .)
    RENAMES         shift and go to state 95

    renames                        shift and go to state 637

state 497

    (80) array_type -> unconstr_array_type .

    ASSIGNMENT      reduce using rule 80 (array_type -> unconstr_array_type .)
    ;               reduce using rule 80 (array_type -> unconstr_array_type .)


state 498

    (346) pkg_body -> PACKAGE BODY compound_name IS decl_part . body_opt END c_id_opt ;
    (347) body_opt -> .
    (348) body_opt -> . block_body
    (304) block_body -> . BEGIN handled_stmt_s

    END             reduce using rule 347 (body_opt -> .)
    BEGIN           shift and go to state 163

    body_opt                       shift and go to state 638
    block_body                     shift and go to state 639

state 499

    (142) decl_item_s1 -> decl_item_s1 decl_item .

    error           reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    USE             reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    PRAGMA          reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    TYPE            reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    SUBTYPE         reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    TASK            reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    PACKAGE         reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    PROTECTED       reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    FOR             reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    PROCEDURE       reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    FUNCTION        reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    GENERIC         reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    IDENTIFIER      reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    END             reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)
    PRIVATE         reduce using rule 142 (decl_item_s1 -> decl_item_s1 decl_item .)


state 500

    (460) body_stub -> PROTECTED BODY . simple_name IS SEPARATE ;
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 640

state 501

    (343) private_part -> PRIVATE . decl_item_s
    (139) decl_item_s -> .
    (140) decl_item_s -> . decl_item_s1
    (141) decl_item_s1 -> . decl_item
    (142) decl_item_s1 -> . decl_item_s1 decl_item
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (352) use_clause -> . USE name_s ;
    (353) use_clause -> . USE TYPE name_s ;
    (506) rep_spec -> . attrib_def
    (507) rep_spec -> . record_type_spec
    (508) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (316) subprog_decl -> . subprog_spec ;
    (317) subprog_decl -> . generic_subp_inst ;
    (318) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (339) pkg_decl -> . pkg_spec ;
    (340) pkg_decl -> . generic_pkg_inst ;
    (364) task_decl -> . task_spec ;
    (372) prot_decl -> . prot_spec ;
    (461) exception_decl -> . def_id_s : EXCEPTION ;
    (356) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (357) rename_decl -> . def_id_s : EXCEPTION renames ;
    (358) rename_decl -> . rename_unit
    (473) generic_decl -> . generic_formal_part subprog_spec ;
    (474) generic_decl -> . generic_formal_part pkg_spec ;
    (457) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (458) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (459) body_stub -> . subprog_spec IS SEPARATE ;
    (460) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (509) attrib_def -> . FOR mark USE expression ;
    (510) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (515) address_spec -> . FOR mark USE AT expression ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (319) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (320) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (321) subprog_spec -> . FUNCTION designator
    (503) generic_subp_inst -> . subprog_spec IS generic_inst
    (336) subprog_spec_is_push -> . subprog_spec IS
    (341) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (365) task_spec -> . TASK simple_name task_def
    (366) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (373) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (374) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (359) rename_unit -> . PACKAGE compound_name renames ;
    (360) rename_unit -> . subprog_spec renames ;
    (361) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (362) rename_unit -> . generic_formal_part subprog_spec renames ;
    (475) generic_formal_part -> . GENERIC
    (476) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    END             reduce using rule 139 (decl_item_s -> .)
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    TASK            shift and go to state 339
    PACKAGE         shift and go to state 340
    PROTECTED       shift and go to state 336
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    task_decl                      shift and go to state 60
    subtype_decl                   shift and go to state 61
    rep_spec                       shift and go to state 82
    decl_item_s1                   shift and go to state 335
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    decl_item                      shift and go to state 337
    subprog_spec_is_push           shift and go to state 341
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 342
    def_id_s                       shift and go to state 88
    task_spec                      shift and go to state 65
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    generic_subp_inst              shift and go to state 29
    def_id                         shift and go to state 89
    rename_decl                    shift and go to state 90
    type_decl                      shift and go to state 56
    rename_unit                    shift and go to state 91
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    subprog_decl                   shift and go to state 58
    decl_item_s                    shift and go to state 641
    pragma                         shift and go to state 74
    pkg_spec                       shift and go to state 37
    number_decl                    shift and go to state 93

state 502

    (341) pkg_spec -> PACKAGE compound_name IS decl_item_s private_part . END c_id_opt

    END             shift and go to state 642


state 503

    (457) body_stub -> TASK BODY . simple_name IS SEPARATE ;
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 643

state 504

    (458) body_stub -> PACKAGE BODY . compound_name IS SEPARATE ;
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 644
    simple_name                    shift and go to state 41

state 505

    (459) body_stub -> subprog_spec IS . SEPARATE ;
    (503) generic_subp_inst -> subprog_spec IS . generic_inst
    (336) subprog_spec_is_push -> subprog_spec IS .
    (505) generic_inst -> . NEW name

    SEPARATE        shift and go to state 325
    ABSTRACT        reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    NEW             shift and go to state 184

    generic_inst                   shift and go to state 185

state 506

    (326) formal_part -> ( param_s ) .

    WHEN            reduce using rule 326 (formal_part -> ( param_s ) .)
    RETURN          reduce using rule 326 (formal_part -> ( param_s ) .)
    ;               reduce using rule 326 (formal_part -> ( param_s ) .)
    IS              reduce using rule 326 (formal_part -> ( param_s ) .)
    RENAMES         reduce using rule 326 (formal_part -> ( param_s ) .)
    DO              reduce using rule 326 (formal_part -> ( param_s ) .)


state 507

    (328) param_s -> param_s ; . param
    (329) param -> . def_id_s : mode mark init_opt
    (330) param -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    error           shift and go to state 109
    IDENTIFIER      shift and go to state 76

    param                          shift and go to state 645
    def_id                         shift and go to state 89
    def_id_s                       shift and go to state 105

state 508

    (480) generic_formal -> WITH FUNCTION designator formal_part_opt . RETURN name subp_default ;

    RETURN          shift and go to state 646


state 509

    (481) generic_formal -> WITH PACKAGE simple_name IS . NEW name ( LESSMORE ) ;
    (482) generic_formal -> WITH PACKAGE simple_name IS . NEW name ;

    NEW             shift and go to state 647


state 510

    (479) generic_formal -> WITH PROCEDURE simple_name formal_part_opt . subp_default ;
    (487) subp_default -> .
    (488) subp_default -> . IS name
    (489) subp_default -> . IS LESSMORE

    ;               reduce using rule 487 (subp_default -> .)
    IS              shift and go to state 648

    subp_default                   shift and go to state 649

state 511

    (334) mode -> IN OUT .

    IDENTIFIER      reduce using rule 334 (mode -> IN OUT .)


state 512

    (329) param -> def_id_s : mode mark . init_opt
    (161) mark -> mark . TICK attribute_id
    (162) mark -> mark . . simple_name
    (33) init_opt -> .
    (34) init_opt -> . ASSIGNMENT expression

    TICK            shift and go to state 315
    .               shift and go to state 314
    ;               reduce using rule 33 (init_opt -> .)
    )               reduce using rule 33 (init_opt -> .)
    ASSIGNMENT      shift and go to state 635

    init_opt                       shift and go to state 650

state 513

    (361) rename_unit -> generic_formal_part PACKAGE compound_name renames ; .

    PACKAGE         reduce using rule 361 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    TASK            reduce using rule 361 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    PROTECTED       reduce using rule 361 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    error           reduce using rule 361 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    USE             reduce using rule 361 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    PRAGMA          reduce using rule 361 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    TYPE            reduce using rule 361 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    SUBTYPE         reduce using rule 361 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    FOR             reduce using rule 361 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    PROCEDURE       reduce using rule 361 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    FUNCTION        reduce using rule 361 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    GENERIC         reduce using rule 361 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    IDENTIFIER      reduce using rule 361 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    BEGIN           reduce using rule 361 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    END             reduce using rule 361 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    PRIVATE         reduce using rule 361 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    WITH            reduce using rule 361 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    SEPARATE        reduce using rule 361 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    $end            reduce using rule 361 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)


state 514

    (478) generic_formal -> TYPE simple_name generic_discrim_part_opt IS . generic_type_def ;
    (490) generic_type_def -> . ( LESSMORE )
    (491) generic_type_def -> . RANGE LESSMORE
    (492) generic_type_def -> . MOD LESSMORE
    (493) generic_type_def -> . DELTA LESSMORE
    (494) generic_type_def -> . DELTA LESSMORE DIGITS LESSMORE
    (495) generic_type_def -> . DIGITS LESSMORE
    (496) generic_type_def -> . array_type
    (497) generic_type_def -> . access_type
    (498) generic_type_def -> . private_type
    (499) generic_type_def -> . generic_derived_type
    (80) array_type -> . unconstr_array_type
    (81) array_type -> . constr_array_type
    (130) access_type -> . ACCESS subtype_ind
    (131) access_type -> . ACCESS CONSTANT subtype_ind
    (132) access_type -> . ACCESS ALL subtype_ind
    (133) access_type -> . ACCESS prot_opt PROCEDURE formal_part_opt
    (134) access_type -> . ACCESS prot_opt FUNCTION formal_part_opt RETURN mark
    (349) private_type -> . tagged_opt limited_opt PRIVATE
    (500) generic_derived_type -> . NEW subtype_ind
    (501) generic_derived_type -> . NEW subtype_ind WITH PRIVATE
    (502) generic_derived_type -> . ABSTRACT NEW subtype_ind WITH PRIVATE
    (82) unconstr_array_type -> . ARRAY ( index_s ) OF component_subtype_def
    (83) constr_array_type -> . ARRAY iter_index_constraint OF component_subtype_def
    (100) tagged_opt -> .
    (101) tagged_opt -> . TAGGED
    (102) tagged_opt -> . ABSTRACT TAGGED

    (               shift and go to state 656
    RANGE           shift and go to state 658
    MOD             shift and go to state 663
    DELTA           shift and go to state 662
    DIGITS          shift and go to state 655
    ACCESS          shift and go to state 620
    NEW             shift and go to state 653
    ABSTRACT        shift and go to state 651
    ARRAY           shift and go to state 493
    LIMITED         reduce using rule 100 (tagged_opt -> .)
    PRIVATE         reduce using rule 100 (tagged_opt -> .)
    TAGGED          shift and go to state 614

    private_type                   shift and go to state 657
    tagged_opt                     shift and go to state 661
    constr_array_type              shift and go to state 495
    access_type                    shift and go to state 659
    generic_derived_type           shift and go to state 654
    generic_type_def               shift and go to state 652
    array_type                     shift and go to state 660
    unconstr_array_type            shift and go to state 497

state 515

    (486) generic_discrim_part_opt -> ( LESSMORE . )

    )               shift and go to state 664


state 516

    (320) subprog_spec -> FUNCTION designator formal_part_opt RETURN name .
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id

    IS              reduce using rule 320 (subprog_spec -> FUNCTION designator formal_part_opt RETURN name .)
    ;               reduce using rule 320 (subprog_spec -> FUNCTION designator formal_part_opt RETURN name .)
    RENAMES         reduce using rule 320 (subprog_spec -> FUNCTION designator formal_part_opt RETURN name .)
    (               shift and go to state 245
    .               shift and go to state 246
    TICK            shift and go to state 256


state 517

    (62) range -> simple_expression DOTDOT simple_expression .
    (222) simple_expression -> simple_expression . adding term
    (225) adding -> . +
    (226) adding -> . -
    (227) adding -> . &

    )               reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    ,               reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    ARROW           reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    |               reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    ;               reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    LOOP            reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    AND             reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    OR              reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    XOR             reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    WITH            reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    IS              reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    THEN            reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    RANGE           reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    DIGITS          reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    RENAMES         reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    ASSIGNMENT      reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    +               shift and go to state 211
    -               shift and go to state 213
    &               shift and go to state 212

    adding                         shift and go to state 209

state 518

    (124) choice_s -> choice_s | choice .

    ARROW           reduce using rule 124 (choice_s -> choice_s | choice .)
    |               reduce using rule 124 (choice_s -> choice_s | choice .)


state 519

    (126) choice -> discrete_with_range .

    ARROW           reduce using rule 126 (choice -> discrete_with_range .)
    |               reduce using rule 126 (choice -> discrete_with_range .)


state 520

    (125) choice -> expression .
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE

    ARROW           reduce using rule 125 (choice -> expression .)
    |               reduce using rule 125 (choice -> expression .)
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250

    logical                        shift and go to state 251
    short_circuit                  shift and go to state 252

state 521

    (199) comp_assoc -> choice_s ARROW expression .
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE

    )               reduce using rule 199 (comp_assoc -> choice_s ARROW expression .)
    ,               reduce using rule 199 (comp_assoc -> choice_s ARROW expression .)
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250

    short_circuit                  shift and go to state 252
    logical                        shift and go to state 251

state 522

    (198) value_s_2 -> value_s_2 , value .

    )               reduce using rule 198 (value_s_2 -> value_s_2 , value .)
    ,               reduce using rule 198 (value_s_2 -> value_s_2 , value .)


state 523

    (63) range -> name . TICK RANGE
    (64) range -> name . TICK RANGE ( expression )
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id
    (239) primary -> name .
    (245) qualified -> name . TICK parenthesized_primary

    TICK            shift and go to state 375
    (               shift and go to state 245
    .               shift and go to state 246
    STARSTAR        reduce using rule 239 (primary -> name .)
    *               reduce using rule 239 (primary -> name .)
    /               reduce using rule 239 (primary -> name .)
    MOD             reduce using rule 239 (primary -> name .)
    REM             reduce using rule 239 (primary -> name .)
    DOTDOT          reduce using rule 239 (primary -> name .)
    +               reduce using rule 239 (primary -> name .)
    -               reduce using rule 239 (primary -> name .)
    &               reduce using rule 239 (primary -> name .)


state 524

    (61) range_constraint -> RANGE range .

    )               reduce using rule 61 (range_constraint -> RANGE range .)
    ,               reduce using rule 61 (range_constraint -> RANGE range .)
    ;               reduce using rule 61 (range_constraint -> RANGE range .)
    RENAMES         reduce using rule 61 (range_constraint -> RANGE range .)
    ASSIGNMENT      reduce using rule 61 (range_constraint -> RANGE range .)
    WITH            reduce using rule 61 (range_constraint -> RANGE range .)
    ARROW           reduce using rule 61 (range_constraint -> RANGE range .)
    |               reduce using rule 61 (range_constraint -> RANGE range .)
    LOOP            reduce using rule 61 (range_constraint -> RANGE range .)


state 525

    (63) range -> name TICK RANGE .
    (64) range -> name TICK RANGE . ( expression )

    )               reduce using rule 63 (range -> name TICK RANGE .)
    ,               reduce using rule 63 (range -> name TICK RANGE .)
    ARROW           reduce using rule 63 (range -> name TICK RANGE .)
    |               reduce using rule 63 (range -> name TICK RANGE .)
    ;               reduce using rule 63 (range -> name TICK RANGE .)
    LOOP            reduce using rule 63 (range -> name TICK RANGE .)
    AND             reduce using rule 63 (range -> name TICK RANGE .)
    OR              reduce using rule 63 (range -> name TICK RANGE .)
    XOR             reduce using rule 63 (range -> name TICK RANGE .)
    WITH            reduce using rule 63 (range -> name TICK RANGE .)
    IS              reduce using rule 63 (range -> name TICK RANGE .)
    THEN            reduce using rule 63 (range -> name TICK RANGE .)
    RANGE           reduce using rule 63 (range -> name TICK RANGE .)
    DIGITS          reduce using rule 63 (range -> name TICK RANGE .)
    RENAMES         reduce using rule 63 (range -> name TICK RANGE .)
    ASSIGNMENT      reduce using rule 63 (range -> name TICK RANGE .)
    (               shift and go to state 665


state 526

    (197) value_s_2 -> value , value .

    )               reduce using rule 197 (value_s_2 -> value , value .)
    ,               reduce using rule 197 (value_s_2 -> value , value .)


state 527

    (196) aggregate -> ( NuLL RECORD ) .

    STARSTAR        reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    *               reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    /               reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    MOD             reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    REM             reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    DOTDOT          reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    =               reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    NOTEQUAL        reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    <               reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    LESSEQ          reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    >               reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    GREATEREQ       reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    IN              reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    NOT             reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    +               reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    -               reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    &               reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    AND             reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    OR              reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    XOR             reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    )               reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    ,               reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    ARROW           reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    |               reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    ;               reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    WITH            reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    IS              reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    THEN            reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    LOOP            reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    RANGE           reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    DIGITS          reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    RENAMES         reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)
    ASSIGNMENT      reduce using rule 196 (aggregate -> ( NuLL RECORD ) .)


state 528

    (194) aggregate -> ( expression WITH value_s . )
    (172) value_s -> value_s . , value

    )               shift and go to state 666
    ,               shift and go to state 531


state 529

    (195) aggregate -> ( expression WITH NuLL . RECORD )
    (191) literal -> NuLL .

    RECORD          shift and go to state 667
    STARSTAR        reduce using rule 191 (literal -> NuLL .)
    *               reduce using rule 191 (literal -> NuLL .)
    /               reduce using rule 191 (literal -> NuLL .)
    MOD             reduce using rule 191 (literal -> NuLL .)
    REM             reduce using rule 191 (literal -> NuLL .)
    DOTDOT          reduce using rule 191 (literal -> NuLL .)
    =               reduce using rule 191 (literal -> NuLL .)
    NOTEQUAL        reduce using rule 191 (literal -> NuLL .)
    <               reduce using rule 191 (literal -> NuLL .)
    LESSEQ          reduce using rule 191 (literal -> NuLL .)
    >               reduce using rule 191 (literal -> NuLL .)
    GREATEREQ       reduce using rule 191 (literal -> NuLL .)
    IN              reduce using rule 191 (literal -> NuLL .)
    NOT             reduce using rule 191 (literal -> NuLL .)
    +               reduce using rule 191 (literal -> NuLL .)
    -               reduce using rule 191 (literal -> NuLL .)
    &               reduce using rule 191 (literal -> NuLL .)
    AND             reduce using rule 191 (literal -> NuLL .)
    OR              reduce using rule 191 (literal -> NuLL .)
    XOR             reduce using rule 191 (literal -> NuLL .)
    )               reduce using rule 191 (literal -> NuLL .)
    ,               reduce using rule 191 (literal -> NuLL .)
    ARROW           reduce using rule 191 (literal -> NuLL .)
    |               reduce using rule 191 (literal -> NuLL .)


state 530

    (170) indexed_comp -> name ( value_s ) .

    TICK            reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    (               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    .               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    STARSTAR        reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    *               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    /               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    MOD             reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    REM             reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    =               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    NOTEQUAL        reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    <               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    LESSEQ          reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    >               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    GREATEREQ       reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    IN              reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    NOT             reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    +               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    -               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    &               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    )               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    AND             reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    OR              reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    XOR             reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    RANGE           reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    DOTDOT          reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    DIGITS          reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    ASSIGNMENT      reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    ;               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    ARROW           reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    |               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    ,               reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    WITH            reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    IS              reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    THEN            reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    LOOP            reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    RENAMES         reduce using rule 170 (indexed_comp -> name ( value_s ) .)
    WHEN            reduce using rule 170 (indexed_comp -> name ( value_s ) .)


state 531

    (172) value_s -> value_s , . value
    (173) value -> . expression
    (174) value -> . comp_assoc
    (175) value -> . discrete_with_range
    (176) value -> . error
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (199) comp_assoc -> . choice_s ARROW expression
    (128) discrete_with_range -> . name range_constraint
    (129) discrete_with_range -> . range
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (123) choice_s -> . choice
    (124) choice_s -> . choice_s | choice
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name TICK RANGE
    (64) range -> . name TICK RANGE ( expression )
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (125) choice -> . expression
    (126) choice -> . discrete_with_range
    (127) choice -> . OTHERS
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 234
    OTHERS          shift and go to state 224
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 384
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    choice_s                       shift and go to state 226
    comp_assoc                     shift and go to state 385
    factor                         shift and go to state 137
    choice                         shift and go to state 228
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    discrete_with_range            shift and go to state 230
    term                           shift and go to state 146
    name                           shift and go to state 231
    operator_symbol                shift and go to state 149
    value                          shift and go to state 668
    range                          shift and go to state 233
    expression                     shift and go to state 387

state 532

    (388) prot_body -> PROTECTED BODY . simple_name IS prot_op_body_s END id_opt ;
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 669

state 533

    (371) task_body -> TASK BODY . simple_name IS decl_part block_body END id_opt ;
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 670

state 534

    (336) subprog_spec_is_push -> subprog_spec IS .

    PACKAGE         reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    TASK            reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    PROTECTED       reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    error           reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    USE             reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    PRAGMA          reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    TYPE            reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    SUBTYPE         reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    FOR             reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    PROCEDURE       reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    FUNCTION        reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    GENERIC         reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    IDENTIFIER      reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)
    BEGIN           reduce using rule 336 (subprog_spec_is_push -> subprog_spec IS .)


state 535

    (460) body_stub -> PROTECTED BODY simple_name IS SEPARATE . ;

    ;               shift and go to state 671


state 536

    (388) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s . END id_opt ;
    (390) prot_op_body_s -> prot_op_body_s . prot_op_body pragma_s
    (391) prot_op_body -> . entry_body
    (392) prot_op_body -> . subprog_body
    (393) prot_op_body -> . subprog_spec ;
    (398) entry_body -> . ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part
    (399) entry_body -> . ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part
    (337) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (319) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (320) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (321) subprog_spec -> . FUNCTION designator
    (336) subprog_spec_is_push -> . subprog_spec IS

    END             shift and go to state 674
    ENTRY           shift and go to state 677
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36

    subprog_body                   shift and go to state 672
    prot_op_body                   shift and go to state 676
    entry_body                     shift and go to state 675
    subprog_spec                   shift and go to state 673
    subprog_spec_is_push           shift and go to state 409

state 537

    (389) prot_op_body_s -> pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 389 (prot_op_body_s -> pragma_s .)
    ENTRY           reduce using rule 389 (prot_op_body_s -> pragma_s .)
    PROCEDURE       reduce using rule 389 (prot_op_body_s -> pragma_s .)
    FUNCTION        reduce using rule 389 (prot_op_body_s -> pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 538

    (382) prot_op_decl -> rep_spec .

    error           reduce using rule 382 (prot_op_decl -> rep_spec .)
    ENTRY           reduce using rule 382 (prot_op_decl -> rep_spec .)
    PROCEDURE       reduce using rule 382 (prot_op_decl -> rep_spec .)
    FUNCTION        reduce using rule 382 (prot_op_decl -> rep_spec .)
    PRAGMA          reduce using rule 382 (prot_op_decl -> rep_spec .)
    FOR             reduce using rule 382 (prot_op_decl -> rep_spec .)
    IDENTIFIER      reduce using rule 382 (prot_op_decl -> rep_spec .)
    END             reduce using rule 382 (prot_op_decl -> rep_spec .)
    PRIVATE         reduce using rule 382 (prot_op_decl -> rep_spec .)


state 539

    (380) prot_op_decl -> entry_decl .

    error           reduce using rule 380 (prot_op_decl -> entry_decl .)
    ENTRY           reduce using rule 380 (prot_op_decl -> entry_decl .)
    PROCEDURE       reduce using rule 380 (prot_op_decl -> entry_decl .)
    FUNCTION        reduce using rule 380 (prot_op_decl -> entry_decl .)
    PRAGMA          reduce using rule 380 (prot_op_decl -> entry_decl .)
    FOR             reduce using rule 380 (prot_op_decl -> entry_decl .)
    IDENTIFIER      reduce using rule 380 (prot_op_decl -> entry_decl .)
    END             reduce using rule 380 (prot_op_decl -> entry_decl .)
    PRIVATE         reduce using rule 380 (prot_op_decl -> entry_decl .)


state 540

    (377) prot_private_opt -> PRIVATE . prot_elem_decl_s
    (384) prot_elem_decl_s -> .
    (385) prot_elem_decl_s -> . prot_elem_decl_s prot_elem_decl

    error           reduce using rule 384 (prot_elem_decl_s -> .)
    ENTRY           reduce using rule 384 (prot_elem_decl_s -> .)
    PROCEDURE       reduce using rule 384 (prot_elem_decl_s -> .)
    FUNCTION        reduce using rule 384 (prot_elem_decl_s -> .)
    PRAGMA          reduce using rule 384 (prot_elem_decl_s -> .)
    FOR             reduce using rule 384 (prot_elem_decl_s -> .)
    IDENTIFIER      reduce using rule 384 (prot_elem_decl_s -> .)
    END             reduce using rule 384 (prot_elem_decl_s -> .)

    prot_elem_decl_s               shift and go to state 678

state 541

    (381) prot_op_decl -> subprog_spec . ;

    ;               shift and go to state 679


state 542

    (375) prot_def -> IS prot_op_decl_s prot_private_opt . END id_opt

    END             shift and go to state 680


state 543

    (383) prot_op_decl -> pragma .

    error           reduce using rule 383 (prot_op_decl -> pragma .)
    ENTRY           reduce using rule 383 (prot_op_decl -> pragma .)
    PROCEDURE       reduce using rule 383 (prot_op_decl -> pragma .)
    FUNCTION        reduce using rule 383 (prot_op_decl -> pragma .)
    PRAGMA          reduce using rule 383 (prot_op_decl -> pragma .)
    FOR             reduce using rule 383 (prot_op_decl -> pragma .)
    IDENTIFIER      reduce using rule 383 (prot_op_decl -> pragma .)
    END             reduce using rule 383 (prot_op_decl -> pragma .)
    PRIVATE         reduce using rule 383 (prot_op_decl -> pragma .)


state 544

    (396) entry_decl -> ENTRY . IDENTIFIER formal_part_opt ;
    (397) entry_decl -> ENTRY . IDENTIFIER ( discrete_range ) formal_part_opt ;

    IDENTIFIER      shift and go to state 681


state 545

    (379) prot_op_decl_s -> prot_op_decl_s prot_op_decl .

    PRIVATE         reduce using rule 379 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    ENTRY           reduce using rule 379 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    PROCEDURE       reduce using rule 379 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    FUNCTION        reduce using rule 379 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    PRAGMA          reduce using rule 379 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    FOR             reduce using rule 379 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    END             reduce using rule 379 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)


state 546

    (374) prot_spec -> PROTECTED TYPE simple_name discrim_part_opt prot_def .

    ;               reduce using rule 374 (prot_spec -> PROTECTED TYPE simple_name discrim_part_opt prot_def .)


state 547

    (411) delay_stmt -> DELAY UNTIL expression . ;
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE

    ;               shift and go to state 682
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250

    logical                        shift and go to state 251
    short_circuit                  shift and go to state 252

state 548

    (410) delay_stmt -> DELAY expression ; .

    END             reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    LESSLESS        reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    error           reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    PRAGMA          reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    NuLL            reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    EXIT            reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    RETURN          reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    GOTO            reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    DELAY           reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    ABORT           reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    RAISE           reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    REQUEUE         reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    IF              reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    CASE            reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    IDENTIFIER      reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    ACCEPT          reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    SELECT          reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    STRING          reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    WHILE           reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    DECLARE         reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    FOR             reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    LOOP            reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    BEGIN           reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    OR              reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    ELSE            reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    THEN            reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    EXCEPTION       reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    ELSIF           reduce using rule 410 (delay_stmt -> DELAY expression ; .)
    WHEN            reduce using rule 410 (delay_stmt -> DELAY expression ; .)


state 549

    (294) iteration -> iter_part reverse_opt . discrete_range
    (93) discrete_range -> . name range_constr_opt
    (94) discrete_range -> . range
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name TICK RANGE
    (64) range -> . name TICK RANGE ( expression )
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    simple_expression              shift and go to state 361
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    parenthesized_primary          shift and go to state 141
    discrete_range                 shift and go to state 683
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 684
    operator_symbol                shift and go to state 149
    range                          shift and go to state 685
    qualified                      shift and go to state 150

state 550

    (297) reverse_opt -> REVERSE .

    IDENTIFIER      reduce using rule 297 (reverse_opt -> REVERSE .)
    STRING          reduce using rule 297 (reverse_opt -> REVERSE .)
    +               reduce using rule 297 (reverse_opt -> REVERSE .)
    -               reduce using rule 297 (reverse_opt -> REVERSE .)
    NOT             reduce using rule 297 (reverse_opt -> REVERSE .)
    ABS             reduce using rule 297 (reverse_opt -> REVERSE .)
    INTEGER         reduce using rule 297 (reverse_opt -> REVERSE .)
    BASE_INTEGER    reduce using rule 297 (reverse_opt -> REVERSE .)
    FLOAT           reduce using rule 297 (reverse_opt -> REVERSE .)
    BASE_FLOAT      reduce using rule 297 (reverse_opt -> REVERSE .)
    NuLL            reduce using rule 297 (reverse_opt -> REVERSE .)
    NEW             reduce using rule 297 (reverse_opt -> REVERSE .)
    (               reduce using rule 297 (reverse_opt -> REVERSE .)
    CHAR            reduce using rule 297 (reverse_opt -> REVERSE .)


state 551

    (295) iter_part -> FOR IDENTIFIER . IN

    IN              shift and go to state 686


state 552

    (301) block -> label_opt block_decl block_body . END id_opt ;

    END             shift and go to state 687


state 553

    (289) loop_stmt -> label_opt iteration basic_loop . id_opt ;
    (299) id_opt -> .
    (300) id_opt -> . designator
    (322) designator -> . compound_name
    (323) designator -> . STRING
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    ;               reduce using rule 299 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 466
    id_opt                         shift and go to state 688
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 554

    (298) basic_loop -> LOOP . statement_s END LOOP
    (248) statement_s -> . statement
    (249) statement_s -> . statement_s statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    statement_s                    shift and go to state 689
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 292
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 555

    (293) iteration -> WHILE condition .

    LOOP            reduce using rule 293 (iteration -> WHILE condition .)


state 556

    (303) block_decl -> DECLARE decl_part .

    BEGIN           reduce using rule 303 (block_decl -> DECLARE decl_part .)


state 557

    (315) goto_stmt -> GOTO name ; .

    LESSLESS        reduce using rule 315 (goto_stmt -> GOTO name ; .)
    error           reduce using rule 315 (goto_stmt -> GOTO name ; .)
    PRAGMA          reduce using rule 315 (goto_stmt -> GOTO name ; .)
    NuLL            reduce using rule 315 (goto_stmt -> GOTO name ; .)
    EXIT            reduce using rule 315 (goto_stmt -> GOTO name ; .)
    RETURN          reduce using rule 315 (goto_stmt -> GOTO name ; .)
    GOTO            reduce using rule 315 (goto_stmt -> GOTO name ; .)
    DELAY           reduce using rule 315 (goto_stmt -> GOTO name ; .)
    ABORT           reduce using rule 315 (goto_stmt -> GOTO name ; .)
    RAISE           reduce using rule 315 (goto_stmt -> GOTO name ; .)
    REQUEUE         reduce using rule 315 (goto_stmt -> GOTO name ; .)
    IF              reduce using rule 315 (goto_stmt -> GOTO name ; .)
    CASE            reduce using rule 315 (goto_stmt -> GOTO name ; .)
    IDENTIFIER      reduce using rule 315 (goto_stmt -> GOTO name ; .)
    ACCEPT          reduce using rule 315 (goto_stmt -> GOTO name ; .)
    SELECT          reduce using rule 315 (goto_stmt -> GOTO name ; .)
    STRING          reduce using rule 315 (goto_stmt -> GOTO name ; .)
    WHILE           reduce using rule 315 (goto_stmt -> GOTO name ; .)
    DECLARE         reduce using rule 315 (goto_stmt -> GOTO name ; .)
    FOR             reduce using rule 315 (goto_stmt -> GOTO name ; .)
    LOOP            reduce using rule 315 (goto_stmt -> GOTO name ; .)
    BEGIN           reduce using rule 315 (goto_stmt -> GOTO name ; .)
    OR              reduce using rule 315 (goto_stmt -> GOTO name ; .)
    ELSE            reduce using rule 315 (goto_stmt -> GOTO name ; .)
    END             reduce using rule 315 (goto_stmt -> GOTO name ; .)
    THEN            reduce using rule 315 (goto_stmt -> GOTO name ; .)
    WHEN            reduce using rule 315 (goto_stmt -> GOTO name ; .)
    EXCEPTION       reduce using rule 315 (goto_stmt -> GOTO name ; .)
    ELSIF           reduce using rule 315 (goto_stmt -> GOTO name ; .)


state 558

    (275) assign_stmt -> name ASSIGNMENT expression . ;
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE

    ;               shift and go to state 690
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250

    logical                        shift and go to state 251
    short_circuit                  shift and go to state 252

state 559

    (431) abort_stmt -> ABORT name_s ; .

    LESSLESS        reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    error           reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    PRAGMA          reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    NuLL            reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    EXIT            reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    RETURN          reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    GOTO            reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    DELAY           reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    ABORT           reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    RAISE           reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    REQUEUE         reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    IF              reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    CASE            reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    IDENTIFIER      reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    ACCEPT          reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    SELECT          reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    STRING          reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    WHILE           reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    DECLARE         reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    FOR             reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    LOOP            reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    BEGIN           reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    WHEN            reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    END             reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    EXCEPTION       reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    OR              reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    ELSE            reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    THEN            reduce using rule 431 (abort_stmt -> ABORT name_s ; .)
    ELSIF           reduce using rule 431 (abort_stmt -> ABORT name_s ; .)


state 560

    (273) label -> LESSLESS IDENTIFIER MOREMORE .

    LESSLESS        reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)
    error           reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)
    PRAGMA          reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)
    NuLL            reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)
    EXIT            reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)
    RETURN          reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)
    GOTO            reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)
    DELAY           reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)
    ABORT           reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)
    RAISE           reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)
    REQUEUE         reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)
    IF              reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)
    CASE            reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)
    IDENTIFIER      reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)
    ACCEPT          reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)
    SELECT          reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)
    STRING          reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)
    WHILE           reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)
    DECLARE         reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)
    FOR             reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)
    LOOP            reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)
    BEGIN           reduce using rule 273 (label -> LESSLESS IDENTIFIER MOREMORE .)


state 561

    (314) return_stmt -> RETURN expression ; .

    LESSLESS        reduce using rule 314 (return_stmt -> RETURN expression ; .)
    error           reduce using rule 314 (return_stmt -> RETURN expression ; .)
    PRAGMA          reduce using rule 314 (return_stmt -> RETURN expression ; .)
    NuLL            reduce using rule 314 (return_stmt -> RETURN expression ; .)
    EXIT            reduce using rule 314 (return_stmt -> RETURN expression ; .)
    RETURN          reduce using rule 314 (return_stmt -> RETURN expression ; .)
    GOTO            reduce using rule 314 (return_stmt -> RETURN expression ; .)
    DELAY           reduce using rule 314 (return_stmt -> RETURN expression ; .)
    ABORT           reduce using rule 314 (return_stmt -> RETURN expression ; .)
    RAISE           reduce using rule 314 (return_stmt -> RETURN expression ; .)
    REQUEUE         reduce using rule 314 (return_stmt -> RETURN expression ; .)
    IF              reduce using rule 314 (return_stmt -> RETURN expression ; .)
    CASE            reduce using rule 314 (return_stmt -> RETURN expression ; .)
    IDENTIFIER      reduce using rule 314 (return_stmt -> RETURN expression ; .)
    ACCEPT          reduce using rule 314 (return_stmt -> RETURN expression ; .)
    SELECT          reduce using rule 314 (return_stmt -> RETURN expression ; .)
    STRING          reduce using rule 314 (return_stmt -> RETURN expression ; .)
    WHILE           reduce using rule 314 (return_stmt -> RETURN expression ; .)
    DECLARE         reduce using rule 314 (return_stmt -> RETURN expression ; .)
    FOR             reduce using rule 314 (return_stmt -> RETURN expression ; .)
    LOOP            reduce using rule 314 (return_stmt -> RETURN expression ; .)
    BEGIN           reduce using rule 314 (return_stmt -> RETURN expression ; .)
    END             reduce using rule 314 (return_stmt -> RETURN expression ; .)
    THEN            reduce using rule 314 (return_stmt -> RETURN expression ; .)
    OR              reduce using rule 314 (return_stmt -> RETURN expression ; .)
    ELSE            reduce using rule 314 (return_stmt -> RETURN expression ; .)
    WHEN            reduce using rule 314 (return_stmt -> RETURN expression ; .)
    ELSIF           reduce using rule 314 (return_stmt -> RETURN expression ; .)
    EXCEPTION       reduce using rule 314 (return_stmt -> RETURN expression ; .)


state 562

    (409) entry_name -> entry_name ( . expression )
    (326) formal_part -> ( . param_s )
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (327) param_s -> . param
    (328) param_s -> . param_s ; param
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (329) param -> . def_id_s : mode mark init_opt
    (330) param -> . error
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (26) def_id -> . IDENTIFIER
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 109
    +               shift and go to state 133
    -               shift and go to state 134
    IDENTIFIER      shift and go to state 691
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    param                          shift and go to state 343
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    param_s                        shift and go to state 344
    literal                        shift and go to state 135
    def_id_s                       shift and go to state 105
    factor                         shift and go to state 137
    def_id                         shift and go to state 89
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    relation                       shift and go to state 125
    expression                     shift and go to state 692

state 563

    (407) accept_hdr -> ACCEPT entry_name formal_part_opt .

    ;               reduce using rule 407 (accept_hdr -> ACCEPT entry_name formal_part_opt .)
    DO              reduce using rule 407 (accept_hdr -> ACCEPT entry_name formal_part_opt .)


state 564

    (421) select_alt -> accept_stmt stmts_opt .

    OR              reduce using rule 421 (select_alt -> accept_stmt stmts_opt .)
    ELSE            reduce using rule 421 (select_alt -> accept_stmt stmts_opt .)
    END             reduce using rule 421 (select_alt -> accept_stmt stmts_opt .)


state 565

    (430) stmts_opt -> statement_s .
    (249) statement_s -> statement_s . statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    OR              reduce using rule 430 (stmts_opt -> statement_s .)
    ELSE            reduce using rule 430 (stmts_opt -> statement_s .)
    END             reduce using rule 430 (stmts_opt -> statement_s .)
    THEN            reduce using rule 430 (stmts_opt -> statement_s .)
    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 459
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 566

    (427) timed_entry_call -> SELECT entry_call stmts_opt . OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> SELECT entry_call stmts_opt . ELSE statement_s END SELECT ;
    (425) delay_or_entry_alt -> entry_call stmts_opt .

    OR              shift and go to state 694
    ELSE            shift and go to state 693
    THEN            reduce using rule 425 (delay_or_entry_alt -> entry_call stmts_opt .)


state 567

    (426) async_select -> SELECT delay_or_entry_alt THEN . ABORT statement_s END SELECT ;

    ABORT           shift and go to state 695


state 568

    (418) guarded_select_alt -> WHEN condition . ARROW select_alt

    ARROW           shift and go to state 696


state 569

    (416) select_wait -> SELECT guarded_select_alt or_select . else_opt END SELECT ;
    (420) or_select -> or_select . OR guarded_select_alt
    (282) else_opt -> .
    (283) else_opt -> . ELSE statement_s

    OR              shift and go to state 698
    END             reduce using rule 282 (else_opt -> .)
    ELSE            shift and go to state 583

    else_opt                       shift and go to state 697

state 570

    (424) delay_or_entry_alt -> delay_stmt stmts_opt .
    (422) select_alt -> delay_stmt stmts_opt .

    THEN            reduce using rule 424 (delay_or_entry_alt -> delay_stmt stmts_opt .)
    OR              reduce using rule 422 (select_alt -> delay_stmt stmts_opt .)
    ELSE            reduce using rule 422 (select_alt -> delay_stmt stmts_opt .)
    END             reduce using rule 422 (select_alt -> delay_stmt stmts_opt .)


state 571

    (423) select_alt -> TERMINATE ; .

    OR              reduce using rule 423 (select_alt -> TERMINATE ; .)
    ELSE            reduce using rule 423 (select_alt -> TERMINATE ; .)
    END             reduce using rule 423 (select_alt -> TERMINATE ; .)


state 572

    (284) case_stmt -> case_hdr pragma_s alternative_s . END CASE ;
    (287) alternative_s -> alternative_s . alternative
    (288) alternative -> . WHEN choice_s ARROW statement_s

    END             shift and go to state 700
    WHEN            shift and go to state 701

    alternative                    shift and go to state 699

state 573

    (470) raise_stmt -> RAISE name_opt ; .

    LESSLESS        reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    error           reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    PRAGMA          reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    NuLL            reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    EXIT            reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    RETURN          reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    GOTO            reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    DELAY           reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    ABORT           reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    RAISE           reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    REQUEUE         reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    IF              reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    CASE            reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    IDENTIFIER      reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    ACCEPT          reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    SELECT          reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    STRING          reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    WHILE           reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    DECLARE         reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    FOR             reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    LOOP            reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    BEGIN           reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    OR              reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    ELSE            reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    END             reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    THEN            reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    WHEN            reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    ELSIF           reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)
    EXCEPTION       reduce using rule 470 (raise_stmt -> RAISE name_opt ; .)


state 574

    (285) case_hdr -> CASE expression IS .

    PRAGMA          reduce using rule 285 (case_hdr -> CASE expression IS .)
    END             reduce using rule 285 (case_hdr -> CASE expression IS .)
    WHEN            reduce using rule 285 (case_hdr -> CASE expression IS .)


state 575

    (471) requeue_stmt -> REQUEUE name ; .

    LESSLESS        reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    error           reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    PRAGMA          reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    NuLL            reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    EXIT            reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    RETURN          reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    GOTO            reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    DELAY           reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    ABORT           reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    RAISE           reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    REQUEUE         reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    IF              reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    CASE            reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    IDENTIFIER      reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    ACCEPT          reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    SELECT          reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    STRING          reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    WHILE           reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    DECLARE         reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    FOR             reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    LOOP            reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    BEGIN           reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    OR              reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    ELSE            reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    END             reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    THEN            reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    WHEN            reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    EXCEPTION       reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)
    ELSIF           reduce using rule 471 (requeue_stmt -> REQUEUE name ; .)


state 576

    (472) requeue_stmt -> REQUEUE name WITH . ABORT ;

    ABORT           shift and go to state 702


state 577

    (406) accept_stmt -> accept_hdr DO handled_stmt_s . END id_opt ;

    END             shift and go to state 703


state 578

    (308) exit_stmt -> EXIT name_opt when_opt . ;

    ;               shift and go to state 704


state 579

    (312) when_opt -> WHEN . condition
    (281) condition -> . expression
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    condition                      shift and go to state 705
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 465

state 580

    (463) except_handler_part -> except_handler_part exception_handler .

    WHEN            reduce using rule 463 (except_handler_part -> except_handler_part exception_handler .)
    END             reduce using rule 463 (except_handler_part -> except_handler_part exception_handler .)


state 581

    (464) exception_handler -> WHEN . except_choice_s ARROW statement_s
    (465) exception_handler -> WHEN . IDENTIFIER : except_choice_s ARROW statement_s
    (466) except_choice_s -> . except_choice
    (467) except_choice_s -> . except_choice_s | except_choice
    (468) except_choice -> . name
    (469) except_choice -> . OTHERS
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 707
    OTHERS          shift and go to state 709
    STRING          shift and go to state 138

    name                           shift and go to state 710
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    except_choice_s                shift and go to state 706
    except_choice                  shift and go to state 708
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 582

    (462) except_handler_part -> EXCEPTION exception_handler .

    WHEN            reduce using rule 462 (except_handler_part -> EXCEPTION exception_handler .)
    END             reduce using rule 462 (except_handler_part -> EXCEPTION exception_handler .)


state 583

    (283) else_opt -> ELSE . statement_s
    (248) statement_s -> . statement
    (249) statement_s -> . statement_s statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    statement_s                    shift and go to state 711
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 292
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 584

    (276) if_stmt -> IF cond_clause_s else_opt . END IF ;

    END             shift and go to state 712


state 585

    (278) cond_clause_s -> cond_clause_s ELSIF . cond_clause
    (279) cond_clause -> . cond_part statement_s
    (280) cond_part -> . condition THEN
    (281) condition -> . expression
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    cond_clause                    shift and go to state 713
    cond_part                      shift and go to state 463
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    condition                      shift and go to state 464
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 465

state 586

    (279) cond_clause -> cond_part statement_s .
    (249) statement_s -> statement_s . statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    ELSIF           reduce using rule 279 (cond_clause -> cond_part statement_s .)
    ELSE            reduce using rule 279 (cond_clause -> cond_part statement_s .)
    END             reduce using rule 279 (cond_clause -> cond_part statement_s .)
    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 459
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 587

    (280) cond_part -> condition THEN .

    LESSLESS        reduce using rule 280 (cond_part -> condition THEN .)
    error           reduce using rule 280 (cond_part -> condition THEN .)
    PRAGMA          reduce using rule 280 (cond_part -> condition THEN .)
    NuLL            reduce using rule 280 (cond_part -> condition THEN .)
    EXIT            reduce using rule 280 (cond_part -> condition THEN .)
    RETURN          reduce using rule 280 (cond_part -> condition THEN .)
    GOTO            reduce using rule 280 (cond_part -> condition THEN .)
    DELAY           reduce using rule 280 (cond_part -> condition THEN .)
    ABORT           reduce using rule 280 (cond_part -> condition THEN .)
    RAISE           reduce using rule 280 (cond_part -> condition THEN .)
    REQUEUE         reduce using rule 280 (cond_part -> condition THEN .)
    IF              reduce using rule 280 (cond_part -> condition THEN .)
    CASE            reduce using rule 280 (cond_part -> condition THEN .)
    IDENTIFIER      reduce using rule 280 (cond_part -> condition THEN .)
    ACCEPT          reduce using rule 280 (cond_part -> condition THEN .)
    SELECT          reduce using rule 280 (cond_part -> condition THEN .)
    STRING          reduce using rule 280 (cond_part -> condition THEN .)
    WHILE           reduce using rule 280 (cond_part -> condition THEN .)
    DECLARE         reduce using rule 280 (cond_part -> condition THEN .)
    FOR             reduce using rule 280 (cond_part -> condition THEN .)
    LOOP            reduce using rule 280 (cond_part -> condition THEN .)
    BEGIN           reduce using rule 280 (cond_part -> condition THEN .)


state 588

    (337) subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .

    PACKAGE         reduce using rule 337 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    TASK            reduce using rule 337 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    PROTECTED       reduce using rule 337 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    error           reduce using rule 337 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    USE             reduce using rule 337 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    PRAGMA          reduce using rule 337 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    TYPE            reduce using rule 337 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    SUBTYPE         reduce using rule 337 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    FOR             reduce using rule 337 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    PROCEDURE       reduce using rule 337 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    FUNCTION        reduce using rule 337 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    GENERIC         reduce using rule 337 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    IDENTIFIER      reduce using rule 337 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    BEGIN           reduce using rule 337 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    PRIVATE         reduce using rule 337 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    WITH            reduce using rule 337 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    SEPARATE        reduce using rule 337 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    $end            reduce using rule 337 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    END             reduce using rule 337 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    ENTRY           reduce using rule 337 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)


state 589

    (510) record_type_spec -> FOR mark USE RECORD align_opt . comp_loc_s END RECORD ;
    (513) comp_loc_s -> .
    (514) comp_loc_s -> . comp_loc_s mark AT expression RANGE range ;

    END             reduce using rule 513 (comp_loc_s -> .)
    IDENTIFIER      reduce using rule 513 (comp_loc_s -> .)

    comp_loc_s                     shift and go to state 714

state 590

    (512) align_opt -> AT . MOD expression ;

    MOD             shift and go to state 715


state 591

    (515) address_spec -> FOR mark USE AT expression . ;
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE

    ;               shift and go to state 716
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250

    short_circuit                  shift and go to state 252
    logical                        shift and go to state 251

state 592

    (509) attrib_def -> FOR mark USE expression ; .

    PACKAGE         reduce using rule 509 (attrib_def -> FOR mark USE expression ; .)
    TASK            reduce using rule 509 (attrib_def -> FOR mark USE expression ; .)
    PROTECTED       reduce using rule 509 (attrib_def -> FOR mark USE expression ; .)
    error           reduce using rule 509 (attrib_def -> FOR mark USE expression ; .)
    USE             reduce using rule 509 (attrib_def -> FOR mark USE expression ; .)
    PRAGMA          reduce using rule 509 (attrib_def -> FOR mark USE expression ; .)
    TYPE            reduce using rule 509 (attrib_def -> FOR mark USE expression ; .)
    SUBTYPE         reduce using rule 509 (attrib_def -> FOR mark USE expression ; .)
    FOR             reduce using rule 509 (attrib_def -> FOR mark USE expression ; .)
    PROCEDURE       reduce using rule 509 (attrib_def -> FOR mark USE expression ; .)
    FUNCTION        reduce using rule 509 (attrib_def -> FOR mark USE expression ; .)
    GENERIC         reduce using rule 509 (attrib_def -> FOR mark USE expression ; .)
    IDENTIFIER      reduce using rule 509 (attrib_def -> FOR mark USE expression ; .)
    BEGIN           reduce using rule 509 (attrib_def -> FOR mark USE expression ; .)
    PRIVATE         reduce using rule 509 (attrib_def -> FOR mark USE expression ; .)
    END             reduce using rule 509 (attrib_def -> FOR mark USE expression ; .)
    ENTRY           reduce using rule 509 (attrib_def -> FOR mark USE expression ; .)


state 593

    (457) body_stub -> TASK BODY simple_name IS SEPARATE . ;

    ;               shift and go to state 717


state 594

    (371) task_body -> TASK BODY simple_name IS decl_part . block_body END id_opt ;
    (304) block_body -> . BEGIN handled_stmt_s

    BEGIN           shift and go to state 163

    block_body                     shift and go to state 718

state 595

    (366) task_spec -> TASK TYPE simple_name discrim_part_opt task_def .

    ;               reduce using rule 366 (task_spec -> TASK TYPE simple_name discrim_part_opt task_def .)


state 596

    (368) task_def -> IS entry_decl_s rep_spec_s . task_private_opt END id_opt
    (403) rep_spec_s -> rep_spec_s . rep_spec pragma_s
    (369) task_private_opt -> .
    (370) task_private_opt -> . PRIVATE entry_decl_s rep_spec_s
    (506) rep_spec -> . attrib_def
    (507) rep_spec -> . record_type_spec
    (508) rep_spec -> . address_spec
    (509) attrib_def -> . FOR mark USE expression ;
    (510) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (515) address_spec -> . FOR mark USE AT expression ;

    END             reduce using rule 369 (task_private_opt -> .)
    PRIVATE         shift and go to state 720
    FOR             shift and go to state 63

    record_type_spec               shift and go to state 68
    rep_spec                       shift and go to state 719
    attrib_def                     shift and go to state 70
    address_spec                   shift and go to state 52
    task_private_opt               shift and go to state 721

state 597

    (395) entry_decl_s -> entry_decl_s entry_decl . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    FOR             reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 722

state 598

    (458) body_stub -> PACKAGE BODY compound_name IS SEPARATE . ;

    ;               shift and go to state 723


state 599

    (112) discrim_part -> ( discrim_spec_s ) .

    IS              reduce using rule 112 (discrim_part -> ( discrim_spec_s ) .)
    ;               reduce using rule 112 (discrim_part -> ( discrim_spec_s ) .)


state 600

    (114) discrim_spec_s -> discrim_spec_s ; . discrim_spec
    (115) discrim_spec -> . def_id_s : access_opt mark init_opt
    (116) discrim_spec -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    error           shift and go to state 478
    IDENTIFIER      shift and go to state 76

    discrim_spec                   shift and go to state 724
    def_id                         shift and go to state 89
    def_id_s                       shift and go to state 480

state 601

    (115) discrim_spec -> def_id_s : . access_opt mark init_opt
    (117) access_opt -> .
    (118) access_opt -> . ACCESS

    IDENTIFIER      reduce using rule 117 (access_opt -> .)
    ACCESS          shift and go to state 725

    access_opt                     shift and go to state 726

state 602

    (39) discrim_part_opt -> ( LESSMORE ) .

    IS              reduce using rule 39 (discrim_part_opt -> ( LESSMORE ) .)
    ;               reduce using rule 39 (discrim_part_opt -> ( LESSMORE ) .)


state 603

    (59) derived_type -> ABSTRACT . NEW subtype_ind WITH PRIVATE
    (60) derived_type -> ABSTRACT . NEW subtype_ind WITH record_def
    (102) tagged_opt -> ABSTRACT . TAGGED

    NEW             shift and go to state 728
    TAGGED          shift and go to state 727


state 604

    (72) range_spec -> range_constraint .

    ;               reduce using rule 72 (range_spec -> range_constraint .)


state 605

    (47) type_def -> access_type .

    ;               reduce using rule 47 (type_def -> access_type .)


state 606

    (46) type_def -> record_type .

    ;               reduce using rule 46 (type_def -> record_type .)


state 607

    (44) type_def -> real_type .

    ;               reduce using rule 44 (type_def -> real_type .)


state 608

    (56) derived_type -> NEW . subtype_ind
    (57) derived_type -> NEW . subtype_ind WITH PRIVATE
    (58) derived_type -> NEW . subtype_ind WITH record_def
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 485
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    subtype_ind                    shift and go to state 729
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 609

    (42) type_def -> enumeration_type .

    ;               reduce using rule 42 (type_def -> enumeration_type .)


state 610

    (49) type_def -> private_type .

    ;               reduce using rule 49 (type_def -> private_type .)


state 611

    (75) real_type -> float_type .

    ;               reduce using rule 75 (real_type -> float_type .)


state 612

    (65) enumeration_type -> ( . enum_id_s )
    (66) enum_id_s -> . enum_id
    (67) enum_id_s -> . enum_id_s , enum_id
    (68) enum_id -> . IDENTIFIER
    (69) enum_id -> . CHAR

    IDENTIFIER      shift and go to state 732
    CHAR            shift and go to state 731

    enum_id                        shift and go to state 733
    enum_id_s                      shift and go to state 730

state 613

    (77) float_type -> DIGITS . expression range_spec_opt
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 734

state 614

    (101) tagged_opt -> TAGGED .

    LIMITED         reduce using rule 101 (tagged_opt -> TAGGED .)
    PRIVATE         reduce using rule 101 (tagged_opt -> TAGGED .)
    RECORD          reduce using rule 101 (tagged_opt -> TAGGED .)
    NuLL            reduce using rule 101 (tagged_opt -> TAGGED .)


state 615

    (78) fixed_type -> DELTA . expression range_spec
    (79) fixed_type -> DELTA . expression DIGITS expression range_spec_opt
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 735

state 616

    (43) type_def -> integer_type .

    ;               reduce using rule 43 (type_def -> integer_type .)


state 617

    (45) type_def -> array_type .

    ;               reduce using rule 45 (type_def -> array_type .)


state 618

    (70) integer_type -> range_spec .

    ;               reduce using rule 70 (integer_type -> range_spec .)


state 619

    (41) type_completion -> IS type_def .

    ;               reduce using rule 41 (type_completion -> IS type_def .)


state 620

    (130) access_type -> ACCESS . subtype_ind
    (131) access_type -> ACCESS . CONSTANT subtype_ind
    (132) access_type -> ACCESS . ALL subtype_ind
    (133) access_type -> ACCESS . prot_opt PROCEDURE formal_part_opt
    (134) access_type -> ACCESS . prot_opt FUNCTION formal_part_opt RETURN mark
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (135) prot_opt -> .
    (136) prot_opt -> . PROTECTED
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    CONSTANT        shift and go to state 736
    ALL             shift and go to state 739
    PROCEDURE       reduce using rule 135 (prot_opt -> .)
    FUNCTION        reduce using rule 135 (prot_opt -> .)
    PROTECTED       shift and go to state 738
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 485
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    prot_opt                       shift and go to state 737
    subtype_ind                    shift and go to state 740
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 621

    (97) record_type -> tagged_opt . limited_opt record_def
    (349) private_type -> tagged_opt . limited_opt PRIVATE
    (350) limited_opt -> .
    (351) limited_opt -> . LIMITED

    PRIVATE         reduce using rule 350 (limited_opt -> .)
    RECORD          reduce using rule 350 (limited_opt -> .)
    NuLL            reduce using rule 350 (limited_opt -> .)
    LIMITED         shift and go to state 741

    limited_opt                    shift and go to state 742

state 622

    (48) type_def -> derived_type .

    ;               reduce using rule 48 (type_def -> derived_type .)


state 623

    (76) real_type -> fixed_type .

    ;               reduce using rule 76 (real_type -> fixed_type .)


state 624

    (71) integer_type -> MOD . expression
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 743

state 625

    (36) type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .

    PACKAGE         reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    TASK            reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    PROTECTED       reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    error           reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    USE             reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    PRAGMA          reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    TYPE            reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    SUBTYPE         reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    FOR             reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    PROCEDURE       reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    FUNCTION        reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    GENERIC         reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    IDENTIFIER      reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    BEGIN           reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    END             reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    PRIVATE         reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)


state 626

    (55) decimal_digits_constraint -> DIGITS . expression range_constr_opt
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 744

state 627

    (51) subtype_ind -> name constraint .

    ;               reduce using rule 51 (subtype_ind -> name constraint .)
    WITH            reduce using rule 51 (subtype_ind -> name constraint .)
    RENAMES         reduce using rule 51 (subtype_ind -> name constraint .)
    ASSIGNMENT      reduce using rule 51 (subtype_ind -> name constraint .)


state 628

    (53) constraint -> range_constraint .

    ;               reduce using rule 53 (constraint -> range_constraint .)
    RENAMES         reduce using rule 53 (constraint -> range_constraint .)
    ASSIGNMENT      reduce using rule 53 (constraint -> range_constraint .)
    WITH            reduce using rule 53 (constraint -> range_constraint .)


state 629

    (54) constraint -> decimal_digits_constraint .

    ;               reduce using rule 54 (constraint -> decimal_digits_constraint .)
    RENAMES         reduce using rule 54 (constraint -> decimal_digits_constraint .)
    ASSIGNMENT      reduce using rule 54 (constraint -> decimal_digits_constraint .)
    WITH            reduce using rule 54 (constraint -> decimal_digits_constraint .)


state 630

    (50) subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .

    PACKAGE         reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    TASK            reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    PROTECTED       reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    error           reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    USE             reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    PRAGMA          reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    TYPE            reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    SUBTYPE         reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    FOR             reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    PROCEDURE       reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    FUNCTION        reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    GENERIC         reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    IDENTIFIER      reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    BEGIN           reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    PRIVATE         reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    END             reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)


state 631

    (357) rename_decl -> def_id_s : EXCEPTION renames ; .

    PACKAGE         reduce using rule 357 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    TASK            reduce using rule 357 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    PROTECTED       reduce using rule 357 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    error           reduce using rule 357 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    USE             reduce using rule 357 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    PRAGMA          reduce using rule 357 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    TYPE            reduce using rule 357 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    SUBTYPE         reduce using rule 357 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    FOR             reduce using rule 357 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    PROCEDURE       reduce using rule 357 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    FUNCTION        reduce using rule 357 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    GENERIC         reduce using rule 357 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    IDENTIFIER      reduce using rule 357 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    BEGIN           reduce using rule 357 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    END             reduce using rule 357 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    PRIVATE         reduce using rule 357 (rename_decl -> def_id_s : EXCEPTION renames ; .)


state 632

    (35) number_decl -> def_id_s : CONSTANT ASSIGNMENT expression . ;
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE

    ;               shift and go to state 745
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250

    logical                        shift and go to state 251
    short_circuit                  shift and go to state 252

state 633

    (82) unconstr_array_type -> ARRAY ( . index_s ) OF component_subtype_def
    (90) iter_index_constraint -> ( . iter_discrete_range_s )
    (87) index_s -> . index
    (88) index_s -> . index_s , index
    (91) iter_discrete_range_s -> . discrete_range
    (92) iter_discrete_range_s -> . iter_discrete_range_s , discrete_range
    (89) index -> . name RANGE LESSMORE
    (93) discrete_range -> . name range_constr_opt
    (94) discrete_range -> . range
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name TICK RANGE
    (64) range -> . name TICK RANGE ( expression )
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    iter_discrete_range_s          shift and go to state 746
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    simple_expression              shift and go to state 361
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    index                          shift and go to state 747
    index_s                        shift and go to state 748
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    primary                        shift and go to state 122
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    discrete_range                 shift and go to state 749
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 750
    operator_symbol                shift and go to state 149
    range                          shift and go to state 685

state 634

    (83) constr_array_type -> ARRAY iter_index_constraint . OF component_subtype_def

    OF              shift and go to state 751


state 635

    (34) init_opt -> ASSIGNMENT . expression
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 752

state 636

    (23) object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt . ;

    ;               shift and go to state 753


state 637

    (356) rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames . ;

    ;               shift and go to state 754


state 638

    (346) pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt . END c_id_opt ;

    END             shift and go to state 755


state 639

    (348) body_opt -> block_body .

    END             reduce using rule 348 (body_opt -> block_body .)


state 640

    (460) body_stub -> PROTECTED BODY simple_name . IS SEPARATE ;

    IS              shift and go to state 756


state 641

    (343) private_part -> PRIVATE decl_item_s .

    END             reduce using rule 343 (private_part -> PRIVATE decl_item_s .)


state 642

    (341) pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END . c_id_opt
    (344) c_id_opt -> .
    (345) c_id_opt -> . compound_name
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    ;               reduce using rule 344 (c_id_opt -> .)
    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 41
    compound_name                  shift and go to state 757
    c_id_opt                       shift and go to state 758

state 643

    (457) body_stub -> TASK BODY simple_name . IS SEPARATE ;

    IS              shift and go to state 759


state 644

    (458) body_stub -> PACKAGE BODY compound_name . IS SEPARATE ;
    (165) compound_name -> compound_name . . simple_name

    IS              shift and go to state 760
    .               shift and go to state 119


state 645

    (328) param_s -> param_s ; param .

    )               reduce using rule 328 (param_s -> param_s ; param .)
    ;               reduce using rule 328 (param_s -> param_s ; param .)


state 646

    (480) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN . name subp_default ;
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 761
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    indexed_comp                   shift and go to state 129
    operator_symbol                shift and go to state 149
    simple_name                    shift and go to state 158

state 647

    (481) generic_formal -> WITH PACKAGE simple_name IS NEW . name ( LESSMORE ) ;
    (482) generic_formal -> WITH PACKAGE simple_name IS NEW . name ;
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 762
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 648

    (488) subp_default -> IS . name
    (489) subp_default -> IS . LESSMORE
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    LESSMORE        shift and go to state 764
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 763
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 649

    (479) generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default . ;

    ;               shift and go to state 765


state 650

    (329) param -> def_id_s : mode mark init_opt .

    ;               reduce using rule 329 (param -> def_id_s : mode mark init_opt .)
    )               reduce using rule 329 (param -> def_id_s : mode mark init_opt .)


state 651

    (502) generic_derived_type -> ABSTRACT . NEW subtype_ind WITH PRIVATE
    (102) tagged_opt -> ABSTRACT . TAGGED

    NEW             shift and go to state 766
    TAGGED          shift and go to state 727


state 652

    (478) generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def . ;

    ;               shift and go to state 767


state 653

    (500) generic_derived_type -> NEW . subtype_ind
    (501) generic_derived_type -> NEW . subtype_ind WITH PRIVATE
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 485
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    subtype_ind                    shift and go to state 768
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 654

    (499) generic_type_def -> generic_derived_type .

    ;               reduce using rule 499 (generic_type_def -> generic_derived_type .)


state 655

    (495) generic_type_def -> DIGITS . LESSMORE

    LESSMORE        shift and go to state 769


state 656

    (490) generic_type_def -> ( . LESSMORE )

    LESSMORE        shift and go to state 770


state 657

    (498) generic_type_def -> private_type .

    ;               reduce using rule 498 (generic_type_def -> private_type .)


state 658

    (491) generic_type_def -> RANGE . LESSMORE

    LESSMORE        shift and go to state 771


state 659

    (497) generic_type_def -> access_type .

    ;               reduce using rule 497 (generic_type_def -> access_type .)


state 660

    (496) generic_type_def -> array_type .

    ;               reduce using rule 496 (generic_type_def -> array_type .)


state 661

    (349) private_type -> tagged_opt . limited_opt PRIVATE
    (350) limited_opt -> .
    (351) limited_opt -> . LIMITED

    PRIVATE         reduce using rule 350 (limited_opt -> .)
    LIMITED         shift and go to state 741

    limited_opt                    shift and go to state 772

state 662

    (493) generic_type_def -> DELTA . LESSMORE
    (494) generic_type_def -> DELTA . LESSMORE DIGITS LESSMORE

    LESSMORE        shift and go to state 773


state 663

    (492) generic_type_def -> MOD . LESSMORE

    LESSMORE        shift and go to state 774


state 664

    (486) generic_discrim_part_opt -> ( LESSMORE ) .

    IS              reduce using rule 486 (generic_discrim_part_opt -> ( LESSMORE ) .)


state 665

    (64) range -> name TICK RANGE ( . expression )
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 775

state 666

    (194) aggregate -> ( expression WITH value_s ) .

    STARSTAR        reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    *               reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    /               reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    MOD             reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    REM             reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    DOTDOT          reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    =               reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    NOTEQUAL        reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    <               reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    LESSEQ          reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    >               reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    GREATEREQ       reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    IN              reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    NOT             reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    +               reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    -               reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    &               reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    AND             reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    OR              reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    XOR             reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    )               reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    ,               reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    ARROW           reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    |               reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    ;               reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    WITH            reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    IS              reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    THEN            reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    LOOP            reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    RANGE           reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    DIGITS          reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    RENAMES         reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)
    ASSIGNMENT      reduce using rule 194 (aggregate -> ( expression WITH value_s ) .)


state 667

    (195) aggregate -> ( expression WITH NuLL RECORD . )

    )               shift and go to state 776


state 668

    (172) value_s -> value_s , value .

    )               reduce using rule 172 (value_s -> value_s , value .)
    ,               reduce using rule 172 (value_s -> value_s , value .)


state 669

    (388) prot_body -> PROTECTED BODY simple_name . IS prot_op_body_s END id_opt ;

    IS              shift and go to state 777


state 670

    (371) task_body -> TASK BODY simple_name . IS decl_part block_body END id_opt ;

    IS              shift and go to state 778


state 671

    (460) body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .

    PACKAGE         reduce using rule 460 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    TASK            reduce using rule 460 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    PROTECTED       reduce using rule 460 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    error           reduce using rule 460 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    USE             reduce using rule 460 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    PRAGMA          reduce using rule 460 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    TYPE            reduce using rule 460 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    SUBTYPE         reduce using rule 460 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    FOR             reduce using rule 460 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    PROCEDURE       reduce using rule 460 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    FUNCTION        reduce using rule 460 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    GENERIC         reduce using rule 460 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    IDENTIFIER      reduce using rule 460 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    BEGIN           reduce using rule 460 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    PRIVATE         reduce using rule 460 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    END             reduce using rule 460 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)


state 672

    (392) prot_op_body -> subprog_body .

    PRAGMA          reduce using rule 392 (prot_op_body -> subprog_body .)
    END             reduce using rule 392 (prot_op_body -> subprog_body .)
    ENTRY           reduce using rule 392 (prot_op_body -> subprog_body .)
    PROCEDURE       reduce using rule 392 (prot_op_body -> subprog_body .)
    FUNCTION        reduce using rule 392 (prot_op_body -> subprog_body .)


state 673

    (393) prot_op_body -> subprog_spec . ;
    (336) subprog_spec_is_push -> subprog_spec . IS

    ;               shift and go to state 779
    IS              shift and go to state 534


state 674

    (388) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END . id_opt ;
    (299) id_opt -> .
    (300) id_opt -> . designator
    (322) designator -> . compound_name
    (323) designator -> . STRING
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    ;               reduce using rule 299 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 114
    id_opt                         shift and go to state 780
    designator                     shift and go to state 466
    simple_name                    shift and go to state 41

state 675

    (391) prot_op_body -> entry_body .

    PRAGMA          reduce using rule 391 (prot_op_body -> entry_body .)
    END             reduce using rule 391 (prot_op_body -> entry_body .)
    ENTRY           reduce using rule 391 (prot_op_body -> entry_body .)
    PROCEDURE       reduce using rule 391 (prot_op_body -> entry_body .)
    FUNCTION        reduce using rule 391 (prot_op_body -> entry_body .)


state 676

    (390) prot_op_body_s -> prot_op_body_s prot_op_body . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 781

state 677

    (398) entry_body -> ENTRY . IDENTIFIER formal_part_opt WHEN condition entry_body_part
    (399) entry_body -> ENTRY . IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part

    IDENTIFIER      shift and go to state 782


state 678

    (377) prot_private_opt -> PRIVATE prot_elem_decl_s .
    (385) prot_elem_decl_s -> prot_elem_decl_s . prot_elem_decl
    (386) prot_elem_decl -> . prot_op_decl
    (387) prot_elem_decl -> . comp_decl
    (380) prot_op_decl -> . entry_decl
    (381) prot_op_decl -> . subprog_spec ;
    (382) prot_op_decl -> . rep_spec
    (383) prot_op_decl -> . pragma
    (110) comp_decl -> . def_id_s : component_subtype_def init_opt ;
    (111) comp_decl -> . error ;
    (396) entry_decl -> . ENTRY IDENTIFIER formal_part_opt ;
    (397) entry_decl -> . ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ;
    (319) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (320) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (321) subprog_spec -> . FUNCTION designator
    (506) rep_spec -> . attrib_def
    (507) rep_spec -> . record_type_spec
    (508) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (509) attrib_def -> . FOR mark USE expression ;
    (510) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (515) address_spec -> . FOR mark USE AT expression ;
    (26) def_id -> . IDENTIFIER

    END             reduce using rule 377 (prot_private_opt -> PRIVATE prot_elem_decl_s .)
    error           shift and go to state 787
    ENTRY           shift and go to state 544
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    PRAGMA          shift and go to state 4
    FOR             shift and go to state 63
    IDENTIFIER      shift and go to state 76

    rep_spec                       shift and go to state 538
    entry_decl                     shift and go to state 539
    address_spec                   shift and go to state 52
    record_type_spec               shift and go to state 68
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 541
    def_id_s                       shift and go to state 783
    comp_decl                      shift and go to state 784
    def_id                         shift and go to state 89
    pragma                         shift and go to state 543
    prot_op_decl                   shift and go to state 785
    prot_elem_decl                 shift and go to state 786

state 679

    (381) prot_op_decl -> subprog_spec ; .

    error           reduce using rule 381 (prot_op_decl -> subprog_spec ; .)
    ENTRY           reduce using rule 381 (prot_op_decl -> subprog_spec ; .)
    PROCEDURE       reduce using rule 381 (prot_op_decl -> subprog_spec ; .)
    FUNCTION        reduce using rule 381 (prot_op_decl -> subprog_spec ; .)
    PRAGMA          reduce using rule 381 (prot_op_decl -> subprog_spec ; .)
    FOR             reduce using rule 381 (prot_op_decl -> subprog_spec ; .)
    IDENTIFIER      reduce using rule 381 (prot_op_decl -> subprog_spec ; .)
    END             reduce using rule 381 (prot_op_decl -> subprog_spec ; .)
    PRIVATE         reduce using rule 381 (prot_op_decl -> subprog_spec ; .)


state 680

    (375) prot_def -> IS prot_op_decl_s prot_private_opt END . id_opt
    (299) id_opt -> .
    (300) id_opt -> . designator
    (322) designator -> . compound_name
    (323) designator -> . STRING
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    ;               reduce using rule 299 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 466
    id_opt                         shift and go to state 788
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 681

    (396) entry_decl -> ENTRY IDENTIFIER . formal_part_opt ;
    (397) entry_decl -> ENTRY IDENTIFIER . ( discrete_range ) formal_part_opt ;
    (324) formal_part_opt -> .
    (325) formal_part_opt -> . formal_part
    (326) formal_part -> . ( param_s )

    (               shift and go to state 789
    ;               reduce using rule 324 (formal_part_opt -> .)

    formal_part                    shift and go to state 189
    formal_part_opt                shift and go to state 790

state 682

    (411) delay_stmt -> DELAY UNTIL expression ; .

    END             reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    LESSLESS        reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    error           reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    PRAGMA          reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    NuLL            reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    EXIT            reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    RETURN          reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    GOTO            reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    DELAY           reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    ABORT           reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    RAISE           reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    REQUEUE         reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    IF              reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    CASE            reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    IDENTIFIER      reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    ACCEPT          reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    SELECT          reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    STRING          reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    WHILE           reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    DECLARE         reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    FOR             reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    LOOP            reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    BEGIN           reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    OR              reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    ELSE            reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    THEN            reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    EXCEPTION       reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    ELSIF           reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)
    WHEN            reduce using rule 411 (delay_stmt -> DELAY UNTIL expression ; .)


state 683

    (294) iteration -> iter_part reverse_opt discrete_range .

    LOOP            reduce using rule 294 (iteration -> iter_part reverse_opt discrete_range .)


state 684

    (93) discrete_range -> name . range_constr_opt
    (63) range -> name . TICK RANGE
    (64) range -> name . TICK RANGE ( expression )
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id
    (239) primary -> name .
    (245) qualified -> name . TICK parenthesized_primary
    (95) range_constr_opt -> .
    (96) range_constr_opt -> . range_constraint
    (61) range_constraint -> . RANGE range

    TICK            shift and go to state 375
    (               shift and go to state 245
    .               shift and go to state 246
    STARSTAR        reduce using rule 239 (primary -> name .)
    *               reduce using rule 239 (primary -> name .)
    /               reduce using rule 239 (primary -> name .)
    MOD             reduce using rule 239 (primary -> name .)
    REM             reduce using rule 239 (primary -> name .)
    DOTDOT          reduce using rule 239 (primary -> name .)
    +               reduce using rule 239 (primary -> name .)
    -               reduce using rule 239 (primary -> name .)
    &               reduce using rule 239 (primary -> name .)
    LOOP            reduce using rule 95 (range_constr_opt -> .)
    )               reduce using rule 95 (range_constr_opt -> .)
    ,               reduce using rule 95 (range_constr_opt -> .)
    RANGE           shift and go to state 373

    range_constr_opt               shift and go to state 792
    range_constraint               shift and go to state 791

state 685

    (94) discrete_range -> range .

    )               reduce using rule 94 (discrete_range -> range .)
    LOOP            reduce using rule 94 (discrete_range -> range .)
    ,               reduce using rule 94 (discrete_range -> range .)


state 686

    (295) iter_part -> FOR IDENTIFIER IN .

    IDENTIFIER      reduce using rule 295 (iter_part -> FOR IDENTIFIER IN .)
    STRING          reduce using rule 295 (iter_part -> FOR IDENTIFIER IN .)
    +               reduce using rule 295 (iter_part -> FOR IDENTIFIER IN .)
    -               reduce using rule 295 (iter_part -> FOR IDENTIFIER IN .)
    NOT             reduce using rule 295 (iter_part -> FOR IDENTIFIER IN .)
    ABS             reduce using rule 295 (iter_part -> FOR IDENTIFIER IN .)
    INTEGER         reduce using rule 295 (iter_part -> FOR IDENTIFIER IN .)
    BASE_INTEGER    reduce using rule 295 (iter_part -> FOR IDENTIFIER IN .)
    FLOAT           reduce using rule 295 (iter_part -> FOR IDENTIFIER IN .)
    BASE_FLOAT      reduce using rule 295 (iter_part -> FOR IDENTIFIER IN .)
    NuLL            reduce using rule 295 (iter_part -> FOR IDENTIFIER IN .)
    NEW             reduce using rule 295 (iter_part -> FOR IDENTIFIER IN .)
    (               reduce using rule 295 (iter_part -> FOR IDENTIFIER IN .)
    CHAR            reduce using rule 295 (iter_part -> FOR IDENTIFIER IN .)
    REVERSE         reduce using rule 295 (iter_part -> FOR IDENTIFIER IN .)


state 687

    (301) block -> label_opt block_decl block_body END . id_opt ;
    (299) id_opt -> .
    (300) id_opt -> . designator
    (322) designator -> . compound_name
    (323) designator -> . STRING
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    ;               reduce using rule 299 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 466
    id_opt                         shift and go to state 793
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 688

    (289) loop_stmt -> label_opt iteration basic_loop id_opt . ;

    ;               shift and go to state 794


state 689

    (298) basic_loop -> LOOP statement_s . END LOOP
    (249) statement_s -> statement_s . statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    END             shift and go to state 795
    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 459
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 690

    (275) assign_stmt -> name ASSIGNMENT expression ; .

    END             reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    LESSLESS        reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    error           reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    PRAGMA          reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    NuLL            reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    EXIT            reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    RETURN          reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    GOTO            reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    DELAY           reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    ABORT           reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    RAISE           reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    REQUEUE         reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    IF              reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    CASE            reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    IDENTIFIER      reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    ACCEPT          reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    SELECT          reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    STRING          reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    WHILE           reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    DECLARE         reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    FOR             reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    LOOP            reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    BEGIN           reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    EXCEPTION       reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    OR              reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    ELSE            reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    THEN            reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    ELSIF           reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)
    WHEN            reduce using rule 275 (assign_stmt -> name ASSIGNMENT expression ; .)


state 691

    (26) def_id -> IDENTIFIER .
    (163) simple_name -> IDENTIFIER .

    :               reduce using rule 26 (def_id -> IDENTIFIER .)
    ,               reduce using rule 26 (def_id -> IDENTIFIER .)
    TICK            reduce using rule 163 (simple_name -> IDENTIFIER .)
    (               reduce using rule 163 (simple_name -> IDENTIFIER .)
    .               reduce using rule 163 (simple_name -> IDENTIFIER .)
    STARSTAR        reduce using rule 163 (simple_name -> IDENTIFIER .)
    *               reduce using rule 163 (simple_name -> IDENTIFIER .)
    /               reduce using rule 163 (simple_name -> IDENTIFIER .)
    MOD             reduce using rule 163 (simple_name -> IDENTIFIER .)
    REM             reduce using rule 163 (simple_name -> IDENTIFIER .)
    =               reduce using rule 163 (simple_name -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 163 (simple_name -> IDENTIFIER .)
    <               reduce using rule 163 (simple_name -> IDENTIFIER .)
    LESSEQ          reduce using rule 163 (simple_name -> IDENTIFIER .)
    >               reduce using rule 163 (simple_name -> IDENTIFIER .)
    GREATEREQ       reduce using rule 163 (simple_name -> IDENTIFIER .)
    IN              reduce using rule 163 (simple_name -> IDENTIFIER .)
    NOT             reduce using rule 163 (simple_name -> IDENTIFIER .)
    +               reduce using rule 163 (simple_name -> IDENTIFIER .)
    -               reduce using rule 163 (simple_name -> IDENTIFIER .)
    &               reduce using rule 163 (simple_name -> IDENTIFIER .)
    )               reduce using rule 163 (simple_name -> IDENTIFIER .)
    AND             reduce using rule 163 (simple_name -> IDENTIFIER .)
    OR              reduce using rule 163 (simple_name -> IDENTIFIER .)
    XOR             reduce using rule 163 (simple_name -> IDENTIFIER .)


state 692

    (409) entry_name -> entry_name ( expression . )
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE

    )               shift and go to state 796
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250

    logical                        shift and go to state 251
    short_circuit                  shift and go to state 252

state 693

    (428) cond_entry_call -> SELECT entry_call stmts_opt ELSE . statement_s END SELECT ;
    (248) statement_s -> . statement
    (249) statement_s -> . statement_s statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    statement_s                    shift and go to state 797
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 292
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 694

    (427) timed_entry_call -> SELECT entry_call stmts_opt OR . delay_stmt stmts_opt END SELECT ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;

    DELAY           shift and go to state 263

    delay_stmt                     shift and go to state 798

state 695

    (426) async_select -> SELECT delay_or_entry_alt THEN ABORT . statement_s END SELECT ;
    (248) statement_s -> . statement
    (249) statement_s -> . statement_s statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    assign_stmt                    shift and go to state 311
    statement_s                    shift and go to state 799
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 292
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    procedure_call                 shift and go to state 279
    block                          shift and go to state 286

state 696

    (418) guarded_select_alt -> WHEN condition ARROW . select_alt
    (421) select_alt -> . accept_stmt stmts_opt
    (422) select_alt -> . delay_stmt stmts_opt
    (423) select_alt -> . TERMINATE ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt

    TERMINATE       shift and go to state 445
    DELAY           shift and go to state 263
    ACCEPT          shift and go to state 278

    delay_stmt                     shift and go to state 800
    accept_hdr                     shift and go to state 295
    accept_stmt                    shift and go to state 436
    select_alt                     shift and go to state 801

state 697

    (416) select_wait -> SELECT guarded_select_alt or_select else_opt . END SELECT ;

    END             shift and go to state 802


state 698

    (420) or_select -> or_select OR . guarded_select_alt
    (417) guarded_select_alt -> . select_alt
    (418) guarded_select_alt -> . WHEN condition ARROW select_alt
    (421) select_alt -> . accept_stmt stmts_opt
    (422) select_alt -> . delay_stmt stmts_opt
    (423) select_alt -> . TERMINATE ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt

    WHEN            shift and go to state 440
    TERMINATE       shift and go to state 445
    DELAY           shift and go to state 263
    ACCEPT          shift and go to state 278

    delay_stmt                     shift and go to state 800
    accept_hdr                     shift and go to state 295
    accept_stmt                    shift and go to state 436
    guarded_select_alt             shift and go to state 803
    select_alt                     shift and go to state 442

state 699

    (287) alternative_s -> alternative_s alternative .

    END             reduce using rule 287 (alternative_s -> alternative_s alternative .)
    WHEN            reduce using rule 287 (alternative_s -> alternative_s alternative .)


state 700

    (284) case_stmt -> case_hdr pragma_s alternative_s END . CASE ;

    CASE            shift and go to state 804


state 701

    (288) alternative -> WHEN . choice_s ARROW statement_s
    (123) choice_s -> . choice
    (124) choice_s -> . choice_s | choice
    (125) choice -> . expression
    (126) choice -> . discrete_with_range
    (127) choice -> . OTHERS
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (128) discrete_with_range -> . name range_constraint
    (129) discrete_with_range -> . range
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name TICK RANGE
    (64) range -> . name TICK RANGE ( expression )
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    OTHERS          shift and go to state 224
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 384
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    allocator                      shift and go to state 130
    choice_s                       shift and go to state 805
    factor                         shift and go to state 137
    choice                         shift and go to state 228
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    discrete_with_range            shift and go to state 519
    term                           shift and go to state 146
    name                           shift and go to state 231
    operator_symbol                shift and go to state 149
    range                          shift and go to state 233
    expression                     shift and go to state 520

state 702

    (472) requeue_stmt -> REQUEUE name WITH ABORT . ;

    ;               shift and go to state 806


state 703

    (406) accept_stmt -> accept_hdr DO handled_stmt_s END . id_opt ;
    (299) id_opt -> .
    (300) id_opt -> . designator
    (322) designator -> . compound_name
    (323) designator -> . STRING
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    ;               reduce using rule 299 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 466
    id_opt                         shift and go to state 807
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 704

    (308) exit_stmt -> EXIT name_opt when_opt ; .

    LESSLESS        reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    error           reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    PRAGMA          reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    NuLL            reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    EXIT            reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    RETURN          reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    GOTO            reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    DELAY           reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    ABORT           reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    RAISE           reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    REQUEUE         reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    IF              reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    CASE            reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    IDENTIFIER      reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    ACCEPT          reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    SELECT          reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    STRING          reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    WHILE           reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    DECLARE         reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    FOR             reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    LOOP            reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    BEGIN           reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    WHEN            reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    END             reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    EXCEPTION       reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    OR              reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    ELSE            reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    THEN            reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)
    ELSIF           reduce using rule 308 (exit_stmt -> EXIT name_opt when_opt ; .)


state 705

    (312) when_opt -> WHEN condition .

    ;               reduce using rule 312 (when_opt -> WHEN condition .)


state 706

    (464) exception_handler -> WHEN except_choice_s . ARROW statement_s
    (467) except_choice_s -> except_choice_s . | except_choice

    ARROW           shift and go to state 808
    |               shift and go to state 809


state 707

    (465) exception_handler -> WHEN IDENTIFIER . : except_choice_s ARROW statement_s
    (163) simple_name -> IDENTIFIER .

    :               shift and go to state 810
    (               reduce using rule 163 (simple_name -> IDENTIFIER .)
    .               reduce using rule 163 (simple_name -> IDENTIFIER .)
    TICK            reduce using rule 163 (simple_name -> IDENTIFIER .)
    ARROW           reduce using rule 163 (simple_name -> IDENTIFIER .)
    |               reduce using rule 163 (simple_name -> IDENTIFIER .)


state 708

    (466) except_choice_s -> except_choice .

    ARROW           reduce using rule 466 (except_choice_s -> except_choice .)
    |               reduce using rule 466 (except_choice_s -> except_choice .)


state 709

    (469) except_choice -> OTHERS .

    ARROW           reduce using rule 469 (except_choice -> OTHERS .)
    |               reduce using rule 469 (except_choice -> OTHERS .)


state 710

    (468) except_choice -> name .
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id

    ARROW           reduce using rule 468 (except_choice -> name .)
    |               reduce using rule 468 (except_choice -> name .)
    (               shift and go to state 245
    .               shift and go to state 246
    TICK            shift and go to state 256


state 711

    (283) else_opt -> ELSE statement_s .
    (249) statement_s -> statement_s . statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    END             reduce using rule 283 (else_opt -> ELSE statement_s .)
    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 459
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 712

    (276) if_stmt -> IF cond_clause_s else_opt END . IF ;

    IF              shift and go to state 811


state 713

    (278) cond_clause_s -> cond_clause_s ELSIF cond_clause .

    ELSIF           reduce using rule 278 (cond_clause_s -> cond_clause_s ELSIF cond_clause .)
    ELSE            reduce using rule 278 (cond_clause_s -> cond_clause_s ELSIF cond_clause .)
    END             reduce using rule 278 (cond_clause_s -> cond_clause_s ELSIF cond_clause .)


state 714

    (510) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s . END RECORD ;
    (514) comp_loc_s -> comp_loc_s . mark AT expression RANGE range ;
    (160) mark -> . simple_name
    (161) mark -> . mark TICK attribute_id
    (162) mark -> . mark . simple_name
    (163) simple_name -> . IDENTIFIER

    END             shift and go to state 812
    IDENTIFIER      shift and go to state 39

    mark                           shift and go to state 813
    simple_name                    shift and go to state 166

state 715

    (512) align_opt -> AT MOD . expression ;
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 814

state 716

    (515) address_spec -> FOR mark USE AT expression ; .

    PACKAGE         reduce using rule 515 (address_spec -> FOR mark USE AT expression ; .)
    TASK            reduce using rule 515 (address_spec -> FOR mark USE AT expression ; .)
    PROTECTED       reduce using rule 515 (address_spec -> FOR mark USE AT expression ; .)
    error           reduce using rule 515 (address_spec -> FOR mark USE AT expression ; .)
    USE             reduce using rule 515 (address_spec -> FOR mark USE AT expression ; .)
    PRAGMA          reduce using rule 515 (address_spec -> FOR mark USE AT expression ; .)
    TYPE            reduce using rule 515 (address_spec -> FOR mark USE AT expression ; .)
    SUBTYPE         reduce using rule 515 (address_spec -> FOR mark USE AT expression ; .)
    FOR             reduce using rule 515 (address_spec -> FOR mark USE AT expression ; .)
    PROCEDURE       reduce using rule 515 (address_spec -> FOR mark USE AT expression ; .)
    FUNCTION        reduce using rule 515 (address_spec -> FOR mark USE AT expression ; .)
    GENERIC         reduce using rule 515 (address_spec -> FOR mark USE AT expression ; .)
    IDENTIFIER      reduce using rule 515 (address_spec -> FOR mark USE AT expression ; .)
    BEGIN           reduce using rule 515 (address_spec -> FOR mark USE AT expression ; .)
    PRIVATE         reduce using rule 515 (address_spec -> FOR mark USE AT expression ; .)
    ENTRY           reduce using rule 515 (address_spec -> FOR mark USE AT expression ; .)
    END             reduce using rule 515 (address_spec -> FOR mark USE AT expression ; .)


state 717

    (457) body_stub -> TASK BODY simple_name IS SEPARATE ; .

    PACKAGE         reduce using rule 457 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    TASK            reduce using rule 457 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    PROTECTED       reduce using rule 457 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    error           reduce using rule 457 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    USE             reduce using rule 457 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    PRAGMA          reduce using rule 457 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    TYPE            reduce using rule 457 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    SUBTYPE         reduce using rule 457 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    FOR             reduce using rule 457 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    PROCEDURE       reduce using rule 457 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    FUNCTION        reduce using rule 457 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    GENERIC         reduce using rule 457 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    IDENTIFIER      reduce using rule 457 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    BEGIN           reduce using rule 457 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    PRIVATE         reduce using rule 457 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    END             reduce using rule 457 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)


state 718

    (371) task_body -> TASK BODY simple_name IS decl_part block_body . END id_opt ;

    END             shift and go to state 815


state 719

    (403) rep_spec_s -> rep_spec_s rep_spec . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    FOR             reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 816

state 720

    (370) task_private_opt -> PRIVATE . entry_decl_s rep_spec_s
    (394) entry_decl_s -> . pragma_s
    (395) entry_decl_s -> . entry_decl_s entry_decl pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    FOR             reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)

    entry_decl_s                   shift and go to state 817
    pragma_s                       shift and go to state 476

state 721

    (368) task_def -> IS entry_decl_s rep_spec_s task_private_opt . END id_opt

    END             shift and go to state 818


state 722

    (395) entry_decl_s -> entry_decl_s entry_decl pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    ENTRY           reduce using rule 395 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
    FOR             reduce using rule 395 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
    END             reduce using rule 395 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
    PRIVATE         reduce using rule 395 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 723

    (458) body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .

    PACKAGE         reduce using rule 458 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    TASK            reduce using rule 458 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    PROTECTED       reduce using rule 458 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    error           reduce using rule 458 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    USE             reduce using rule 458 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    PRAGMA          reduce using rule 458 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    TYPE            reduce using rule 458 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    SUBTYPE         reduce using rule 458 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    FOR             reduce using rule 458 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    PROCEDURE       reduce using rule 458 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    FUNCTION        reduce using rule 458 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    GENERIC         reduce using rule 458 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    IDENTIFIER      reduce using rule 458 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    BEGIN           reduce using rule 458 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    PRIVATE         reduce using rule 458 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    END             reduce using rule 458 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)


state 724

    (114) discrim_spec_s -> discrim_spec_s ; discrim_spec .

    )               reduce using rule 114 (discrim_spec_s -> discrim_spec_s ; discrim_spec .)
    ;               reduce using rule 114 (discrim_spec_s -> discrim_spec_s ; discrim_spec .)


state 725

    (118) access_opt -> ACCESS .

    IDENTIFIER      reduce using rule 118 (access_opt -> ACCESS .)


state 726

    (115) discrim_spec -> def_id_s : access_opt . mark init_opt
    (160) mark -> . simple_name
    (161) mark -> . mark TICK attribute_id
    (162) mark -> . mark . simple_name
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    mark                           shift and go to state 819
    simple_name                    shift and go to state 166

state 727

    (102) tagged_opt -> ABSTRACT TAGGED .

    LIMITED         reduce using rule 102 (tagged_opt -> ABSTRACT TAGGED .)
    PRIVATE         reduce using rule 102 (tagged_opt -> ABSTRACT TAGGED .)
    RECORD          reduce using rule 102 (tagged_opt -> ABSTRACT TAGGED .)
    NuLL            reduce using rule 102 (tagged_opt -> ABSTRACT TAGGED .)


state 728

    (59) derived_type -> ABSTRACT NEW . subtype_ind WITH PRIVATE
    (60) derived_type -> ABSTRACT NEW . subtype_ind WITH record_def
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 485
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    subtype_ind                    shift and go to state 820
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 729

    (56) derived_type -> NEW subtype_ind .
    (57) derived_type -> NEW subtype_ind . WITH PRIVATE
    (58) derived_type -> NEW subtype_ind . WITH record_def

    ;               reduce using rule 56 (derived_type -> NEW subtype_ind .)
    WITH            shift and go to state 821


state 730

    (65) enumeration_type -> ( enum_id_s . )
    (67) enum_id_s -> enum_id_s . , enum_id

    )               shift and go to state 822
    ,               shift and go to state 823


state 731

    (69) enum_id -> CHAR .

    )               reduce using rule 69 (enum_id -> CHAR .)
    ,               reduce using rule 69 (enum_id -> CHAR .)


state 732

    (68) enum_id -> IDENTIFIER .

    )               reduce using rule 68 (enum_id -> IDENTIFIER .)
    ,               reduce using rule 68 (enum_id -> IDENTIFIER .)


state 733

    (66) enum_id_s -> enum_id .

    )               reduce using rule 66 (enum_id_s -> enum_id .)
    ,               reduce using rule 66 (enum_id_s -> enum_id .)


state 734

    (77) float_type -> DIGITS expression . range_spec_opt
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (73) range_spec_opt -> .
    (74) range_spec_opt -> . range_spec
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE
    (72) range_spec -> . range_constraint
    (61) range_constraint -> . RANGE range

    ;               reduce using rule 73 (range_spec_opt -> .)
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250
    RANGE           shift and go to state 373

    logical                        shift and go to state 251
    short_circuit                  shift and go to state 252
    range_constraint               shift and go to state 604
    range_spec                     shift and go to state 824
    range_spec_opt                 shift and go to state 825

state 735

    (78) fixed_type -> DELTA expression . range_spec
    (79) fixed_type -> DELTA expression . DIGITS expression range_spec_opt
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (72) range_spec -> . range_constraint
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE
    (61) range_constraint -> . RANGE range

    DIGITS          shift and go to state 826
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250
    RANGE           shift and go to state 373

    logical                        shift and go to state 251
    short_circuit                  shift and go to state 252
    range_constraint               shift and go to state 604
    range_spec                     shift and go to state 827

state 736

    (131) access_type -> ACCESS CONSTANT . subtype_ind
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 485
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    subtype_ind                    shift and go to state 828
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 737

    (133) access_type -> ACCESS prot_opt . PROCEDURE formal_part_opt
    (134) access_type -> ACCESS prot_opt . FUNCTION formal_part_opt RETURN mark

    PROCEDURE       shift and go to state 830
    FUNCTION        shift and go to state 829


state 738

    (136) prot_opt -> PROTECTED .

    PROCEDURE       reduce using rule 136 (prot_opt -> PROTECTED .)
    FUNCTION        reduce using rule 136 (prot_opt -> PROTECTED .)


state 739

    (132) access_type -> ACCESS ALL . subtype_ind
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 485
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    subtype_ind                    shift and go to state 831
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 740

    (130) access_type -> ACCESS subtype_ind .

    ;               reduce using rule 130 (access_type -> ACCESS subtype_ind .)


state 741

    (351) limited_opt -> LIMITED .

    PRIVATE         reduce using rule 351 (limited_opt -> LIMITED .)
    RECORD          reduce using rule 351 (limited_opt -> LIMITED .)
    NuLL            reduce using rule 351 (limited_opt -> LIMITED .)


state 742

    (97) record_type -> tagged_opt limited_opt . record_def
    (349) private_type -> tagged_opt limited_opt . PRIVATE
    (98) record_def -> . RECORD pragma_s comp_list END RECORD
    (99) record_def -> . NuLL RECORD

    PRIVATE         shift and go to state 832
    RECORD          shift and go to state 833
    NuLL            shift and go to state 834

    record_def                     shift and go to state 835

state 743

    (71) integer_type -> MOD expression .
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE

    ;               reduce using rule 71 (integer_type -> MOD expression .)
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250

    logical                        shift and go to state 251
    short_circuit                  shift and go to state 252

state 744

    (55) decimal_digits_constraint -> DIGITS expression . range_constr_opt
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (95) range_constr_opt -> .
    (96) range_constr_opt -> . range_constraint
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE
    (61) range_constraint -> . RANGE range

    ;               reduce using rule 95 (range_constr_opt -> .)
    RENAMES         reduce using rule 95 (range_constr_opt -> .)
    ASSIGNMENT      reduce using rule 95 (range_constr_opt -> .)
    WITH            reduce using rule 95 (range_constr_opt -> .)
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250
    RANGE           shift and go to state 373

    range_constr_opt               shift and go to state 836
    logical                        shift and go to state 251
    short_circuit                  shift and go to state 252
    range_constraint               shift and go to state 791

state 745

    (35) number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .

    PACKAGE         reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    TASK            reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    PROTECTED       reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    error           reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    USE             reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    PRAGMA          reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    TYPE            reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    SUBTYPE         reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    FOR             reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    PROCEDURE       reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    FUNCTION        reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    GENERIC         reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    IDENTIFIER      reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    BEGIN           reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    PRIVATE         reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    END             reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)


state 746

    (90) iter_index_constraint -> ( iter_discrete_range_s . )
    (92) iter_discrete_range_s -> iter_discrete_range_s . , discrete_range

    )               shift and go to state 837
    ,               shift and go to state 838


state 747

    (87) index_s -> index .

    )               reduce using rule 87 (index_s -> index .)
    ,               reduce using rule 87 (index_s -> index .)


state 748

    (82) unconstr_array_type -> ARRAY ( index_s . ) OF component_subtype_def
    (88) index_s -> index_s . , index

    )               shift and go to state 839
    ,               shift and go to state 840


state 749

    (91) iter_discrete_range_s -> discrete_range .

    )               reduce using rule 91 (iter_discrete_range_s -> discrete_range .)
    ,               reduce using rule 91 (iter_discrete_range_s -> discrete_range .)


state 750

    (89) index -> name . RANGE LESSMORE
    (93) discrete_range -> name . range_constr_opt
    (63) range -> name . TICK RANGE
    (64) range -> name . TICK RANGE ( expression )
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id
    (239) primary -> name .
    (245) qualified -> name . TICK parenthesized_primary
    (95) range_constr_opt -> .
    (96) range_constr_opt -> . range_constraint
    (61) range_constraint -> . RANGE range

    RANGE           shift and go to state 841
    TICK            shift and go to state 375
    (               shift and go to state 245
    .               shift and go to state 246
    STARSTAR        reduce using rule 239 (primary -> name .)
    *               reduce using rule 239 (primary -> name .)
    /               reduce using rule 239 (primary -> name .)
    MOD             reduce using rule 239 (primary -> name .)
    REM             reduce using rule 239 (primary -> name .)
    DOTDOT          reduce using rule 239 (primary -> name .)
    +               reduce using rule 239 (primary -> name .)
    -               reduce using rule 239 (primary -> name .)
    &               reduce using rule 239 (primary -> name .)
    )               reduce using rule 95 (range_constr_opt -> .)
    ,               reduce using rule 95 (range_constr_opt -> .)

    range_constr_opt               shift and go to state 792
    range_constraint               shift and go to state 791

state 751

    (83) constr_array_type -> ARRAY iter_index_constraint OF . component_subtype_def
    (84) component_subtype_def -> . aliased_opt subtype_ind
    (85) aliased_opt -> .
    (86) aliased_opt -> . ALIASED

    IDENTIFIER      reduce using rule 85 (aliased_opt -> .)
    STRING          reduce using rule 85 (aliased_opt -> .)
    ALIASED         shift and go to state 842

    aliased_opt                    shift and go to state 843
    component_subtype_def          shift and go to state 844

state 752

    (34) init_opt -> ASSIGNMENT expression .
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE

    ;               reduce using rule 34 (init_opt -> ASSIGNMENT expression .)
    )               reduce using rule 34 (init_opt -> ASSIGNMENT expression .)
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250

    logical                        shift and go to state 251
    short_circuit                  shift and go to state 252

state 753

    (23) object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .

    PACKAGE         reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    TASK            reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    PROTECTED       reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    error           reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    USE             reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    PRAGMA          reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    TYPE            reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    SUBTYPE         reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    FOR             reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    PROCEDURE       reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    FUNCTION        reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    GENERIC         reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    IDENTIFIER      reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    BEGIN           reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    END             reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    PRIVATE         reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)


state 754

    (356) rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .

    PACKAGE         reduce using rule 356 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    TASK            reduce using rule 356 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    PROTECTED       reduce using rule 356 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    error           reduce using rule 356 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    USE             reduce using rule 356 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    PRAGMA          reduce using rule 356 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    TYPE            reduce using rule 356 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    SUBTYPE         reduce using rule 356 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    FOR             reduce using rule 356 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    PROCEDURE       reduce using rule 356 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    FUNCTION        reduce using rule 356 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    GENERIC         reduce using rule 356 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    IDENTIFIER      reduce using rule 356 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    BEGIN           reduce using rule 356 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    END             reduce using rule 356 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    PRIVATE         reduce using rule 356 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)


state 755

    (346) pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END . c_id_opt ;
    (344) c_id_opt -> .
    (345) c_id_opt -> . compound_name
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    ;               reduce using rule 344 (c_id_opt -> .)
    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 757
    c_id_opt                       shift and go to state 845
    simple_name                    shift and go to state 41

state 756

    (460) body_stub -> PROTECTED BODY simple_name IS . SEPARATE ;

    SEPARATE        shift and go to state 535


state 757

    (345) c_id_opt -> compound_name .
    (165) compound_name -> compound_name . . simple_name

    ;               reduce using rule 345 (c_id_opt -> compound_name .)
    .               shift and go to state 119


state 758

    (341) pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END c_id_opt .

    ;               reduce using rule 341 (pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END c_id_opt .)


state 759

    (457) body_stub -> TASK BODY simple_name IS . SEPARATE ;

    SEPARATE        shift and go to state 593


state 760

    (458) body_stub -> PACKAGE BODY compound_name IS . SEPARATE ;

    SEPARATE        shift and go to state 598


state 761

    (480) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name . subp_default ;
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id
    (487) subp_default -> .
    (488) subp_default -> . IS name
    (489) subp_default -> . IS LESSMORE

    (               shift and go to state 245
    .               shift and go to state 246
    TICK            shift and go to state 256
    ;               reduce using rule 487 (subp_default -> .)
    IS              shift and go to state 648

    subp_default                   shift and go to state 846

state 762

    (481) generic_formal -> WITH PACKAGE simple_name IS NEW name . ( LESSMORE ) ;
    (482) generic_formal -> WITH PACKAGE simple_name IS NEW name . ;
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id

    (               shift and go to state 847
    ;               shift and go to state 848
    .               shift and go to state 246
    TICK            shift and go to state 256


state 763

    (488) subp_default -> IS name .
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id

    ;               reduce using rule 488 (subp_default -> IS name .)
    (               shift and go to state 245
    .               shift and go to state 246
    TICK            shift and go to state 256


state 764

    (489) subp_default -> IS LESSMORE .

    ;               reduce using rule 489 (subp_default -> IS LESSMORE .)


state 765

    (479) generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .

    PACKAGE         reduce using rule 479 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    PROCEDURE       reduce using rule 479 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    FUNCTION        reduce using rule 479 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    TYPE            reduce using rule 479 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    WITH            reduce using rule 479 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    error           reduce using rule 479 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    USE             reduce using rule 479 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    IDENTIFIER      reduce using rule 479 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)


state 766

    (502) generic_derived_type -> ABSTRACT NEW . subtype_ind WITH PRIVATE
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 485
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    subtype_ind                    shift and go to state 849
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 767

    (478) generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .

    PACKAGE         reduce using rule 478 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    PROCEDURE       reduce using rule 478 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    FUNCTION        reduce using rule 478 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    TYPE            reduce using rule 478 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    WITH            reduce using rule 478 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    error           reduce using rule 478 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    USE             reduce using rule 478 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    IDENTIFIER      reduce using rule 478 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)


state 768

    (500) generic_derived_type -> NEW subtype_ind .
    (501) generic_derived_type -> NEW subtype_ind . WITH PRIVATE

    ;               reduce using rule 500 (generic_derived_type -> NEW subtype_ind .)
    WITH            shift and go to state 850


state 769

    (495) generic_type_def -> DIGITS LESSMORE .

    ;               reduce using rule 495 (generic_type_def -> DIGITS LESSMORE .)


state 770

    (490) generic_type_def -> ( LESSMORE . )

    )               shift and go to state 851


state 771

    (491) generic_type_def -> RANGE LESSMORE .

    ;               reduce using rule 491 (generic_type_def -> RANGE LESSMORE .)


state 772

    (349) private_type -> tagged_opt limited_opt . PRIVATE

    PRIVATE         shift and go to state 832


state 773

    (493) generic_type_def -> DELTA LESSMORE .
    (494) generic_type_def -> DELTA LESSMORE . DIGITS LESSMORE

    ;               reduce using rule 493 (generic_type_def -> DELTA LESSMORE .)
    DIGITS          shift and go to state 852


state 774

    (492) generic_type_def -> MOD LESSMORE .

    ;               reduce using rule 492 (generic_type_def -> MOD LESSMORE .)


state 775

    (64) range -> name TICK RANGE ( expression . )
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE

    )               shift and go to state 853
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250

    logical                        shift and go to state 251
    short_circuit                  shift and go to state 252

state 776

    (195) aggregate -> ( expression WITH NuLL RECORD ) .

    STARSTAR        reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    *               reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    /               reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    MOD             reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    REM             reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    DOTDOT          reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    =               reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    NOTEQUAL        reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    <               reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    LESSEQ          reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    >               reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    GREATEREQ       reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    IN              reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    NOT             reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    +               reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    -               reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    &               reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    AND             reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    OR              reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    XOR             reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    )               reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    ,               reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    ARROW           reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    |               reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    ;               reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    WITH            reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    IS              reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    THEN            reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    LOOP            reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    RANGE           reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    DIGITS          reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    RENAMES         reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)
    ASSIGNMENT      reduce using rule 195 (aggregate -> ( expression WITH NuLL RECORD ) .)


state 777

    (388) prot_body -> PROTECTED BODY simple_name IS . prot_op_body_s END id_opt ;
    (389) prot_op_body_s -> . pragma_s
    (390) prot_op_body_s -> . prot_op_body_s prot_op_body pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)

    prot_op_body_s                 shift and go to state 536
    pragma_s                       shift and go to state 537

state 778

    (371) task_body -> TASK BODY simple_name IS . decl_part block_body END id_opt ;
    (137) decl_part -> .
    (138) decl_part -> . decl_item_or_body_s1
    (147) decl_item_or_body_s1 -> . decl_item_or_body
    (148) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (149) decl_item_or_body -> . body
    (150) decl_item_or_body -> . decl_item
    (151) body -> . subprog_body
    (152) body -> . pkg_body
    (153) body -> . task_body
    (154) body -> . prot_body
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (337) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (346) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (371) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (388) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (352) use_clause -> . USE name_s ;
    (353) use_clause -> . USE TYPE name_s ;
    (506) rep_spec -> . attrib_def
    (507) rep_spec -> . record_type_spec
    (508) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (336) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (316) subprog_decl -> . subprog_spec ;
    (317) subprog_decl -> . generic_subp_inst ;
    (318) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (339) pkg_decl -> . pkg_spec ;
    (340) pkg_decl -> . generic_pkg_inst ;
    (364) task_decl -> . task_spec ;
    (372) prot_decl -> . prot_spec ;
    (461) exception_decl -> . def_id_s : EXCEPTION ;
    (356) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (357) rename_decl -> . def_id_s : EXCEPTION renames ;
    (358) rename_decl -> . rename_unit
    (473) generic_decl -> . generic_formal_part subprog_spec ;
    (474) generic_decl -> . generic_formal_part pkg_spec ;
    (457) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (458) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (459) body_stub -> . subprog_spec IS SEPARATE ;
    (460) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (509) attrib_def -> . FOR mark USE expression ;
    (510) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (515) address_spec -> . FOR mark USE AT expression ;
    (319) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (320) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (321) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (503) generic_subp_inst -> . subprog_spec IS generic_inst
    (341) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (365) task_spec -> . TASK simple_name task_def
    (366) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (373) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (374) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (359) rename_unit -> . PACKAGE compound_name renames ;
    (360) rename_unit -> . subprog_spec renames ;
    (361) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (362) rename_unit -> . generic_formal_part subprog_spec renames ;
    (475) generic_formal_part -> . GENERIC
    (476) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 137 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    decl_item                      shift and go to state 53
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 594
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 779

    (393) prot_op_body -> subprog_spec ; .

    PRAGMA          reduce using rule 393 (prot_op_body -> subprog_spec ; .)
    END             reduce using rule 393 (prot_op_body -> subprog_spec ; .)
    ENTRY           reduce using rule 393 (prot_op_body -> subprog_spec ; .)
    PROCEDURE       reduce using rule 393 (prot_op_body -> subprog_spec ; .)
    FUNCTION        reduce using rule 393 (prot_op_body -> subprog_spec ; .)


state 780

    (388) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt . ;

    ;               shift and go to state 854


state 781

    (390) prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 390 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
    ENTRY           reduce using rule 390 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
    PROCEDURE       reduce using rule 390 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
    FUNCTION        reduce using rule 390 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 782

    (398) entry_body -> ENTRY IDENTIFIER . formal_part_opt WHEN condition entry_body_part
    (399) entry_body -> ENTRY IDENTIFIER . ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part
    (324) formal_part_opt -> .
    (325) formal_part_opt -> . formal_part
    (326) formal_part -> . ( param_s )

    (               shift and go to state 855
    WHEN            reduce using rule 324 (formal_part_opt -> .)

    formal_part                    shift and go to state 189
    formal_part_opt                shift and go to state 856

state 783

    (110) comp_decl -> def_id_s . : component_subtype_def init_opt ;
    (25) def_id_s -> def_id_s . , def_id

    :               shift and go to state 857
    ,               shift and go to state 180


state 784

    (387) prot_elem_decl -> comp_decl .

    error           reduce using rule 387 (prot_elem_decl -> comp_decl .)
    ENTRY           reduce using rule 387 (prot_elem_decl -> comp_decl .)
    PROCEDURE       reduce using rule 387 (prot_elem_decl -> comp_decl .)
    FUNCTION        reduce using rule 387 (prot_elem_decl -> comp_decl .)
    PRAGMA          reduce using rule 387 (prot_elem_decl -> comp_decl .)
    FOR             reduce using rule 387 (prot_elem_decl -> comp_decl .)
    IDENTIFIER      reduce using rule 387 (prot_elem_decl -> comp_decl .)
    END             reduce using rule 387 (prot_elem_decl -> comp_decl .)


state 785

    (386) prot_elem_decl -> prot_op_decl .

    error           reduce using rule 386 (prot_elem_decl -> prot_op_decl .)
    ENTRY           reduce using rule 386 (prot_elem_decl -> prot_op_decl .)
    PROCEDURE       reduce using rule 386 (prot_elem_decl -> prot_op_decl .)
    FUNCTION        reduce using rule 386 (prot_elem_decl -> prot_op_decl .)
    PRAGMA          reduce using rule 386 (prot_elem_decl -> prot_op_decl .)
    FOR             reduce using rule 386 (prot_elem_decl -> prot_op_decl .)
    IDENTIFIER      reduce using rule 386 (prot_elem_decl -> prot_op_decl .)
    END             reduce using rule 386 (prot_elem_decl -> prot_op_decl .)


state 786

    (385) prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .

    error           reduce using rule 385 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    ENTRY           reduce using rule 385 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    PROCEDURE       reduce using rule 385 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    FUNCTION        reduce using rule 385 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    PRAGMA          reduce using rule 385 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    FOR             reduce using rule 385 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    IDENTIFIER      reduce using rule 385 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    END             reduce using rule 385 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)


state 787

    (111) comp_decl -> error . ;

    ;               shift and go to state 858


state 788

    (375) prot_def -> IS prot_op_decl_s prot_private_opt END id_opt .

    ;               reduce using rule 375 (prot_def -> IS prot_op_decl_s prot_private_opt END id_opt .)


state 789

    (397) entry_decl -> ENTRY IDENTIFIER ( . discrete_range ) formal_part_opt ;
    (326) formal_part -> ( . param_s )
    (93) discrete_range -> . name range_constr_opt
    (94) discrete_range -> . range
    (327) param_s -> . param
    (328) param_s -> . param_s ; param
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name TICK RANGE
    (64) range -> . name TICK RANGE ( expression )
    (329) param -> . def_id_s : mode mark init_opt
    (330) param -> . error
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (26) def_id -> . IDENTIFIER
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 109
    IDENTIFIER      shift and go to state 859
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    param                          shift and go to state 343
    simple_expression              shift and go to state 361
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    param_s                        shift and go to state 344
    literal                        shift and go to state 135
    def_id_s                       shift and go to state 105
    factor                         shift and go to state 137
    def_id                         shift and go to state 89
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    discrete_range                 shift and go to state 860
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 684
    operator_symbol                shift and go to state 149
    range                          shift and go to state 685

state 790

    (396) entry_decl -> ENTRY IDENTIFIER formal_part_opt . ;

    ;               shift and go to state 861


state 791

    (96) range_constr_opt -> range_constraint .

    LOOP            reduce using rule 96 (range_constr_opt -> range_constraint .)
    )               reduce using rule 96 (range_constr_opt -> range_constraint .)
    ,               reduce using rule 96 (range_constr_opt -> range_constraint .)
    ;               reduce using rule 96 (range_constr_opt -> range_constraint .)
    RENAMES         reduce using rule 96 (range_constr_opt -> range_constraint .)
    ASSIGNMENT      reduce using rule 96 (range_constr_opt -> range_constraint .)
    WITH            reduce using rule 96 (range_constr_opt -> range_constraint .)


state 792

    (93) discrete_range -> name range_constr_opt .

    )               reduce using rule 93 (discrete_range -> name range_constr_opt .)
    LOOP            reduce using rule 93 (discrete_range -> name range_constr_opt .)
    ,               reduce using rule 93 (discrete_range -> name range_constr_opt .)


state 793

    (301) block -> label_opt block_decl block_body END id_opt . ;

    ;               shift and go to state 862


state 794

    (289) loop_stmt -> label_opt iteration basic_loop id_opt ; .

    EXCEPTION       reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    LESSLESS        reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    error           reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    PRAGMA          reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    NuLL            reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    EXIT            reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    RETURN          reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    GOTO            reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    DELAY           reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    ABORT           reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    RAISE           reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    REQUEUE         reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    IF              reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    CASE            reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    IDENTIFIER      reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    ACCEPT          reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    SELECT          reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    STRING          reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    WHILE           reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    DECLARE         reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    FOR             reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    LOOP            reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    BEGIN           reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    END             reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    WHEN            reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    THEN            reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    OR              reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    ELSE            reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    ELSIF           reduce using rule 289 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)


state 795

    (298) basic_loop -> LOOP statement_s END . LOOP

    LOOP            shift and go to state 863


state 796

    (409) entry_name -> entry_name ( expression ) .

    (               reduce using rule 409 (entry_name -> entry_name ( expression ) .)
    ;               reduce using rule 409 (entry_name -> entry_name ( expression ) .)
    DO              reduce using rule 409 (entry_name -> entry_name ( expression ) .)


state 797

    (428) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s . END SELECT ;
    (249) statement_s -> statement_s . statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    END             shift and go to state 864
    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 459
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 798

    (427) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt . stmts_opt END SELECT ;
    (429) stmts_opt -> .
    (430) stmts_opt -> . statement_s
    (248) statement_s -> . statement
    (249) statement_s -> . statement_s statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    END             reduce using rule 429 (stmts_opt -> .)
    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    statement_s                    shift and go to state 565
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 292
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    stmts_opt                      shift and go to state 865
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 799

    (426) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s . END SELECT ;
    (249) statement_s -> statement_s . statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    END             shift and go to state 866
    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    assign_stmt                    shift and go to state 311
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 459
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    procedure_call                 shift and go to state 279
    block                          shift and go to state 286

state 800

    (422) select_alt -> delay_stmt . stmts_opt
    (429) stmts_opt -> .
    (430) stmts_opt -> . statement_s
    (248) statement_s -> . statement
    (249) statement_s -> . statement_s statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    OR              reduce using rule 429 (stmts_opt -> .)
    ELSE            reduce using rule 429 (stmts_opt -> .)
    END             reduce using rule 429 (stmts_opt -> .)
    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    statement_s                    shift and go to state 565
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 292
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    stmts_opt                      shift and go to state 867
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 801

    (418) guarded_select_alt -> WHEN condition ARROW select_alt .

    OR              reduce using rule 418 (guarded_select_alt -> WHEN condition ARROW select_alt .)
    ELSE            reduce using rule 418 (guarded_select_alt -> WHEN condition ARROW select_alt .)
    END             reduce using rule 418 (guarded_select_alt -> WHEN condition ARROW select_alt .)


state 802

    (416) select_wait -> SELECT guarded_select_alt or_select else_opt END . SELECT ;

    SELECT          shift and go to state 868


state 803

    (420) or_select -> or_select OR guarded_select_alt .

    OR              reduce using rule 420 (or_select -> or_select OR guarded_select_alt .)
    ELSE            reduce using rule 420 (or_select -> or_select OR guarded_select_alt .)
    END             reduce using rule 420 (or_select -> or_select OR guarded_select_alt .)


state 804

    (284) case_stmt -> case_hdr pragma_s alternative_s END CASE . ;

    ;               shift and go to state 869


state 805

    (288) alternative -> WHEN choice_s . ARROW statement_s
    (124) choice_s -> choice_s . | choice

    ARROW           shift and go to state 870
    |               shift and go to state 368


state 806

    (472) requeue_stmt -> REQUEUE name WITH ABORT ; .

    LESSLESS        reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    error           reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    PRAGMA          reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    NuLL            reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    EXIT            reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    RETURN          reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    GOTO            reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    DELAY           reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    ABORT           reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    RAISE           reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    REQUEUE         reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    IF              reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    CASE            reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    IDENTIFIER      reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    ACCEPT          reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    SELECT          reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    STRING          reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    WHILE           reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    DECLARE         reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    FOR             reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    LOOP            reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    BEGIN           reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    OR              reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    ELSE            reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    END             reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    THEN            reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    WHEN            reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    EXCEPTION       reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    ELSIF           reduce using rule 472 (requeue_stmt -> REQUEUE name WITH ABORT ; .)


state 807

    (406) accept_stmt -> accept_hdr DO handled_stmt_s END id_opt . ;

    ;               shift and go to state 871


state 808

    (464) exception_handler -> WHEN except_choice_s ARROW . statement_s
    (248) statement_s -> . statement
    (249) statement_s -> . statement_s statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    statement_s                    shift and go to state 872
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 292
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 809

    (467) except_choice_s -> except_choice_s | . except_choice
    (468) except_choice -> . name
    (469) except_choice -> . OTHERS
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    OTHERS          shift and go to state 709
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 710
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    except_choice                  shift and go to state 873
    simple_name                    shift and go to state 158

state 810

    (465) exception_handler -> WHEN IDENTIFIER : . except_choice_s ARROW statement_s
    (466) except_choice_s -> . except_choice
    (467) except_choice_s -> . except_choice_s | except_choice
    (468) except_choice -> . name
    (469) except_choice -> . OTHERS
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    OTHERS          shift and go to state 709
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 710
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    except_choice_s                shift and go to state 874
    except_choice                  shift and go to state 708
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 811

    (276) if_stmt -> IF cond_clause_s else_opt END IF . ;

    ;               shift and go to state 875


state 812

    (510) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END . RECORD ;

    RECORD          shift and go to state 876


state 813

    (514) comp_loc_s -> comp_loc_s mark . AT expression RANGE range ;
    (161) mark -> mark . TICK attribute_id
    (162) mark -> mark . . simple_name

    AT              shift and go to state 877
    TICK            shift and go to state 315
    .               shift and go to state 314


state 814

    (512) align_opt -> AT MOD expression . ;
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE

    ;               shift and go to state 878
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250

    logical                        shift and go to state 251
    short_circuit                  shift and go to state 252

state 815

    (371) task_body -> TASK BODY simple_name IS decl_part block_body END . id_opt ;
    (299) id_opt -> .
    (300) id_opt -> . designator
    (322) designator -> . compound_name
    (323) designator -> . STRING
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    ;               reduce using rule 299 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 466
    id_opt                         shift and go to state 879
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 816

    (403) rep_spec_s -> rep_spec_s rep_spec pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    PRIVATE         reduce using rule 403 (rep_spec_s -> rep_spec_s rep_spec pragma_s .)
    FOR             reduce using rule 403 (rep_spec_s -> rep_spec_s rep_spec pragma_s .)
    END             reduce using rule 403 (rep_spec_s -> rep_spec_s rep_spec pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 817

    (370) task_private_opt -> PRIVATE entry_decl_s . rep_spec_s
    (395) entry_decl_s -> entry_decl_s . entry_decl pragma_s
    (402) rep_spec_s -> .
    (403) rep_spec_s -> . rep_spec_s rep_spec pragma_s
    (396) entry_decl -> . ENTRY IDENTIFIER formal_part_opt ;
    (397) entry_decl -> . ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ;

    FOR             reduce using rule 402 (rep_spec_s -> .)
    END             reduce using rule 402 (rep_spec_s -> .)
    ENTRY           shift and go to state 544

    rep_spec_s                     shift and go to state 880
    entry_decl                     shift and go to state 597

state 818

    (368) task_def -> IS entry_decl_s rep_spec_s task_private_opt END . id_opt
    (299) id_opt -> .
    (300) id_opt -> . designator
    (322) designator -> . compound_name
    (323) designator -> . STRING
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    ;               reduce using rule 299 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 466
    id_opt                         shift and go to state 881
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 819

    (115) discrim_spec -> def_id_s : access_opt mark . init_opt
    (161) mark -> mark . TICK attribute_id
    (162) mark -> mark . . simple_name
    (33) init_opt -> .
    (34) init_opt -> . ASSIGNMENT expression

    TICK            shift and go to state 315
    .               shift and go to state 314
    )               reduce using rule 33 (init_opt -> .)
    ;               reduce using rule 33 (init_opt -> .)
    ASSIGNMENT      shift and go to state 635

    init_opt                       shift and go to state 882

state 820

    (59) derived_type -> ABSTRACT NEW subtype_ind . WITH PRIVATE
    (60) derived_type -> ABSTRACT NEW subtype_ind . WITH record_def

    WITH            shift and go to state 883


state 821

    (57) derived_type -> NEW subtype_ind WITH . PRIVATE
    (58) derived_type -> NEW subtype_ind WITH . record_def
    (98) record_def -> . RECORD pragma_s comp_list END RECORD
    (99) record_def -> . NuLL RECORD

    PRIVATE         shift and go to state 884
    RECORD          shift and go to state 833
    NuLL            shift and go to state 834

    record_def                     shift and go to state 885

state 822

    (65) enumeration_type -> ( enum_id_s ) .

    ;               reduce using rule 65 (enumeration_type -> ( enum_id_s ) .)


state 823

    (67) enum_id_s -> enum_id_s , . enum_id
    (68) enum_id -> . IDENTIFIER
    (69) enum_id -> . CHAR

    IDENTIFIER      shift and go to state 732
    CHAR            shift and go to state 731

    enum_id                        shift and go to state 886

state 824

    (74) range_spec_opt -> range_spec .

    ;               reduce using rule 74 (range_spec_opt -> range_spec .)


state 825

    (77) float_type -> DIGITS expression range_spec_opt .

    ;               reduce using rule 77 (float_type -> DIGITS expression range_spec_opt .)


state 826

    (79) fixed_type -> DELTA expression DIGITS . expression range_spec_opt
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 887

state 827

    (78) fixed_type -> DELTA expression range_spec .

    ;               reduce using rule 78 (fixed_type -> DELTA expression range_spec .)


state 828

    (131) access_type -> ACCESS CONSTANT subtype_ind .

    ;               reduce using rule 131 (access_type -> ACCESS CONSTANT subtype_ind .)


state 829

    (134) access_type -> ACCESS prot_opt FUNCTION . formal_part_opt RETURN mark
    (324) formal_part_opt -> .
    (325) formal_part_opt -> . formal_part
    (326) formal_part -> . ( param_s )

    RETURN          reduce using rule 324 (formal_part_opt -> .)
    (               shift and go to state 190

    formal_part                    shift and go to state 189
    formal_part_opt                shift and go to state 888

state 830

    (133) access_type -> ACCESS prot_opt PROCEDURE . formal_part_opt
    (324) formal_part_opt -> .
    (325) formal_part_opt -> . formal_part
    (326) formal_part -> . ( param_s )

    ;               reduce using rule 324 (formal_part_opt -> .)
    (               shift and go to state 190

    formal_part                    shift and go to state 189
    formal_part_opt                shift and go to state 889

state 831

    (132) access_type -> ACCESS ALL subtype_ind .

    ;               reduce using rule 132 (access_type -> ACCESS ALL subtype_ind .)


state 832

    (349) private_type -> tagged_opt limited_opt PRIVATE .

    ;               reduce using rule 349 (private_type -> tagged_opt limited_opt PRIVATE .)


state 833

    (98) record_def -> RECORD . pragma_s comp_list END RECORD
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    NuLL            reduce using rule 8 (pragma_s -> .)
    PRAGMA          reduce using rule 8 (pragma_s -> .)
    CASE            reduce using rule 8 (pragma_s -> .)
    error           reduce using rule 8 (pragma_s -> .)
    IDENTIFIER      reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 890

state 834

    (99) record_def -> NuLL . RECORD

    RECORD          shift and go to state 891


state 835

    (97) record_type -> tagged_opt limited_opt record_def .

    ;               reduce using rule 97 (record_type -> tagged_opt limited_opt record_def .)


state 836

    (55) decimal_digits_constraint -> DIGITS expression range_constr_opt .

    ;               reduce using rule 55 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)
    RENAMES         reduce using rule 55 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)
    ASSIGNMENT      reduce using rule 55 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)
    WITH            reduce using rule 55 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)


state 837

    (90) iter_index_constraint -> ( iter_discrete_range_s ) .

    OF              reduce using rule 90 (iter_index_constraint -> ( iter_discrete_range_s ) .)


state 838

    (92) iter_discrete_range_s -> iter_discrete_range_s , . discrete_range
    (93) discrete_range -> . name range_constr_opt
    (94) discrete_range -> . range
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name TICK RANGE
    (64) range -> . name TICK RANGE ( expression )
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    simple_expression              shift and go to state 361
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    discrete_range                 shift and go to state 892
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 684
    operator_symbol                shift and go to state 149
    range                          shift and go to state 685

state 839

    (82) unconstr_array_type -> ARRAY ( index_s ) . OF component_subtype_def

    OF              shift and go to state 893


state 840

    (88) index_s -> index_s , . index
    (89) index -> . name RANGE LESSMORE
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    index                          shift and go to state 894
    name                           shift and go to state 895
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 841

    (89) index -> name RANGE . LESSMORE
    (61) range_constraint -> RANGE . range
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name TICK RANGE
    (64) range -> . name TICK RANGE ( expression )
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    LESSMORE        shift and go to state 896
    +               shift and go to state 133
    -               shift and go to state 134
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    simple_expression              shift and go to state 361
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 523
    operator_symbol                shift and go to state 149
    range                          shift and go to state 524

state 842

    (86) aliased_opt -> ALIASED .

    IDENTIFIER      reduce using rule 86 (aliased_opt -> ALIASED .)
    STRING          reduce using rule 86 (aliased_opt -> ALIASED .)


state 843

    (84) component_subtype_def -> aliased_opt . subtype_ind
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 485
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    subtype_ind                    shift and go to state 897
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158

state 844

    (83) constr_array_type -> ARRAY iter_index_constraint OF component_subtype_def .

    ;               reduce using rule 83 (constr_array_type -> ARRAY iter_index_constraint OF component_subtype_def .)
    ASSIGNMENT      reduce using rule 83 (constr_array_type -> ARRAY iter_index_constraint OF component_subtype_def .)


state 845

    (346) pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt . ;

    ;               shift and go to state 898


state 846

    (480) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default . ;

    ;               shift and go to state 899


state 847

    (481) generic_formal -> WITH PACKAGE simple_name IS NEW name ( . LESSMORE ) ;
    (170) indexed_comp -> name ( . value_s )
    (171) value_s -> . value
    (172) value_s -> . value_s , value
    (173) value -> . expression
    (174) value -> . comp_assoc
    (175) value -> . discrete_with_range
    (176) value -> . error
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (199) comp_assoc -> . choice_s ARROW expression
    (128) discrete_with_range -> . name range_constraint
    (129) discrete_with_range -> . range
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (123) choice_s -> . choice
    (124) choice_s -> . choice_s | choice
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name TICK RANGE
    (64) range -> . name TICK RANGE ( expression )
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (125) choice -> . expression
    (126) choice -> . discrete_with_range
    (127) choice -> . OTHERS
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    LESSMORE        shift and go to state 900
    error           shift and go to state 234
    OTHERS          shift and go to state 224
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    value_s                        shift and go to state 383
    simple_expression              shift and go to state 384
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    choice_s                       shift and go to state 226
    comp_assoc                     shift and go to state 385
    factor                         shift and go to state 137
    choice                         shift and go to state 228
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    discrete_with_range            shift and go to state 230
    term                           shift and go to state 146
    name                           shift and go to state 231
    operator_symbol                shift and go to state 149
    value                          shift and go to state 386
    range                          shift and go to state 233
    expression                     shift and go to state 387

state 848

    (482) generic_formal -> WITH PACKAGE simple_name IS NEW name ; .

    PACKAGE         reduce using rule 482 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    PROCEDURE       reduce using rule 482 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    FUNCTION        reduce using rule 482 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    TYPE            reduce using rule 482 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    WITH            reduce using rule 482 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    error           reduce using rule 482 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    USE             reduce using rule 482 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    IDENTIFIER      reduce using rule 482 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)


state 849

    (502) generic_derived_type -> ABSTRACT NEW subtype_ind . WITH PRIVATE

    WITH            shift and go to state 901


state 850

    (501) generic_derived_type -> NEW subtype_ind WITH . PRIVATE

    PRIVATE         shift and go to state 902


state 851

    (490) generic_type_def -> ( LESSMORE ) .

    ;               reduce using rule 490 (generic_type_def -> ( LESSMORE ) .)


state 852

    (494) generic_type_def -> DELTA LESSMORE DIGITS . LESSMORE

    LESSMORE        shift and go to state 903


state 853

    (64) range -> name TICK RANGE ( expression ) .

    )               reduce using rule 64 (range -> name TICK RANGE ( expression ) .)
    ,               reduce using rule 64 (range -> name TICK RANGE ( expression ) .)
    ARROW           reduce using rule 64 (range -> name TICK RANGE ( expression ) .)
    |               reduce using rule 64 (range -> name TICK RANGE ( expression ) .)
    ;               reduce using rule 64 (range -> name TICK RANGE ( expression ) .)
    LOOP            reduce using rule 64 (range -> name TICK RANGE ( expression ) .)
    AND             reduce using rule 64 (range -> name TICK RANGE ( expression ) .)
    OR              reduce using rule 64 (range -> name TICK RANGE ( expression ) .)
    XOR             reduce using rule 64 (range -> name TICK RANGE ( expression ) .)
    WITH            reduce using rule 64 (range -> name TICK RANGE ( expression ) .)
    IS              reduce using rule 64 (range -> name TICK RANGE ( expression ) .)
    THEN            reduce using rule 64 (range -> name TICK RANGE ( expression ) .)
    RANGE           reduce using rule 64 (range -> name TICK RANGE ( expression ) .)
    DIGITS          reduce using rule 64 (range -> name TICK RANGE ( expression ) .)
    RENAMES         reduce using rule 64 (range -> name TICK RANGE ( expression ) .)
    ASSIGNMENT      reduce using rule 64 (range -> name TICK RANGE ( expression ) .)


state 854

    (388) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .

    PACKAGE         reduce using rule 388 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    TASK            reduce using rule 388 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    PROTECTED       reduce using rule 388 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    error           reduce using rule 388 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    USE             reduce using rule 388 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    PRAGMA          reduce using rule 388 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    TYPE            reduce using rule 388 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    SUBTYPE         reduce using rule 388 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    FOR             reduce using rule 388 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    PROCEDURE       reduce using rule 388 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    FUNCTION        reduce using rule 388 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    GENERIC         reduce using rule 388 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    IDENTIFIER      reduce using rule 388 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    BEGIN           reduce using rule 388 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    END             reduce using rule 388 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    PRIVATE         reduce using rule 388 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    WITH            reduce using rule 388 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    SEPARATE        reduce using rule 388 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    $end            reduce using rule 388 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)


state 855

    (399) entry_body -> ENTRY IDENTIFIER ( . iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part
    (326) formal_part -> ( . param_s )
    (295) iter_part -> . FOR IDENTIFIER IN
    (327) param_s -> . param
    (328) param_s -> . param_s ; param
    (329) param -> . def_id_s : mode mark init_opt
    (330) param -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    FOR             shift and go to state 420
    error           shift and go to state 109
    IDENTIFIER      shift and go to state 76

    def_id                         shift and go to state 89
    param_s                        shift and go to state 344
    iter_part                      shift and go to state 904
    param                          shift and go to state 343
    def_id_s                       shift and go to state 105

state 856

    (398) entry_body -> ENTRY IDENTIFIER formal_part_opt . WHEN condition entry_body_part

    WHEN            shift and go to state 905


state 857

    (110) comp_decl -> def_id_s : . component_subtype_def init_opt ;
    (84) component_subtype_def -> . aliased_opt subtype_ind
    (85) aliased_opt -> .
    (86) aliased_opt -> . ALIASED

    IDENTIFIER      reduce using rule 85 (aliased_opt -> .)
    STRING          reduce using rule 85 (aliased_opt -> .)
    ALIASED         shift and go to state 842

    aliased_opt                    shift and go to state 843
    component_subtype_def          shift and go to state 906

state 858

    (111) comp_decl -> error ; .

    error           reduce using rule 111 (comp_decl -> error ; .)
    CASE            reduce using rule 111 (comp_decl -> error ; .)
    PRAGMA          reduce using rule 111 (comp_decl -> error ; .)
    IDENTIFIER      reduce using rule 111 (comp_decl -> error ; .)
    END             reduce using rule 111 (comp_decl -> error ; .)
    WHEN            reduce using rule 111 (comp_decl -> error ; .)
    ENTRY           reduce using rule 111 (comp_decl -> error ; .)
    PROCEDURE       reduce using rule 111 (comp_decl -> error ; .)
    FUNCTION        reduce using rule 111 (comp_decl -> error ; .)
    FOR             reduce using rule 111 (comp_decl -> error ; .)


state 859

    (163) simple_name -> IDENTIFIER .
    (26) def_id -> IDENTIFIER .

    TICK            reduce using rule 163 (simple_name -> IDENTIFIER .)
    (               reduce using rule 163 (simple_name -> IDENTIFIER .)
    .               reduce using rule 163 (simple_name -> IDENTIFIER .)
    RANGE           reduce using rule 163 (simple_name -> IDENTIFIER .)
    )               reduce using rule 163 (simple_name -> IDENTIFIER .)
    STARSTAR        reduce using rule 163 (simple_name -> IDENTIFIER .)
    *               reduce using rule 163 (simple_name -> IDENTIFIER .)
    /               reduce using rule 163 (simple_name -> IDENTIFIER .)
    MOD             reduce using rule 163 (simple_name -> IDENTIFIER .)
    REM             reduce using rule 163 (simple_name -> IDENTIFIER .)
    DOTDOT          reduce using rule 163 (simple_name -> IDENTIFIER .)
    +               reduce using rule 163 (simple_name -> IDENTIFIER .)
    -               reduce using rule 163 (simple_name -> IDENTIFIER .)
    &               reduce using rule 163 (simple_name -> IDENTIFIER .)
    :               reduce using rule 26 (def_id -> IDENTIFIER .)
    ,               reduce using rule 26 (def_id -> IDENTIFIER .)


state 860

    (397) entry_decl -> ENTRY IDENTIFIER ( discrete_range . ) formal_part_opt ;

    )               shift and go to state 907


state 861

    (396) entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .

    PRIVATE         reduce using rule 396 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    ENTRY           reduce using rule 396 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    PROCEDURE       reduce using rule 396 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    FUNCTION        reduce using rule 396 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    PRAGMA          reduce using rule 396 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    FOR             reduce using rule 396 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    END             reduce using rule 396 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    error           reduce using rule 396 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    IDENTIFIER      reduce using rule 396 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)


state 862

    (301) block -> label_opt block_decl block_body END id_opt ; .

    END             reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    LESSLESS        reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    error           reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    PRAGMA          reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    NuLL            reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    EXIT            reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    RETURN          reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    GOTO            reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    DELAY           reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    ABORT           reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    RAISE           reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    REQUEUE         reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    IF              reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    CASE            reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    IDENTIFIER      reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    ACCEPT          reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    SELECT          reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    STRING          reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    WHILE           reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    DECLARE         reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    FOR             reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    LOOP            reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    BEGIN           reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    EXCEPTION       reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    WHEN            reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    OR              reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    ELSE            reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    THEN            reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)
    ELSIF           reduce using rule 301 (block -> label_opt block_decl block_body END id_opt ; .)


state 863

    (298) basic_loop -> LOOP statement_s END LOOP .

    STRING          reduce using rule 298 (basic_loop -> LOOP statement_s END LOOP .)
    IDENTIFIER      reduce using rule 298 (basic_loop -> LOOP statement_s END LOOP .)
    ;               reduce using rule 298 (basic_loop -> LOOP statement_s END LOOP .)


state 864

    (428) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END . SELECT ;

    SELECT          shift and go to state 908


state 865

    (427) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt . END SELECT ;

    END             shift and go to state 909


state 866

    (426) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END . SELECT ;

    SELECT          shift and go to state 910


state 867

    (422) select_alt -> delay_stmt stmts_opt .

    OR              reduce using rule 422 (select_alt -> delay_stmt stmts_opt .)
    ELSE            reduce using rule 422 (select_alt -> delay_stmt stmts_opt .)
    END             reduce using rule 422 (select_alt -> delay_stmt stmts_opt .)


state 868

    (416) select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT . ;

    ;               shift and go to state 911


state 869

    (284) case_stmt -> case_hdr pragma_s alternative_s END CASE ; .

    LESSLESS        reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    error           reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    PRAGMA          reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    NuLL            reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    EXIT            reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    RETURN          reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    GOTO            reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    DELAY           reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    ABORT           reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    RAISE           reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    REQUEUE         reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    IF              reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    CASE            reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    IDENTIFIER      reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    ACCEPT          reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    SELECT          reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    STRING          reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    WHILE           reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    DECLARE         reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    FOR             reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    LOOP            reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    BEGIN           reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    OR              reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    ELSE            reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    END             reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    THEN            reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    EXCEPTION       reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    WHEN            reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    ELSIF           reduce using rule 284 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)


state 870

    (288) alternative -> WHEN choice_s ARROW . statement_s
    (248) statement_s -> . statement
    (249) statement_s -> . statement_s statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    statement_s                    shift and go to state 912
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 292
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 871

    (406) accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .

    END             reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    LESSLESS        reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    error           reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    PRAGMA          reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    NuLL            reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    EXIT            reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    RETURN          reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    GOTO            reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    DELAY           reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    ABORT           reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    RAISE           reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    REQUEUE         reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    IF              reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    CASE            reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    IDENTIFIER      reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    ACCEPT          reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    SELECT          reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    STRING          reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    WHILE           reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    DECLARE         reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    FOR             reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    LOOP            reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    BEGIN           reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    WHEN            reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    ELSIF           reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    ELSE            reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    OR              reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    THEN            reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    EXCEPTION       reduce using rule 406 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)


state 872

    (464) exception_handler -> WHEN except_choice_s ARROW statement_s .
    (249) statement_s -> statement_s . statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    WHEN            reduce using rule 464 (exception_handler -> WHEN except_choice_s ARROW statement_s .)
    END             reduce using rule 464 (exception_handler -> WHEN except_choice_s ARROW statement_s .)
    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 459
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 873

    (467) except_choice_s -> except_choice_s | except_choice .

    ARROW           reduce using rule 467 (except_choice_s -> except_choice_s | except_choice .)
    |               reduce using rule 467 (except_choice_s -> except_choice_s | except_choice .)


state 874

    (465) exception_handler -> WHEN IDENTIFIER : except_choice_s . ARROW statement_s
    (467) except_choice_s -> except_choice_s . | except_choice

    ARROW           shift and go to state 913
    |               shift and go to state 809


state 875

    (276) if_stmt -> IF cond_clause_s else_opt END IF ; .

    LESSLESS        reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    error           reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    PRAGMA          reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    NuLL            reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    EXIT            reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    RETURN          reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    GOTO            reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    DELAY           reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    ABORT           reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    RAISE           reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    REQUEUE         reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    IF              reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    CASE            reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    IDENTIFIER      reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    ACCEPT          reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    SELECT          reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    STRING          reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    WHILE           reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    DECLARE         reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    FOR             reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    LOOP            reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    BEGIN           reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    END             reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    WHEN            reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    EXCEPTION       reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    OR              reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    ELSE            reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    THEN            reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    ELSIF           reduce using rule 276 (if_stmt -> IF cond_clause_s else_opt END IF ; .)


state 876

    (510) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD . ;

    ;               shift and go to state 914


state 877

    (514) comp_loc_s -> comp_loc_s mark AT . expression RANGE range ;
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 915

state 878

    (512) align_opt -> AT MOD expression ; .

    END             reduce using rule 512 (align_opt -> AT MOD expression ; .)
    IDENTIFIER      reduce using rule 512 (align_opt -> AT MOD expression ; .)


state 879

    (371) task_body -> TASK BODY simple_name IS decl_part block_body END id_opt . ;

    ;               shift and go to state 916


state 880

    (370) task_private_opt -> PRIVATE entry_decl_s rep_spec_s .
    (403) rep_spec_s -> rep_spec_s . rep_spec pragma_s
    (506) rep_spec -> . attrib_def
    (507) rep_spec -> . record_type_spec
    (508) rep_spec -> . address_spec
    (509) attrib_def -> . FOR mark USE expression ;
    (510) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (515) address_spec -> . FOR mark USE AT expression ;

    END             reduce using rule 370 (task_private_opt -> PRIVATE entry_decl_s rep_spec_s .)
    FOR             shift and go to state 63

    record_type_spec               shift and go to state 68
    rep_spec                       shift and go to state 719
    attrib_def                     shift and go to state 70
    address_spec                   shift and go to state 52

state 881

    (368) task_def -> IS entry_decl_s rep_spec_s task_private_opt END id_opt .

    ;               reduce using rule 368 (task_def -> IS entry_decl_s rep_spec_s task_private_opt END id_opt .)


state 882

    (115) discrim_spec -> def_id_s : access_opt mark init_opt .

    )               reduce using rule 115 (discrim_spec -> def_id_s : access_opt mark init_opt .)
    ;               reduce using rule 115 (discrim_spec -> def_id_s : access_opt mark init_opt .)


state 883

    (59) derived_type -> ABSTRACT NEW subtype_ind WITH . PRIVATE
    (60) derived_type -> ABSTRACT NEW subtype_ind WITH . record_def
    (98) record_def -> . RECORD pragma_s comp_list END RECORD
    (99) record_def -> . NuLL RECORD

    PRIVATE         shift and go to state 917
    RECORD          shift and go to state 833
    NuLL            shift and go to state 834

    record_def                     shift and go to state 918

state 884

    (57) derived_type -> NEW subtype_ind WITH PRIVATE .

    ;               reduce using rule 57 (derived_type -> NEW subtype_ind WITH PRIVATE .)


state 885

    (58) derived_type -> NEW subtype_ind WITH record_def .

    ;               reduce using rule 58 (derived_type -> NEW subtype_ind WITH record_def .)


state 886

    (67) enum_id_s -> enum_id_s , enum_id .

    )               reduce using rule 67 (enum_id_s -> enum_id_s , enum_id .)
    ,               reduce using rule 67 (enum_id_s -> enum_id_s , enum_id .)


state 887

    (79) fixed_type -> DELTA expression DIGITS expression . range_spec_opt
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (73) range_spec_opt -> .
    (74) range_spec_opt -> . range_spec
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE
    (72) range_spec -> . range_constraint
    (61) range_constraint -> . RANGE range

    ;               reduce using rule 73 (range_spec_opt -> .)
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250
    RANGE           shift and go to state 373

    logical                        shift and go to state 251
    short_circuit                  shift and go to state 252
    range_constraint               shift and go to state 604
    range_spec                     shift and go to state 824
    range_spec_opt                 shift and go to state 919

state 888

    (134) access_type -> ACCESS prot_opt FUNCTION formal_part_opt . RETURN mark

    RETURN          shift and go to state 920


state 889

    (133) access_type -> ACCESS prot_opt PROCEDURE formal_part_opt .

    ;               reduce using rule 133 (access_type -> ACCESS prot_opt PROCEDURE formal_part_opt .)


state 890

    (98) record_def -> RECORD pragma_s . comp_list END RECORD
    (9) pragma_s -> pragma_s . pragma
    (103) comp_list -> . comp_decl_s variant_part_opt
    (104) comp_list -> . variant_part pragma_s
    (105) comp_list -> . NuLL ; pragma_s
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (106) comp_decl_s -> . comp_decl
    (107) comp_decl_s -> . comp_decl_s pragma_s comp_decl
    (119) variant_part -> . CASE simple_name IS pragma_s variant_s END CASE ;
    (110) comp_decl -> . def_id_s : component_subtype_def init_opt ;
    (111) comp_decl -> . error ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    NuLL            shift and go to state 926
    PRAGMA          shift and go to state 4
    CASE            shift and go to state 922
    error           shift and go to state 787
    IDENTIFIER      shift and go to state 76

    def_id_s                       shift and go to state 783
    comp_list                      shift and go to state 923
    comp_decl                      shift and go to state 924
    def_id                         shift and go to state 89
    variant_part                   shift and go to state 925
    pragma                         shift and go to state 14
    comp_decl_s                    shift and go to state 921

state 891

    (99) record_def -> NuLL RECORD .

    ;               reduce using rule 99 (record_def -> NuLL RECORD .)


state 892

    (92) iter_discrete_range_s -> iter_discrete_range_s , discrete_range .

    )               reduce using rule 92 (iter_discrete_range_s -> iter_discrete_range_s , discrete_range .)
    ,               reduce using rule 92 (iter_discrete_range_s -> iter_discrete_range_s , discrete_range .)


state 893

    (82) unconstr_array_type -> ARRAY ( index_s ) OF . component_subtype_def
    (84) component_subtype_def -> . aliased_opt subtype_ind
    (85) aliased_opt -> .
    (86) aliased_opt -> . ALIASED

    IDENTIFIER      reduce using rule 85 (aliased_opt -> .)
    STRING          reduce using rule 85 (aliased_opt -> .)
    ALIASED         shift and go to state 842

    aliased_opt                    shift and go to state 843
    component_subtype_def          shift and go to state 927

state 894

    (88) index_s -> index_s , index .

    )               reduce using rule 88 (index_s -> index_s , index .)
    ,               reduce using rule 88 (index_s -> index_s , index .)


state 895

    (89) index -> name . RANGE LESSMORE
    (170) indexed_comp -> name . ( value_s )
    (177) selected_comp -> name . . simple_name
    (178) selected_comp -> name . . used_char
    (179) selected_comp -> name . . operator_symbol
    (180) selected_comp -> name . . ALL
    (181) attribute -> name . TICK attribute_id

    RANGE           shift and go to state 928
    (               shift and go to state 245
    .               shift and go to state 246
    TICK            shift and go to state 256


state 896

    (89) index -> name RANGE LESSMORE .

    )               reduce using rule 89 (index -> name RANGE LESSMORE .)
    ,               reduce using rule 89 (index -> name RANGE LESSMORE .)


state 897

    (84) component_subtype_def -> aliased_opt subtype_ind .

    ASSIGNMENT      reduce using rule 84 (component_subtype_def -> aliased_opt subtype_ind .)
    ;               reduce using rule 84 (component_subtype_def -> aliased_opt subtype_ind .)


state 898

    (346) pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .

    PACKAGE         reduce using rule 346 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    TASK            reduce using rule 346 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    PROTECTED       reduce using rule 346 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    error           reduce using rule 346 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    USE             reduce using rule 346 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    PRAGMA          reduce using rule 346 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    TYPE            reduce using rule 346 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    SUBTYPE         reduce using rule 346 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    FOR             reduce using rule 346 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    PROCEDURE       reduce using rule 346 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    FUNCTION        reduce using rule 346 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    GENERIC         reduce using rule 346 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    IDENTIFIER      reduce using rule 346 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    BEGIN           reduce using rule 346 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    END             reduce using rule 346 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    PRIVATE         reduce using rule 346 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    WITH            reduce using rule 346 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    SEPARATE        reduce using rule 346 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    $end            reduce using rule 346 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)


state 899

    (480) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .

    PACKAGE         reduce using rule 480 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    PROCEDURE       reduce using rule 480 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    FUNCTION        reduce using rule 480 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    TYPE            reduce using rule 480 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    WITH            reduce using rule 480 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    error           reduce using rule 480 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    USE             reduce using rule 480 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    IDENTIFIER      reduce using rule 480 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)


state 900

    (481) generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE . ) ;

    )               shift and go to state 929


state 901

    (502) generic_derived_type -> ABSTRACT NEW subtype_ind WITH . PRIVATE

    PRIVATE         shift and go to state 930


state 902

    (501) generic_derived_type -> NEW subtype_ind WITH PRIVATE .

    ;               reduce using rule 501 (generic_derived_type -> NEW subtype_ind WITH PRIVATE .)


state 903

    (494) generic_type_def -> DELTA LESSMORE DIGITS LESSMORE .

    ;               reduce using rule 494 (generic_type_def -> DELTA LESSMORE DIGITS LESSMORE .)


state 904

    (399) entry_body -> ENTRY IDENTIFIER ( iter_part . discrete_range ) formal_part_opt WHEN condition entry_body_part
    (93) discrete_range -> . name range_constr_opt
    (94) discrete_range -> . range
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name TICK RANGE
    (64) range -> . name TICK RANGE ( expression )
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    simple_expression              shift and go to state 361
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    allocator                      shift and go to state 130
    factor                         shift and go to state 137
    parenthesized_primary          shift and go to state 141
    discrete_range                 shift and go to state 931
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 684
    operator_symbol                shift and go to state 149
    range                          shift and go to state 685
    qualified                      shift and go to state 150

state 905

    (398) entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN . condition entry_body_part
    (281) condition -> . expression
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    allocator                      shift and go to state 130
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    condition                      shift and go to state 932
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 465

state 906

    (110) comp_decl -> def_id_s : component_subtype_def . init_opt ;
    (33) init_opt -> .
    (34) init_opt -> . ASSIGNMENT expression

    ;               reduce using rule 33 (init_opt -> .)
    ASSIGNMENT      shift and go to state 635

    init_opt                       shift and go to state 933

state 907

    (397) entry_decl -> ENTRY IDENTIFIER ( discrete_range ) . formal_part_opt ;
    (324) formal_part_opt -> .
    (325) formal_part_opt -> . formal_part
    (326) formal_part -> . ( param_s )

    ;               reduce using rule 324 (formal_part_opt -> .)
    (               shift and go to state 190

    formal_part                    shift and go to state 189
    formal_part_opt                shift and go to state 934

state 908

    (428) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT . ;

    ;               shift and go to state 935


state 909

    (427) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END . SELECT ;

    SELECT          shift and go to state 936


state 910

    (426) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT . ;

    ;               shift and go to state 937


state 911

    (416) select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .

    LESSLESS        reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    error           reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    PRAGMA          reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    NuLL            reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    EXIT            reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    RETURN          reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    GOTO            reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    DELAY           reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    ABORT           reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    RAISE           reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    REQUEUE         reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    IF              reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    CASE            reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    IDENTIFIER      reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    ACCEPT          reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    SELECT          reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    STRING          reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    WHILE           reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    DECLARE         reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    FOR             reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    LOOP            reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    BEGIN           reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    OR              reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    ELSE            reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    END             reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    THEN            reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    WHEN            reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    EXCEPTION       reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    ELSIF           reduce using rule 416 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)


state 912

    (288) alternative -> WHEN choice_s ARROW statement_s .
    (249) statement_s -> statement_s . statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    END             reduce using rule 288 (alternative -> WHEN choice_s ARROW statement_s .)
    WHEN            reduce using rule 288 (alternative -> WHEN choice_s ARROW statement_s .)
    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 459
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 913

    (465) exception_handler -> WHEN IDENTIFIER : except_choice_s ARROW . statement_s
    (248) statement_s -> . statement
    (249) statement_s -> . statement_s statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    statement_s                    shift and go to state 938
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 292
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 914

    (510) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .

    PACKAGE         reduce using rule 510 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    TASK            reduce using rule 510 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    PROTECTED       reduce using rule 510 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    error           reduce using rule 510 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    USE             reduce using rule 510 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    PRAGMA          reduce using rule 510 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    TYPE            reduce using rule 510 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    SUBTYPE         reduce using rule 510 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    FOR             reduce using rule 510 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    PROCEDURE       reduce using rule 510 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    FUNCTION        reduce using rule 510 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    GENERIC         reduce using rule 510 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    IDENTIFIER      reduce using rule 510 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    BEGIN           reduce using rule 510 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    PRIVATE         reduce using rule 510 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    END             reduce using rule 510 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    ENTRY           reduce using rule 510 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)


state 915

    (514) comp_loc_s -> comp_loc_s mark AT expression . RANGE range ;
    (201) expression -> expression . logical relation
    (202) expression -> expression . short_circuit relation
    (203) logical -> . AND
    (204) logical -> . OR
    (205) logical -> . XOR
    (206) short_circuit -> . AND THEN
    (207) short_circuit -> . OR ELSE

    RANGE           shift and go to state 939
    AND             shift and go to state 249
    OR              shift and go to state 253
    XOR             shift and go to state 250

    logical                        shift and go to state 251
    short_circuit                  shift and go to state 252

state 916

    (371) task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .

    PRAGMA          reduce using rule 371 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    PRIVATE         reduce using rule 371 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    WITH            reduce using rule 371 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    PACKAGE         reduce using rule 371 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    SEPARATE        reduce using rule 371 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    PROCEDURE       reduce using rule 371 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    FUNCTION        reduce using rule 371 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    GENERIC         reduce using rule 371 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    $end            reduce using rule 371 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    TASK            reduce using rule 371 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    PROTECTED       reduce using rule 371 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    error           reduce using rule 371 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    USE             reduce using rule 371 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    TYPE            reduce using rule 371 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    SUBTYPE         reduce using rule 371 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    FOR             reduce using rule 371 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    IDENTIFIER      reduce using rule 371 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    BEGIN           reduce using rule 371 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    END             reduce using rule 371 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)


state 917

    (59) derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .

    ;               reduce using rule 59 (derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .)


state 918

    (60) derived_type -> ABSTRACT NEW subtype_ind WITH record_def .

    ;               reduce using rule 60 (derived_type -> ABSTRACT NEW subtype_ind WITH record_def .)


state 919

    (79) fixed_type -> DELTA expression DIGITS expression range_spec_opt .

    ;               reduce using rule 79 (fixed_type -> DELTA expression DIGITS expression range_spec_opt .)


state 920

    (134) access_type -> ACCESS prot_opt FUNCTION formal_part_opt RETURN . mark
    (160) mark -> . simple_name
    (161) mark -> . mark TICK attribute_id
    (162) mark -> . mark . simple_name
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 166
    mark                           shift and go to state 940

state 921

    (103) comp_list -> comp_decl_s . variant_part_opt
    (107) comp_decl_s -> comp_decl_s . pragma_s comp_decl
    (108) variant_part_opt -> . pragma_s
    (109) variant_part_opt -> . pragma_s variant_part pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    error           reduce using rule 8 (pragma_s -> .)
    CASE            reduce using rule 8 (pragma_s -> .)
    PRAGMA          reduce using rule 8 (pragma_s -> .)
    IDENTIFIER      reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 941
    variant_part_opt               shift and go to state 942

state 922

    (119) variant_part -> CASE . simple_name IS pragma_s variant_s END CASE ;
    (163) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 943

state 923

    (98) record_def -> RECORD pragma_s comp_list . END RECORD

    END             shift and go to state 944


state 924

    (106) comp_decl_s -> comp_decl .

    error           reduce using rule 106 (comp_decl_s -> comp_decl .)
    CASE            reduce using rule 106 (comp_decl_s -> comp_decl .)
    PRAGMA          reduce using rule 106 (comp_decl_s -> comp_decl .)
    IDENTIFIER      reduce using rule 106 (comp_decl_s -> comp_decl .)
    END             reduce using rule 106 (comp_decl_s -> comp_decl .)
    WHEN            reduce using rule 106 (comp_decl_s -> comp_decl .)


state 925

    (104) comp_list -> variant_part . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 945

state 926

    (105) comp_list -> NuLL . ; pragma_s

    ;               shift and go to state 946


state 927

    (82) unconstr_array_type -> ARRAY ( index_s ) OF component_subtype_def .

    ;               reduce using rule 82 (unconstr_array_type -> ARRAY ( index_s ) OF component_subtype_def .)
    ASSIGNMENT      reduce using rule 82 (unconstr_array_type -> ARRAY ( index_s ) OF component_subtype_def .)


state 928

    (89) index -> name RANGE . LESSMORE

    LESSMORE        shift and go to state 896


state 929

    (481) generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) . ;

    ;               shift and go to state 947


state 930

    (502) generic_derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .

    ;               reduce using rule 502 (generic_derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .)


state 931

    (399) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range . ) formal_part_opt WHEN condition entry_body_part

    )               shift and go to state 948


state 932

    (398) entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition . entry_body_part
    (400) entry_body_part -> . ;
    (401) entry_body_part -> . IS decl_part block_body END id_opt ;

    ;               shift and go to state 951
    IS              shift and go to state 950

    entry_body_part                shift and go to state 949

state 933

    (110) comp_decl -> def_id_s : component_subtype_def init_opt . ;

    ;               shift and go to state 952


state 934

    (397) entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt . ;

    ;               shift and go to state 953


state 935

    (428) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .

    LESSLESS        reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    error           reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    PRAGMA          reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    NuLL            reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    EXIT            reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    RETURN          reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    GOTO            reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    DELAY           reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    ABORT           reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    RAISE           reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    REQUEUE         reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    IF              reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    CASE            reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    IDENTIFIER      reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    ACCEPT          reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    SELECT          reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    STRING          reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    WHILE           reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    DECLARE         reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    FOR             reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    LOOP            reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    BEGIN           reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    OR              reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    ELSE            reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    THEN            reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    END             reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    WHEN            reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    ELSIF           reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    EXCEPTION       reduce using rule 428 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)


state 936

    (427) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT . ;

    ;               shift and go to state 954


state 937

    (426) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .

    END             reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    LESSLESS        reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    error           reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    PRAGMA          reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    NuLL            reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    EXIT            reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    RETURN          reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    GOTO            reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    DELAY           reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    ABORT           reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    RAISE           reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    REQUEUE         reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    IF              reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    CASE            reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    IDENTIFIER      reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    ACCEPT          reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    SELECT          reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    STRING          reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    WHILE           reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    DECLARE         reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    FOR             reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    LOOP            reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    BEGIN           reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    ELSIF           reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    ELSE            reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    EXCEPTION       reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    OR              reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    THEN            reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    WHEN            reduce using rule 426 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)


state 938

    (465) exception_handler -> WHEN IDENTIFIER : except_choice_s ARROW statement_s .
    (249) statement_s -> statement_s . statement
    (250) statement -> . unlabeled
    (251) statement -> . label statement
    (252) unlabeled -> . simple_stmt
    (253) unlabeled -> . compound_stmt
    (254) unlabeled -> . pragma
    (273) label -> . LESSLESS IDENTIFIER MOREMORE
    (255) simple_stmt -> . null_stmt
    (256) simple_stmt -> . assign_stmt
    (257) simple_stmt -> . exit_stmt
    (258) simple_stmt -> . return_stmt
    (259) simple_stmt -> . goto_stmt
    (260) simple_stmt -> . procedure_call
    (261) simple_stmt -> . delay_stmt
    (262) simple_stmt -> . abort_stmt
    (263) simple_stmt -> . raise_stmt
    (264) simple_stmt -> . code_stmt
    (265) simple_stmt -> . requeue_stmt
    (266) simple_stmt -> . error ;
    (267) compound_stmt -> . if_stmt
    (268) compound_stmt -> . case_stmt
    (269) compound_stmt -> . loop_stmt
    (270) compound_stmt -> . block
    (271) compound_stmt -> . accept_stmt
    (272) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (274) null_stmt -> . NuLL ;
    (275) assign_stmt -> . name ASSIGNMENT expression ;
    (308) exit_stmt -> . EXIT name_opt when_opt ;
    (313) return_stmt -> . RETURN ;
    (314) return_stmt -> . RETURN expression ;
    (315) goto_stmt -> . GOTO name ;
    (338) procedure_call -> . name ;
    (410) delay_stmt -> . DELAY expression ;
    (411) delay_stmt -> . DELAY UNTIL expression ;
    (431) abort_stmt -> . ABORT name_s ;
    (470) raise_stmt -> . RAISE name_opt ;
    (516) code_stmt -> . qualified ;
    (471) requeue_stmt -> . REQUEUE name ;
    (472) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (276) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (284) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (289) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (301) block -> . label_opt block_decl block_body END id_opt ;
    (405) accept_stmt -> . accept_hdr ;
    (406) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (412) select_stmt -> . select_wait
    (413) select_stmt -> . async_select
    (414) select_stmt -> . timed_entry_call
    (415) select_stmt -> . cond_entry_call
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (245) qualified -> . name TICK parenthesized_primary
    (285) case_hdr -> . CASE expression IS
    (290) label_opt -> .
    (291) label_opt -> . IDENTIFIER :
    (407) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (416) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (426) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (427) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (428) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING

    WHEN            reduce using rule 465 (exception_handler -> WHEN IDENTIFIER : except_choice_s ARROW statement_s .)
    END             reduce using rule 465 (exception_handler -> WHEN IDENTIFIER : except_choice_s ARROW statement_s .)
    LESSLESS        shift and go to state 275
    error           shift and go to state 301
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 274
    EXIT            shift and go to state 300
    RETURN          shift and go to state 277
    GOTO            shift and go to state 267
    DELAY           shift and go to state 263
    ABORT           shift and go to state 273
    RAISE           shift and go to state 287
    REQUEUE         shift and go to state 291
    IF              shift and go to state 308
    CASE            shift and go to state 290
    WHILE           reduce using rule 290 (label_opt -> .)
    DECLARE         reduce using rule 290 (label_opt -> .)
    FOR             reduce using rule 290 (label_opt -> .)
    LOOP            reduce using rule 290 (label_opt -> .)
    BEGIN           reduce using rule 290 (label_opt -> .)
    IDENTIFIER      shift and go to state 293
    ACCEPT          shift and go to state 278
    SELECT          shift and go to state 280
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 276
    label_opt                      shift and go to state 266
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 307
    abort_stmt                     shift and go to state 302
    return_stmt                    shift and go to state 288
    procedure_call                 shift and go to state 279
    assign_stmt                    shift and go to state 311
    simple_name                    shift and go to state 158
    code_stmt                      shift and go to state 304
    case_stmt                      shift and go to state 281
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 282
    exit_stmt                      shift and go to state 306
    select_stmt                    shift and go to state 265
    statement                      shift and go to state 459
    compound_stmt                  shift and go to state 283
    case_hdr                       shift and go to state 285
    delay_stmt                     shift and go to state 294
    unlabeled                      shift and go to state 305
    simple_stmt                    shift and go to state 268
    loop_stmt                      shift and go to state 269
    qualified                      shift and go to state 270
    pragma                         shift and go to state 296
    async_select                   shift and go to state 264
    requeue_stmt                   shift and go to state 297
    raise_stmt                     shift and go to state 298
    name                           shift and go to state 272
    if_stmt                        shift and go to state 271
    accept_hdr                     shift and go to state 295
    cond_entry_call                shift and go to state 309
    timed_entry_call               shift and go to state 299
    goto_stmt                      shift and go to state 284
    null_stmt                      shift and go to state 310
    block                          shift and go to state 286

state 939

    (514) comp_loc_s -> comp_loc_s mark AT expression RANGE . range ;
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name TICK RANGE
    (64) range -> . name TICK RANGE ( expression )
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    simple_expression              shift and go to state 361
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 523
    operator_symbol                shift and go to state 149
    range                          shift and go to state 955

state 940

    (134) access_type -> ACCESS prot_opt FUNCTION formal_part_opt RETURN mark .
    (161) mark -> mark . TICK attribute_id
    (162) mark -> mark . . simple_name

    ;               reduce using rule 134 (access_type -> ACCESS prot_opt FUNCTION formal_part_opt RETURN mark .)
    TICK            shift and go to state 315
    .               shift and go to state 314


state 941

    (107) comp_decl_s -> comp_decl_s pragma_s . comp_decl
    (108) variant_part_opt -> pragma_s .
    (109) variant_part_opt -> pragma_s . variant_part pragma_s
    (9) pragma_s -> pragma_s . pragma
    (110) comp_decl -> . def_id_s : component_subtype_def init_opt ;
    (111) comp_decl -> . error ;
    (119) variant_part -> . CASE simple_name IS pragma_s variant_s END CASE ;
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    END             reduce using rule 108 (variant_part_opt -> pragma_s .)
    WHEN            reduce using rule 108 (variant_part_opt -> pragma_s .)
    error           shift and go to state 787
    CASE            shift and go to state 922
    PRAGMA          shift and go to state 4
    IDENTIFIER      shift and go to state 76

    comp_decl                      shift and go to state 956
    def_id                         shift and go to state 89
    def_id_s                       shift and go to state 783
    pragma                         shift and go to state 14
    variant_part                   shift and go to state 957

state 942

    (103) comp_list -> comp_decl_s variant_part_opt .

    END             reduce using rule 103 (comp_list -> comp_decl_s variant_part_opt .)
    WHEN            reduce using rule 103 (comp_list -> comp_decl_s variant_part_opt .)


state 943

    (119) variant_part -> CASE simple_name . IS pragma_s variant_s END CASE ;

    IS              shift and go to state 958


state 944

    (98) record_def -> RECORD pragma_s comp_list END . RECORD

    RECORD          shift and go to state 959


state 945

    (104) comp_list -> variant_part pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 104 (comp_list -> variant_part pragma_s .)
    WHEN            reduce using rule 104 (comp_list -> variant_part pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 946

    (105) comp_list -> NuLL ; . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 960

state 947

    (481) generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .

    PACKAGE         reduce using rule 481 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)
    PROCEDURE       reduce using rule 481 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)
    FUNCTION        reduce using rule 481 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)
    TYPE            reduce using rule 481 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)
    WITH            reduce using rule 481 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)
    error           reduce using rule 481 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)
    USE             reduce using rule 481 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)
    IDENTIFIER      reduce using rule 481 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)


state 948

    (399) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) . formal_part_opt WHEN condition entry_body_part
    (324) formal_part_opt -> .
    (325) formal_part_opt -> . formal_part
    (326) formal_part -> . ( param_s )

    WHEN            reduce using rule 324 (formal_part_opt -> .)
    (               shift and go to state 190

    formal_part                    shift and go to state 189
    formal_part_opt                shift and go to state 961

state 949

    (398) entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .

    PRAGMA          reduce using rule 398 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)
    END             reduce using rule 398 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)
    ENTRY           reduce using rule 398 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)
    PROCEDURE       reduce using rule 398 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)
    FUNCTION        reduce using rule 398 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)


state 950

    (401) entry_body_part -> IS . decl_part block_body END id_opt ;
    (137) decl_part -> .
    (138) decl_part -> . decl_item_or_body_s1
    (147) decl_item_or_body_s1 -> . decl_item_or_body
    (148) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (149) decl_item_or_body -> . body
    (150) decl_item_or_body -> . decl_item
    (151) body -> . subprog_body
    (152) body -> . pkg_body
    (153) body -> . task_body
    (154) body -> . prot_body
    (143) decl_item -> . decl
    (144) decl_item -> . use_clause
    (145) decl_item -> . rep_spec
    (146) decl_item -> . pragma
    (337) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (346) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (371) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (388) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (352) use_clause -> . USE name_s ;
    (353) use_clause -> . USE TYPE name_s ;
    (506) rep_spec -> . attrib_def
    (507) rep_spec -> . record_type_spec
    (508) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (336) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (316) subprog_decl -> . subprog_spec ;
    (317) subprog_decl -> . generic_subp_inst ;
    (318) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (339) pkg_decl -> . pkg_spec ;
    (340) pkg_decl -> . generic_pkg_inst ;
    (364) task_decl -> . task_spec ;
    (372) prot_decl -> . prot_spec ;
    (461) exception_decl -> . def_id_s : EXCEPTION ;
    (356) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (357) rename_decl -> . def_id_s : EXCEPTION renames ;
    (358) rename_decl -> . rename_unit
    (473) generic_decl -> . generic_formal_part subprog_spec ;
    (474) generic_decl -> . generic_formal_part pkg_spec ;
    (457) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (458) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (459) body_stub -> . subprog_spec IS SEPARATE ;
    (460) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (509) attrib_def -> . FOR mark USE expression ;
    (510) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (515) address_spec -> . FOR mark USE AT expression ;
    (319) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (320) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (321) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (503) generic_subp_inst -> . subprog_spec IS generic_inst
    (341) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (504) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (365) task_spec -> . TASK simple_name task_def
    (366) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (373) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (374) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (359) rename_unit -> . PACKAGE compound_name renames ;
    (360) rename_unit -> . subprog_spec renames ;
    (361) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (362) rename_unit -> . generic_formal_part subprog_spec renames ;
    (475) generic_formal_part -> . GENERIC
    (476) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 137 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 962
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 951

    (400) entry_body_part -> ; .

    PRAGMA          reduce using rule 400 (entry_body_part -> ; .)
    END             reduce using rule 400 (entry_body_part -> ; .)
    ENTRY           reduce using rule 400 (entry_body_part -> ; .)
    PROCEDURE       reduce using rule 400 (entry_body_part -> ; .)
    FUNCTION        reduce using rule 400 (entry_body_part -> ; .)


state 952

    (110) comp_decl -> def_id_s : component_subtype_def init_opt ; .

    error           reduce using rule 110 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    CASE            reduce using rule 110 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    PRAGMA          reduce using rule 110 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    IDENTIFIER      reduce using rule 110 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    END             reduce using rule 110 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    WHEN            reduce using rule 110 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    ENTRY           reduce using rule 110 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    PROCEDURE       reduce using rule 110 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    FUNCTION        reduce using rule 110 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    FOR             reduce using rule 110 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)


state 953

    (397) entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .

    PRIVATE         reduce using rule 397 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    ENTRY           reduce using rule 397 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    PROCEDURE       reduce using rule 397 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    FUNCTION        reduce using rule 397 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    PRAGMA          reduce using rule 397 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    FOR             reduce using rule 397 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    END             reduce using rule 397 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    error           reduce using rule 397 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    IDENTIFIER      reduce using rule 397 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)


state 954

    (427) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .

    LESSLESS        reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    error           reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    PRAGMA          reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    NuLL            reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    EXIT            reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    RETURN          reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    GOTO            reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    DELAY           reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    ABORT           reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    RAISE           reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    REQUEUE         reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    IF              reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    CASE            reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    IDENTIFIER      reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    ACCEPT          reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    SELECT          reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    STRING          reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    WHILE           reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    DECLARE         reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    FOR             reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    LOOP            reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    BEGIN           reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    ELSIF           reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    ELSE            reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    END             reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    OR              reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    WHEN            reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    EXCEPTION       reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    THEN            reduce using rule 427 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)


state 955

    (514) comp_loc_s -> comp_loc_s mark AT expression RANGE range . ;

    ;               shift and go to state 963


state 956

    (107) comp_decl_s -> comp_decl_s pragma_s comp_decl .

    error           reduce using rule 107 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
    CASE            reduce using rule 107 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
    PRAGMA          reduce using rule 107 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
    IDENTIFIER      reduce using rule 107 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
    END             reduce using rule 107 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
    WHEN            reduce using rule 107 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)


state 957

    (109) variant_part_opt -> pragma_s variant_part . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 964

state 958

    (119) variant_part -> CASE simple_name IS . pragma_s variant_s END CASE ;
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 965

state 959

    (98) record_def -> RECORD pragma_s comp_list END RECORD .

    ;               reduce using rule 98 (record_def -> RECORD pragma_s comp_list END RECORD .)


state 960

    (105) comp_list -> NuLL ; pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 105 (comp_list -> NuLL ; pragma_s .)
    WHEN            reduce using rule 105 (comp_list -> NuLL ; pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 961

    (399) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt . WHEN condition entry_body_part

    WHEN            shift and go to state 966


state 962

    (401) entry_body_part -> IS decl_part . block_body END id_opt ;
    (304) block_body -> . BEGIN handled_stmt_s

    BEGIN           shift and go to state 163

    block_body                     shift and go to state 967

state 963

    (514) comp_loc_s -> comp_loc_s mark AT expression RANGE range ; .

    END             reduce using rule 514 (comp_loc_s -> comp_loc_s mark AT expression RANGE range ; .)
    IDENTIFIER      reduce using rule 514 (comp_loc_s -> comp_loc_s mark AT expression RANGE range ; .)


state 964

    (109) variant_part_opt -> pragma_s variant_part pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 109 (variant_part_opt -> pragma_s variant_part pragma_s .)
    WHEN            reduce using rule 109 (variant_part_opt -> pragma_s variant_part pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 965

    (119) variant_part -> CASE simple_name IS pragma_s . variant_s END CASE ;
    (9) pragma_s -> pragma_s . pragma
    (120) variant_s -> . variant
    (121) variant_s -> . variant_s variant
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (122) variant -> . WHEN choice_s ARROW pragma_s comp_list

    PRAGMA          shift and go to state 4
    WHEN            shift and go to state 969

    variant_s                      shift and go to state 968
    variant                        shift and go to state 970
    pragma                         shift and go to state 14

state 966

    (399) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN . condition entry_body_part
    (281) condition -> . expression
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    allocator                      shift and go to state 130
    factor                         shift and go to state 137
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    condition                      shift and go to state 971
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    qualified                      shift and go to state 150
    expression                     shift and go to state 465

state 967

    (401) entry_body_part -> IS decl_part block_body . END id_opt ;

    END             shift and go to state 972


state 968

    (119) variant_part -> CASE simple_name IS pragma_s variant_s . END CASE ;
    (121) variant_s -> variant_s . variant
    (122) variant -> . WHEN choice_s ARROW pragma_s comp_list

    END             shift and go to state 973
    WHEN            shift and go to state 969

    variant                        shift and go to state 974

state 969

    (122) variant -> WHEN . choice_s ARROW pragma_s comp_list
    (123) choice_s -> . choice
    (124) choice_s -> . choice_s | choice
    (125) choice -> . expression
    (126) choice -> . discrete_with_range
    (127) choice -> . OTHERS
    (200) expression -> . relation
    (201) expression -> . expression logical relation
    (202) expression -> . expression short_circuit relation
    (128) discrete_with_range -> . name range_constraint
    (129) discrete_with_range -> . range
    (208) relation -> . simple_expression
    (209) relation -> . simple_expression relational simple_expression
    (210) relation -> . simple_expression membership range
    (211) relation -> . simple_expression membership name
    (155) name -> . simple_name
    (156) name -> . indexed_comp
    (157) name -> . selected_comp
    (158) name -> . attribute
    (159) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name TICK RANGE
    (64) range -> . name TICK RANGE ( expression )
    (220) simple_expression -> . unary term
    (221) simple_expression -> . term
    (222) simple_expression -> . simple_expression adding term
    (163) simple_name -> . IDENTIFIER
    (170) indexed_comp -> . name ( value_s )
    (177) selected_comp -> . name . simple_name
    (178) selected_comp -> . name . used_char
    (179) selected_comp -> . name . operator_symbol
    (180) selected_comp -> . name . ALL
    (181) attribute -> . name TICK attribute_id
    (169) operator_symbol -> . STRING
    (223) unary -> . +
    (224) unary -> . -
    (228) term -> . factor
    (229) term -> . term multiplying factor
    (234) factor -> . primary
    (235) factor -> . NOT primary
    (236) factor -> . ABS primary
    (237) factor -> . primary STARSTAR primary
    (238) primary -> . literal
    (239) primary -> . name
    (240) primary -> . allocator
    (241) primary -> . qualified
    (242) primary -> . parenthesized_primary
    (186) literal -> . INTEGER
    (187) literal -> . BASE_INTEGER
    (188) literal -> . FLOAT
    (189) literal -> . BASE_FLOAT
    (190) literal -> . used_char
    (191) literal -> . NuLL
    (246) allocator -> . NEW name
    (247) allocator -> . NEW qualified
    (245) qualified -> . name TICK parenthesized_primary
    (243) parenthesized_primary -> . aggregate
    (244) parenthesized_primary -> . ( expression )
    (168) used_char -> . CHAR
    (192) aggregate -> . ( comp_assoc )
    (193) aggregate -> . ( value_s_2 )
    (194) aggregate -> . ( expression WITH value_s )
    (195) aggregate -> . ( expression WITH NuLL RECORD )
    (196) aggregate -> . ( NuLL RECORD )

    OTHERS          shift and go to state 224
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 151
    ABS             shift and go to state 140
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 152
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 384
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 158
    literal                        shift and go to state 135
    choice_s                       shift and go to state 975
    factor                         shift and go to state 137
    choice                         shift and go to state 228
    qualified                      shift and go to state 150
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    discrete_with_range            shift and go to state 519
    term                           shift and go to state 146
    name                           shift and go to state 231
    operator_symbol                shift and go to state 149
    range                          shift and go to state 233
    expression                     shift and go to state 520

state 970

    (120) variant_s -> variant .

    END             reduce using rule 120 (variant_s -> variant .)
    WHEN            reduce using rule 120 (variant_s -> variant .)


state 971

    (399) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition . entry_body_part
    (400) entry_body_part -> . ;
    (401) entry_body_part -> . IS decl_part block_body END id_opt ;

    ;               shift and go to state 951
    IS              shift and go to state 950

    entry_body_part                shift and go to state 976

state 972

    (401) entry_body_part -> IS decl_part block_body END . id_opt ;
    (299) id_opt -> .
    (300) id_opt -> . designator
    (322) designator -> . compound_name
    (323) designator -> . STRING
    (164) compound_name -> . simple_name
    (165) compound_name -> . compound_name . simple_name
    (163) simple_name -> . IDENTIFIER

    ;               reduce using rule 299 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 466
    id_opt                         shift and go to state 977
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 973

    (119) variant_part -> CASE simple_name IS pragma_s variant_s END . CASE ;

    CASE            shift and go to state 978


state 974

    (121) variant_s -> variant_s variant .

    END             reduce using rule 121 (variant_s -> variant_s variant .)
    WHEN            reduce using rule 121 (variant_s -> variant_s variant .)


state 975

    (122) variant -> WHEN choice_s . ARROW pragma_s comp_list
    (124) choice_s -> choice_s . | choice

    ARROW           shift and go to state 979
    |               shift and go to state 368


state 976

    (399) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .

    PRAGMA          reduce using rule 399 (entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)
    END             reduce using rule 399 (entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)
    ENTRY           reduce using rule 399 (entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)
    PROCEDURE       reduce using rule 399 (entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)
    FUNCTION        reduce using rule 399 (entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)


state 977

    (401) entry_body_part -> IS decl_part block_body END id_opt . ;

    ;               shift and go to state 980


state 978

    (119) variant_part -> CASE simple_name IS pragma_s variant_s END CASE . ;

    ;               shift and go to state 981


state 979

    (122) variant -> WHEN choice_s ARROW . pragma_s comp_list
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    NuLL            reduce using rule 8 (pragma_s -> .)
    PRAGMA          reduce using rule 8 (pragma_s -> .)
    CASE            reduce using rule 8 (pragma_s -> .)
    error           reduce using rule 8 (pragma_s -> .)
    IDENTIFIER      reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 982

state 980

    (401) entry_body_part -> IS decl_part block_body END id_opt ; .

    PRAGMA          reduce using rule 401 (entry_body_part -> IS decl_part block_body END id_opt ; .)
    END             reduce using rule 401 (entry_body_part -> IS decl_part block_body END id_opt ; .)
    ENTRY           reduce using rule 401 (entry_body_part -> IS decl_part block_body END id_opt ; .)
    PROCEDURE       reduce using rule 401 (entry_body_part -> IS decl_part block_body END id_opt ; .)
    FUNCTION        reduce using rule 401 (entry_body_part -> IS decl_part block_body END id_opt ; .)


state 981

    (119) variant_part -> CASE simple_name IS pragma_s variant_s END CASE ; .

    PRAGMA          reduce using rule 119 (variant_part -> CASE simple_name IS pragma_s variant_s END CASE ; .)
    END             reduce using rule 119 (variant_part -> CASE simple_name IS pragma_s variant_s END CASE ; .)
    WHEN            reduce using rule 119 (variant_part -> CASE simple_name IS pragma_s variant_s END CASE ; .)


state 982

    (122) variant -> WHEN choice_s ARROW pragma_s . comp_list
    (9) pragma_s -> pragma_s . pragma
    (103) comp_list -> . comp_decl_s variant_part_opt
    (104) comp_list -> . variant_part pragma_s
    (105) comp_list -> . NuLL ; pragma_s
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (106) comp_decl_s -> . comp_decl
    (107) comp_decl_s -> . comp_decl_s pragma_s comp_decl
    (119) variant_part -> . CASE simple_name IS pragma_s variant_s END CASE ;
    (110) comp_decl -> . def_id_s : component_subtype_def init_opt ;
    (111) comp_decl -> . error ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    NuLL            shift and go to state 926
    PRAGMA          shift and go to state 4
    CASE            shift and go to state 922
    error           shift and go to state 787
    IDENTIFIER      shift and go to state 76

    def_id_s                       shift and go to state 783
    comp_list                      shift and go to state 983
    comp_decl                      shift and go to state 924
    def_id                         shift and go to state 89
    variant_part                   shift and go to state 925
    pragma                         shift and go to state 14
    comp_decl_s                    shift and go to state 921

state 983

    (122) variant -> WHEN choice_s ARROW pragma_s comp_list .

    END             reduce using rule 122 (variant -> WHEN choice_s ARROW pragma_s comp_list .)
    WHEN            reduce using rule 122 (variant -> WHEN choice_s ARROW pragma_s comp_list .)

