Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    XOR
    ABS

Grammar

Rule 0     S' -> start_symbol
Rule 1     start_symbol -> compilation
Rule 2     pragma -> PRAGMA IDENTIFIER ;
Rule 3     pragma -> PRAGMA simple_name ( pragma_arg_s ) ;
Rule 4     pragma_arg_s -> pragma_arg
Rule 5     pragma_arg_s -> pragma_arg_s , pragma_arg
Rule 6     pragma_arg -> expression
Rule 7     pragma_arg -> simple_name ARROW expression
Rule 8     pragma_s -> <empty>
Rule 9     pragma_s -> pragma_s pragma
Rule 10    decl -> object_decl
Rule 11    decl -> number_decl
Rule 12    decl -> type_decl
Rule 13    decl -> subtype_decl
Rule 14    decl -> subprog_decl
Rule 15    decl -> pkg_decl
Rule 16    decl -> task_decl
Rule 17    decl -> prot_decl
Rule 18    decl -> exception_decl
Rule 19    decl -> rename_decl
Rule 20    decl -> generic_decl
Rule 21    decl -> body_stub
Rule 22    decl -> error ;
Rule 23    object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ;
Rule 24    def_id_s -> def_id
Rule 25    def_id_s -> def_id_s , def_id
Rule 26    def_id -> IDENTIFIER
Rule 27    object_qualifier_opt -> <empty>
Rule 28    object_qualifier_opt -> ALIASED
Rule 29    object_qualifier_opt -> ALIASED CONSTANT
Rule 30    object_qualifier_opt -> CONSTANT
Rule 31    object_subtype_def -> subtype_ind
Rule 32    object_subtype_def -> array_type
Rule 33    init_opt -> <empty>
Rule 34    init_opt -> ASSIGNMENT expression
Rule 35    number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ;
Rule 36    type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ;
Rule 37    discrim_part_opt -> <empty>
Rule 38    discrim_part_opt -> discrim_part
Rule 39    discrim_part_opt -> ( LESSMORE )
Rule 40    type_completion -> <empty>
Rule 41    type_completion -> IS type_def
Rule 42    type_def -> enumeration_type
Rule 43    type_def -> integer_type
Rule 44    type_def -> real_type
Rule 45    type_def -> array_type
Rule 46    type_def -> record_type
Rule 47    type_def -> access_type
Rule 48    type_def -> derived_type
Rule 49    type_def -> private_type
Rule 50    subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ;
Rule 51    subtype_ind -> name constraint
Rule 52    subtype_ind -> name
Rule 53    constraint -> range_constraint
Rule 54    constraint -> decimal_digits_constraint
Rule 55    decimal_digits_constraint -> DIGITS expression range_constr_opt
Rule 56    derived_type -> NEW subtype_ind
Rule 57    derived_type -> NEW subtype_ind WITH PRIVATE
Rule 58    derived_type -> NEW subtype_ind WITH record_def
Rule 59    derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE
Rule 60    derived_type -> ABSTRACT NEW subtype_ind WITH record_def
Rule 61    range_constraint -> RANGE range
Rule 62    range -> simple_expression DOTDOT simple_expression
Rule 63    enumeration_type -> ( enum_id_s )
Rule 64    enum_id_s -> enum_id
Rule 65    enum_id_s -> enum_id_s , enum_id
Rule 66    enum_id -> IDENTIFIER
Rule 67    enum_id -> CHAR
Rule 68    integer_type -> range_spec
Rule 69    integer_type -> MOD expression
Rule 70    range_spec -> range_constraint
Rule 71    range_spec_opt -> <empty>
Rule 72    range_spec_opt -> range_spec
Rule 73    real_type -> float_type
Rule 74    real_type -> fixed_type
Rule 75    float_type -> DIGITS expression range_spec_opt
Rule 76    fixed_type -> DELTA expression range_spec
Rule 77    fixed_type -> DELTA expression DIGITS expression range_spec_opt
Rule 78    array_type -> unconstr_array_type
Rule 79    array_type -> constr_array_type
Rule 80    unconstr_array_type -> ARRAY ( index_s ) OF component_subtype_def
Rule 81    constr_array_type -> ARRAY iter_index_constraint OF component_subtype_def
Rule 82    component_subtype_def -> aliased_opt subtype_ind
Rule 83    aliased_opt -> <empty>
Rule 84    aliased_opt -> ALIASED
Rule 85    index_s -> index
Rule 86    index_s -> index_s , index
Rule 87    index -> name RANGE LESSMORE
Rule 88    iter_index_constraint -> ( iter_discrete_range_s )
Rule 89    iter_discrete_range_s -> discrete_range
Rule 90    iter_discrete_range_s -> iter_discrete_range_s , discrete_range
Rule 91    discrete_range -> name range_constr_opt
Rule 92    discrete_range -> range
Rule 93    range_constr_opt -> <empty>
Rule 94    range_constr_opt -> range_constraint
Rule 95    record_type -> tagged_opt limited_opt record_def
Rule 96    record_def -> RECORD pragma_s comp_list END RECORD
Rule 97    record_def -> NuLL RECORD
Rule 98    tagged_opt -> <empty>
Rule 99    tagged_opt -> TAGGED
Rule 100   tagged_opt -> ABSTRACT TAGGED
Rule 101   comp_list -> comp_decl_s variant_part_opt
Rule 102   comp_list -> variant_part pragma_s
Rule 103   comp_list -> NuLL ; pragma_s
Rule 104   comp_decl_s -> comp_decl
Rule 105   comp_decl_s -> comp_decl_s pragma_s comp_decl
Rule 106   variant_part_opt -> pragma_s
Rule 107   variant_part_opt -> pragma_s variant_part pragma_s
Rule 108   comp_decl -> def_id_s : component_subtype_def init_opt ;
Rule 109   comp_decl -> error ;
Rule 110   discrim_part -> ( discrim_spec_s )
Rule 111   discrim_spec_s -> discrim_spec
Rule 112   discrim_spec_s -> discrim_spec_s ; discrim_spec
Rule 113   discrim_spec -> def_id_s : access_opt mark init_opt
Rule 114   discrim_spec -> error
Rule 115   access_opt -> <empty>
Rule 116   access_opt -> ACCESS
Rule 117   variant_part -> CASE simple_name IS pragma_s variant_s END CASE ;
Rule 118   variant_s -> variant
Rule 119   variant_s -> variant_s variant
Rule 120   variant -> WHEN choice_s ARROW pragma_s comp_list
Rule 121   choice_s -> choice
Rule 122   choice_s -> choice_s | choice
Rule 123   choice -> expression
Rule 124   choice -> discrete_with_range
Rule 125   choice -> OTHERS
Rule 126   discrete_with_range -> name range_constraint
Rule 127   discrete_with_range -> range
Rule 128   access_type -> ACCESS subtype_ind
Rule 129   access_type -> ACCESS CONSTANT subtype_ind
Rule 130   access_type -> ACCESS ALL subtype_ind
Rule 131   access_type -> ACCESS prot_opt PROCEDURE formal_part_opt
Rule 132   access_type -> ACCESS prot_opt FUNCTION formal_part_opt RETURN mark
Rule 133   prot_opt -> <empty>
Rule 134   prot_opt -> PROTECTED
Rule 135   decl_part -> <empty>
Rule 136   decl_part -> decl_item_or_body_s1
Rule 137   decl_item_s -> <empty>
Rule 138   decl_item_s -> decl_item_s1
Rule 139   decl_item_s1 -> decl_item
Rule 140   decl_item_s1 -> decl_item_s1 decl_item
Rule 141   decl_item -> decl
Rule 142   decl_item -> use_clause
Rule 143   decl_item -> rep_spec
Rule 144   decl_item -> pragma
Rule 145   decl_item_or_body_s1 -> decl_item_or_body
Rule 146   decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body
Rule 147   decl_item_or_body -> body
Rule 148   decl_item_or_body -> decl_item
Rule 149   body -> subprog_body
Rule 150   body -> pkg_body
Rule 151   body -> task_body
Rule 152   body -> prot_body
Rule 153   name -> simple_name
Rule 154   name -> indexed_comp
Rule 155   name -> selected_comp
Rule 156   name -> attribute
Rule 157   name -> operator_symbol
Rule 158   mark -> simple_name
Rule 159   mark -> mark TICK attribute_id
Rule 160   mark -> mark . simple_name
Rule 161   simple_name -> IDENTIFIER
Rule 162   compound_name -> simple_name
Rule 163   compound_name -> compound_name . simple_name
Rule 164   c_name_list -> compound_name
Rule 165   c_name_list -> c_name_list , compound_name
Rule 166   used_char -> CHAR
Rule 167   operator_symbol -> STRING
Rule 168   indexed_comp -> name ( value_s )
Rule 169   value_s -> value
Rule 170   value_s -> value_s , value
Rule 171   value -> expression
Rule 172   value -> comp_assoc
Rule 173   value -> discrete_with_range
Rule 174   value -> error
Rule 175   selected_comp -> name . simple_name
Rule 176   selected_comp -> name . used_char
Rule 177   selected_comp -> name . operator_symbol
Rule 178   selected_comp -> name . ALL
Rule 179   attribute -> name TICK attribute_id
Rule 180   attribute_id -> IDENTIFIER
Rule 181   attribute_id -> DIGITS
Rule 182   attribute_id -> DELTA
Rule 183   attribute_id -> ACCESS
Rule 184   literal -> INTEGER
Rule 185   literal -> BASE_INTEGER
Rule 186   literal -> FLOAT
Rule 187   literal -> BASE_FLOAT
Rule 188   literal -> used_char
Rule 189   literal -> NuLL
Rule 190   aggregate -> ( comp_assoc )
Rule 191   aggregate -> ( value_s_2 )
Rule 192   aggregate -> ( expression WITH value_s )
Rule 193   aggregate -> ( expression WITH NuLL RECORD )
Rule 194   aggregate -> ( NuLL RECORD )
Rule 195   value_s_2 -> value , value
Rule 196   value_s_2 -> value_s_2 , value
Rule 197   comp_assoc -> choice_s ARROW expression
Rule 198   expression -> relation
Rule 199   expression -> expression logical relation
Rule 200   expression -> expression short_circuit relation
Rule 201   logical -> AND
Rule 202   logical -> OR
Rule 203   short_circuit -> AND THEN
Rule 204   short_circuit -> OR ELSE
Rule 205   relation -> simple_expression
Rule 206   relation -> simple_expression relational simple_expression
Rule 207   relation -> simple_expression membership range
Rule 208   relation -> simple_expression membership name
Rule 209   relational -> =
Rule 210   relational -> NOTEQUAL
Rule 211   relational -> <
Rule 212   relational -> LESSEQ
Rule 213   relational -> >
Rule 214   relational -> GREATEREQ
Rule 215   membership -> IN
Rule 216   membership -> NOT IN
Rule 217   simple_expression -> unary term
Rule 218   simple_expression -> term
Rule 219   simple_expression -> simple_expression adding term
Rule 220   unary -> +
Rule 221   unary -> -
Rule 222   adding -> +
Rule 223   adding -> -
Rule 224   adding -> &
Rule 225   term -> factor
Rule 226   term -> term multiplying factor
Rule 227   multiplying -> *
Rule 228   multiplying -> /
Rule 229   multiplying -> MOD
Rule 230   multiplying -> REM
Rule 231   factor -> primary
Rule 232   factor -> NOT primary
Rule 233   factor -> primary STARSTAR primary
Rule 234   primary -> literal
Rule 235   primary -> name
Rule 236   primary -> allocator
Rule 237   primary -> qualified
Rule 238   primary -> parenthesized_primary
Rule 239   parenthesized_primary -> aggregate
Rule 240   parenthesized_primary -> ( expression )
Rule 241   qualified -> name TICK parenthesized_primary
Rule 242   allocator -> NEW name
Rule 243   allocator -> NEW qualified
Rule 244   statement_s -> statement
Rule 245   statement_s -> statement_s statement
Rule 246   statement -> unlabeled
Rule 247   statement -> label statement
Rule 248   unlabeled -> simple_stmt
Rule 249   unlabeled -> compound_stmt
Rule 250   unlabeled -> pragma
Rule 251   simple_stmt -> null_stmt
Rule 252   simple_stmt -> assign_stmt
Rule 253   simple_stmt -> exit_stmt
Rule 254   simple_stmt -> return_stmt
Rule 255   simple_stmt -> goto_stmt
Rule 256   simple_stmt -> procedure_call
Rule 257   simple_stmt -> delay_stmt
Rule 258   simple_stmt -> abort_stmt
Rule 259   simple_stmt -> raise_stmt
Rule 260   simple_stmt -> code_stmt
Rule 261   simple_stmt -> requeue_stmt
Rule 262   simple_stmt -> error ;
Rule 263   compound_stmt -> if_stmt
Rule 264   compound_stmt -> case_stmt
Rule 265   compound_stmt -> loop_stmt
Rule 266   compound_stmt -> block
Rule 267   compound_stmt -> accept_stmt
Rule 268   compound_stmt -> select_stmt
Rule 269   label -> LESSLESS IDENTIFIER MOREMORE
Rule 270   null_stmt -> NuLL ;
Rule 271   assign_stmt -> name ASSIGNMENT expression ;
Rule 272   if_stmt -> IF cond_clause_s else_opt END IF ;
Rule 273   cond_clause_s -> cond_clause
Rule 274   cond_clause_s -> cond_clause_s ELSIF cond_clause
Rule 275   cond_clause -> cond_part statement_s
Rule 276   cond_part -> condition THEN
Rule 277   condition -> expression
Rule 278   else_opt -> <empty>
Rule 279   else_opt -> ELSE statement_s
Rule 280   case_stmt -> case_hdr pragma_s alternative_s END CASE ;
Rule 281   case_hdr -> CASE expression IS
Rule 282   alternative_s -> <empty>
Rule 283   alternative_s -> alternative_s alternative
Rule 284   alternative -> WHEN choice_s ARROW statement_s
Rule 285   loop_stmt -> label_opt iteration basic_loop id_opt ;
Rule 286   label_opt -> <empty>
Rule 287   label_opt -> IDENTIFIER :
Rule 288   iteration -> <empty>
Rule 289   iteration -> WHILE condition
Rule 290   iteration -> iter_part reverse_opt discrete_range
Rule 291   iter_part -> FOR IDENTIFIER IN
Rule 292   reverse_opt -> <empty>
Rule 293   reverse_opt -> REVERSE
Rule 294   basic_loop -> LOOP statement_s END LOOP
Rule 295   id_opt -> <empty>
Rule 296   id_opt -> designator
Rule 297   block -> label_opt block_decl block_body END id_opt ;
Rule 298   block_decl -> <empty>
Rule 299   block_decl -> DECLARE decl_part
Rule 300   block_body -> BEGIN handled_stmt_s
Rule 301   handled_stmt_s -> statement_s except_handler_part_opt
Rule 302   except_handler_part_opt -> <empty>
Rule 303   except_handler_part_opt -> except_handler_part
Rule 304   exit_stmt -> EXIT name_opt when_opt ;
Rule 305   name_opt -> <empty>
Rule 306   name_opt -> name
Rule 307   when_opt -> <empty>
Rule 308   when_opt -> WHEN condition
Rule 309   return_stmt -> RETURN ;
Rule 310   return_stmt -> RETURN expression ;
Rule 311   goto_stmt -> GOTO name ;
Rule 312   subprog_decl -> subprog_spec ;
Rule 313   subprog_decl -> generic_subp_inst ;
Rule 314   subprog_decl -> subprog_spec_is_push ABSTRACT ;
Rule 315   subprog_spec -> PROCEDURE compound_name formal_part_opt
Rule 316   subprog_spec -> FUNCTION designator formal_part_opt RETURN name
Rule 317   subprog_spec -> FUNCTION designator
Rule 318   designator -> compound_name
Rule 319   designator -> STRING
Rule 320   formal_part_opt -> <empty>
Rule 321   formal_part_opt -> formal_part
Rule 322   formal_part -> ( param_s )
Rule 323   param_s -> param
Rule 324   param_s -> param_s ; param
Rule 325   param -> def_id_s : mode mark init_opt
Rule 326   param -> error
Rule 327   mode -> <empty>
Rule 328   mode -> IN
Rule 329   mode -> OUT
Rule 330   mode -> IN OUT
Rule 331   mode -> ACCESS
Rule 332   subprog_spec_is_push -> subprog_spec IS
Rule 333   subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ;
Rule 334   procedure_call -> name ;
Rule 335   pkg_decl -> pkg_spec ;
Rule 336   pkg_decl -> generic_pkg_inst ;
Rule 337   pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END c_id_opt
Rule 338   private_part -> <empty>
Rule 339   private_part -> PRIVATE decl_item_s
Rule 340   c_id_opt -> <empty>
Rule 341   c_id_opt -> compound_name
Rule 342   pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
Rule 343   body_opt -> <empty>
Rule 344   body_opt -> block_body
Rule 345   private_type -> tagged_opt limited_opt PRIVATE
Rule 346   limited_opt -> <empty>
Rule 347   limited_opt -> LIMITED
Rule 348   use_clause -> USE name_s ;
Rule 349   use_clause -> USE TYPE name_s ;
Rule 350   name_s -> name
Rule 351   name_s -> name_s , name
Rule 352   rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ;
Rule 353   rename_decl -> def_id_s : EXCEPTION renames ;
Rule 354   rename_decl -> rename_unit
Rule 355   rename_unit -> PACKAGE compound_name renames ;
Rule 356   rename_unit -> subprog_spec renames ;
Rule 357   rename_unit -> generic_formal_part PACKAGE compound_name renames ;
Rule 358   rename_unit -> generic_formal_part subprog_spec renames ;
Rule 359   renames -> RENAMES name
Rule 360   task_decl -> task_spec ;
Rule 361   task_spec -> TASK simple_name task_def
Rule 362   task_spec -> TASK TYPE simple_name discrim_part_opt task_def
Rule 363   task_def -> <empty>
Rule 364   task_def -> IS entry_decl_s rep_spec_s task_private_opt END id_opt
Rule 365   task_private_opt -> <empty>
Rule 366   task_private_opt -> PRIVATE entry_decl_s rep_spec_s
Rule 367   task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ;
Rule 368   prot_decl -> prot_spec ;
Rule 369   prot_spec -> PROTECTED IDENTIFIER prot_def
Rule 370   prot_spec -> PROTECTED TYPE simple_name discrim_part_opt prot_def
Rule 371   prot_def -> IS prot_op_decl_s prot_private_opt END id_opt
Rule 372   prot_private_opt -> <empty>
Rule 373   prot_private_opt -> PRIVATE prot_elem_decl_s
Rule 374   prot_op_decl_s -> <empty>
Rule 375   prot_op_decl_s -> prot_op_decl_s prot_op_decl
Rule 376   prot_op_decl -> entry_decl
Rule 377   prot_op_decl -> subprog_spec ;
Rule 378   prot_op_decl -> rep_spec
Rule 379   prot_op_decl -> pragma
Rule 380   prot_elem_decl_s -> <empty>
Rule 381   prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl
Rule 382   prot_elem_decl -> prot_op_decl
Rule 383   prot_elem_decl -> comp_decl
Rule 384   prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
Rule 385   prot_op_body_s -> pragma_s
Rule 386   prot_op_body_s -> prot_op_body_s prot_op_body pragma_s
Rule 387   prot_op_body -> entry_body
Rule 388   prot_op_body -> subprog_body
Rule 389   prot_op_body -> subprog_spec ;
Rule 390   entry_decl_s -> pragma_s
Rule 391   entry_decl_s -> entry_decl_s entry_decl pragma_s
Rule 392   entry_decl -> ENTRY IDENTIFIER formal_part_opt ;
Rule 393   entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ;
Rule 394   entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part
Rule 395   entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part
Rule 396   entry_body_part -> ;
Rule 397   entry_body_part -> IS decl_part block_body END id_opt ;
Rule 398   rep_spec_s -> <empty>
Rule 399   rep_spec_s -> rep_spec_s rep_spec pragma_s
Rule 400   entry_call -> procedure_call
Rule 401   accept_stmt -> accept_hdr ;
Rule 402   accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ;
Rule 403   accept_hdr -> ACCEPT entry_name formal_part_opt
Rule 404   entry_name -> simple_name
Rule 405   entry_name -> entry_name ( expression )
Rule 406   delay_stmt -> DELAY expression ;
Rule 407   delay_stmt -> DELAY UNTIL expression ;
Rule 408   select_stmt -> select_wait
Rule 409   select_stmt -> async_select
Rule 410   select_stmt -> timed_entry_call
Rule 411   select_stmt -> cond_entry_call
Rule 412   select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ;
Rule 413   guarded_select_alt -> select_alt
Rule 414   guarded_select_alt -> WHEN condition ARROW select_alt
Rule 415   or_select -> <empty>
Rule 416   or_select -> or_select OR guarded_select_alt
Rule 417   select_alt -> accept_stmt stmts_opt
Rule 418   select_alt -> delay_stmt stmts_opt
Rule 419   select_alt -> TERMINATE ;
Rule 420   delay_or_entry_alt -> delay_stmt stmts_opt
Rule 421   delay_or_entry_alt -> entry_call stmts_opt
Rule 422   async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
Rule 423   timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
Rule 424   cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
Rule 425   stmts_opt -> <empty>
Rule 426   stmts_opt -> statement_s
Rule 427   abort_stmt -> ABORT name_s ;
Rule 428   compilation -> <empty>
Rule 429   compilation -> compilation comp_unit
Rule 430   compilation -> pragma pragma_s
Rule 431   comp_unit -> context_spec private_opt unit pragma_s
Rule 432   comp_unit -> private_opt unit pragma_s
Rule 433   private_opt -> <empty>
Rule 434   private_opt -> PRIVATE
Rule 435   context_spec -> with_clause use_clause_opt
Rule 436   context_spec -> context_spec with_clause use_clause_opt
Rule 437   context_spec -> context_spec pragma
Rule 438   with_clause -> WITH c_name_list ;
Rule 439   use_clause_opt -> <empty>
Rule 440   use_clause_opt -> use_clause_opt use_clause
Rule 441   unit -> pkg_decl
Rule 442   unit -> pkg_body
Rule 443   unit -> subprog_decl
Rule 444   unit -> subprog_body
Rule 445   unit -> subunit
Rule 446   unit -> generic_decl
Rule 447   unit -> rename_unit
Rule 448   subunit -> SEPARATE ( compound_name ) subunit_body
Rule 449   subunit_body -> subprog_body
Rule 450   subunit_body -> pkg_body
Rule 451   subunit_body -> task_body
Rule 452   subunit_body -> prot_body
Rule 453   body_stub -> TASK BODY simple_name IS SEPARATE ;
Rule 454   body_stub -> PACKAGE BODY compound_name IS SEPARATE ;
Rule 455   body_stub -> subprog_spec IS SEPARATE ;
Rule 456   body_stub -> PROTECTED BODY simple_name IS SEPARATE ;
Rule 457   exception_decl -> def_id_s : EXCEPTION ;
Rule 458   except_handler_part -> EXCEPTION exception_handler
Rule 459   except_handler_part -> except_handler_part exception_handler
Rule 460   exception_handler -> WHEN except_choice_s ARROW statement_s
Rule 461   exception_handler -> WHEN IDENTIFIER : except_choice_s ARROW statement_s
Rule 462   except_choice_s -> except_choice
Rule 463   except_choice_s -> except_choice_s | except_choice
Rule 464   except_choice -> name
Rule 465   except_choice -> OTHERS
Rule 466   raise_stmt -> RAISE name_opt ;
Rule 467   requeue_stmt -> REQUEUE name ;
Rule 468   requeue_stmt -> REQUEUE name WITH ABORT ;
Rule 469   generic_decl -> generic_formal_part subprog_spec ;
Rule 470   generic_decl -> generic_formal_part pkg_spec ;
Rule 471   generic_formal_part -> GENERIC
Rule 472   generic_formal_part -> generic_formal_part generic_formal
Rule 473   generic_formal -> param ;
Rule 474   generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ;
Rule 475   generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ;
Rule 476   generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ;
Rule 477   generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ;
Rule 478   generic_formal -> WITH PACKAGE simple_name IS NEW name ;
Rule 479   generic_formal -> use_clause
Rule 480   generic_discrim_part_opt -> <empty>
Rule 481   generic_discrim_part_opt -> discrim_part
Rule 482   generic_discrim_part_opt -> ( LESSMORE )
Rule 483   subp_default -> <empty>
Rule 484   subp_default -> IS name
Rule 485   subp_default -> IS LESSMORE
Rule 486   generic_type_def -> ( LESSMORE )
Rule 487   generic_type_def -> RANGE LESSMORE
Rule 488   generic_type_def -> MOD LESSMORE
Rule 489   generic_type_def -> DELTA LESSMORE
Rule 490   generic_type_def -> DELTA LESSMORE DIGITS LESSMORE
Rule 491   generic_type_def -> DIGITS LESSMORE
Rule 492   generic_type_def -> array_type
Rule 493   generic_type_def -> access_type
Rule 494   generic_type_def -> private_type
Rule 495   generic_type_def -> generic_derived_type
Rule 496   generic_derived_type -> NEW subtype_ind
Rule 497   generic_derived_type -> NEW subtype_ind WITH PRIVATE
Rule 498   generic_derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE
Rule 499   generic_subp_inst -> subprog_spec IS generic_inst
Rule 500   generic_pkg_inst -> PACKAGE compound_name IS generic_inst
Rule 501   generic_inst -> NEW name
Rule 502   rep_spec -> attrib_def
Rule 503   rep_spec -> record_type_spec
Rule 504   rep_spec -> address_spec
Rule 505   attrib_def -> FOR mark USE expression ;
Rule 506   record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
Rule 507   align_opt -> <empty>
Rule 508   align_opt -> AT MOD expression ;
Rule 509   comp_loc_s -> <empty>
Rule 510   comp_loc_s -> comp_loc_s mark AT expression RANGE range ;
Rule 511   address_spec -> FOR mark USE AT expression ;
Rule 512   code_stmt -> qualified ;

Terminals, with rules where they appear

&                    : 224
(                    : 3 39 63 80 88 110 168 190 191 192 193 194 240 322 393 395 405 448 477 482 486
)                    : 3 39 63 80 88 110 168 190 191 192 193 194 240 322 393 395 405 448 477 482 486
*                    : 227
+                    : 220 222
,                    : 5 25 65 86 90 165 170 195 196 351
-                    : 221 223
.                    : 160 163 175 176 177 178
/                    : 228
:                    : 23 35 108 113 287 325 352 353 457 461
;                    : 2 3 22 23 35 36 50 103 108 109 112 117 262 270 271 272 280 285 297 304 309 310 311 312 313 314 324 333 334 335 336 342 348 349 352 353 355 356 357 358 360 367 368 377 384 389 392 393 396 397 401 402 406 407 412 419 422 423 424 427 438 453 454 455 456 457 466 467 468 469 470 473 474 475 476 477 478 505 506 508 510 511 512
<                    : 211
=                    : 209
>                    : 213
ABORT                : 422 427 468
ABS                  : 
ABSTRACT             : 59 60 100 314 498
ACCEPT               : 403
ACCESS               : 116 128 129 130 131 132 183 331
ALIASED              : 28 29 84
ALL                  : 130 178
AND                  : 201 203
ARRAY                : 80 81
ARROW                : 7 120 197 284 414 460 461
ASSIGNMENT           : 34 35 271
AT                   : 508 510 511
BASE_FLOAT           : 187
BASE_INTEGER         : 185
BEGIN                : 300
BODY                 : 342 367 384 453 454 456
CASE                 : 117 117 280 281
CHAR                 : 67 166
CONSTANT             : 29 30 35 129
DECLARE              : 299
DELAY                : 406 407
DELTA                : 76 77 182 489 490
DIGITS               : 55 75 77 181 490 491
DO                   : 402
DOTDOT               : 62
ELSE                 : 204 279 424
ELSIF                : 274
END                  : 96 117 272 280 294 297 333 337 342 364 367 371 384 397 402 412 422 423 424 506
ENTRY                : 392 393 394 395
EXCEPTION            : 353 457 458
EXIT                 : 304
FLOAT                : 186
FOR                  : 291 505 506 511
FUNCTION             : 132 316 317 476
GENERIC              : 471
GOTO                 : 311
GREATEREQ            : 214
IDENTIFIER           : 2 26 36 50 66 161 180 269 287 291 369 392 393 394 395 461
IF                   : 272 272
IN                   : 215 216 291 328 330
INTEGER              : 184
IS                   : 41 50 117 281 332 337 342 364 367 371 384 397 453 454 455 456 474 477 478 484 485 499 500
LESSEQ               : 212
LESSLESS             : 269
LESSMORE             : 39 87 477 482 485 486 487 488 489 490 490 491
LIMITED              : 347
LOOP                 : 294 294
MOD                  : 69 229 488 508
MOREMORE             : 269
NEW                  : 56 57 58 59 60 242 243 477 478 496 497 498 501
NOT                  : 216 232
NOTEQUAL             : 210
NuLL                 : 97 103 189 193 194 270
OF                   : 80 81
OR                   : 202 204 416 423
OTHERS               : 125 465
OUT                  : 329 330
PACKAGE              : 337 342 355 357 454 477 478 500
PRAGMA               : 2 3
PRIVATE              : 57 59 339 345 366 373 434 497 498
PROCEDURE            : 131 315 475
PROTECTED            : 134 369 370 384 456
RAISE                : 466
RANGE                : 61 87 487 510
RECORD               : 96 96 97 193 194 506 506
REM                  : 230
RENAMES              : 359
REQUEUE              : 467 468
RETURN               : 132 309 310 316 476
REVERSE              : 293
SELECT               : 412 412 422 422 423 423 424 424
SEPARATE             : 448 453 454 455 456
STARSTAR             : 233
STRING               : 167 319
SUBTYPE              : 50
TAGGED               : 99 100
TASK                 : 361 362 367 453
TERMINATE            : 419
THEN                 : 203 276 422
TICK                 : 159 179 241
TYPE                 : 36 349 362 370 474
UNTIL                : 407
USE                  : 348 349 505 506 511
WHEN                 : 120 284 308 394 395 414 460 461
WHILE                : 289
WITH                 : 57 58 59 60 192 193 438 468 475 476 477 478 497 498
XOR                  : 
error                : 22 109 114 174 262 326
|                    : 122 463

Nonterminals, with rules where they appear

abort_stmt           : 258
accept_hdr           : 401 402
accept_stmt          : 267 417
access_opt           : 113
access_type          : 47 493
adding               : 219
address_spec         : 504
aggregate            : 239
aliased_opt          : 82
align_opt            : 506
allocator            : 236
alternative          : 283
alternative_s        : 280 283
array_type           : 32 45 492
assign_stmt          : 252
async_select         : 409
attrib_def           : 502
attribute            : 156
attribute_id         : 159 179
basic_loop           : 285
block                : 266
block_body           : 297 333 344 367 397
block_decl           : 297
body                 : 147
body_opt             : 342
body_stub            : 21
c_id_opt             : 337 342
c_name_list          : 165 438
case_hdr             : 280
case_stmt            : 264
choice               : 121 122
choice_s             : 120 122 197 284
code_stmt            : 260
comp_assoc           : 172 190
comp_decl            : 104 105 383
comp_decl_s          : 101 105
comp_list            : 96 120
comp_loc_s           : 506 510
comp_unit            : 429
compilation          : 1 429
component_subtype_def : 80 81 108
compound_name        : 163 164 165 315 318 337 341 342 355 357 448 454 500
compound_stmt        : 249
cond_clause          : 273 274
cond_clause_s        : 272 274
cond_entry_call      : 411
cond_part            : 275
condition            : 276 289 308 394 395 414
constr_array_type    : 79
constraint           : 51
context_spec         : 431 436 437
decimal_digits_constraint : 54
decl                 : 141
decl_item            : 139 140 148
decl_item_or_body    : 145 146
decl_item_or_body_s1 : 136 146
decl_item_s          : 337 339
decl_item_s1         : 138 140
decl_part            : 299 333 342 367 397
def_id               : 24 25
def_id_s             : 23 25 35 108 113 325 352 353 457
delay_or_entry_alt   : 422
delay_stmt           : 257 418 420 423
derived_type         : 48
designator           : 296 316 317 476
discrete_range       : 89 90 290 393 395
discrete_with_range  : 124 173
discrim_part         : 38 481
discrim_part_opt     : 36 362 370
discrim_spec         : 111 112
discrim_spec_s       : 110 112
else_opt             : 272 412
entry_body           : 387
entry_body_part      : 394 395
entry_call           : 421 423 424
entry_decl           : 376 391
entry_decl_s         : 364 366 391
entry_name           : 403 405
enum_id              : 64 65
enum_id_s            : 63 65
enumeration_type     : 42
except_choice        : 462 463
except_choice_s      : 460 461 463
except_handler_part  : 303 459
except_handler_part_opt : 301
exception_decl       : 18
exception_handler    : 458 459
exit_stmt            : 253
expression           : 6 7 34 35 55 69 75 76 77 77 123 171 192 193 197 199 200 240 271 277 281 310 405 406 407 505 508 510 511
factor               : 225 226
fixed_type           : 74
float_type           : 73
formal_part          : 321
formal_part_opt      : 131 132 315 316 392 393 394 395 403 475 476
generic_decl         : 20 446
generic_derived_type : 495
generic_discrim_part_opt : 474
generic_formal       : 472
generic_formal_part  : 357 358 469 470 472
generic_inst         : 499 500
generic_pkg_inst     : 336
generic_subp_inst    : 313
generic_type_def     : 474
goto_stmt            : 255
guarded_select_alt   : 412 416
handled_stmt_s       : 300 402
id_opt               : 285 297 333 364 367 371 384 397 402
if_stmt              : 263
index                : 85 86
index_s              : 80 86
indexed_comp         : 154
init_opt             : 23 108 113 325
integer_type         : 43
iter_discrete_range_s : 88 90
iter_index_constraint : 81
iter_part            : 290 395
iteration            : 285
label                : 247
label_opt            : 285 297
limited_opt          : 95 345
literal              : 234
logical              : 199
loop_stmt            : 265
mark                 : 113 132 159 160 325 505 506 510 511
membership           : 207 208
mode                 : 325
multiplying          : 226
name                 : 51 52 87 91 126 168 175 176 177 178 179 208 235 241 242 271 306 311 316 334 350 351 359 464 467 468 476 477 478 484 501
name_opt             : 304 466
name_s               : 348 349 351 427
null_stmt            : 251
number_decl          : 11
object_decl          : 10
object_qualifier_opt : 23 352
object_subtype_def   : 23
operator_symbol      : 157 177
or_select            : 412 416
param                : 323 324 473
param_s              : 322 324
parenthesized_primary : 238 241
pkg_body             : 150 442 450
pkg_decl             : 15 441
pkg_spec             : 335 470
pragma               : 9 144 250 379 430 437
pragma_arg           : 4 5
pragma_arg_s         : 3 5
pragma_s             : 9 96 102 103 105 106 107 107 117 120 280 385 386 390 391 399 430 431 432
primary              : 231 232 233 233
private_opt          : 431 432
private_part         : 337
private_type         : 49 494
procedure_call       : 256 400
prot_body            : 152 452
prot_decl            : 17
prot_def             : 369 370
prot_elem_decl       : 381
prot_elem_decl_s     : 373 381
prot_op_body         : 386
prot_op_body_s       : 384 386
prot_op_decl         : 375 382
prot_op_decl_s       : 371 375
prot_opt             : 131 132
prot_private_opt     : 371
prot_spec            : 368
qualified            : 237 243 512
raise_stmt           : 259
range                : 61 92 127 207 510
range_constr_opt     : 55 91
range_constraint     : 53 70 94 126
range_spec           : 68 72 76
range_spec_opt       : 75 77
real_type            : 44
record_def           : 58 60 95
record_type          : 46
record_type_spec     : 503
relation             : 198 199 200
relational           : 206
rename_decl          : 19
rename_unit          : 354 447
renames              : 352 353 355 356 357 358
rep_spec             : 143 378 399
rep_spec_s           : 364 366 399
requeue_stmt         : 261
return_stmt          : 254
reverse_opt          : 290
select_alt           : 413 414
select_stmt          : 268
select_wait          : 408
selected_comp        : 155
short_circuit        : 200
simple_expression    : 62 62 205 206 206 207 208 219
simple_name          : 3 7 117 153 158 160 162 163 175 361 362 367 370 384 404 453 456 474 475 477 478
simple_stmt          : 248
start_symbol         : 0
statement            : 244 245 247
statement_s          : 245 275 279 284 294 301 422 424 426 460 461
stmts_opt            : 417 418 420 421 423 423 424
subp_default         : 475 476
subprog_body         : 149 388 444 449
subprog_decl         : 14 443
subprog_spec         : 312 332 356 358 377 389 455 469 499
subprog_spec_is_push : 314 333
subtype_decl         : 13
subtype_ind          : 31 50 56 57 58 59 60 82 128 129 130 352 496 497 498
subunit              : 445
subunit_body         : 448
tagged_opt           : 95 345
task_body            : 151 451
task_decl            : 16
task_def             : 361 362
task_private_opt     : 364
task_spec            : 360
term                 : 217 218 219 226
timed_entry_call     : 410
type_completion      : 36
type_decl            : 12
type_def             : 41
unary                : 217
unconstr_array_type  : 78
unit                 : 431 432
unlabeled            : 246
use_clause           : 142 440 479
use_clause_opt       : 435 436 440
used_char            : 176 188
value                : 169 170 195 195 196
value_s              : 168 170 192
value_s_2            : 191 196
variant              : 118 119
variant_part         : 102 107
variant_part_opt     : 101
variant_s            : 117 119
when_opt             : 304
with_clause          : 435 436

Parsing method: LALR

state 0

    (0) S' -> . start_symbol
    (1) start_symbol -> . compilation
    (428) compilation -> .
    (429) compilation -> . compilation comp_unit
    (430) compilation -> . pragma pragma_s
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    PRIVATE         reduce using rule 428 (compilation -> .)
    WITH            reduce using rule 428 (compilation -> .)
    PACKAGE         reduce using rule 428 (compilation -> .)
    SEPARATE        reduce using rule 428 (compilation -> .)
    PROCEDURE       reduce using rule 428 (compilation -> .)
    FUNCTION        reduce using rule 428 (compilation -> .)
    GENERIC         reduce using rule 428 (compilation -> .)
    $end            reduce using rule 428 (compilation -> .)
    PRAGMA          shift and go to state 4

    start_symbol                   shift and go to state 1
    compilation                    shift and go to state 3
    pragma                         shift and go to state 2

state 1

    (0) S' -> start_symbol .



state 2

    (430) compilation -> pragma . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    WITH            reduce using rule 8 (pragma_s -> .)
    PACKAGE         reduce using rule 8 (pragma_s -> .)
    SEPARATE        reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)
    GENERIC         reduce using rule 8 (pragma_s -> .)
    $end            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 5

state 3

    (1) start_symbol -> compilation .
    (429) compilation -> compilation . comp_unit
    (431) comp_unit -> . context_spec private_opt unit pragma_s
    (432) comp_unit -> . private_opt unit pragma_s
    (435) context_spec -> . with_clause use_clause_opt
    (436) context_spec -> . context_spec with_clause use_clause_opt
    (437) context_spec -> . context_spec pragma
    (433) private_opt -> .
    (434) private_opt -> . PRIVATE
    (438) with_clause -> . WITH c_name_list ;

    $end            reduce using rule 1 (start_symbol -> compilation .)
    PACKAGE         reduce using rule 433 (private_opt -> .)
    SEPARATE        reduce using rule 433 (private_opt -> .)
    PROCEDURE       reduce using rule 433 (private_opt -> .)
    FUNCTION        reduce using rule 433 (private_opt -> .)
    GENERIC         reduce using rule 433 (private_opt -> .)
    PRIVATE         shift and go to state 7
    WITH            shift and go to state 11

    context_spec                   shift and go to state 6
    with_clause                    shift and go to state 8
    private_opt                    shift and go to state 9
    comp_unit                      shift and go to state 10

state 4

    (2) pragma -> PRAGMA . IDENTIFIER ;
    (3) pragma -> PRAGMA . simple_name ( pragma_arg_s ) ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 12

    simple_name                    shift and go to state 13

state 5

    (430) compilation -> pragma pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    PRIVATE         reduce using rule 430 (compilation -> pragma pragma_s .)
    WITH            reduce using rule 430 (compilation -> pragma pragma_s .)
    PACKAGE         reduce using rule 430 (compilation -> pragma pragma_s .)
    SEPARATE        reduce using rule 430 (compilation -> pragma pragma_s .)
    PROCEDURE       reduce using rule 430 (compilation -> pragma pragma_s .)
    FUNCTION        reduce using rule 430 (compilation -> pragma pragma_s .)
    GENERIC         reduce using rule 430 (compilation -> pragma pragma_s .)
    $end            reduce using rule 430 (compilation -> pragma pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 6

    (431) comp_unit -> context_spec . private_opt unit pragma_s
    (436) context_spec -> context_spec . with_clause use_clause_opt
    (437) context_spec -> context_spec . pragma
    (433) private_opt -> .
    (434) private_opt -> . PRIVATE
    (438) with_clause -> . WITH c_name_list ;
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    PACKAGE         reduce using rule 433 (private_opt -> .)
    SEPARATE        reduce using rule 433 (private_opt -> .)
    PROCEDURE       reduce using rule 433 (private_opt -> .)
    FUNCTION        reduce using rule 433 (private_opt -> .)
    GENERIC         reduce using rule 433 (private_opt -> .)
    PRIVATE         shift and go to state 7
    WITH            shift and go to state 11
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 15
    with_clause                    shift and go to state 16
    private_opt                    shift and go to state 17

state 7

    (434) private_opt -> PRIVATE .

    PACKAGE         reduce using rule 434 (private_opt -> PRIVATE .)
    SEPARATE        reduce using rule 434 (private_opt -> PRIVATE .)
    PROCEDURE       reduce using rule 434 (private_opt -> PRIVATE .)
    FUNCTION        reduce using rule 434 (private_opt -> PRIVATE .)
    GENERIC         reduce using rule 434 (private_opt -> PRIVATE .)


state 8

    (435) context_spec -> with_clause . use_clause_opt
    (439) use_clause_opt -> .
    (440) use_clause_opt -> . use_clause_opt use_clause

    USE             reduce using rule 439 (use_clause_opt -> .)
    PRIVATE         reduce using rule 439 (use_clause_opt -> .)
    WITH            reduce using rule 439 (use_clause_opt -> .)
    PRAGMA          reduce using rule 439 (use_clause_opt -> .)
    PACKAGE         reduce using rule 439 (use_clause_opt -> .)
    SEPARATE        reduce using rule 439 (use_clause_opt -> .)
    PROCEDURE       reduce using rule 439 (use_clause_opt -> .)
    FUNCTION        reduce using rule 439 (use_clause_opt -> .)
    GENERIC         reduce using rule 439 (use_clause_opt -> .)

    use_clause_opt                 shift and go to state 18

state 9

    (432) comp_unit -> private_opt . unit pragma_s
    (441) unit -> . pkg_decl
    (442) unit -> . pkg_body
    (443) unit -> . subprog_decl
    (444) unit -> . subprog_body
    (445) unit -> . subunit
    (446) unit -> . generic_decl
    (447) unit -> . rename_unit
    (335) pkg_decl -> . pkg_spec ;
    (336) pkg_decl -> . generic_pkg_inst ;
    (342) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (312) subprog_decl -> . subprog_spec ;
    (313) subprog_decl -> . generic_subp_inst ;
    (314) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (333) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (448) subunit -> . SEPARATE ( compound_name ) subunit_body
    (469) generic_decl -> . generic_formal_part subprog_spec ;
    (470) generic_decl -> . generic_formal_part pkg_spec ;
    (355) rename_unit -> . PACKAGE compound_name renames ;
    (356) rename_unit -> . subprog_spec renames ;
    (357) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (358) rename_unit -> . generic_formal_part subprog_spec renames ;
    (337) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (315) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (316) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (317) subprog_spec -> . FUNCTION designator
    (499) generic_subp_inst -> . subprog_spec IS generic_inst
    (332) subprog_spec_is_push -> . subprog_spec IS
    (471) generic_formal_part -> . GENERIC
    (472) generic_formal_part -> . generic_formal_part generic_formal

    PACKAGE         shift and go to state 28
    SEPARATE        shift and go to state 20
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21

    subprog_body                   shift and go to state 19
    pkg_body                       shift and go to state 22
    unit                           shift and go to state 23
    subprog_spec_is_push           shift and go to state 24
    generic_decl                   shift and go to state 25
    subprog_spec                   shift and go to state 26
    subunit                        shift and go to state 27
    generic_subp_inst              shift and go to state 29
    rename_unit                    shift and go to state 30
    pkg_decl                       shift and go to state 32
    generic_formal_part            shift and go to state 33
    generic_pkg_inst               shift and go to state 34
    subprog_decl                   shift and go to state 35
    pkg_spec                       shift and go to state 37

state 10

    (429) compilation -> compilation comp_unit .

    PRIVATE         reduce using rule 429 (compilation -> compilation comp_unit .)
    WITH            reduce using rule 429 (compilation -> compilation comp_unit .)
    PACKAGE         reduce using rule 429 (compilation -> compilation comp_unit .)
    SEPARATE        reduce using rule 429 (compilation -> compilation comp_unit .)
    PROCEDURE       reduce using rule 429 (compilation -> compilation comp_unit .)
    FUNCTION        reduce using rule 429 (compilation -> compilation comp_unit .)
    GENERIC         reduce using rule 429 (compilation -> compilation comp_unit .)
    $end            reduce using rule 429 (compilation -> compilation comp_unit .)


state 11

    (438) with_clause -> WITH . c_name_list ;
    (164) c_name_list -> . compound_name
    (165) c_name_list -> . c_name_list , compound_name
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    c_name_list                    shift and go to state 38
    compound_name                  shift and go to state 40
    simple_name                    shift and go to state 41

state 12

    (2) pragma -> PRAGMA IDENTIFIER . ;
    (161) simple_name -> IDENTIFIER .

    ;               shift and go to state 42
    (               reduce using rule 161 (simple_name -> IDENTIFIER .)


state 13

    (3) pragma -> PRAGMA simple_name . ( pragma_arg_s ) ;

    (               shift and go to state 43


state 14

    (9) pragma_s -> pragma_s pragma .

    PRAGMA          reduce using rule 9 (pragma_s -> pragma_s pragma .)
    END             reduce using rule 9 (pragma_s -> pragma_s pragma .)
    ENTRY           reduce using rule 9 (pragma_s -> pragma_s pragma .)
    PROCEDURE       reduce using rule 9 (pragma_s -> pragma_s pragma .)
    FUNCTION        reduce using rule 9 (pragma_s -> pragma_s pragma .)
    PRIVATE         reduce using rule 9 (pragma_s -> pragma_s pragma .)
    WITH            reduce using rule 9 (pragma_s -> pragma_s pragma .)
    PACKAGE         reduce using rule 9 (pragma_s -> pragma_s pragma .)
    SEPARATE        reduce using rule 9 (pragma_s -> pragma_s pragma .)
    GENERIC         reduce using rule 9 (pragma_s -> pragma_s pragma .)
    $end            reduce using rule 9 (pragma_s -> pragma_s pragma .)
    FOR             reduce using rule 9 (pragma_s -> pragma_s pragma .)
    WHEN            reduce using rule 9 (pragma_s -> pragma_s pragma .)
    NuLL            reduce using rule 9 (pragma_s -> pragma_s pragma .)
    CASE            reduce using rule 9 (pragma_s -> pragma_s pragma .)
    error           reduce using rule 9 (pragma_s -> pragma_s pragma .)
    IDENTIFIER      reduce using rule 9 (pragma_s -> pragma_s pragma .)


state 15

    (437) context_spec -> context_spec pragma .

    PRIVATE         reduce using rule 437 (context_spec -> context_spec pragma .)
    WITH            reduce using rule 437 (context_spec -> context_spec pragma .)
    PRAGMA          reduce using rule 437 (context_spec -> context_spec pragma .)
    PACKAGE         reduce using rule 437 (context_spec -> context_spec pragma .)
    SEPARATE        reduce using rule 437 (context_spec -> context_spec pragma .)
    PROCEDURE       reduce using rule 437 (context_spec -> context_spec pragma .)
    FUNCTION        reduce using rule 437 (context_spec -> context_spec pragma .)
    GENERIC         reduce using rule 437 (context_spec -> context_spec pragma .)


state 16

    (436) context_spec -> context_spec with_clause . use_clause_opt
    (439) use_clause_opt -> .
    (440) use_clause_opt -> . use_clause_opt use_clause

    USE             reduce using rule 439 (use_clause_opt -> .)
    PRIVATE         reduce using rule 439 (use_clause_opt -> .)
    WITH            reduce using rule 439 (use_clause_opt -> .)
    PRAGMA          reduce using rule 439 (use_clause_opt -> .)
    PACKAGE         reduce using rule 439 (use_clause_opt -> .)
    SEPARATE        reduce using rule 439 (use_clause_opt -> .)
    PROCEDURE       reduce using rule 439 (use_clause_opt -> .)
    FUNCTION        reduce using rule 439 (use_clause_opt -> .)
    GENERIC         reduce using rule 439 (use_clause_opt -> .)

    use_clause_opt                 shift and go to state 44

state 17

    (431) comp_unit -> context_spec private_opt . unit pragma_s
    (441) unit -> . pkg_decl
    (442) unit -> . pkg_body
    (443) unit -> . subprog_decl
    (444) unit -> . subprog_body
    (445) unit -> . subunit
    (446) unit -> . generic_decl
    (447) unit -> . rename_unit
    (335) pkg_decl -> . pkg_spec ;
    (336) pkg_decl -> . generic_pkg_inst ;
    (342) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (312) subprog_decl -> . subprog_spec ;
    (313) subprog_decl -> . generic_subp_inst ;
    (314) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (333) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (448) subunit -> . SEPARATE ( compound_name ) subunit_body
    (469) generic_decl -> . generic_formal_part subprog_spec ;
    (470) generic_decl -> . generic_formal_part pkg_spec ;
    (355) rename_unit -> . PACKAGE compound_name renames ;
    (356) rename_unit -> . subprog_spec renames ;
    (357) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (358) rename_unit -> . generic_formal_part subprog_spec renames ;
    (337) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (315) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (316) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (317) subprog_spec -> . FUNCTION designator
    (499) generic_subp_inst -> . subprog_spec IS generic_inst
    (332) subprog_spec_is_push -> . subprog_spec IS
    (471) generic_formal_part -> . GENERIC
    (472) generic_formal_part -> . generic_formal_part generic_formal

    PACKAGE         shift and go to state 28
    SEPARATE        shift and go to state 20
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21

    subprog_body                   shift and go to state 19
    subprog_decl                   shift and go to state 35
    unit                           shift and go to state 45
    subprog_spec_is_push           shift and go to state 24
    generic_decl                   shift and go to state 25
    subprog_spec                   shift and go to state 26
    subunit                        shift and go to state 27
    generic_subp_inst              shift and go to state 29
    rename_unit                    shift and go to state 30
    pkg_decl                       shift and go to state 32
    generic_formal_part            shift and go to state 33
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 22
    pkg_spec                       shift and go to state 37

state 18

    (435) context_spec -> with_clause use_clause_opt .
    (440) use_clause_opt -> use_clause_opt . use_clause
    (348) use_clause -> . USE name_s ;
    (349) use_clause -> . USE TYPE name_s ;

    PRIVATE         reduce using rule 435 (context_spec -> with_clause use_clause_opt .)
    WITH            reduce using rule 435 (context_spec -> with_clause use_clause_opt .)
    PRAGMA          reduce using rule 435 (context_spec -> with_clause use_clause_opt .)
    PACKAGE         reduce using rule 435 (context_spec -> with_clause use_clause_opt .)
    SEPARATE        reduce using rule 435 (context_spec -> with_clause use_clause_opt .)
    PROCEDURE       reduce using rule 435 (context_spec -> with_clause use_clause_opt .)
    FUNCTION        reduce using rule 435 (context_spec -> with_clause use_clause_opt .)
    GENERIC         reduce using rule 435 (context_spec -> with_clause use_clause_opt .)
    USE             shift and go to state 46

    use_clause                     shift and go to state 47

state 19

    (444) unit -> subprog_body .

    PRAGMA          reduce using rule 444 (unit -> subprog_body .)
    PRIVATE         reduce using rule 444 (unit -> subprog_body .)
    WITH            reduce using rule 444 (unit -> subprog_body .)
    PACKAGE         reduce using rule 444 (unit -> subprog_body .)
    SEPARATE        reduce using rule 444 (unit -> subprog_body .)
    PROCEDURE       reduce using rule 444 (unit -> subprog_body .)
    FUNCTION        reduce using rule 444 (unit -> subprog_body .)
    GENERIC         reduce using rule 444 (unit -> subprog_body .)
    $end            reduce using rule 444 (unit -> subprog_body .)


state 20

    (448) subunit -> SEPARATE . ( compound_name ) subunit_body

    (               shift and go to state 48


state 21

    (471) generic_formal_part -> GENERIC .

    PACKAGE         reduce using rule 471 (generic_formal_part -> GENERIC .)
    PROCEDURE       reduce using rule 471 (generic_formal_part -> GENERIC .)
    FUNCTION        reduce using rule 471 (generic_formal_part -> GENERIC .)
    TYPE            reduce using rule 471 (generic_formal_part -> GENERIC .)
    WITH            reduce using rule 471 (generic_formal_part -> GENERIC .)
    error           reduce using rule 471 (generic_formal_part -> GENERIC .)
    USE             reduce using rule 471 (generic_formal_part -> GENERIC .)
    IDENTIFIER      reduce using rule 471 (generic_formal_part -> GENERIC .)


state 22

    (442) unit -> pkg_body .

    PRAGMA          reduce using rule 442 (unit -> pkg_body .)
    PRIVATE         reduce using rule 442 (unit -> pkg_body .)
    WITH            reduce using rule 442 (unit -> pkg_body .)
    PACKAGE         reduce using rule 442 (unit -> pkg_body .)
    SEPARATE        reduce using rule 442 (unit -> pkg_body .)
    PROCEDURE       reduce using rule 442 (unit -> pkg_body .)
    FUNCTION        reduce using rule 442 (unit -> pkg_body .)
    GENERIC         reduce using rule 442 (unit -> pkg_body .)
    $end            reduce using rule 442 (unit -> pkg_body .)


state 23

    (432) comp_unit -> private_opt unit . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    WITH            reduce using rule 8 (pragma_s -> .)
    PACKAGE         reduce using rule 8 (pragma_s -> .)
    SEPARATE        reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)
    GENERIC         reduce using rule 8 (pragma_s -> .)
    $end            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 49

state 24

    (314) subprog_decl -> subprog_spec_is_push . ABSTRACT ;
    (333) subprog_body -> subprog_spec_is_push . decl_part block_body END id_opt ;
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (333) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (342) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (367) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (384) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (348) use_clause -> . USE name_s ;
    (349) use_clause -> . USE TYPE name_s ;
    (502) rep_spec -> . attrib_def
    (503) rep_spec -> . record_type_spec
    (504) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (332) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (312) subprog_decl -> . subprog_spec ;
    (313) subprog_decl -> . generic_subp_inst ;
    (314) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (335) pkg_decl -> . pkg_spec ;
    (336) pkg_decl -> . generic_pkg_inst ;
    (360) task_decl -> . task_spec ;
    (368) prot_decl -> . prot_spec ;
    (457) exception_decl -> . def_id_s : EXCEPTION ;
    (352) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (353) rename_decl -> . def_id_s : EXCEPTION renames ;
    (354) rename_decl -> . rename_unit
    (469) generic_decl -> . generic_formal_part subprog_spec ;
    (470) generic_decl -> . generic_formal_part pkg_spec ;
    (453) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (454) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (455) body_stub -> . subprog_spec IS SEPARATE ;
    (456) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (505) attrib_def -> . FOR mark USE expression ;
    (506) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (511) address_spec -> . FOR mark USE AT expression ;
    (315) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (316) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (317) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (499) generic_subp_inst -> . subprog_spec IS generic_inst
    (337) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (361) task_spec -> . TASK simple_name task_def
    (362) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (369) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (370) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (355) rename_unit -> . PACKAGE compound_name renames ;
    (356) rename_unit -> . subprog_spec renames ;
    (357) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (358) rename_unit -> . generic_formal_part subprog_spec renames ;
    (471) generic_formal_part -> . GENERIC
    (472) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    ABSTRACT        shift and go to state 81
    BEGIN           reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 54
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 25

    (446) unit -> generic_decl .

    PRAGMA          reduce using rule 446 (unit -> generic_decl .)
    PRIVATE         reduce using rule 446 (unit -> generic_decl .)
    WITH            reduce using rule 446 (unit -> generic_decl .)
    PACKAGE         reduce using rule 446 (unit -> generic_decl .)
    SEPARATE        reduce using rule 446 (unit -> generic_decl .)
    PROCEDURE       reduce using rule 446 (unit -> generic_decl .)
    FUNCTION        reduce using rule 446 (unit -> generic_decl .)
    GENERIC         reduce using rule 446 (unit -> generic_decl .)
    $end            reduce using rule 446 (unit -> generic_decl .)


state 26

    (312) subprog_decl -> subprog_spec . ;
    (356) rename_unit -> subprog_spec . renames ;
    (499) generic_subp_inst -> subprog_spec . IS generic_inst
    (332) subprog_spec_is_push -> subprog_spec . IS
    (359) renames -> . RENAMES name

    ;               shift and go to state 97
    IS              shift and go to state 96
    RENAMES         shift and go to state 95

    renames                        shift and go to state 94

state 27

    (445) unit -> subunit .

    PRAGMA          reduce using rule 445 (unit -> subunit .)
    PRIVATE         reduce using rule 445 (unit -> subunit .)
    WITH            reduce using rule 445 (unit -> subunit .)
    PACKAGE         reduce using rule 445 (unit -> subunit .)
    SEPARATE        reduce using rule 445 (unit -> subunit .)
    PROCEDURE       reduce using rule 445 (unit -> subunit .)
    FUNCTION        reduce using rule 445 (unit -> subunit .)
    GENERIC         reduce using rule 445 (unit -> subunit .)
    $end            reduce using rule 445 (unit -> subunit .)


state 28

    (342) pkg_body -> PACKAGE . BODY compound_name IS decl_part body_opt END c_id_opt ;
    (355) rename_unit -> PACKAGE . compound_name renames ;
    (337) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> PACKAGE . compound_name IS generic_inst
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    BODY            shift and go to state 98
    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 41
    compound_name                  shift and go to state 99

state 29

    (313) subprog_decl -> generic_subp_inst . ;

    ;               shift and go to state 100


state 30

    (447) unit -> rename_unit .

    PRAGMA          reduce using rule 447 (unit -> rename_unit .)
    PRIVATE         reduce using rule 447 (unit -> rename_unit .)
    WITH            reduce using rule 447 (unit -> rename_unit .)
    PACKAGE         reduce using rule 447 (unit -> rename_unit .)
    SEPARATE        reduce using rule 447 (unit -> rename_unit .)
    PROCEDURE       reduce using rule 447 (unit -> rename_unit .)
    FUNCTION        reduce using rule 447 (unit -> rename_unit .)
    GENERIC         reduce using rule 447 (unit -> rename_unit .)
    $end            reduce using rule 447 (unit -> rename_unit .)


state 31

    (315) subprog_spec -> PROCEDURE . compound_name formal_part_opt
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 101
    simple_name                    shift and go to state 41

state 32

    (441) unit -> pkg_decl .

    PRAGMA          reduce using rule 441 (unit -> pkg_decl .)
    PRIVATE         reduce using rule 441 (unit -> pkg_decl .)
    WITH            reduce using rule 441 (unit -> pkg_decl .)
    PACKAGE         reduce using rule 441 (unit -> pkg_decl .)
    SEPARATE        reduce using rule 441 (unit -> pkg_decl .)
    PROCEDURE       reduce using rule 441 (unit -> pkg_decl .)
    FUNCTION        reduce using rule 441 (unit -> pkg_decl .)
    GENERIC         reduce using rule 441 (unit -> pkg_decl .)
    $end            reduce using rule 441 (unit -> pkg_decl .)


state 33

    (469) generic_decl -> generic_formal_part . subprog_spec ;
    (470) generic_decl -> generic_formal_part . pkg_spec ;
    (357) rename_unit -> generic_formal_part . PACKAGE compound_name renames ;
    (358) rename_unit -> generic_formal_part . subprog_spec renames ;
    (472) generic_formal_part -> generic_formal_part . generic_formal
    (315) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (316) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (317) subprog_spec -> . FUNCTION designator
    (337) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (473) generic_formal -> . param ;
    (474) generic_formal -> . TYPE simple_name generic_discrim_part_opt IS generic_type_def ;
    (475) generic_formal -> . WITH PROCEDURE simple_name formal_part_opt subp_default ;
    (476) generic_formal -> . WITH FUNCTION designator formal_part_opt RETURN name subp_default ;
    (477) generic_formal -> . WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ;
    (478) generic_formal -> . WITH PACKAGE simple_name IS NEW name ;
    (479) generic_formal -> . use_clause
    (325) param -> . def_id_s : mode mark init_opt
    (326) param -> . error
    (348) use_clause -> . USE name_s ;
    (349) use_clause -> . USE TYPE name_s ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    PACKAGE         shift and go to state 106
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    TYPE            shift and go to state 111
    WITH            shift and go to state 102
    error           shift and go to state 109
    USE             shift and go to state 46
    IDENTIFIER      shift and go to state 76

    param                          shift and go to state 103
    subprog_spec                   shift and go to state 104
    def_id_s                       shift and go to state 105
    def_id                         shift and go to state 89
    generic_formal                 shift and go to state 107
    use_clause                     shift and go to state 108
    pkg_spec                       shift and go to state 110

state 34

    (336) pkg_decl -> generic_pkg_inst . ;

    ;               shift and go to state 112


state 35

    (443) unit -> subprog_decl .

    PRAGMA          reduce using rule 443 (unit -> subprog_decl .)
    PRIVATE         reduce using rule 443 (unit -> subprog_decl .)
    WITH            reduce using rule 443 (unit -> subprog_decl .)
    PACKAGE         reduce using rule 443 (unit -> subprog_decl .)
    SEPARATE        reduce using rule 443 (unit -> subprog_decl .)
    PROCEDURE       reduce using rule 443 (unit -> subprog_decl .)
    FUNCTION        reduce using rule 443 (unit -> subprog_decl .)
    GENERIC         reduce using rule 443 (unit -> subprog_decl .)
    $end            reduce using rule 443 (unit -> subprog_decl .)


state 36

    (316) subprog_spec -> FUNCTION . designator formal_part_opt RETURN name
    (317) subprog_spec -> FUNCTION . designator
    (318) designator -> . compound_name
    (319) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 114
    designator                     shift and go to state 113
    simple_name                    shift and go to state 41

state 37

    (335) pkg_decl -> pkg_spec . ;

    ;               shift and go to state 116


state 38

    (438) with_clause -> WITH c_name_list . ;
    (165) c_name_list -> c_name_list . , compound_name

    ;               shift and go to state 117
    ,               shift and go to state 118


state 39

    (161) simple_name -> IDENTIFIER .

    USE             reduce using rule 161 (simple_name -> IDENTIFIER .)
    TICK            reduce using rule 161 (simple_name -> IDENTIFIER .)
    .               reduce using rule 161 (simple_name -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 161 (simple_name -> IDENTIFIER .)
    ;               reduce using rule 161 (simple_name -> IDENTIFIER .)
    )               reduce using rule 161 (simple_name -> IDENTIFIER .)
    AT              reduce using rule 161 (simple_name -> IDENTIFIER .)
    (               reduce using rule 161 (simple_name -> IDENTIFIER .)
    RANGE           reduce using rule 161 (simple_name -> IDENTIFIER .)
    DIGITS          reduce using rule 161 (simple_name -> IDENTIFIER .)
    STARSTAR        reduce using rule 161 (simple_name -> IDENTIFIER .)
    *               reduce using rule 161 (simple_name -> IDENTIFIER .)
    /               reduce using rule 161 (simple_name -> IDENTIFIER .)
    MOD             reduce using rule 161 (simple_name -> IDENTIFIER .)
    REM             reduce using rule 161 (simple_name -> IDENTIFIER .)
    =               reduce using rule 161 (simple_name -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 161 (simple_name -> IDENTIFIER .)
    <               reduce using rule 161 (simple_name -> IDENTIFIER .)
    LESSEQ          reduce using rule 161 (simple_name -> IDENTIFIER .)
    >               reduce using rule 161 (simple_name -> IDENTIFIER .)
    GREATEREQ       reduce using rule 161 (simple_name -> IDENTIFIER .)
    IN              reduce using rule 161 (simple_name -> IDENTIFIER .)
    NOT             reduce using rule 161 (simple_name -> IDENTIFIER .)
    +               reduce using rule 161 (simple_name -> IDENTIFIER .)
    -               reduce using rule 161 (simple_name -> IDENTIFIER .)
    &               reduce using rule 161 (simple_name -> IDENTIFIER .)
    AND             reduce using rule 161 (simple_name -> IDENTIFIER .)
    OR              reduce using rule 161 (simple_name -> IDENTIFIER .)
    IS              reduce using rule 161 (simple_name -> IDENTIFIER .)
    ,               reduce using rule 161 (simple_name -> IDENTIFIER .)
    DOTDOT          reduce using rule 161 (simple_name -> IDENTIFIER .)
    WITH            reduce using rule 161 (simple_name -> IDENTIFIER .)
    ARROW           reduce using rule 161 (simple_name -> IDENTIFIER .)
    |               reduce using rule 161 (simple_name -> IDENTIFIER .)
    THEN            reduce using rule 161 (simple_name -> IDENTIFIER .)
    LOOP            reduce using rule 161 (simple_name -> IDENTIFIER .)
    RENAMES         reduce using rule 161 (simple_name -> IDENTIFIER .)
    WHEN            reduce using rule 161 (simple_name -> IDENTIFIER .)
    RETURN          reduce using rule 161 (simple_name -> IDENTIFIER .)
    DO              reduce using rule 161 (simple_name -> IDENTIFIER .)


state 40

    (164) c_name_list -> compound_name .
    (163) compound_name -> compound_name . . simple_name

    ;               reduce using rule 164 (c_name_list -> compound_name .)
    ,               reduce using rule 164 (c_name_list -> compound_name .)
    .               shift and go to state 119


state 41

    (162) compound_name -> simple_name .

    .               reduce using rule 162 (compound_name -> simple_name .)
    ;               reduce using rule 162 (compound_name -> simple_name .)
    (               reduce using rule 162 (compound_name -> simple_name .)
    RETURN          reduce using rule 162 (compound_name -> simple_name .)
    ,               reduce using rule 162 (compound_name -> simple_name .)
    IS              reduce using rule 162 (compound_name -> simple_name .)
    RENAMES         reduce using rule 162 (compound_name -> simple_name .)
    )               reduce using rule 162 (compound_name -> simple_name .)


state 42

    (2) pragma -> PRAGMA IDENTIFIER ; .

    PRAGMA          reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    PRIVATE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    WITH            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    PACKAGE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    SEPARATE        reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    PROCEDURE       reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    FUNCTION        reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    GENERIC         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    $end            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    TASK            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    PROTECTED       reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    error           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    USE             reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    TYPE            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    SUBTYPE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    FOR             reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    IDENTIFIER      reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    BEGIN           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    END             reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    LESSLESS        reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    NuLL            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    EXIT            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    RETURN          reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    GOTO            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    DELAY           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    ABORT           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    RAISE           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    REQUEUE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    IF              reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    CASE            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    ACCEPT          reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    SELECT          reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    STRING          reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    WHILE           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    DECLARE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    LOOP            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    WHEN            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    ENTRY           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    EXCEPTION       reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    ELSIF           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    ELSE            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    OR              reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    THEN            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)


state 43

    (3) pragma -> PRAGMA simple_name ( . pragma_arg_s ) ;
    (4) pragma_arg_s -> . pragma_arg
    (5) pragma_arg_s -> . pragma_arg_s , pragma_arg
    (6) pragma_arg -> . expression
    (7) pragma_arg -> . simple_name ARROW expression
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (161) simple_name -> . IDENTIFIER
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 39
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    pragma_arg                     shift and go to state 123
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 131
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    pragma_arg_s                   shift and go to state 139
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    used_char                      shift and go to state 144
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 152

state 44

    (436) context_spec -> context_spec with_clause use_clause_opt .
    (440) use_clause_opt -> use_clause_opt . use_clause
    (348) use_clause -> . USE name_s ;
    (349) use_clause -> . USE TYPE name_s ;

    PRIVATE         reduce using rule 436 (context_spec -> context_spec with_clause use_clause_opt .)
    WITH            reduce using rule 436 (context_spec -> context_spec with_clause use_clause_opt .)
    PRAGMA          reduce using rule 436 (context_spec -> context_spec with_clause use_clause_opt .)
    PACKAGE         reduce using rule 436 (context_spec -> context_spec with_clause use_clause_opt .)
    SEPARATE        reduce using rule 436 (context_spec -> context_spec with_clause use_clause_opt .)
    PROCEDURE       reduce using rule 436 (context_spec -> context_spec with_clause use_clause_opt .)
    FUNCTION        reduce using rule 436 (context_spec -> context_spec with_clause use_clause_opt .)
    GENERIC         reduce using rule 436 (context_spec -> context_spec with_clause use_clause_opt .)
    USE             shift and go to state 46

    use_clause                     shift and go to state 47

state 45

    (431) comp_unit -> context_spec private_opt unit . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    WITH            reduce using rule 8 (pragma_s -> .)
    PACKAGE         reduce using rule 8 (pragma_s -> .)
    SEPARATE        reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)
    GENERIC         reduce using rule 8 (pragma_s -> .)
    $end            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 153

state 46

    (348) use_clause -> USE . name_s ;
    (349) use_clause -> USE . TYPE name_s ;
    (350) name_s -> . name
    (351) name_s -> . name_s , name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    TYPE            shift and go to state 156
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name_s                         shift and go to state 154
    name                           shift and go to state 155
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 47

    (440) use_clause_opt -> use_clause_opt use_clause .

    USE             reduce using rule 440 (use_clause_opt -> use_clause_opt use_clause .)
    PRIVATE         reduce using rule 440 (use_clause_opt -> use_clause_opt use_clause .)
    WITH            reduce using rule 440 (use_clause_opt -> use_clause_opt use_clause .)
    PRAGMA          reduce using rule 440 (use_clause_opt -> use_clause_opt use_clause .)
    PACKAGE         reduce using rule 440 (use_clause_opt -> use_clause_opt use_clause .)
    SEPARATE        reduce using rule 440 (use_clause_opt -> use_clause_opt use_clause .)
    PROCEDURE       reduce using rule 440 (use_clause_opt -> use_clause_opt use_clause .)
    FUNCTION        reduce using rule 440 (use_clause_opt -> use_clause_opt use_clause .)
    GENERIC         reduce using rule 440 (use_clause_opt -> use_clause_opt use_clause .)


state 48

    (448) subunit -> SEPARATE ( . compound_name ) subunit_body
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 158
    simple_name                    shift and go to state 41

state 49

    (432) comp_unit -> private_opt unit pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    PRIVATE         reduce using rule 432 (comp_unit -> private_opt unit pragma_s .)
    WITH            reduce using rule 432 (comp_unit -> private_opt unit pragma_s .)
    PACKAGE         reduce using rule 432 (comp_unit -> private_opt unit pragma_s .)
    SEPARATE        reduce using rule 432 (comp_unit -> private_opt unit pragma_s .)
    PROCEDURE       reduce using rule 432 (comp_unit -> private_opt unit pragma_s .)
    FUNCTION        reduce using rule 432 (comp_unit -> private_opt unit pragma_s .)
    GENERIC         reduce using rule 432 (comp_unit -> private_opt unit pragma_s .)
    $end            reduce using rule 432 (comp_unit -> private_opt unit pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 50

    (141) decl_item -> decl .

    error           reduce using rule 141 (decl_item -> decl .)
    USE             reduce using rule 141 (decl_item -> decl .)
    PRAGMA          reduce using rule 141 (decl_item -> decl .)
    TYPE            reduce using rule 141 (decl_item -> decl .)
    SUBTYPE         reduce using rule 141 (decl_item -> decl .)
    TASK            reduce using rule 141 (decl_item -> decl .)
    PACKAGE         reduce using rule 141 (decl_item -> decl .)
    PROTECTED       reduce using rule 141 (decl_item -> decl .)
    FOR             reduce using rule 141 (decl_item -> decl .)
    PROCEDURE       reduce using rule 141 (decl_item -> decl .)
    FUNCTION        reduce using rule 141 (decl_item -> decl .)
    GENERIC         reduce using rule 141 (decl_item -> decl .)
    IDENTIFIER      reduce using rule 141 (decl_item -> decl .)
    PRIVATE         reduce using rule 141 (decl_item -> decl .)
    END             reduce using rule 141 (decl_item -> decl .)
    BEGIN           reduce using rule 141 (decl_item -> decl .)


state 51

    (384) prot_body -> PROTECTED . BODY simple_name IS prot_op_body_s END id_opt ;
    (456) body_stub -> PROTECTED . BODY simple_name IS SEPARATE ;
    (369) prot_spec -> PROTECTED . IDENTIFIER prot_def
    (370) prot_spec -> PROTECTED . TYPE simple_name discrim_part_opt prot_def

    BODY            shift and go to state 159
    IDENTIFIER      shift and go to state 160
    TYPE            shift and go to state 161


state 52

    (504) rep_spec -> address_spec .

    PACKAGE         reduce using rule 504 (rep_spec -> address_spec .)
    TASK            reduce using rule 504 (rep_spec -> address_spec .)
    PROTECTED       reduce using rule 504 (rep_spec -> address_spec .)
    error           reduce using rule 504 (rep_spec -> address_spec .)
    USE             reduce using rule 504 (rep_spec -> address_spec .)
    PRAGMA          reduce using rule 504 (rep_spec -> address_spec .)
    TYPE            reduce using rule 504 (rep_spec -> address_spec .)
    SUBTYPE         reduce using rule 504 (rep_spec -> address_spec .)
    FOR             reduce using rule 504 (rep_spec -> address_spec .)
    PROCEDURE       reduce using rule 504 (rep_spec -> address_spec .)
    FUNCTION        reduce using rule 504 (rep_spec -> address_spec .)
    GENERIC         reduce using rule 504 (rep_spec -> address_spec .)
    IDENTIFIER      reduce using rule 504 (rep_spec -> address_spec .)
    BEGIN           reduce using rule 504 (rep_spec -> address_spec .)
    END             reduce using rule 504 (rep_spec -> address_spec .)
    PRIVATE         reduce using rule 504 (rep_spec -> address_spec .)
    ENTRY           reduce using rule 504 (rep_spec -> address_spec .)


state 53

    (148) decl_item_or_body -> decl_item .

    PACKAGE         reduce using rule 148 (decl_item_or_body -> decl_item .)
    TASK            reduce using rule 148 (decl_item_or_body -> decl_item .)
    PROTECTED       reduce using rule 148 (decl_item_or_body -> decl_item .)
    error           reduce using rule 148 (decl_item_or_body -> decl_item .)
    USE             reduce using rule 148 (decl_item_or_body -> decl_item .)
    PRAGMA          reduce using rule 148 (decl_item_or_body -> decl_item .)
    TYPE            reduce using rule 148 (decl_item_or_body -> decl_item .)
    SUBTYPE         reduce using rule 148 (decl_item_or_body -> decl_item .)
    FOR             reduce using rule 148 (decl_item_or_body -> decl_item .)
    PROCEDURE       reduce using rule 148 (decl_item_or_body -> decl_item .)
    FUNCTION        reduce using rule 148 (decl_item_or_body -> decl_item .)
    GENERIC         reduce using rule 148 (decl_item_or_body -> decl_item .)
    IDENTIFIER      reduce using rule 148 (decl_item_or_body -> decl_item .)
    BEGIN           reduce using rule 148 (decl_item_or_body -> decl_item .)
    END             reduce using rule 148 (decl_item_or_body -> decl_item .)


state 54

    (333) subprog_body -> subprog_spec_is_push decl_part . block_body END id_opt ;
    (300) block_body -> . BEGIN handled_stmt_s

    BEGIN           shift and go to state 162

    block_body                     shift and go to state 163

state 55

    (17) decl -> prot_decl .

    PACKAGE         reduce using rule 17 (decl -> prot_decl .)
    TASK            reduce using rule 17 (decl -> prot_decl .)
    PROTECTED       reduce using rule 17 (decl -> prot_decl .)
    error           reduce using rule 17 (decl -> prot_decl .)
    USE             reduce using rule 17 (decl -> prot_decl .)
    PRAGMA          reduce using rule 17 (decl -> prot_decl .)
    TYPE            reduce using rule 17 (decl -> prot_decl .)
    SUBTYPE         reduce using rule 17 (decl -> prot_decl .)
    FOR             reduce using rule 17 (decl -> prot_decl .)
    PROCEDURE       reduce using rule 17 (decl -> prot_decl .)
    FUNCTION        reduce using rule 17 (decl -> prot_decl .)
    GENERIC         reduce using rule 17 (decl -> prot_decl .)
    IDENTIFIER      reduce using rule 17 (decl -> prot_decl .)
    BEGIN           reduce using rule 17 (decl -> prot_decl .)
    END             reduce using rule 17 (decl -> prot_decl .)
    PRIVATE         reduce using rule 17 (decl -> prot_decl .)


state 56

    (12) decl -> type_decl .

    PACKAGE         reduce using rule 12 (decl -> type_decl .)
    TASK            reduce using rule 12 (decl -> type_decl .)
    PROTECTED       reduce using rule 12 (decl -> type_decl .)
    error           reduce using rule 12 (decl -> type_decl .)
    USE             reduce using rule 12 (decl -> type_decl .)
    PRAGMA          reduce using rule 12 (decl -> type_decl .)
    TYPE            reduce using rule 12 (decl -> type_decl .)
    SUBTYPE         reduce using rule 12 (decl -> type_decl .)
    FOR             reduce using rule 12 (decl -> type_decl .)
    PROCEDURE       reduce using rule 12 (decl -> type_decl .)
    FUNCTION        reduce using rule 12 (decl -> type_decl .)
    GENERIC         reduce using rule 12 (decl -> type_decl .)
    IDENTIFIER      reduce using rule 12 (decl -> type_decl .)
    BEGIN           reduce using rule 12 (decl -> type_decl .)
    END             reduce using rule 12 (decl -> type_decl .)
    PRIVATE         reduce using rule 12 (decl -> type_decl .)


state 57

    (15) decl -> pkg_decl .

    PACKAGE         reduce using rule 15 (decl -> pkg_decl .)
    TASK            reduce using rule 15 (decl -> pkg_decl .)
    PROTECTED       reduce using rule 15 (decl -> pkg_decl .)
    error           reduce using rule 15 (decl -> pkg_decl .)
    USE             reduce using rule 15 (decl -> pkg_decl .)
    PRAGMA          reduce using rule 15 (decl -> pkg_decl .)
    TYPE            reduce using rule 15 (decl -> pkg_decl .)
    SUBTYPE         reduce using rule 15 (decl -> pkg_decl .)
    FOR             reduce using rule 15 (decl -> pkg_decl .)
    PROCEDURE       reduce using rule 15 (decl -> pkg_decl .)
    FUNCTION        reduce using rule 15 (decl -> pkg_decl .)
    GENERIC         reduce using rule 15 (decl -> pkg_decl .)
    IDENTIFIER      reduce using rule 15 (decl -> pkg_decl .)
    BEGIN           reduce using rule 15 (decl -> pkg_decl .)
    END             reduce using rule 15 (decl -> pkg_decl .)
    PRIVATE         reduce using rule 15 (decl -> pkg_decl .)


state 58

    (14) decl -> subprog_decl .

    PACKAGE         reduce using rule 14 (decl -> subprog_decl .)
    TASK            reduce using rule 14 (decl -> subprog_decl .)
    PROTECTED       reduce using rule 14 (decl -> subprog_decl .)
    error           reduce using rule 14 (decl -> subprog_decl .)
    USE             reduce using rule 14 (decl -> subprog_decl .)
    PRAGMA          reduce using rule 14 (decl -> subprog_decl .)
    TYPE            reduce using rule 14 (decl -> subprog_decl .)
    SUBTYPE         reduce using rule 14 (decl -> subprog_decl .)
    FOR             reduce using rule 14 (decl -> subprog_decl .)
    PROCEDURE       reduce using rule 14 (decl -> subprog_decl .)
    FUNCTION        reduce using rule 14 (decl -> subprog_decl .)
    GENERIC         reduce using rule 14 (decl -> subprog_decl .)
    IDENTIFIER      reduce using rule 14 (decl -> subprog_decl .)
    BEGIN           reduce using rule 14 (decl -> subprog_decl .)
    END             reduce using rule 14 (decl -> subprog_decl .)
    PRIVATE         reduce using rule 14 (decl -> subprog_decl .)


state 59

    (149) body -> subprog_body .

    PACKAGE         reduce using rule 149 (body -> subprog_body .)
    TASK            reduce using rule 149 (body -> subprog_body .)
    PROTECTED       reduce using rule 149 (body -> subprog_body .)
    error           reduce using rule 149 (body -> subprog_body .)
    USE             reduce using rule 149 (body -> subprog_body .)
    PRAGMA          reduce using rule 149 (body -> subprog_body .)
    TYPE            reduce using rule 149 (body -> subprog_body .)
    SUBTYPE         reduce using rule 149 (body -> subprog_body .)
    FOR             reduce using rule 149 (body -> subprog_body .)
    PROCEDURE       reduce using rule 149 (body -> subprog_body .)
    FUNCTION        reduce using rule 149 (body -> subprog_body .)
    GENERIC         reduce using rule 149 (body -> subprog_body .)
    IDENTIFIER      reduce using rule 149 (body -> subprog_body .)
    BEGIN           reduce using rule 149 (body -> subprog_body .)
    END             reduce using rule 149 (body -> subprog_body .)


state 60

    (16) decl -> task_decl .

    PACKAGE         reduce using rule 16 (decl -> task_decl .)
    TASK            reduce using rule 16 (decl -> task_decl .)
    PROTECTED       reduce using rule 16 (decl -> task_decl .)
    error           reduce using rule 16 (decl -> task_decl .)
    USE             reduce using rule 16 (decl -> task_decl .)
    PRAGMA          reduce using rule 16 (decl -> task_decl .)
    TYPE            reduce using rule 16 (decl -> task_decl .)
    SUBTYPE         reduce using rule 16 (decl -> task_decl .)
    FOR             reduce using rule 16 (decl -> task_decl .)
    PROCEDURE       reduce using rule 16 (decl -> task_decl .)
    FUNCTION        reduce using rule 16 (decl -> task_decl .)
    GENERIC         reduce using rule 16 (decl -> task_decl .)
    IDENTIFIER      reduce using rule 16 (decl -> task_decl .)
    BEGIN           reduce using rule 16 (decl -> task_decl .)
    END             reduce using rule 16 (decl -> task_decl .)
    PRIVATE         reduce using rule 16 (decl -> task_decl .)


state 61

    (13) decl -> subtype_decl .

    PACKAGE         reduce using rule 13 (decl -> subtype_decl .)
    TASK            reduce using rule 13 (decl -> subtype_decl .)
    PROTECTED       reduce using rule 13 (decl -> subtype_decl .)
    error           reduce using rule 13 (decl -> subtype_decl .)
    USE             reduce using rule 13 (decl -> subtype_decl .)
    PRAGMA          reduce using rule 13 (decl -> subtype_decl .)
    TYPE            reduce using rule 13 (decl -> subtype_decl .)
    SUBTYPE         reduce using rule 13 (decl -> subtype_decl .)
    FOR             reduce using rule 13 (decl -> subtype_decl .)
    PROCEDURE       reduce using rule 13 (decl -> subtype_decl .)
    FUNCTION        reduce using rule 13 (decl -> subtype_decl .)
    GENERIC         reduce using rule 13 (decl -> subtype_decl .)
    IDENTIFIER      reduce using rule 13 (decl -> subtype_decl .)
    BEGIN           reduce using rule 13 (decl -> subtype_decl .)
    END             reduce using rule 13 (decl -> subtype_decl .)
    PRIVATE         reduce using rule 13 (decl -> subtype_decl .)


state 62

    (147) decl_item_or_body -> body .

    PACKAGE         reduce using rule 147 (decl_item_or_body -> body .)
    TASK            reduce using rule 147 (decl_item_or_body -> body .)
    PROTECTED       reduce using rule 147 (decl_item_or_body -> body .)
    error           reduce using rule 147 (decl_item_or_body -> body .)
    USE             reduce using rule 147 (decl_item_or_body -> body .)
    PRAGMA          reduce using rule 147 (decl_item_or_body -> body .)
    TYPE            reduce using rule 147 (decl_item_or_body -> body .)
    SUBTYPE         reduce using rule 147 (decl_item_or_body -> body .)
    FOR             reduce using rule 147 (decl_item_or_body -> body .)
    PROCEDURE       reduce using rule 147 (decl_item_or_body -> body .)
    FUNCTION        reduce using rule 147 (decl_item_or_body -> body .)
    GENERIC         reduce using rule 147 (decl_item_or_body -> body .)
    IDENTIFIER      reduce using rule 147 (decl_item_or_body -> body .)
    BEGIN           reduce using rule 147 (decl_item_or_body -> body .)
    END             reduce using rule 147 (decl_item_or_body -> body .)


state 63

    (505) attrib_def -> FOR . mark USE expression ;
    (506) record_type_spec -> FOR . mark USE RECORD align_opt comp_loc_s END RECORD ;
    (511) address_spec -> FOR . mark USE AT expression ;
    (158) mark -> . simple_name
    (159) mark -> . mark TICK attribute_id
    (160) mark -> . mark . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    mark                           shift and go to state 164
    simple_name                    shift and go to state 165

state 64

    (10) decl -> object_decl .

    PACKAGE         reduce using rule 10 (decl -> object_decl .)
    TASK            reduce using rule 10 (decl -> object_decl .)
    PROTECTED       reduce using rule 10 (decl -> object_decl .)
    error           reduce using rule 10 (decl -> object_decl .)
    USE             reduce using rule 10 (decl -> object_decl .)
    PRAGMA          reduce using rule 10 (decl -> object_decl .)
    TYPE            reduce using rule 10 (decl -> object_decl .)
    SUBTYPE         reduce using rule 10 (decl -> object_decl .)
    FOR             reduce using rule 10 (decl -> object_decl .)
    PROCEDURE       reduce using rule 10 (decl -> object_decl .)
    FUNCTION        reduce using rule 10 (decl -> object_decl .)
    GENERIC         reduce using rule 10 (decl -> object_decl .)
    IDENTIFIER      reduce using rule 10 (decl -> object_decl .)
    BEGIN           reduce using rule 10 (decl -> object_decl .)
    END             reduce using rule 10 (decl -> object_decl .)
    PRIVATE         reduce using rule 10 (decl -> object_decl .)


state 65

    (360) task_decl -> task_spec . ;

    ;               shift and go to state 166


state 66

    (142) decl_item -> use_clause .

    error           reduce using rule 142 (decl_item -> use_clause .)
    USE             reduce using rule 142 (decl_item -> use_clause .)
    PRAGMA          reduce using rule 142 (decl_item -> use_clause .)
    TYPE            reduce using rule 142 (decl_item -> use_clause .)
    SUBTYPE         reduce using rule 142 (decl_item -> use_clause .)
    TASK            reduce using rule 142 (decl_item -> use_clause .)
    PACKAGE         reduce using rule 142 (decl_item -> use_clause .)
    PROTECTED       reduce using rule 142 (decl_item -> use_clause .)
    FOR             reduce using rule 142 (decl_item -> use_clause .)
    PROCEDURE       reduce using rule 142 (decl_item -> use_clause .)
    FUNCTION        reduce using rule 142 (decl_item -> use_clause .)
    GENERIC         reduce using rule 142 (decl_item -> use_clause .)
    IDENTIFIER      reduce using rule 142 (decl_item -> use_clause .)
    PRIVATE         reduce using rule 142 (decl_item -> use_clause .)
    END             reduce using rule 142 (decl_item -> use_clause .)
    BEGIN           reduce using rule 142 (decl_item -> use_clause .)


state 67

    (367) task_body -> TASK . BODY simple_name IS decl_part block_body END id_opt ;
    (453) body_stub -> TASK . BODY simple_name IS SEPARATE ;
    (361) task_spec -> TASK . simple_name task_def
    (362) task_spec -> TASK . TYPE simple_name discrim_part_opt task_def
    (161) simple_name -> . IDENTIFIER

    BODY            shift and go to state 167
    TYPE            shift and go to state 168
    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 169

state 68

    (503) rep_spec -> record_type_spec .

    PACKAGE         reduce using rule 503 (rep_spec -> record_type_spec .)
    TASK            reduce using rule 503 (rep_spec -> record_type_spec .)
    PROTECTED       reduce using rule 503 (rep_spec -> record_type_spec .)
    error           reduce using rule 503 (rep_spec -> record_type_spec .)
    USE             reduce using rule 503 (rep_spec -> record_type_spec .)
    PRAGMA          reduce using rule 503 (rep_spec -> record_type_spec .)
    TYPE            reduce using rule 503 (rep_spec -> record_type_spec .)
    SUBTYPE         reduce using rule 503 (rep_spec -> record_type_spec .)
    FOR             reduce using rule 503 (rep_spec -> record_type_spec .)
    PROCEDURE       reduce using rule 503 (rep_spec -> record_type_spec .)
    FUNCTION        reduce using rule 503 (rep_spec -> record_type_spec .)
    GENERIC         reduce using rule 503 (rep_spec -> record_type_spec .)
    IDENTIFIER      reduce using rule 503 (rep_spec -> record_type_spec .)
    BEGIN           reduce using rule 503 (rep_spec -> record_type_spec .)
    END             reduce using rule 503 (rep_spec -> record_type_spec .)
    PRIVATE         reduce using rule 503 (rep_spec -> record_type_spec .)
    ENTRY           reduce using rule 503 (rep_spec -> record_type_spec .)


state 69

    (20) decl -> generic_decl .

    PACKAGE         reduce using rule 20 (decl -> generic_decl .)
    TASK            reduce using rule 20 (decl -> generic_decl .)
    PROTECTED       reduce using rule 20 (decl -> generic_decl .)
    error           reduce using rule 20 (decl -> generic_decl .)
    USE             reduce using rule 20 (decl -> generic_decl .)
    PRAGMA          reduce using rule 20 (decl -> generic_decl .)
    TYPE            reduce using rule 20 (decl -> generic_decl .)
    SUBTYPE         reduce using rule 20 (decl -> generic_decl .)
    FOR             reduce using rule 20 (decl -> generic_decl .)
    PROCEDURE       reduce using rule 20 (decl -> generic_decl .)
    FUNCTION        reduce using rule 20 (decl -> generic_decl .)
    GENERIC         reduce using rule 20 (decl -> generic_decl .)
    IDENTIFIER      reduce using rule 20 (decl -> generic_decl .)
    BEGIN           reduce using rule 20 (decl -> generic_decl .)
    END             reduce using rule 20 (decl -> generic_decl .)
    PRIVATE         reduce using rule 20 (decl -> generic_decl .)


state 70

    (502) rep_spec -> attrib_def .

    PACKAGE         reduce using rule 502 (rep_spec -> attrib_def .)
    TASK            reduce using rule 502 (rep_spec -> attrib_def .)
    PROTECTED       reduce using rule 502 (rep_spec -> attrib_def .)
    error           reduce using rule 502 (rep_spec -> attrib_def .)
    USE             reduce using rule 502 (rep_spec -> attrib_def .)
    PRAGMA          reduce using rule 502 (rep_spec -> attrib_def .)
    TYPE            reduce using rule 502 (rep_spec -> attrib_def .)
    SUBTYPE         reduce using rule 502 (rep_spec -> attrib_def .)
    FOR             reduce using rule 502 (rep_spec -> attrib_def .)
    PROCEDURE       reduce using rule 502 (rep_spec -> attrib_def .)
    FUNCTION        reduce using rule 502 (rep_spec -> attrib_def .)
    GENERIC         reduce using rule 502 (rep_spec -> attrib_def .)
    IDENTIFIER      reduce using rule 502 (rep_spec -> attrib_def .)
    BEGIN           reduce using rule 502 (rep_spec -> attrib_def .)
    END             reduce using rule 502 (rep_spec -> attrib_def .)
    PRIVATE         reduce using rule 502 (rep_spec -> attrib_def .)
    ENTRY           reduce using rule 502 (rep_spec -> attrib_def .)


state 71

    (136) decl_part -> decl_item_or_body_s1 .
    (146) decl_item_or_body_s1 -> decl_item_or_body_s1 . decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (333) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (342) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (367) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (384) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (348) use_clause -> . USE name_s ;
    (349) use_clause -> . USE TYPE name_s ;
    (502) rep_spec -> . attrib_def
    (503) rep_spec -> . record_type_spec
    (504) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (332) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (312) subprog_decl -> . subprog_spec ;
    (313) subprog_decl -> . generic_subp_inst ;
    (314) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (335) pkg_decl -> . pkg_spec ;
    (336) pkg_decl -> . generic_pkg_inst ;
    (360) task_decl -> . task_spec ;
    (368) prot_decl -> . prot_spec ;
    (457) exception_decl -> . def_id_s : EXCEPTION ;
    (352) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (353) rename_decl -> . def_id_s : EXCEPTION renames ;
    (354) rename_decl -> . rename_unit
    (469) generic_decl -> . generic_formal_part subprog_spec ;
    (470) generic_decl -> . generic_formal_part pkg_spec ;
    (453) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (454) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (455) body_stub -> . subprog_spec IS SEPARATE ;
    (456) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (505) attrib_def -> . FOR mark USE expression ;
    (506) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (511) address_spec -> . FOR mark USE AT expression ;
    (315) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (316) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (317) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (499) generic_subp_inst -> . subprog_spec IS generic_inst
    (337) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (361) task_spec -> . TASK simple_name task_def
    (362) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (369) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (370) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (355) rename_unit -> . PACKAGE compound_name renames ;
    (356) rename_unit -> . subprog_spec renames ;
    (357) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (358) rename_unit -> . generic_formal_part subprog_spec renames ;
    (471) generic_formal_part -> . GENERIC
    (472) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 136 (decl_part -> decl_item_or_body_s1 .)
    END             reduce using rule 136 (decl_part -> decl_item_or_body_s1 .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 170
    number_decl                    shift and go to state 93

state 72

    (342) pkg_body -> PACKAGE . BODY compound_name IS decl_part body_opt END c_id_opt ;
    (454) body_stub -> PACKAGE . BODY compound_name IS SEPARATE ;
    (337) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> PACKAGE . compound_name IS generic_inst
    (355) rename_unit -> PACKAGE . compound_name renames ;
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    BODY            shift and go to state 171
    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 41
    compound_name                  shift and go to state 172

state 73

    (21) decl -> body_stub .

    PACKAGE         reduce using rule 21 (decl -> body_stub .)
    TASK            reduce using rule 21 (decl -> body_stub .)
    PROTECTED       reduce using rule 21 (decl -> body_stub .)
    error           reduce using rule 21 (decl -> body_stub .)
    USE             reduce using rule 21 (decl -> body_stub .)
    PRAGMA          reduce using rule 21 (decl -> body_stub .)
    TYPE            reduce using rule 21 (decl -> body_stub .)
    SUBTYPE         reduce using rule 21 (decl -> body_stub .)
    FOR             reduce using rule 21 (decl -> body_stub .)
    PROCEDURE       reduce using rule 21 (decl -> body_stub .)
    FUNCTION        reduce using rule 21 (decl -> body_stub .)
    GENERIC         reduce using rule 21 (decl -> body_stub .)
    IDENTIFIER      reduce using rule 21 (decl -> body_stub .)
    BEGIN           reduce using rule 21 (decl -> body_stub .)
    END             reduce using rule 21 (decl -> body_stub .)
    PRIVATE         reduce using rule 21 (decl -> body_stub .)


state 74

    (144) decl_item -> pragma .

    error           reduce using rule 144 (decl_item -> pragma .)
    USE             reduce using rule 144 (decl_item -> pragma .)
    PRAGMA          reduce using rule 144 (decl_item -> pragma .)
    TYPE            reduce using rule 144 (decl_item -> pragma .)
    SUBTYPE         reduce using rule 144 (decl_item -> pragma .)
    TASK            reduce using rule 144 (decl_item -> pragma .)
    PACKAGE         reduce using rule 144 (decl_item -> pragma .)
    PROTECTED       reduce using rule 144 (decl_item -> pragma .)
    FOR             reduce using rule 144 (decl_item -> pragma .)
    PROCEDURE       reduce using rule 144 (decl_item -> pragma .)
    FUNCTION        reduce using rule 144 (decl_item -> pragma .)
    GENERIC         reduce using rule 144 (decl_item -> pragma .)
    IDENTIFIER      reduce using rule 144 (decl_item -> pragma .)
    PRIVATE         reduce using rule 144 (decl_item -> pragma .)
    END             reduce using rule 144 (decl_item -> pragma .)
    BEGIN           reduce using rule 144 (decl_item -> pragma .)


state 75

    (368) prot_decl -> prot_spec . ;

    ;               shift and go to state 173


state 76

    (26) def_id -> IDENTIFIER .

    :               reduce using rule 26 (def_id -> IDENTIFIER .)
    ,               reduce using rule 26 (def_id -> IDENTIFIER .)


state 77

    (150) body -> pkg_body .

    PACKAGE         reduce using rule 150 (body -> pkg_body .)
    TASK            reduce using rule 150 (body -> pkg_body .)
    PROTECTED       reduce using rule 150 (body -> pkg_body .)
    error           reduce using rule 150 (body -> pkg_body .)
    USE             reduce using rule 150 (body -> pkg_body .)
    PRAGMA          reduce using rule 150 (body -> pkg_body .)
    TYPE            reduce using rule 150 (body -> pkg_body .)
    SUBTYPE         reduce using rule 150 (body -> pkg_body .)
    FOR             reduce using rule 150 (body -> pkg_body .)
    PROCEDURE       reduce using rule 150 (body -> pkg_body .)
    FUNCTION        reduce using rule 150 (body -> pkg_body .)
    GENERIC         reduce using rule 150 (body -> pkg_body .)
    IDENTIFIER      reduce using rule 150 (body -> pkg_body .)
    BEGIN           reduce using rule 150 (body -> pkg_body .)
    END             reduce using rule 150 (body -> pkg_body .)


state 78

    (22) decl -> error . ;

    ;               shift and go to state 174


state 79

    (145) decl_item_or_body_s1 -> decl_item_or_body .

    PACKAGE         reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    TASK            reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    PROTECTED       reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    error           reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    USE             reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    PRAGMA          reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    TYPE            reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    SUBTYPE         reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    FOR             reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    PROCEDURE       reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    FUNCTION        reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    GENERIC         reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    IDENTIFIER      reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    BEGIN           reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    END             reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)


state 80

    (36) type_decl -> TYPE . IDENTIFIER discrim_part_opt type_completion ;

    IDENTIFIER      shift and go to state 175


state 81

    (314) subprog_decl -> subprog_spec_is_push ABSTRACT . ;

    ;               shift and go to state 176


state 82

    (143) decl_item -> rep_spec .

    error           reduce using rule 143 (decl_item -> rep_spec .)
    USE             reduce using rule 143 (decl_item -> rep_spec .)
    PRAGMA          reduce using rule 143 (decl_item -> rep_spec .)
    TYPE            reduce using rule 143 (decl_item -> rep_spec .)
    SUBTYPE         reduce using rule 143 (decl_item -> rep_spec .)
    TASK            reduce using rule 143 (decl_item -> rep_spec .)
    PACKAGE         reduce using rule 143 (decl_item -> rep_spec .)
    PROTECTED       reduce using rule 143 (decl_item -> rep_spec .)
    FOR             reduce using rule 143 (decl_item -> rep_spec .)
    PROCEDURE       reduce using rule 143 (decl_item -> rep_spec .)
    FUNCTION        reduce using rule 143 (decl_item -> rep_spec .)
    GENERIC         reduce using rule 143 (decl_item -> rep_spec .)
    IDENTIFIER      reduce using rule 143 (decl_item -> rep_spec .)
    PRIVATE         reduce using rule 143 (decl_item -> rep_spec .)
    END             reduce using rule 143 (decl_item -> rep_spec .)
    BEGIN           reduce using rule 143 (decl_item -> rep_spec .)


state 83

    (151) body -> task_body .

    PACKAGE         reduce using rule 151 (body -> task_body .)
    TASK            reduce using rule 151 (body -> task_body .)
    PROTECTED       reduce using rule 151 (body -> task_body .)
    error           reduce using rule 151 (body -> task_body .)
    USE             reduce using rule 151 (body -> task_body .)
    PRAGMA          reduce using rule 151 (body -> task_body .)
    TYPE            reduce using rule 151 (body -> task_body .)
    SUBTYPE         reduce using rule 151 (body -> task_body .)
    FOR             reduce using rule 151 (body -> task_body .)
    PROCEDURE       reduce using rule 151 (body -> task_body .)
    FUNCTION        reduce using rule 151 (body -> task_body .)
    GENERIC         reduce using rule 151 (body -> task_body .)
    IDENTIFIER      reduce using rule 151 (body -> task_body .)
    BEGIN           reduce using rule 151 (body -> task_body .)
    END             reduce using rule 151 (body -> task_body .)


state 84

    (50) subtype_decl -> SUBTYPE . IDENTIFIER IS subtype_ind ;

    IDENTIFIER      shift and go to state 177


state 85

    (18) decl -> exception_decl .

    PACKAGE         reduce using rule 18 (decl -> exception_decl .)
    TASK            reduce using rule 18 (decl -> exception_decl .)
    PROTECTED       reduce using rule 18 (decl -> exception_decl .)
    error           reduce using rule 18 (decl -> exception_decl .)
    USE             reduce using rule 18 (decl -> exception_decl .)
    PRAGMA          reduce using rule 18 (decl -> exception_decl .)
    TYPE            reduce using rule 18 (decl -> exception_decl .)
    SUBTYPE         reduce using rule 18 (decl -> exception_decl .)
    FOR             reduce using rule 18 (decl -> exception_decl .)
    PROCEDURE       reduce using rule 18 (decl -> exception_decl .)
    FUNCTION        reduce using rule 18 (decl -> exception_decl .)
    GENERIC         reduce using rule 18 (decl -> exception_decl .)
    IDENTIFIER      reduce using rule 18 (decl -> exception_decl .)
    BEGIN           reduce using rule 18 (decl -> exception_decl .)
    END             reduce using rule 18 (decl -> exception_decl .)
    PRIVATE         reduce using rule 18 (decl -> exception_decl .)


state 86

    (333) subprog_body -> subprog_spec_is_push . decl_part block_body END id_opt ;
    (314) subprog_decl -> subprog_spec_is_push . ABSTRACT ;
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (333) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (342) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (367) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (384) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (348) use_clause -> . USE name_s ;
    (349) use_clause -> . USE TYPE name_s ;
    (502) rep_spec -> . attrib_def
    (503) rep_spec -> . record_type_spec
    (504) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (332) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (312) subprog_decl -> . subprog_spec ;
    (313) subprog_decl -> . generic_subp_inst ;
    (314) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (335) pkg_decl -> . pkg_spec ;
    (336) pkg_decl -> . generic_pkg_inst ;
    (360) task_decl -> . task_spec ;
    (368) prot_decl -> . prot_spec ;
    (457) exception_decl -> . def_id_s : EXCEPTION ;
    (352) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (353) rename_decl -> . def_id_s : EXCEPTION renames ;
    (354) rename_decl -> . rename_unit
    (469) generic_decl -> . generic_formal_part subprog_spec ;
    (470) generic_decl -> . generic_formal_part pkg_spec ;
    (453) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (454) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (455) body_stub -> . subprog_spec IS SEPARATE ;
    (456) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (505) attrib_def -> . FOR mark USE expression ;
    (506) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (511) address_spec -> . FOR mark USE AT expression ;
    (315) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (316) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (317) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (499) generic_subp_inst -> . subprog_spec IS generic_inst
    (337) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (361) task_spec -> . TASK simple_name task_def
    (362) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (369) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (370) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (355) rename_unit -> . PACKAGE compound_name renames ;
    (356) rename_unit -> . subprog_spec renames ;
    (357) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (358) rename_unit -> . generic_formal_part subprog_spec renames ;
    (471) generic_formal_part -> . GENERIC
    (472) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    ABSTRACT        shift and go to state 81
    BEGIN           reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 54
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 87

    (332) subprog_spec_is_push -> subprog_spec . IS
    (312) subprog_decl -> subprog_spec . ;
    (455) body_stub -> subprog_spec . IS SEPARATE ;
    (499) generic_subp_inst -> subprog_spec . IS generic_inst
    (356) rename_unit -> subprog_spec . renames ;
    (359) renames -> . RENAMES name

    IS              shift and go to state 178
    ;               shift and go to state 97
    RENAMES         shift and go to state 95

    renames                        shift and go to state 94

state 88

    (23) object_decl -> def_id_s . : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> def_id_s . : CONSTANT ASSIGNMENT expression ;
    (457) exception_decl -> def_id_s . : EXCEPTION ;
    (352) rename_decl -> def_id_s . : object_qualifier_opt subtype_ind renames ;
    (353) rename_decl -> def_id_s . : EXCEPTION renames ;
    (25) def_id_s -> def_id_s . , def_id

    :               shift and go to state 180
    ,               shift and go to state 179


state 89

    (24) def_id_s -> def_id .

    :               reduce using rule 24 (def_id_s -> def_id .)
    ,               reduce using rule 24 (def_id_s -> def_id .)


state 90

    (19) decl -> rename_decl .

    PACKAGE         reduce using rule 19 (decl -> rename_decl .)
    TASK            reduce using rule 19 (decl -> rename_decl .)
    PROTECTED       reduce using rule 19 (decl -> rename_decl .)
    error           reduce using rule 19 (decl -> rename_decl .)
    USE             reduce using rule 19 (decl -> rename_decl .)
    PRAGMA          reduce using rule 19 (decl -> rename_decl .)
    TYPE            reduce using rule 19 (decl -> rename_decl .)
    SUBTYPE         reduce using rule 19 (decl -> rename_decl .)
    FOR             reduce using rule 19 (decl -> rename_decl .)
    PROCEDURE       reduce using rule 19 (decl -> rename_decl .)
    FUNCTION        reduce using rule 19 (decl -> rename_decl .)
    GENERIC         reduce using rule 19 (decl -> rename_decl .)
    IDENTIFIER      reduce using rule 19 (decl -> rename_decl .)
    BEGIN           reduce using rule 19 (decl -> rename_decl .)
    END             reduce using rule 19 (decl -> rename_decl .)
    PRIVATE         reduce using rule 19 (decl -> rename_decl .)


state 91

    (354) rename_decl -> rename_unit .

    PACKAGE         reduce using rule 354 (rename_decl -> rename_unit .)
    TASK            reduce using rule 354 (rename_decl -> rename_unit .)
    PROTECTED       reduce using rule 354 (rename_decl -> rename_unit .)
    error           reduce using rule 354 (rename_decl -> rename_unit .)
    USE             reduce using rule 354 (rename_decl -> rename_unit .)
    PRAGMA          reduce using rule 354 (rename_decl -> rename_unit .)
    TYPE            reduce using rule 354 (rename_decl -> rename_unit .)
    SUBTYPE         reduce using rule 354 (rename_decl -> rename_unit .)
    FOR             reduce using rule 354 (rename_decl -> rename_unit .)
    PROCEDURE       reduce using rule 354 (rename_decl -> rename_unit .)
    FUNCTION        reduce using rule 354 (rename_decl -> rename_unit .)
    GENERIC         reduce using rule 354 (rename_decl -> rename_unit .)
    IDENTIFIER      reduce using rule 354 (rename_decl -> rename_unit .)
    BEGIN           reduce using rule 354 (rename_decl -> rename_unit .)
    END             reduce using rule 354 (rename_decl -> rename_unit .)
    PRIVATE         reduce using rule 354 (rename_decl -> rename_unit .)


state 92

    (152) body -> prot_body .

    PACKAGE         reduce using rule 152 (body -> prot_body .)
    TASK            reduce using rule 152 (body -> prot_body .)
    PROTECTED       reduce using rule 152 (body -> prot_body .)
    error           reduce using rule 152 (body -> prot_body .)
    USE             reduce using rule 152 (body -> prot_body .)
    PRAGMA          reduce using rule 152 (body -> prot_body .)
    TYPE            reduce using rule 152 (body -> prot_body .)
    SUBTYPE         reduce using rule 152 (body -> prot_body .)
    FOR             reduce using rule 152 (body -> prot_body .)
    PROCEDURE       reduce using rule 152 (body -> prot_body .)
    FUNCTION        reduce using rule 152 (body -> prot_body .)
    GENERIC         reduce using rule 152 (body -> prot_body .)
    IDENTIFIER      reduce using rule 152 (body -> prot_body .)
    BEGIN           reduce using rule 152 (body -> prot_body .)
    END             reduce using rule 152 (body -> prot_body .)


state 93

    (11) decl -> number_decl .

    PACKAGE         reduce using rule 11 (decl -> number_decl .)
    TASK            reduce using rule 11 (decl -> number_decl .)
    PROTECTED       reduce using rule 11 (decl -> number_decl .)
    error           reduce using rule 11 (decl -> number_decl .)
    USE             reduce using rule 11 (decl -> number_decl .)
    PRAGMA          reduce using rule 11 (decl -> number_decl .)
    TYPE            reduce using rule 11 (decl -> number_decl .)
    SUBTYPE         reduce using rule 11 (decl -> number_decl .)
    FOR             reduce using rule 11 (decl -> number_decl .)
    PROCEDURE       reduce using rule 11 (decl -> number_decl .)
    FUNCTION        reduce using rule 11 (decl -> number_decl .)
    GENERIC         reduce using rule 11 (decl -> number_decl .)
    IDENTIFIER      reduce using rule 11 (decl -> number_decl .)
    BEGIN           reduce using rule 11 (decl -> number_decl .)
    END             reduce using rule 11 (decl -> number_decl .)
    PRIVATE         reduce using rule 11 (decl -> number_decl .)


state 94

    (356) rename_unit -> subprog_spec renames . ;

    ;               shift and go to state 181


state 95

    (359) renames -> RENAMES . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 182
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 96

    (499) generic_subp_inst -> subprog_spec IS . generic_inst
    (332) subprog_spec_is_push -> subprog_spec IS .
    (501) generic_inst -> . NEW name

    ABSTRACT        reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    PACKAGE         reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    TASK            reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    PROTECTED       reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    error           reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    USE             reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    PRAGMA          reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    TYPE            reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    SUBTYPE         reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    FOR             reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    PROCEDURE       reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    FUNCTION        reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    GENERIC         reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    IDENTIFIER      reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    BEGIN           reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    NEW             shift and go to state 183

    generic_inst                   shift and go to state 184

state 97

    (312) subprog_decl -> subprog_spec ; .

    PACKAGE         reduce using rule 312 (subprog_decl -> subprog_spec ; .)
    TASK            reduce using rule 312 (subprog_decl -> subprog_spec ; .)
    PROTECTED       reduce using rule 312 (subprog_decl -> subprog_spec ; .)
    error           reduce using rule 312 (subprog_decl -> subprog_spec ; .)
    USE             reduce using rule 312 (subprog_decl -> subprog_spec ; .)
    PRAGMA          reduce using rule 312 (subprog_decl -> subprog_spec ; .)
    TYPE            reduce using rule 312 (subprog_decl -> subprog_spec ; .)
    SUBTYPE         reduce using rule 312 (subprog_decl -> subprog_spec ; .)
    FOR             reduce using rule 312 (subprog_decl -> subprog_spec ; .)
    PROCEDURE       reduce using rule 312 (subprog_decl -> subprog_spec ; .)
    FUNCTION        reduce using rule 312 (subprog_decl -> subprog_spec ; .)
    GENERIC         reduce using rule 312 (subprog_decl -> subprog_spec ; .)
    IDENTIFIER      reduce using rule 312 (subprog_decl -> subprog_spec ; .)
    BEGIN           reduce using rule 312 (subprog_decl -> subprog_spec ; .)
    PRIVATE         reduce using rule 312 (subprog_decl -> subprog_spec ; .)
    WITH            reduce using rule 312 (subprog_decl -> subprog_spec ; .)
    SEPARATE        reduce using rule 312 (subprog_decl -> subprog_spec ; .)
    $end            reduce using rule 312 (subprog_decl -> subprog_spec ; .)
    END             reduce using rule 312 (subprog_decl -> subprog_spec ; .)


state 98

    (342) pkg_body -> PACKAGE BODY . compound_name IS decl_part body_opt END c_id_opt ;
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 185
    simple_name                    shift and go to state 41

state 99

    (355) rename_unit -> PACKAGE compound_name . renames ;
    (337) pkg_spec -> PACKAGE compound_name . IS decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> PACKAGE compound_name . IS generic_inst
    (163) compound_name -> compound_name . . simple_name
    (359) renames -> . RENAMES name

    IS              shift and go to state 187
    .               shift and go to state 119
    RENAMES         shift and go to state 95

    renames                        shift and go to state 186

state 100

    (313) subprog_decl -> generic_subp_inst ; .

    PACKAGE         reduce using rule 313 (subprog_decl -> generic_subp_inst ; .)
    TASK            reduce using rule 313 (subprog_decl -> generic_subp_inst ; .)
    PROTECTED       reduce using rule 313 (subprog_decl -> generic_subp_inst ; .)
    error           reduce using rule 313 (subprog_decl -> generic_subp_inst ; .)
    USE             reduce using rule 313 (subprog_decl -> generic_subp_inst ; .)
    PRAGMA          reduce using rule 313 (subprog_decl -> generic_subp_inst ; .)
    TYPE            reduce using rule 313 (subprog_decl -> generic_subp_inst ; .)
    SUBTYPE         reduce using rule 313 (subprog_decl -> generic_subp_inst ; .)
    FOR             reduce using rule 313 (subprog_decl -> generic_subp_inst ; .)
    PROCEDURE       reduce using rule 313 (subprog_decl -> generic_subp_inst ; .)
    FUNCTION        reduce using rule 313 (subprog_decl -> generic_subp_inst ; .)
    GENERIC         reduce using rule 313 (subprog_decl -> generic_subp_inst ; .)
    IDENTIFIER      reduce using rule 313 (subprog_decl -> generic_subp_inst ; .)
    BEGIN           reduce using rule 313 (subprog_decl -> generic_subp_inst ; .)
    PRIVATE         reduce using rule 313 (subprog_decl -> generic_subp_inst ; .)
    WITH            reduce using rule 313 (subprog_decl -> generic_subp_inst ; .)
    SEPARATE        reduce using rule 313 (subprog_decl -> generic_subp_inst ; .)
    $end            reduce using rule 313 (subprog_decl -> generic_subp_inst ; .)
    END             reduce using rule 313 (subprog_decl -> generic_subp_inst ; .)


state 101

    (315) subprog_spec -> PROCEDURE compound_name . formal_part_opt
    (163) compound_name -> compound_name . . simple_name
    (320) formal_part_opt -> .
    (321) formal_part_opt -> . formal_part
    (322) formal_part -> . ( param_s )

    .               shift and go to state 119
    ;               reduce using rule 320 (formal_part_opt -> .)
    IS              reduce using rule 320 (formal_part_opt -> .)
    RENAMES         reduce using rule 320 (formal_part_opt -> .)
    (               shift and go to state 189

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 190

state 102

    (475) generic_formal -> WITH . PROCEDURE simple_name formal_part_opt subp_default ;
    (476) generic_formal -> WITH . FUNCTION designator formal_part_opt RETURN name subp_default ;
    (477) generic_formal -> WITH . PACKAGE simple_name IS NEW name ( LESSMORE ) ;
    (478) generic_formal -> WITH . PACKAGE simple_name IS NEW name ;

    PROCEDURE       shift and go to state 193
    FUNCTION        shift and go to state 191
    PACKAGE         shift and go to state 192


state 103

    (473) generic_formal -> param . ;

    ;               shift and go to state 194


state 104

    (469) generic_decl -> generic_formal_part subprog_spec . ;
    (358) rename_unit -> generic_formal_part subprog_spec . renames ;
    (359) renames -> . RENAMES name

    ;               shift and go to state 196
    RENAMES         shift and go to state 95

    renames                        shift and go to state 195

state 105

    (325) param -> def_id_s . : mode mark init_opt
    (25) def_id_s -> def_id_s . , def_id

    :               shift and go to state 197
    ,               shift and go to state 179


state 106

    (357) rename_unit -> generic_formal_part PACKAGE . compound_name renames ;
    (337) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 41
    compound_name                  shift and go to state 198

state 107

    (472) generic_formal_part -> generic_formal_part generic_formal .

    PACKAGE         reduce using rule 472 (generic_formal_part -> generic_formal_part generic_formal .)
    PROCEDURE       reduce using rule 472 (generic_formal_part -> generic_formal_part generic_formal .)
    FUNCTION        reduce using rule 472 (generic_formal_part -> generic_formal_part generic_formal .)
    TYPE            reduce using rule 472 (generic_formal_part -> generic_formal_part generic_formal .)
    WITH            reduce using rule 472 (generic_formal_part -> generic_formal_part generic_formal .)
    error           reduce using rule 472 (generic_formal_part -> generic_formal_part generic_formal .)
    USE             reduce using rule 472 (generic_formal_part -> generic_formal_part generic_formal .)
    IDENTIFIER      reduce using rule 472 (generic_formal_part -> generic_formal_part generic_formal .)


state 108

    (479) generic_formal -> use_clause .

    PACKAGE         reduce using rule 479 (generic_formal -> use_clause .)
    PROCEDURE       reduce using rule 479 (generic_formal -> use_clause .)
    FUNCTION        reduce using rule 479 (generic_formal -> use_clause .)
    TYPE            reduce using rule 479 (generic_formal -> use_clause .)
    WITH            reduce using rule 479 (generic_formal -> use_clause .)
    error           reduce using rule 479 (generic_formal -> use_clause .)
    USE             reduce using rule 479 (generic_formal -> use_clause .)
    IDENTIFIER      reduce using rule 479 (generic_formal -> use_clause .)


state 109

    (326) param -> error .

    )               reduce using rule 326 (param -> error .)
    ;               reduce using rule 326 (param -> error .)


state 110

    (470) generic_decl -> generic_formal_part pkg_spec . ;

    ;               shift and go to state 199


state 111

    (474) generic_formal -> TYPE . simple_name generic_discrim_part_opt IS generic_type_def ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 200

state 112

    (336) pkg_decl -> generic_pkg_inst ; .

    error           reduce using rule 336 (pkg_decl -> generic_pkg_inst ; .)
    USE             reduce using rule 336 (pkg_decl -> generic_pkg_inst ; .)
    PRAGMA          reduce using rule 336 (pkg_decl -> generic_pkg_inst ; .)
    TYPE            reduce using rule 336 (pkg_decl -> generic_pkg_inst ; .)
    SUBTYPE         reduce using rule 336 (pkg_decl -> generic_pkg_inst ; .)
    TASK            reduce using rule 336 (pkg_decl -> generic_pkg_inst ; .)
    PACKAGE         reduce using rule 336 (pkg_decl -> generic_pkg_inst ; .)
    PROTECTED       reduce using rule 336 (pkg_decl -> generic_pkg_inst ; .)
    FOR             reduce using rule 336 (pkg_decl -> generic_pkg_inst ; .)
    PROCEDURE       reduce using rule 336 (pkg_decl -> generic_pkg_inst ; .)
    FUNCTION        reduce using rule 336 (pkg_decl -> generic_pkg_inst ; .)
    GENERIC         reduce using rule 336 (pkg_decl -> generic_pkg_inst ; .)
    IDENTIFIER      reduce using rule 336 (pkg_decl -> generic_pkg_inst ; .)
    PRIVATE         reduce using rule 336 (pkg_decl -> generic_pkg_inst ; .)
    END             reduce using rule 336 (pkg_decl -> generic_pkg_inst ; .)
    BEGIN           reduce using rule 336 (pkg_decl -> generic_pkg_inst ; .)
    WITH            reduce using rule 336 (pkg_decl -> generic_pkg_inst ; .)
    SEPARATE        reduce using rule 336 (pkg_decl -> generic_pkg_inst ; .)
    $end            reduce using rule 336 (pkg_decl -> generic_pkg_inst ; .)


state 113

    (316) subprog_spec -> FUNCTION designator . formal_part_opt RETURN name
    (317) subprog_spec -> FUNCTION designator .
    (320) formal_part_opt -> .
    (321) formal_part_opt -> . formal_part
    (322) formal_part -> . ( param_s )

    ;               reduce using rule 317 (subprog_spec -> FUNCTION designator .)
    IS              reduce using rule 317 (subprog_spec -> FUNCTION designator .)
    RENAMES         reduce using rule 317 (subprog_spec -> FUNCTION designator .)
    RETURN          reduce using rule 320 (formal_part_opt -> .)
    (               shift and go to state 189

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 201

state 114

    (318) designator -> compound_name .
    (163) compound_name -> compound_name . . simple_name

    (               reduce using rule 318 (designator -> compound_name .)
    RETURN          reduce using rule 318 (designator -> compound_name .)
    ;               reduce using rule 318 (designator -> compound_name .)
    IS              reduce using rule 318 (designator -> compound_name .)
    RENAMES         reduce using rule 318 (designator -> compound_name .)
    .               shift and go to state 119


state 115

    (319) designator -> STRING .

    (               reduce using rule 319 (designator -> STRING .)
    RETURN          reduce using rule 319 (designator -> STRING .)
    ;               reduce using rule 319 (designator -> STRING .)
    IS              reduce using rule 319 (designator -> STRING .)
    RENAMES         reduce using rule 319 (designator -> STRING .)


state 116

    (335) pkg_decl -> pkg_spec ; .

    error           reduce using rule 335 (pkg_decl -> pkg_spec ; .)
    USE             reduce using rule 335 (pkg_decl -> pkg_spec ; .)
    PRAGMA          reduce using rule 335 (pkg_decl -> pkg_spec ; .)
    TYPE            reduce using rule 335 (pkg_decl -> pkg_spec ; .)
    SUBTYPE         reduce using rule 335 (pkg_decl -> pkg_spec ; .)
    TASK            reduce using rule 335 (pkg_decl -> pkg_spec ; .)
    PACKAGE         reduce using rule 335 (pkg_decl -> pkg_spec ; .)
    PROTECTED       reduce using rule 335 (pkg_decl -> pkg_spec ; .)
    FOR             reduce using rule 335 (pkg_decl -> pkg_spec ; .)
    PROCEDURE       reduce using rule 335 (pkg_decl -> pkg_spec ; .)
    FUNCTION        reduce using rule 335 (pkg_decl -> pkg_spec ; .)
    GENERIC         reduce using rule 335 (pkg_decl -> pkg_spec ; .)
    IDENTIFIER      reduce using rule 335 (pkg_decl -> pkg_spec ; .)
    PRIVATE         reduce using rule 335 (pkg_decl -> pkg_spec ; .)
    END             reduce using rule 335 (pkg_decl -> pkg_spec ; .)
    BEGIN           reduce using rule 335 (pkg_decl -> pkg_spec ; .)
    WITH            reduce using rule 335 (pkg_decl -> pkg_spec ; .)
    SEPARATE        reduce using rule 335 (pkg_decl -> pkg_spec ; .)
    $end            reduce using rule 335 (pkg_decl -> pkg_spec ; .)


state 117

    (438) with_clause -> WITH c_name_list ; .

    USE             reduce using rule 438 (with_clause -> WITH c_name_list ; .)
    PRIVATE         reduce using rule 438 (with_clause -> WITH c_name_list ; .)
    WITH            reduce using rule 438 (with_clause -> WITH c_name_list ; .)
    PRAGMA          reduce using rule 438 (with_clause -> WITH c_name_list ; .)
    PACKAGE         reduce using rule 438 (with_clause -> WITH c_name_list ; .)
    SEPARATE        reduce using rule 438 (with_clause -> WITH c_name_list ; .)
    PROCEDURE       reduce using rule 438 (with_clause -> WITH c_name_list ; .)
    FUNCTION        reduce using rule 438 (with_clause -> WITH c_name_list ; .)
    GENERIC         reduce using rule 438 (with_clause -> WITH c_name_list ; .)


state 118

    (165) c_name_list -> c_name_list , . compound_name
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 202
    simple_name                    shift and go to state 41

state 119

    (163) compound_name -> compound_name . . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 203

state 120

    (155) name -> selected_comp .

    TICK            reduce using rule 155 (name -> selected_comp .)
    (               reduce using rule 155 (name -> selected_comp .)
    .               reduce using rule 155 (name -> selected_comp .)
    STARSTAR        reduce using rule 155 (name -> selected_comp .)
    *               reduce using rule 155 (name -> selected_comp .)
    /               reduce using rule 155 (name -> selected_comp .)
    MOD             reduce using rule 155 (name -> selected_comp .)
    REM             reduce using rule 155 (name -> selected_comp .)
    =               reduce using rule 155 (name -> selected_comp .)
    NOTEQUAL        reduce using rule 155 (name -> selected_comp .)
    <               reduce using rule 155 (name -> selected_comp .)
    LESSEQ          reduce using rule 155 (name -> selected_comp .)
    >               reduce using rule 155 (name -> selected_comp .)
    GREATEREQ       reduce using rule 155 (name -> selected_comp .)
    IN              reduce using rule 155 (name -> selected_comp .)
    NOT             reduce using rule 155 (name -> selected_comp .)
    +               reduce using rule 155 (name -> selected_comp .)
    -               reduce using rule 155 (name -> selected_comp .)
    &               reduce using rule 155 (name -> selected_comp .)
    IS              reduce using rule 155 (name -> selected_comp .)
    AND             reduce using rule 155 (name -> selected_comp .)
    OR              reduce using rule 155 (name -> selected_comp .)
    RANGE           reduce using rule 155 (name -> selected_comp .)
    DIGITS          reduce using rule 155 (name -> selected_comp .)
    RENAMES         reduce using rule 155 (name -> selected_comp .)
    ASSIGNMENT      reduce using rule 155 (name -> selected_comp .)
    ;               reduce using rule 155 (name -> selected_comp .)
    LOOP            reduce using rule 155 (name -> selected_comp .)
    WITH            reduce using rule 155 (name -> selected_comp .)
    DOTDOT          reduce using rule 155 (name -> selected_comp .)
    )               reduce using rule 155 (name -> selected_comp .)
    ,               reduce using rule 155 (name -> selected_comp .)
    ARROW           reduce using rule 155 (name -> selected_comp .)
    |               reduce using rule 155 (name -> selected_comp .)
    THEN            reduce using rule 155 (name -> selected_comp .)
    WHEN            reduce using rule 155 (name -> selected_comp .)


state 121

    (156) name -> attribute .

    TICK            reduce using rule 156 (name -> attribute .)
    (               reduce using rule 156 (name -> attribute .)
    .               reduce using rule 156 (name -> attribute .)
    STARSTAR        reduce using rule 156 (name -> attribute .)
    *               reduce using rule 156 (name -> attribute .)
    /               reduce using rule 156 (name -> attribute .)
    MOD             reduce using rule 156 (name -> attribute .)
    REM             reduce using rule 156 (name -> attribute .)
    =               reduce using rule 156 (name -> attribute .)
    NOTEQUAL        reduce using rule 156 (name -> attribute .)
    <               reduce using rule 156 (name -> attribute .)
    LESSEQ          reduce using rule 156 (name -> attribute .)
    >               reduce using rule 156 (name -> attribute .)
    GREATEREQ       reduce using rule 156 (name -> attribute .)
    IN              reduce using rule 156 (name -> attribute .)
    NOT             reduce using rule 156 (name -> attribute .)
    +               reduce using rule 156 (name -> attribute .)
    -               reduce using rule 156 (name -> attribute .)
    &               reduce using rule 156 (name -> attribute .)
    IS              reduce using rule 156 (name -> attribute .)
    AND             reduce using rule 156 (name -> attribute .)
    OR              reduce using rule 156 (name -> attribute .)
    RANGE           reduce using rule 156 (name -> attribute .)
    DIGITS          reduce using rule 156 (name -> attribute .)
    RENAMES         reduce using rule 156 (name -> attribute .)
    ASSIGNMENT      reduce using rule 156 (name -> attribute .)
    ;               reduce using rule 156 (name -> attribute .)
    LOOP            reduce using rule 156 (name -> attribute .)
    WITH            reduce using rule 156 (name -> attribute .)
    DOTDOT          reduce using rule 156 (name -> attribute .)
    )               reduce using rule 156 (name -> attribute .)
    ,               reduce using rule 156 (name -> attribute .)
    ARROW           reduce using rule 156 (name -> attribute .)
    |               reduce using rule 156 (name -> attribute .)
    THEN            reduce using rule 156 (name -> attribute .)
    WHEN            reduce using rule 156 (name -> attribute .)


state 122

    (231) factor -> primary .
    (233) factor -> primary . STARSTAR primary

    *               reduce using rule 231 (factor -> primary .)
    /               reduce using rule 231 (factor -> primary .)
    MOD             reduce using rule 231 (factor -> primary .)
    REM             reduce using rule 231 (factor -> primary .)
    =               reduce using rule 231 (factor -> primary .)
    NOTEQUAL        reduce using rule 231 (factor -> primary .)
    <               reduce using rule 231 (factor -> primary .)
    LESSEQ          reduce using rule 231 (factor -> primary .)
    >               reduce using rule 231 (factor -> primary .)
    GREATEREQ       reduce using rule 231 (factor -> primary .)
    IN              reduce using rule 231 (factor -> primary .)
    NOT             reduce using rule 231 (factor -> primary .)
    +               reduce using rule 231 (factor -> primary .)
    -               reduce using rule 231 (factor -> primary .)
    &               reduce using rule 231 (factor -> primary .)
    AND             reduce using rule 231 (factor -> primary .)
    OR              reduce using rule 231 (factor -> primary .)
    )               reduce using rule 231 (factor -> primary .)
    ,               reduce using rule 231 (factor -> primary .)
    DOTDOT          reduce using rule 231 (factor -> primary .)
    ARROW           reduce using rule 231 (factor -> primary .)
    |               reduce using rule 231 (factor -> primary .)
    RANGE           reduce using rule 231 (factor -> primary .)
    ;               reduce using rule 231 (factor -> primary .)
    WITH            reduce using rule 231 (factor -> primary .)
    IS              reduce using rule 231 (factor -> primary .)
    THEN            reduce using rule 231 (factor -> primary .)
    LOOP            reduce using rule 231 (factor -> primary .)
    DIGITS          reduce using rule 231 (factor -> primary .)
    RENAMES         reduce using rule 231 (factor -> primary .)
    ASSIGNMENT      reduce using rule 231 (factor -> primary .)
    STARSTAR        shift and go to state 204


state 123

    (4) pragma_arg_s -> pragma_arg .

    )               reduce using rule 4 (pragma_arg_s -> pragma_arg .)
    ,               reduce using rule 4 (pragma_arg_s -> pragma_arg .)


state 124

    (217) simple_expression -> unary . term
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 205
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149

state 125

    (198) expression -> relation .

    AND             reduce using rule 198 (expression -> relation .)
    OR              reduce using rule 198 (expression -> relation .)
    )               reduce using rule 198 (expression -> relation .)
    ,               reduce using rule 198 (expression -> relation .)
    ARROW           reduce using rule 198 (expression -> relation .)
    |               reduce using rule 198 (expression -> relation .)
    ;               reduce using rule 198 (expression -> relation .)
    IS              reduce using rule 198 (expression -> relation .)
    RANGE           reduce using rule 198 (expression -> relation .)
    THEN            reduce using rule 198 (expression -> relation .)
    RENAMES         reduce using rule 198 (expression -> relation .)
    ASSIGNMENT      reduce using rule 198 (expression -> relation .)
    WITH            reduce using rule 198 (expression -> relation .)
    LOOP            reduce using rule 198 (expression -> relation .)
    DIGITS          reduce using rule 198 (expression -> relation .)


state 126

    (187) literal -> BASE_FLOAT .

    STARSTAR        reduce using rule 187 (literal -> BASE_FLOAT .)
    *               reduce using rule 187 (literal -> BASE_FLOAT .)
    /               reduce using rule 187 (literal -> BASE_FLOAT .)
    MOD             reduce using rule 187 (literal -> BASE_FLOAT .)
    REM             reduce using rule 187 (literal -> BASE_FLOAT .)
    DOTDOT          reduce using rule 187 (literal -> BASE_FLOAT .)
    +               reduce using rule 187 (literal -> BASE_FLOAT .)
    -               reduce using rule 187 (literal -> BASE_FLOAT .)
    &               reduce using rule 187 (literal -> BASE_FLOAT .)
    =               reduce using rule 187 (literal -> BASE_FLOAT .)
    NOTEQUAL        reduce using rule 187 (literal -> BASE_FLOAT .)
    <               reduce using rule 187 (literal -> BASE_FLOAT .)
    LESSEQ          reduce using rule 187 (literal -> BASE_FLOAT .)
    >               reduce using rule 187 (literal -> BASE_FLOAT .)
    GREATEREQ       reduce using rule 187 (literal -> BASE_FLOAT .)
    IN              reduce using rule 187 (literal -> BASE_FLOAT .)
    NOT             reduce using rule 187 (literal -> BASE_FLOAT .)
    AND             reduce using rule 187 (literal -> BASE_FLOAT .)
    OR              reduce using rule 187 (literal -> BASE_FLOAT .)
    )               reduce using rule 187 (literal -> BASE_FLOAT .)
    ,               reduce using rule 187 (literal -> BASE_FLOAT .)
    RANGE           reduce using rule 187 (literal -> BASE_FLOAT .)
    ;               reduce using rule 187 (literal -> BASE_FLOAT .)
    IS              reduce using rule 187 (literal -> BASE_FLOAT .)
    ARROW           reduce using rule 187 (literal -> BASE_FLOAT .)
    |               reduce using rule 187 (literal -> BASE_FLOAT .)
    WITH            reduce using rule 187 (literal -> BASE_FLOAT .)
    THEN            reduce using rule 187 (literal -> BASE_FLOAT .)
    LOOP            reduce using rule 187 (literal -> BASE_FLOAT .)
    DIGITS          reduce using rule 187 (literal -> BASE_FLOAT .)
    RENAMES         reduce using rule 187 (literal -> BASE_FLOAT .)
    ASSIGNMENT      reduce using rule 187 (literal -> BASE_FLOAT .)


state 127

    (242) allocator -> NEW . name
    (243) allocator -> NEW . qualified
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 206
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    qualified                      shift and go to state 207
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 128

    (205) relation -> simple_expression .
    (206) relation -> simple_expression . relational simple_expression
    (207) relation -> simple_expression . membership range
    (208) relation -> simple_expression . membership name
    (219) simple_expression -> simple_expression . adding term
    (209) relational -> . =
    (210) relational -> . NOTEQUAL
    (211) relational -> . <
    (212) relational -> . LESSEQ
    (213) relational -> . >
    (214) relational -> . GREATEREQ
    (215) membership -> . IN
    (216) membership -> . NOT IN
    (222) adding -> . +
    (223) adding -> . -
    (224) adding -> . &

    AND             reduce using rule 205 (relation -> simple_expression .)
    OR              reduce using rule 205 (relation -> simple_expression .)
    )               reduce using rule 205 (relation -> simple_expression .)
    ,               reduce using rule 205 (relation -> simple_expression .)
    WITH            reduce using rule 205 (relation -> simple_expression .)
    ARROW           reduce using rule 205 (relation -> simple_expression .)
    |               reduce using rule 205 (relation -> simple_expression .)
    ;               reduce using rule 205 (relation -> simple_expression .)
    IS              reduce using rule 205 (relation -> simple_expression .)
    THEN            reduce using rule 205 (relation -> simple_expression .)
    LOOP            reduce using rule 205 (relation -> simple_expression .)
    RANGE           reduce using rule 205 (relation -> simple_expression .)
    DIGITS          reduce using rule 205 (relation -> simple_expression .)
    RENAMES         reduce using rule 205 (relation -> simple_expression .)
    ASSIGNMENT      reduce using rule 205 (relation -> simple_expression .)
    =               shift and go to state 219
    NOTEQUAL        shift and go to state 209
    <               shift and go to state 220
    LESSEQ          shift and go to state 215
    >               shift and go to state 221
    GREATEREQ       shift and go to state 214
    IN              shift and go to state 216
    NOT             shift and go to state 217
    +               shift and go to state 210
    -               shift and go to state 212
    &               shift and go to state 211

    adding                         shift and go to state 208
    membership                     shift and go to state 213
    relational                     shift and go to state 218

state 129

    (154) name -> indexed_comp .

    TICK            reduce using rule 154 (name -> indexed_comp .)
    (               reduce using rule 154 (name -> indexed_comp .)
    .               reduce using rule 154 (name -> indexed_comp .)
    STARSTAR        reduce using rule 154 (name -> indexed_comp .)
    *               reduce using rule 154 (name -> indexed_comp .)
    /               reduce using rule 154 (name -> indexed_comp .)
    MOD             reduce using rule 154 (name -> indexed_comp .)
    REM             reduce using rule 154 (name -> indexed_comp .)
    =               reduce using rule 154 (name -> indexed_comp .)
    NOTEQUAL        reduce using rule 154 (name -> indexed_comp .)
    <               reduce using rule 154 (name -> indexed_comp .)
    LESSEQ          reduce using rule 154 (name -> indexed_comp .)
    >               reduce using rule 154 (name -> indexed_comp .)
    GREATEREQ       reduce using rule 154 (name -> indexed_comp .)
    IN              reduce using rule 154 (name -> indexed_comp .)
    NOT             reduce using rule 154 (name -> indexed_comp .)
    +               reduce using rule 154 (name -> indexed_comp .)
    -               reduce using rule 154 (name -> indexed_comp .)
    &               reduce using rule 154 (name -> indexed_comp .)
    IS              reduce using rule 154 (name -> indexed_comp .)
    AND             reduce using rule 154 (name -> indexed_comp .)
    OR              reduce using rule 154 (name -> indexed_comp .)
    RANGE           reduce using rule 154 (name -> indexed_comp .)
    DIGITS          reduce using rule 154 (name -> indexed_comp .)
    RENAMES         reduce using rule 154 (name -> indexed_comp .)
    ASSIGNMENT      reduce using rule 154 (name -> indexed_comp .)
    ;               reduce using rule 154 (name -> indexed_comp .)
    LOOP            reduce using rule 154 (name -> indexed_comp .)
    WITH            reduce using rule 154 (name -> indexed_comp .)
    DOTDOT          reduce using rule 154 (name -> indexed_comp .)
    )               reduce using rule 154 (name -> indexed_comp .)
    ,               reduce using rule 154 (name -> indexed_comp .)
    ARROW           reduce using rule 154 (name -> indexed_comp .)
    |               reduce using rule 154 (name -> indexed_comp .)
    THEN            reduce using rule 154 (name -> indexed_comp .)
    WHEN            reduce using rule 154 (name -> indexed_comp .)


state 130

    (236) primary -> allocator .

    STARSTAR        reduce using rule 236 (primary -> allocator .)
    *               reduce using rule 236 (primary -> allocator .)
    /               reduce using rule 236 (primary -> allocator .)
    MOD             reduce using rule 236 (primary -> allocator .)
    REM             reduce using rule 236 (primary -> allocator .)
    =               reduce using rule 236 (primary -> allocator .)
    NOTEQUAL        reduce using rule 236 (primary -> allocator .)
    <               reduce using rule 236 (primary -> allocator .)
    LESSEQ          reduce using rule 236 (primary -> allocator .)
    >               reduce using rule 236 (primary -> allocator .)
    GREATEREQ       reduce using rule 236 (primary -> allocator .)
    IN              reduce using rule 236 (primary -> allocator .)
    NOT             reduce using rule 236 (primary -> allocator .)
    +               reduce using rule 236 (primary -> allocator .)
    -               reduce using rule 236 (primary -> allocator .)
    &               reduce using rule 236 (primary -> allocator .)
    AND             reduce using rule 236 (primary -> allocator .)
    OR              reduce using rule 236 (primary -> allocator .)
    )               reduce using rule 236 (primary -> allocator .)
    ,               reduce using rule 236 (primary -> allocator .)
    WITH            reduce using rule 236 (primary -> allocator .)
    ARROW           reduce using rule 236 (primary -> allocator .)
    |               reduce using rule 236 (primary -> allocator .)
    ;               reduce using rule 236 (primary -> allocator .)
    IS              reduce using rule 236 (primary -> allocator .)
    THEN            reduce using rule 236 (primary -> allocator .)
    LOOP            reduce using rule 236 (primary -> allocator .)
    RANGE           reduce using rule 236 (primary -> allocator .)
    DIGITS          reduce using rule 236 (primary -> allocator .)
    RENAMES         reduce using rule 236 (primary -> allocator .)
    ASSIGNMENT      reduce using rule 236 (primary -> allocator .)
    DOTDOT          reduce using rule 236 (primary -> allocator .)


state 131

    (7) pragma_arg -> simple_name . ARROW expression
    (153) name -> simple_name .

    ARROW           shift and go to state 222
    TICK            reduce using rule 153 (name -> simple_name .)
    (               reduce using rule 153 (name -> simple_name .)
    .               reduce using rule 153 (name -> simple_name .)
    STARSTAR        reduce using rule 153 (name -> simple_name .)
    *               reduce using rule 153 (name -> simple_name .)
    /               reduce using rule 153 (name -> simple_name .)
    MOD             reduce using rule 153 (name -> simple_name .)
    REM             reduce using rule 153 (name -> simple_name .)
    =               reduce using rule 153 (name -> simple_name .)
    NOTEQUAL        reduce using rule 153 (name -> simple_name .)
    <               reduce using rule 153 (name -> simple_name .)
    LESSEQ          reduce using rule 153 (name -> simple_name .)
    >               reduce using rule 153 (name -> simple_name .)
    GREATEREQ       reduce using rule 153 (name -> simple_name .)
    IN              reduce using rule 153 (name -> simple_name .)
    NOT             reduce using rule 153 (name -> simple_name .)
    +               reduce using rule 153 (name -> simple_name .)
    -               reduce using rule 153 (name -> simple_name .)
    &               reduce using rule 153 (name -> simple_name .)
    AND             reduce using rule 153 (name -> simple_name .)
    OR              reduce using rule 153 (name -> simple_name .)
    )               reduce using rule 153 (name -> simple_name .)
    ,               reduce using rule 153 (name -> simple_name .)


state 132

    (240) parenthesized_primary -> ( . expression )
    (190) aggregate -> ( . comp_assoc )
    (191) aggregate -> ( . value_s_2 )
    (192) aggregate -> ( . expression WITH value_s )
    (193) aggregate -> ( . expression WITH NuLL RECORD )
    (194) aggregate -> ( . NuLL RECORD )
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (197) comp_assoc -> . choice_s ARROW expression
    (195) value_s_2 -> . value , value
    (196) value_s_2 -> . value_s_2 , value
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (171) value -> . expression
    (172) value -> . comp_assoc
    (173) value -> . discrete_with_range
    (174) value -> . error
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    NuLL            shift and go to state 234
    error           shift and go to state 233
    OTHERS          shift and go to state 223
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 224
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    comp_assoc                     shift and go to state 226
    choice_s                       shift and go to state 225
    choice                         shift and go to state 227
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    value_s_2                      shift and go to state 228
    aggregate                      shift and go to state 143
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 146
    name                           shift and go to state 230
    operator_symbol                shift and go to state 149
    value                          shift and go to state 231
    range                          shift and go to state 232
    expression                     shift and go to state 235

state 133

    (220) unary -> + .

    NOT             reduce using rule 220 (unary -> + .)
    INTEGER         reduce using rule 220 (unary -> + .)
    BASE_INTEGER    reduce using rule 220 (unary -> + .)
    FLOAT           reduce using rule 220 (unary -> + .)
    BASE_FLOAT      reduce using rule 220 (unary -> + .)
    NuLL            reduce using rule 220 (unary -> + .)
    NEW             reduce using rule 220 (unary -> + .)
    (               reduce using rule 220 (unary -> + .)
    CHAR            reduce using rule 220 (unary -> + .)
    IDENTIFIER      reduce using rule 220 (unary -> + .)
    STRING          reduce using rule 220 (unary -> + .)


state 134

    (221) unary -> - .

    NOT             reduce using rule 221 (unary -> - .)
    INTEGER         reduce using rule 221 (unary -> - .)
    BASE_INTEGER    reduce using rule 221 (unary -> - .)
    FLOAT           reduce using rule 221 (unary -> - .)
    BASE_FLOAT      reduce using rule 221 (unary -> - .)
    NuLL            reduce using rule 221 (unary -> - .)
    NEW             reduce using rule 221 (unary -> - .)
    (               reduce using rule 221 (unary -> - .)
    CHAR            reduce using rule 221 (unary -> - .)
    IDENTIFIER      reduce using rule 221 (unary -> - .)
    STRING          reduce using rule 221 (unary -> - .)


state 135

    (234) primary -> literal .

    STARSTAR        reduce using rule 234 (primary -> literal .)
    *               reduce using rule 234 (primary -> literal .)
    /               reduce using rule 234 (primary -> literal .)
    MOD             reduce using rule 234 (primary -> literal .)
    REM             reduce using rule 234 (primary -> literal .)
    =               reduce using rule 234 (primary -> literal .)
    NOTEQUAL        reduce using rule 234 (primary -> literal .)
    <               reduce using rule 234 (primary -> literal .)
    LESSEQ          reduce using rule 234 (primary -> literal .)
    >               reduce using rule 234 (primary -> literal .)
    GREATEREQ       reduce using rule 234 (primary -> literal .)
    IN              reduce using rule 234 (primary -> literal .)
    NOT             reduce using rule 234 (primary -> literal .)
    +               reduce using rule 234 (primary -> literal .)
    -               reduce using rule 234 (primary -> literal .)
    &               reduce using rule 234 (primary -> literal .)
    AND             reduce using rule 234 (primary -> literal .)
    OR              reduce using rule 234 (primary -> literal .)
    )               reduce using rule 234 (primary -> literal .)
    ,               reduce using rule 234 (primary -> literal .)
    WITH            reduce using rule 234 (primary -> literal .)
    ARROW           reduce using rule 234 (primary -> literal .)
    |               reduce using rule 234 (primary -> literal .)
    ;               reduce using rule 234 (primary -> literal .)
    IS              reduce using rule 234 (primary -> literal .)
    THEN            reduce using rule 234 (primary -> literal .)
    LOOP            reduce using rule 234 (primary -> literal .)
    RANGE           reduce using rule 234 (primary -> literal .)
    DIGITS          reduce using rule 234 (primary -> literal .)
    RENAMES         reduce using rule 234 (primary -> literal .)
    ASSIGNMENT      reduce using rule 234 (primary -> literal .)
    DOTDOT          reduce using rule 234 (primary -> literal .)


state 136

    (185) literal -> BASE_INTEGER .

    STARSTAR        reduce using rule 185 (literal -> BASE_INTEGER .)
    *               reduce using rule 185 (literal -> BASE_INTEGER .)
    /               reduce using rule 185 (literal -> BASE_INTEGER .)
    MOD             reduce using rule 185 (literal -> BASE_INTEGER .)
    REM             reduce using rule 185 (literal -> BASE_INTEGER .)
    DOTDOT          reduce using rule 185 (literal -> BASE_INTEGER .)
    +               reduce using rule 185 (literal -> BASE_INTEGER .)
    -               reduce using rule 185 (literal -> BASE_INTEGER .)
    &               reduce using rule 185 (literal -> BASE_INTEGER .)
    =               reduce using rule 185 (literal -> BASE_INTEGER .)
    NOTEQUAL        reduce using rule 185 (literal -> BASE_INTEGER .)
    <               reduce using rule 185 (literal -> BASE_INTEGER .)
    LESSEQ          reduce using rule 185 (literal -> BASE_INTEGER .)
    >               reduce using rule 185 (literal -> BASE_INTEGER .)
    GREATEREQ       reduce using rule 185 (literal -> BASE_INTEGER .)
    IN              reduce using rule 185 (literal -> BASE_INTEGER .)
    NOT             reduce using rule 185 (literal -> BASE_INTEGER .)
    AND             reduce using rule 185 (literal -> BASE_INTEGER .)
    OR              reduce using rule 185 (literal -> BASE_INTEGER .)
    )               reduce using rule 185 (literal -> BASE_INTEGER .)
    ,               reduce using rule 185 (literal -> BASE_INTEGER .)
    RANGE           reduce using rule 185 (literal -> BASE_INTEGER .)
    ;               reduce using rule 185 (literal -> BASE_INTEGER .)
    IS              reduce using rule 185 (literal -> BASE_INTEGER .)
    ARROW           reduce using rule 185 (literal -> BASE_INTEGER .)
    |               reduce using rule 185 (literal -> BASE_INTEGER .)
    WITH            reduce using rule 185 (literal -> BASE_INTEGER .)
    THEN            reduce using rule 185 (literal -> BASE_INTEGER .)
    LOOP            reduce using rule 185 (literal -> BASE_INTEGER .)
    DIGITS          reduce using rule 185 (literal -> BASE_INTEGER .)
    RENAMES         reduce using rule 185 (literal -> BASE_INTEGER .)
    ASSIGNMENT      reduce using rule 185 (literal -> BASE_INTEGER .)


state 137

    (225) term -> factor .

    *               reduce using rule 225 (term -> factor .)
    /               reduce using rule 225 (term -> factor .)
    MOD             reduce using rule 225 (term -> factor .)
    REM             reduce using rule 225 (term -> factor .)
    =               reduce using rule 225 (term -> factor .)
    NOTEQUAL        reduce using rule 225 (term -> factor .)
    <               reduce using rule 225 (term -> factor .)
    LESSEQ          reduce using rule 225 (term -> factor .)
    >               reduce using rule 225 (term -> factor .)
    GREATEREQ       reduce using rule 225 (term -> factor .)
    IN              reduce using rule 225 (term -> factor .)
    NOT             reduce using rule 225 (term -> factor .)
    +               reduce using rule 225 (term -> factor .)
    -               reduce using rule 225 (term -> factor .)
    &               reduce using rule 225 (term -> factor .)
    IS              reduce using rule 225 (term -> factor .)
    AND             reduce using rule 225 (term -> factor .)
    OR              reduce using rule 225 (term -> factor .)
    )               reduce using rule 225 (term -> factor .)
    ,               reduce using rule 225 (term -> factor .)
    DOTDOT          reduce using rule 225 (term -> factor .)
    WITH            reduce using rule 225 (term -> factor .)
    ARROW           reduce using rule 225 (term -> factor .)
    |               reduce using rule 225 (term -> factor .)
    ;               reduce using rule 225 (term -> factor .)
    THEN            reduce using rule 225 (term -> factor .)
    LOOP            reduce using rule 225 (term -> factor .)
    RANGE           reduce using rule 225 (term -> factor .)
    DIGITS          reduce using rule 225 (term -> factor .)
    RENAMES         reduce using rule 225 (term -> factor .)
    ASSIGNMENT      reduce using rule 225 (term -> factor .)


state 138

    (167) operator_symbol -> STRING .

    (               reduce using rule 167 (operator_symbol -> STRING .)
    .               reduce using rule 167 (operator_symbol -> STRING .)
    TICK            reduce using rule 167 (operator_symbol -> STRING .)
    RANGE           reduce using rule 167 (operator_symbol -> STRING .)
    STARSTAR        reduce using rule 167 (operator_symbol -> STRING .)
    *               reduce using rule 167 (operator_symbol -> STRING .)
    /               reduce using rule 167 (operator_symbol -> STRING .)
    MOD             reduce using rule 167 (operator_symbol -> STRING .)
    REM             reduce using rule 167 (operator_symbol -> STRING .)
    DOTDOT          reduce using rule 167 (operator_symbol -> STRING .)
    =               reduce using rule 167 (operator_symbol -> STRING .)
    NOTEQUAL        reduce using rule 167 (operator_symbol -> STRING .)
    <               reduce using rule 167 (operator_symbol -> STRING .)
    LESSEQ          reduce using rule 167 (operator_symbol -> STRING .)
    >               reduce using rule 167 (operator_symbol -> STRING .)
    GREATEREQ       reduce using rule 167 (operator_symbol -> STRING .)
    IN              reduce using rule 167 (operator_symbol -> STRING .)
    NOT             reduce using rule 167 (operator_symbol -> STRING .)
    +               reduce using rule 167 (operator_symbol -> STRING .)
    -               reduce using rule 167 (operator_symbol -> STRING .)
    &               reduce using rule 167 (operator_symbol -> STRING .)
    AND             reduce using rule 167 (operator_symbol -> STRING .)
    OR              reduce using rule 167 (operator_symbol -> STRING .)
    )               reduce using rule 167 (operator_symbol -> STRING .)
    ,               reduce using rule 167 (operator_symbol -> STRING .)
    ARROW           reduce using rule 167 (operator_symbol -> STRING .)
    |               reduce using rule 167 (operator_symbol -> STRING .)
    DIGITS          reduce using rule 167 (operator_symbol -> STRING .)
    ;               reduce using rule 167 (operator_symbol -> STRING .)
    ASSIGNMENT      reduce using rule 167 (operator_symbol -> STRING .)
    WITH            reduce using rule 167 (operator_symbol -> STRING .)
    LOOP            reduce using rule 167 (operator_symbol -> STRING .)
    IS              reduce using rule 167 (operator_symbol -> STRING .)
    THEN            reduce using rule 167 (operator_symbol -> STRING .)
    RENAMES         reduce using rule 167 (operator_symbol -> STRING .)
    WHEN            reduce using rule 167 (operator_symbol -> STRING .)


state 139

    (3) pragma -> PRAGMA simple_name ( pragma_arg_s . ) ;
    (5) pragma_arg_s -> pragma_arg_s . , pragma_arg

    )               shift and go to state 236
    ,               shift and go to state 237


state 140

    (237) primary -> qualified .

    STARSTAR        reduce using rule 237 (primary -> qualified .)
    *               reduce using rule 237 (primary -> qualified .)
    /               reduce using rule 237 (primary -> qualified .)
    MOD             reduce using rule 237 (primary -> qualified .)
    REM             reduce using rule 237 (primary -> qualified .)
    =               reduce using rule 237 (primary -> qualified .)
    NOTEQUAL        reduce using rule 237 (primary -> qualified .)
    <               reduce using rule 237 (primary -> qualified .)
    LESSEQ          reduce using rule 237 (primary -> qualified .)
    >               reduce using rule 237 (primary -> qualified .)
    GREATEREQ       reduce using rule 237 (primary -> qualified .)
    IN              reduce using rule 237 (primary -> qualified .)
    NOT             reduce using rule 237 (primary -> qualified .)
    +               reduce using rule 237 (primary -> qualified .)
    -               reduce using rule 237 (primary -> qualified .)
    &               reduce using rule 237 (primary -> qualified .)
    AND             reduce using rule 237 (primary -> qualified .)
    OR              reduce using rule 237 (primary -> qualified .)
    )               reduce using rule 237 (primary -> qualified .)
    ,               reduce using rule 237 (primary -> qualified .)
    WITH            reduce using rule 237 (primary -> qualified .)
    ARROW           reduce using rule 237 (primary -> qualified .)
    |               reduce using rule 237 (primary -> qualified .)
    ;               reduce using rule 237 (primary -> qualified .)
    IS              reduce using rule 237 (primary -> qualified .)
    THEN            reduce using rule 237 (primary -> qualified .)
    LOOP            reduce using rule 237 (primary -> qualified .)
    RANGE           reduce using rule 237 (primary -> qualified .)
    DIGITS          reduce using rule 237 (primary -> qualified .)
    RENAMES         reduce using rule 237 (primary -> qualified .)
    ASSIGNMENT      reduce using rule 237 (primary -> qualified .)
    DOTDOT          reduce using rule 237 (primary -> qualified .)


state 141

    (238) primary -> parenthesized_primary .

    STARSTAR        reduce using rule 238 (primary -> parenthesized_primary .)
    *               reduce using rule 238 (primary -> parenthesized_primary .)
    /               reduce using rule 238 (primary -> parenthesized_primary .)
    MOD             reduce using rule 238 (primary -> parenthesized_primary .)
    REM             reduce using rule 238 (primary -> parenthesized_primary .)
    =               reduce using rule 238 (primary -> parenthesized_primary .)
    NOTEQUAL        reduce using rule 238 (primary -> parenthesized_primary .)
    <               reduce using rule 238 (primary -> parenthesized_primary .)
    LESSEQ          reduce using rule 238 (primary -> parenthesized_primary .)
    >               reduce using rule 238 (primary -> parenthesized_primary .)
    GREATEREQ       reduce using rule 238 (primary -> parenthesized_primary .)
    IN              reduce using rule 238 (primary -> parenthesized_primary .)
    NOT             reduce using rule 238 (primary -> parenthesized_primary .)
    +               reduce using rule 238 (primary -> parenthesized_primary .)
    -               reduce using rule 238 (primary -> parenthesized_primary .)
    &               reduce using rule 238 (primary -> parenthesized_primary .)
    AND             reduce using rule 238 (primary -> parenthesized_primary .)
    OR              reduce using rule 238 (primary -> parenthesized_primary .)
    )               reduce using rule 238 (primary -> parenthesized_primary .)
    ,               reduce using rule 238 (primary -> parenthesized_primary .)
    WITH            reduce using rule 238 (primary -> parenthesized_primary .)
    ARROW           reduce using rule 238 (primary -> parenthesized_primary .)
    |               reduce using rule 238 (primary -> parenthesized_primary .)
    ;               reduce using rule 238 (primary -> parenthesized_primary .)
    IS              reduce using rule 238 (primary -> parenthesized_primary .)
    THEN            reduce using rule 238 (primary -> parenthesized_primary .)
    LOOP            reduce using rule 238 (primary -> parenthesized_primary .)
    RANGE           reduce using rule 238 (primary -> parenthesized_primary .)
    DIGITS          reduce using rule 238 (primary -> parenthesized_primary .)
    RENAMES         reduce using rule 238 (primary -> parenthesized_primary .)
    ASSIGNMENT      reduce using rule 238 (primary -> parenthesized_primary .)
    DOTDOT          reduce using rule 238 (primary -> parenthesized_primary .)


state 142

    (184) literal -> INTEGER .

    STARSTAR        reduce using rule 184 (literal -> INTEGER .)
    *               reduce using rule 184 (literal -> INTEGER .)
    /               reduce using rule 184 (literal -> INTEGER .)
    MOD             reduce using rule 184 (literal -> INTEGER .)
    REM             reduce using rule 184 (literal -> INTEGER .)
    DOTDOT          reduce using rule 184 (literal -> INTEGER .)
    +               reduce using rule 184 (literal -> INTEGER .)
    -               reduce using rule 184 (literal -> INTEGER .)
    &               reduce using rule 184 (literal -> INTEGER .)
    =               reduce using rule 184 (literal -> INTEGER .)
    NOTEQUAL        reduce using rule 184 (literal -> INTEGER .)
    <               reduce using rule 184 (literal -> INTEGER .)
    LESSEQ          reduce using rule 184 (literal -> INTEGER .)
    >               reduce using rule 184 (literal -> INTEGER .)
    GREATEREQ       reduce using rule 184 (literal -> INTEGER .)
    IN              reduce using rule 184 (literal -> INTEGER .)
    NOT             reduce using rule 184 (literal -> INTEGER .)
    AND             reduce using rule 184 (literal -> INTEGER .)
    OR              reduce using rule 184 (literal -> INTEGER .)
    )               reduce using rule 184 (literal -> INTEGER .)
    ,               reduce using rule 184 (literal -> INTEGER .)
    RANGE           reduce using rule 184 (literal -> INTEGER .)
    ;               reduce using rule 184 (literal -> INTEGER .)
    IS              reduce using rule 184 (literal -> INTEGER .)
    ARROW           reduce using rule 184 (literal -> INTEGER .)
    |               reduce using rule 184 (literal -> INTEGER .)
    WITH            reduce using rule 184 (literal -> INTEGER .)
    THEN            reduce using rule 184 (literal -> INTEGER .)
    LOOP            reduce using rule 184 (literal -> INTEGER .)
    DIGITS          reduce using rule 184 (literal -> INTEGER .)
    RENAMES         reduce using rule 184 (literal -> INTEGER .)
    ASSIGNMENT      reduce using rule 184 (literal -> INTEGER .)


state 143

    (239) parenthesized_primary -> aggregate .

    STARSTAR        reduce using rule 239 (parenthesized_primary -> aggregate .)
    *               reduce using rule 239 (parenthesized_primary -> aggregate .)
    /               reduce using rule 239 (parenthesized_primary -> aggregate .)
    MOD             reduce using rule 239 (parenthesized_primary -> aggregate .)
    REM             reduce using rule 239 (parenthesized_primary -> aggregate .)
    =               reduce using rule 239 (parenthesized_primary -> aggregate .)
    NOTEQUAL        reduce using rule 239 (parenthesized_primary -> aggregate .)
    <               reduce using rule 239 (parenthesized_primary -> aggregate .)
    LESSEQ          reduce using rule 239 (parenthesized_primary -> aggregate .)
    >               reduce using rule 239 (parenthesized_primary -> aggregate .)
    GREATEREQ       reduce using rule 239 (parenthesized_primary -> aggregate .)
    IN              reduce using rule 239 (parenthesized_primary -> aggregate .)
    NOT             reduce using rule 239 (parenthesized_primary -> aggregate .)
    +               reduce using rule 239 (parenthesized_primary -> aggregate .)
    -               reduce using rule 239 (parenthesized_primary -> aggregate .)
    &               reduce using rule 239 (parenthesized_primary -> aggregate .)
    AND             reduce using rule 239 (parenthesized_primary -> aggregate .)
    OR              reduce using rule 239 (parenthesized_primary -> aggregate .)
    )               reduce using rule 239 (parenthesized_primary -> aggregate .)
    ,               reduce using rule 239 (parenthesized_primary -> aggregate .)
    ;               reduce using rule 239 (parenthesized_primary -> aggregate .)
    IS              reduce using rule 239 (parenthesized_primary -> aggregate .)
    DOTDOT          reduce using rule 239 (parenthesized_primary -> aggregate .)
    WITH            reduce using rule 239 (parenthesized_primary -> aggregate .)
    ARROW           reduce using rule 239 (parenthesized_primary -> aggregate .)
    |               reduce using rule 239 (parenthesized_primary -> aggregate .)
    THEN            reduce using rule 239 (parenthesized_primary -> aggregate .)
    LOOP            reduce using rule 239 (parenthesized_primary -> aggregate .)
    RANGE           reduce using rule 239 (parenthesized_primary -> aggregate .)
    DIGITS          reduce using rule 239 (parenthesized_primary -> aggregate .)
    RENAMES         reduce using rule 239 (parenthesized_primary -> aggregate .)
    ASSIGNMENT      reduce using rule 239 (parenthesized_primary -> aggregate .)


state 144

    (188) literal -> used_char .

    STARSTAR        reduce using rule 188 (literal -> used_char .)
    *               reduce using rule 188 (literal -> used_char .)
    /               reduce using rule 188 (literal -> used_char .)
    MOD             reduce using rule 188 (literal -> used_char .)
    REM             reduce using rule 188 (literal -> used_char .)
    DOTDOT          reduce using rule 188 (literal -> used_char .)
    +               reduce using rule 188 (literal -> used_char .)
    -               reduce using rule 188 (literal -> used_char .)
    &               reduce using rule 188 (literal -> used_char .)
    =               reduce using rule 188 (literal -> used_char .)
    NOTEQUAL        reduce using rule 188 (literal -> used_char .)
    <               reduce using rule 188 (literal -> used_char .)
    LESSEQ          reduce using rule 188 (literal -> used_char .)
    >               reduce using rule 188 (literal -> used_char .)
    GREATEREQ       reduce using rule 188 (literal -> used_char .)
    IN              reduce using rule 188 (literal -> used_char .)
    NOT             reduce using rule 188 (literal -> used_char .)
    AND             reduce using rule 188 (literal -> used_char .)
    OR              reduce using rule 188 (literal -> used_char .)
    )               reduce using rule 188 (literal -> used_char .)
    ,               reduce using rule 188 (literal -> used_char .)
    RANGE           reduce using rule 188 (literal -> used_char .)
    ;               reduce using rule 188 (literal -> used_char .)
    IS              reduce using rule 188 (literal -> used_char .)
    ARROW           reduce using rule 188 (literal -> used_char .)
    |               reduce using rule 188 (literal -> used_char .)
    WITH            reduce using rule 188 (literal -> used_char .)
    THEN            reduce using rule 188 (literal -> used_char .)
    LOOP            reduce using rule 188 (literal -> used_char .)
    DIGITS          reduce using rule 188 (literal -> used_char .)
    RENAMES         reduce using rule 188 (literal -> used_char .)
    ASSIGNMENT      reduce using rule 188 (literal -> used_char .)


state 145

    (166) used_char -> CHAR .

    STARSTAR        reduce using rule 166 (used_char -> CHAR .)
    *               reduce using rule 166 (used_char -> CHAR .)
    /               reduce using rule 166 (used_char -> CHAR .)
    MOD             reduce using rule 166 (used_char -> CHAR .)
    REM             reduce using rule 166 (used_char -> CHAR .)
    =               reduce using rule 166 (used_char -> CHAR .)
    NOTEQUAL        reduce using rule 166 (used_char -> CHAR .)
    <               reduce using rule 166 (used_char -> CHAR .)
    LESSEQ          reduce using rule 166 (used_char -> CHAR .)
    >               reduce using rule 166 (used_char -> CHAR .)
    GREATEREQ       reduce using rule 166 (used_char -> CHAR .)
    IN              reduce using rule 166 (used_char -> CHAR .)
    NOT             reduce using rule 166 (used_char -> CHAR .)
    +               reduce using rule 166 (used_char -> CHAR .)
    -               reduce using rule 166 (used_char -> CHAR .)
    &               reduce using rule 166 (used_char -> CHAR .)
    AND             reduce using rule 166 (used_char -> CHAR .)
    OR              reduce using rule 166 (used_char -> CHAR .)
    ;               reduce using rule 166 (used_char -> CHAR .)
    IS              reduce using rule 166 (used_char -> CHAR .)
    RANGE           reduce using rule 166 (used_char -> CHAR .)
    THEN            reduce using rule 166 (used_char -> CHAR .)
    )               reduce using rule 166 (used_char -> CHAR .)
    ,               reduce using rule 166 (used_char -> CHAR .)
    WITH            reduce using rule 166 (used_char -> CHAR .)
    ARROW           reduce using rule 166 (used_char -> CHAR .)
    |               reduce using rule 166 (used_char -> CHAR .)
    LOOP            reduce using rule 166 (used_char -> CHAR .)
    DIGITS          reduce using rule 166 (used_char -> CHAR .)
    RENAMES         reduce using rule 166 (used_char -> CHAR .)
    ASSIGNMENT      reduce using rule 166 (used_char -> CHAR .)
    DOTDOT          reduce using rule 166 (used_char -> CHAR .)
    TICK            reduce using rule 166 (used_char -> CHAR .)
    (               reduce using rule 166 (used_char -> CHAR .)
    .               reduce using rule 166 (used_char -> CHAR .)
    WHEN            reduce using rule 166 (used_char -> CHAR .)


state 146

    (218) simple_expression -> term .
    (226) term -> term . multiplying factor
    (227) multiplying -> . *
    (228) multiplying -> . /
    (229) multiplying -> . MOD
    (230) multiplying -> . REM

    +               reduce using rule 218 (simple_expression -> term .)
    -               reduce using rule 218 (simple_expression -> term .)
    &               reduce using rule 218 (simple_expression -> term .)
    ,               reduce using rule 218 (simple_expression -> term .)
    ARROW           reduce using rule 218 (simple_expression -> term .)
    |               reduce using rule 218 (simple_expression -> term .)
    AND             reduce using rule 218 (simple_expression -> term .)
    OR              reduce using rule 218 (simple_expression -> term .)
    )               reduce using rule 218 (simple_expression -> term .)
    WITH            reduce using rule 218 (simple_expression -> term .)
    ;               reduce using rule 218 (simple_expression -> term .)
    IS              reduce using rule 218 (simple_expression -> term .)
    THEN            reduce using rule 218 (simple_expression -> term .)
    LOOP            reduce using rule 218 (simple_expression -> term .)
    RANGE           reduce using rule 218 (simple_expression -> term .)
    DIGITS          reduce using rule 218 (simple_expression -> term .)
    RENAMES         reduce using rule 218 (simple_expression -> term .)
    ASSIGNMENT      reduce using rule 218 (simple_expression -> term .)
    =               reduce using rule 218 (simple_expression -> term .)
    NOTEQUAL        reduce using rule 218 (simple_expression -> term .)
    <               reduce using rule 218 (simple_expression -> term .)
    LESSEQ          reduce using rule 218 (simple_expression -> term .)
    >               reduce using rule 218 (simple_expression -> term .)
    GREATEREQ       reduce using rule 218 (simple_expression -> term .)
    IN              reduce using rule 218 (simple_expression -> term .)
    NOT             reduce using rule 218 (simple_expression -> term .)
    DOTDOT          reduce using rule 218 (simple_expression -> term .)
    *               shift and go to state 240
    /               shift and go to state 241
    MOD             shift and go to state 242
    REM             shift and go to state 238

    multiplying                    shift and go to state 239

state 147

    (235) primary -> name .
    (241) qualified -> name . TICK parenthesized_primary
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id

    STARSTAR        reduce using rule 235 (primary -> name .)
    *               reduce using rule 235 (primary -> name .)
    /               reduce using rule 235 (primary -> name .)
    MOD             reduce using rule 235 (primary -> name .)
    REM             reduce using rule 235 (primary -> name .)
    =               reduce using rule 235 (primary -> name .)
    NOTEQUAL        reduce using rule 235 (primary -> name .)
    <               reduce using rule 235 (primary -> name .)
    LESSEQ          reduce using rule 235 (primary -> name .)
    >               reduce using rule 235 (primary -> name .)
    GREATEREQ       reduce using rule 235 (primary -> name .)
    IN              reduce using rule 235 (primary -> name .)
    NOT             reduce using rule 235 (primary -> name .)
    +               reduce using rule 235 (primary -> name .)
    -               reduce using rule 235 (primary -> name .)
    &               reduce using rule 235 (primary -> name .)
    AND             reduce using rule 235 (primary -> name .)
    OR              reduce using rule 235 (primary -> name .)
    )               reduce using rule 235 (primary -> name .)
    ,               reduce using rule 235 (primary -> name .)
    WITH            reduce using rule 235 (primary -> name .)
    ARROW           reduce using rule 235 (primary -> name .)
    |               reduce using rule 235 (primary -> name .)
    ;               reduce using rule 235 (primary -> name .)
    IS              reduce using rule 235 (primary -> name .)
    THEN            reduce using rule 235 (primary -> name .)
    LOOP            reduce using rule 235 (primary -> name .)
    RANGE           reduce using rule 235 (primary -> name .)
    DIGITS          reduce using rule 235 (primary -> name .)
    RENAMES         reduce using rule 235 (primary -> name .)
    ASSIGNMENT      reduce using rule 235 (primary -> name .)
    DOTDOT          reduce using rule 235 (primary -> name .)
    TICK            shift and go to state 245
    (               shift and go to state 243
    .               shift and go to state 244


state 148

    (186) literal -> FLOAT .

    STARSTAR        reduce using rule 186 (literal -> FLOAT .)
    *               reduce using rule 186 (literal -> FLOAT .)
    /               reduce using rule 186 (literal -> FLOAT .)
    MOD             reduce using rule 186 (literal -> FLOAT .)
    REM             reduce using rule 186 (literal -> FLOAT .)
    DOTDOT          reduce using rule 186 (literal -> FLOAT .)
    +               reduce using rule 186 (literal -> FLOAT .)
    -               reduce using rule 186 (literal -> FLOAT .)
    &               reduce using rule 186 (literal -> FLOAT .)
    =               reduce using rule 186 (literal -> FLOAT .)
    NOTEQUAL        reduce using rule 186 (literal -> FLOAT .)
    <               reduce using rule 186 (literal -> FLOAT .)
    LESSEQ          reduce using rule 186 (literal -> FLOAT .)
    >               reduce using rule 186 (literal -> FLOAT .)
    GREATEREQ       reduce using rule 186 (literal -> FLOAT .)
    IN              reduce using rule 186 (literal -> FLOAT .)
    NOT             reduce using rule 186 (literal -> FLOAT .)
    AND             reduce using rule 186 (literal -> FLOAT .)
    OR              reduce using rule 186 (literal -> FLOAT .)
    )               reduce using rule 186 (literal -> FLOAT .)
    ,               reduce using rule 186 (literal -> FLOAT .)
    RANGE           reduce using rule 186 (literal -> FLOAT .)
    ;               reduce using rule 186 (literal -> FLOAT .)
    IS              reduce using rule 186 (literal -> FLOAT .)
    ARROW           reduce using rule 186 (literal -> FLOAT .)
    |               reduce using rule 186 (literal -> FLOAT .)
    WITH            reduce using rule 186 (literal -> FLOAT .)
    THEN            reduce using rule 186 (literal -> FLOAT .)
    LOOP            reduce using rule 186 (literal -> FLOAT .)
    DIGITS          reduce using rule 186 (literal -> FLOAT .)
    RENAMES         reduce using rule 186 (literal -> FLOAT .)
    ASSIGNMENT      reduce using rule 186 (literal -> FLOAT .)


state 149

    (157) name -> operator_symbol .

    TICK            reduce using rule 157 (name -> operator_symbol .)
    (               reduce using rule 157 (name -> operator_symbol .)
    .               reduce using rule 157 (name -> operator_symbol .)
    STARSTAR        reduce using rule 157 (name -> operator_symbol .)
    *               reduce using rule 157 (name -> operator_symbol .)
    /               reduce using rule 157 (name -> operator_symbol .)
    MOD             reduce using rule 157 (name -> operator_symbol .)
    REM             reduce using rule 157 (name -> operator_symbol .)
    =               reduce using rule 157 (name -> operator_symbol .)
    NOTEQUAL        reduce using rule 157 (name -> operator_symbol .)
    <               reduce using rule 157 (name -> operator_symbol .)
    LESSEQ          reduce using rule 157 (name -> operator_symbol .)
    >               reduce using rule 157 (name -> operator_symbol .)
    GREATEREQ       reduce using rule 157 (name -> operator_symbol .)
    IN              reduce using rule 157 (name -> operator_symbol .)
    NOT             reduce using rule 157 (name -> operator_symbol .)
    +               reduce using rule 157 (name -> operator_symbol .)
    -               reduce using rule 157 (name -> operator_symbol .)
    &               reduce using rule 157 (name -> operator_symbol .)
    IS              reduce using rule 157 (name -> operator_symbol .)
    AND             reduce using rule 157 (name -> operator_symbol .)
    OR              reduce using rule 157 (name -> operator_symbol .)
    RANGE           reduce using rule 157 (name -> operator_symbol .)
    DIGITS          reduce using rule 157 (name -> operator_symbol .)
    RENAMES         reduce using rule 157 (name -> operator_symbol .)
    ASSIGNMENT      reduce using rule 157 (name -> operator_symbol .)
    ;               reduce using rule 157 (name -> operator_symbol .)
    LOOP            reduce using rule 157 (name -> operator_symbol .)
    WITH            reduce using rule 157 (name -> operator_symbol .)
    DOTDOT          reduce using rule 157 (name -> operator_symbol .)
    )               reduce using rule 157 (name -> operator_symbol .)
    ,               reduce using rule 157 (name -> operator_symbol .)
    ARROW           reduce using rule 157 (name -> operator_symbol .)
    |               reduce using rule 157 (name -> operator_symbol .)
    THEN            reduce using rule 157 (name -> operator_symbol .)
    WHEN            reduce using rule 157 (name -> operator_symbol .)


state 150

    (232) factor -> NOT . primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 147
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    primary                        shift and go to state 246
    used_char                      shift and go to state 144
    literal                        shift and go to state 135
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157

state 151

    (189) literal -> NuLL .

    STARSTAR        reduce using rule 189 (literal -> NuLL .)
    *               reduce using rule 189 (literal -> NuLL .)
    /               reduce using rule 189 (literal -> NuLL .)
    MOD             reduce using rule 189 (literal -> NuLL .)
    REM             reduce using rule 189 (literal -> NuLL .)
    DOTDOT          reduce using rule 189 (literal -> NuLL .)
    +               reduce using rule 189 (literal -> NuLL .)
    -               reduce using rule 189 (literal -> NuLL .)
    &               reduce using rule 189 (literal -> NuLL .)
    =               reduce using rule 189 (literal -> NuLL .)
    NOTEQUAL        reduce using rule 189 (literal -> NuLL .)
    <               reduce using rule 189 (literal -> NuLL .)
    LESSEQ          reduce using rule 189 (literal -> NuLL .)
    >               reduce using rule 189 (literal -> NuLL .)
    GREATEREQ       reduce using rule 189 (literal -> NuLL .)
    IN              reduce using rule 189 (literal -> NuLL .)
    NOT             reduce using rule 189 (literal -> NuLL .)
    AND             reduce using rule 189 (literal -> NuLL .)
    OR              reduce using rule 189 (literal -> NuLL .)
    )               reduce using rule 189 (literal -> NuLL .)
    ,               reduce using rule 189 (literal -> NuLL .)
    RANGE           reduce using rule 189 (literal -> NuLL .)
    ;               reduce using rule 189 (literal -> NuLL .)
    IS              reduce using rule 189 (literal -> NuLL .)
    ARROW           reduce using rule 189 (literal -> NuLL .)
    |               reduce using rule 189 (literal -> NuLL .)
    WITH            reduce using rule 189 (literal -> NuLL .)
    THEN            reduce using rule 189 (literal -> NuLL .)
    LOOP            reduce using rule 189 (literal -> NuLL .)
    DIGITS          reduce using rule 189 (literal -> NuLL .)
    RENAMES         reduce using rule 189 (literal -> NuLL .)
    ASSIGNMENT      reduce using rule 189 (literal -> NuLL .)


state 152

    (6) pragma_arg -> expression .
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    )               reduce using rule 6 (pragma_arg -> expression .)
    ,               reduce using rule 6 (pragma_arg -> expression .)
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 153

    (431) comp_unit -> context_spec private_opt unit pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    PRIVATE         reduce using rule 431 (comp_unit -> context_spec private_opt unit pragma_s .)
    WITH            reduce using rule 431 (comp_unit -> context_spec private_opt unit pragma_s .)
    PACKAGE         reduce using rule 431 (comp_unit -> context_spec private_opt unit pragma_s .)
    SEPARATE        reduce using rule 431 (comp_unit -> context_spec private_opt unit pragma_s .)
    PROCEDURE       reduce using rule 431 (comp_unit -> context_spec private_opt unit pragma_s .)
    FUNCTION        reduce using rule 431 (comp_unit -> context_spec private_opt unit pragma_s .)
    GENERIC         reduce using rule 431 (comp_unit -> context_spec private_opt unit pragma_s .)
    $end            reduce using rule 431 (comp_unit -> context_spec private_opt unit pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 154

    (348) use_clause -> USE name_s . ;
    (351) name_s -> name_s . , name

    ;               shift and go to state 251
    ,               shift and go to state 252


state 155

    (350) name_s -> name .
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id

    ;               reduce using rule 350 (name_s -> name .)
    ,               reduce using rule 350 (name_s -> name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 156

    (349) use_clause -> USE TYPE . name_s ;
    (350) name_s -> . name
    (351) name_s -> . name_s , name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name_s                         shift and go to state 254
    name                           shift and go to state 155
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 157

    (153) name -> simple_name .

    TICK            reduce using rule 153 (name -> simple_name .)
    (               reduce using rule 153 (name -> simple_name .)
    .               reduce using rule 153 (name -> simple_name .)
    STARSTAR        reduce using rule 153 (name -> simple_name .)
    *               reduce using rule 153 (name -> simple_name .)
    /               reduce using rule 153 (name -> simple_name .)
    MOD             reduce using rule 153 (name -> simple_name .)
    REM             reduce using rule 153 (name -> simple_name .)
    =               reduce using rule 153 (name -> simple_name .)
    NOTEQUAL        reduce using rule 153 (name -> simple_name .)
    <               reduce using rule 153 (name -> simple_name .)
    LESSEQ          reduce using rule 153 (name -> simple_name .)
    >               reduce using rule 153 (name -> simple_name .)
    GREATEREQ       reduce using rule 153 (name -> simple_name .)
    IN              reduce using rule 153 (name -> simple_name .)
    NOT             reduce using rule 153 (name -> simple_name .)
    +               reduce using rule 153 (name -> simple_name .)
    -               reduce using rule 153 (name -> simple_name .)
    &               reduce using rule 153 (name -> simple_name .)
    IS              reduce using rule 153 (name -> simple_name .)
    AND             reduce using rule 153 (name -> simple_name .)
    OR              reduce using rule 153 (name -> simple_name .)
    RANGE           reduce using rule 153 (name -> simple_name .)
    DIGITS          reduce using rule 153 (name -> simple_name .)
    RENAMES         reduce using rule 153 (name -> simple_name .)
    ASSIGNMENT      reduce using rule 153 (name -> simple_name .)
    ;               reduce using rule 153 (name -> simple_name .)
    LOOP            reduce using rule 153 (name -> simple_name .)
    WITH            reduce using rule 153 (name -> simple_name .)
    DOTDOT          reduce using rule 153 (name -> simple_name .)
    )               reduce using rule 153 (name -> simple_name .)
    ,               reduce using rule 153 (name -> simple_name .)
    ARROW           reduce using rule 153 (name -> simple_name .)
    |               reduce using rule 153 (name -> simple_name .)
    THEN            reduce using rule 153 (name -> simple_name .)
    WHEN            reduce using rule 153 (name -> simple_name .)


state 158

    (448) subunit -> SEPARATE ( compound_name . ) subunit_body
    (163) compound_name -> compound_name . . simple_name

    )               shift and go to state 255
    .               shift and go to state 119


state 159

    (384) prot_body -> PROTECTED BODY . simple_name IS prot_op_body_s END id_opt ;
    (456) body_stub -> PROTECTED BODY . simple_name IS SEPARATE ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 256

state 160

    (369) prot_spec -> PROTECTED IDENTIFIER . prot_def
    (371) prot_def -> . IS prot_op_decl_s prot_private_opt END id_opt

    IS              shift and go to state 257

    prot_def                       shift and go to state 258

state 161

    (370) prot_spec -> PROTECTED TYPE . simple_name discrim_part_opt prot_def
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 259

state 162

    (300) block_body -> BEGIN . handled_stmt_s
    (301) handled_stmt_s -> . statement_s except_handler_part_opt
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    label                          shift and go to state 279
    statement_s                    shift and go to state 300
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    handled_stmt_s                 shift and go to state 286
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    assign_stmt                    shift and go to state 308
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 163

    (333) subprog_body -> subprog_spec_is_push decl_part block_body . END id_opt ;

    END             shift and go to state 309


state 164

    (505) attrib_def -> FOR mark . USE expression ;
    (506) record_type_spec -> FOR mark . USE RECORD align_opt comp_loc_s END RECORD ;
    (511) address_spec -> FOR mark . USE AT expression ;
    (159) mark -> mark . TICK attribute_id
    (160) mark -> mark . . simple_name

    USE             shift and go to state 310
    TICK            shift and go to state 312
    .               shift and go to state 311


state 165

    (158) mark -> simple_name .

    AT              reduce using rule 158 (mark -> simple_name .)
    TICK            reduce using rule 158 (mark -> simple_name .)
    .               reduce using rule 158 (mark -> simple_name .)
    ;               reduce using rule 158 (mark -> simple_name .)
    USE             reduce using rule 158 (mark -> simple_name .)
    ASSIGNMENT      reduce using rule 158 (mark -> simple_name .)
    )               reduce using rule 158 (mark -> simple_name .)


state 166

    (360) task_decl -> task_spec ; .

    PACKAGE         reduce using rule 360 (task_decl -> task_spec ; .)
    TASK            reduce using rule 360 (task_decl -> task_spec ; .)
    PROTECTED       reduce using rule 360 (task_decl -> task_spec ; .)
    error           reduce using rule 360 (task_decl -> task_spec ; .)
    USE             reduce using rule 360 (task_decl -> task_spec ; .)
    PRAGMA          reduce using rule 360 (task_decl -> task_spec ; .)
    TYPE            reduce using rule 360 (task_decl -> task_spec ; .)
    SUBTYPE         reduce using rule 360 (task_decl -> task_spec ; .)
    FOR             reduce using rule 360 (task_decl -> task_spec ; .)
    PROCEDURE       reduce using rule 360 (task_decl -> task_spec ; .)
    FUNCTION        reduce using rule 360 (task_decl -> task_spec ; .)
    GENERIC         reduce using rule 360 (task_decl -> task_spec ; .)
    IDENTIFIER      reduce using rule 360 (task_decl -> task_spec ; .)
    BEGIN           reduce using rule 360 (task_decl -> task_spec ; .)
    END             reduce using rule 360 (task_decl -> task_spec ; .)
    PRIVATE         reduce using rule 360 (task_decl -> task_spec ; .)


state 167

    (367) task_body -> TASK BODY . simple_name IS decl_part block_body END id_opt ;
    (453) body_stub -> TASK BODY . simple_name IS SEPARATE ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 313

state 168

    (362) task_spec -> TASK TYPE . simple_name discrim_part_opt task_def
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 314

state 169

    (361) task_spec -> TASK simple_name . task_def
    (363) task_def -> .
    (364) task_def -> . IS entry_decl_s rep_spec_s task_private_opt END id_opt

    ;               reduce using rule 363 (task_def -> .)
    IS              shift and go to state 315

    task_def                       shift and go to state 316

state 170

    (146) decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .

    PACKAGE         reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    TASK            reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    PROTECTED       reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    error           reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    USE             reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    PRAGMA          reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    TYPE            reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    SUBTYPE         reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    FOR             reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    PROCEDURE       reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    FUNCTION        reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    GENERIC         reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    IDENTIFIER      reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    BEGIN           reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    END             reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)


state 171

    (342) pkg_body -> PACKAGE BODY . compound_name IS decl_part body_opt END c_id_opt ;
    (454) body_stub -> PACKAGE BODY . compound_name IS SEPARATE ;
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 317
    simple_name                    shift and go to state 41

state 172

    (337) pkg_spec -> PACKAGE compound_name . IS decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> PACKAGE compound_name . IS generic_inst
    (355) rename_unit -> PACKAGE compound_name . renames ;
    (163) compound_name -> compound_name . . simple_name
    (359) renames -> . RENAMES name

    IS              shift and go to state 187
    .               shift and go to state 119
    RENAMES         shift and go to state 95

    renames                        shift and go to state 186

state 173

    (368) prot_decl -> prot_spec ; .

    PACKAGE         reduce using rule 368 (prot_decl -> prot_spec ; .)
    TASK            reduce using rule 368 (prot_decl -> prot_spec ; .)
    PROTECTED       reduce using rule 368 (prot_decl -> prot_spec ; .)
    error           reduce using rule 368 (prot_decl -> prot_spec ; .)
    USE             reduce using rule 368 (prot_decl -> prot_spec ; .)
    PRAGMA          reduce using rule 368 (prot_decl -> prot_spec ; .)
    TYPE            reduce using rule 368 (prot_decl -> prot_spec ; .)
    SUBTYPE         reduce using rule 368 (prot_decl -> prot_spec ; .)
    FOR             reduce using rule 368 (prot_decl -> prot_spec ; .)
    PROCEDURE       reduce using rule 368 (prot_decl -> prot_spec ; .)
    FUNCTION        reduce using rule 368 (prot_decl -> prot_spec ; .)
    GENERIC         reduce using rule 368 (prot_decl -> prot_spec ; .)
    IDENTIFIER      reduce using rule 368 (prot_decl -> prot_spec ; .)
    BEGIN           reduce using rule 368 (prot_decl -> prot_spec ; .)
    END             reduce using rule 368 (prot_decl -> prot_spec ; .)
    PRIVATE         reduce using rule 368 (prot_decl -> prot_spec ; .)


state 174

    (22) decl -> error ; .

    PACKAGE         reduce using rule 22 (decl -> error ; .)
    TASK            reduce using rule 22 (decl -> error ; .)
    PROTECTED       reduce using rule 22 (decl -> error ; .)
    error           reduce using rule 22 (decl -> error ; .)
    USE             reduce using rule 22 (decl -> error ; .)
    PRAGMA          reduce using rule 22 (decl -> error ; .)
    TYPE            reduce using rule 22 (decl -> error ; .)
    SUBTYPE         reduce using rule 22 (decl -> error ; .)
    FOR             reduce using rule 22 (decl -> error ; .)
    PROCEDURE       reduce using rule 22 (decl -> error ; .)
    FUNCTION        reduce using rule 22 (decl -> error ; .)
    GENERIC         reduce using rule 22 (decl -> error ; .)
    IDENTIFIER      reduce using rule 22 (decl -> error ; .)
    BEGIN           reduce using rule 22 (decl -> error ; .)
    END             reduce using rule 22 (decl -> error ; .)
    PRIVATE         reduce using rule 22 (decl -> error ; .)


state 175

    (36) type_decl -> TYPE IDENTIFIER . discrim_part_opt type_completion ;
    (37) discrim_part_opt -> .
    (38) discrim_part_opt -> . discrim_part
    (39) discrim_part_opt -> . ( LESSMORE )
    (110) discrim_part -> . ( discrim_spec_s )

    IS              reduce using rule 37 (discrim_part_opt -> .)
    ;               reduce using rule 37 (discrim_part_opt -> .)
    (               shift and go to state 318

    discrim_part_opt               shift and go to state 319
    discrim_part                   shift and go to state 320

state 176

    (314) subprog_decl -> subprog_spec_is_push ABSTRACT ; .

    PACKAGE         reduce using rule 314 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    TASK            reduce using rule 314 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    PROTECTED       reduce using rule 314 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    error           reduce using rule 314 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    USE             reduce using rule 314 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    PRAGMA          reduce using rule 314 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    TYPE            reduce using rule 314 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    SUBTYPE         reduce using rule 314 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    FOR             reduce using rule 314 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    PROCEDURE       reduce using rule 314 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    FUNCTION        reduce using rule 314 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    GENERIC         reduce using rule 314 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    IDENTIFIER      reduce using rule 314 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    BEGIN           reduce using rule 314 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    PRIVATE         reduce using rule 314 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    WITH            reduce using rule 314 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    SEPARATE        reduce using rule 314 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    $end            reduce using rule 314 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    END             reduce using rule 314 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)


state 177

    (50) subtype_decl -> SUBTYPE IDENTIFIER . IS subtype_ind ;

    IS              shift and go to state 321


state 178

    (332) subprog_spec_is_push -> subprog_spec IS .
    (455) body_stub -> subprog_spec IS . SEPARATE ;
    (499) generic_subp_inst -> subprog_spec IS . generic_inst
    (501) generic_inst -> . NEW name

    ABSTRACT        reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    PACKAGE         reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    TASK            reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    PROTECTED       reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    error           reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    USE             reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    PRAGMA          reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    TYPE            reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    SUBTYPE         reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    FOR             reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    PROCEDURE       reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    FUNCTION        reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    GENERIC         reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    IDENTIFIER      reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    BEGIN           reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    SEPARATE        shift and go to state 322
    NEW             shift and go to state 183

    generic_inst                   shift and go to state 184

state 179

    (25) def_id_s -> def_id_s , . def_id
    (26) def_id -> . IDENTIFIER

    IDENTIFIER      shift and go to state 76

    def_id                         shift and go to state 323

state 180

    (23) object_decl -> def_id_s : . object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> def_id_s : . CONSTANT ASSIGNMENT expression ;
    (457) exception_decl -> def_id_s : . EXCEPTION ;
    (352) rename_decl -> def_id_s : . object_qualifier_opt subtype_ind renames ;
    (353) rename_decl -> def_id_s : . EXCEPTION renames ;
    (27) object_qualifier_opt -> .
    (28) object_qualifier_opt -> . ALIASED
    (29) object_qualifier_opt -> . ALIASED CONSTANT
    (30) object_qualifier_opt -> . CONSTANT

    CONSTANT        shift and go to state 325
    EXCEPTION       shift and go to state 324
    ARRAY           reduce using rule 27 (object_qualifier_opt -> .)
    IDENTIFIER      reduce using rule 27 (object_qualifier_opt -> .)
    STRING          reduce using rule 27 (object_qualifier_opt -> .)
    ALIASED         shift and go to state 326

    object_qualifier_opt           shift and go to state 327

state 181

    (356) rename_unit -> subprog_spec renames ; .

    PACKAGE         reduce using rule 356 (rename_unit -> subprog_spec renames ; .)
    TASK            reduce using rule 356 (rename_unit -> subprog_spec renames ; .)
    PROTECTED       reduce using rule 356 (rename_unit -> subprog_spec renames ; .)
    error           reduce using rule 356 (rename_unit -> subprog_spec renames ; .)
    USE             reduce using rule 356 (rename_unit -> subprog_spec renames ; .)
    PRAGMA          reduce using rule 356 (rename_unit -> subprog_spec renames ; .)
    TYPE            reduce using rule 356 (rename_unit -> subprog_spec renames ; .)
    SUBTYPE         reduce using rule 356 (rename_unit -> subprog_spec renames ; .)
    FOR             reduce using rule 356 (rename_unit -> subprog_spec renames ; .)
    PROCEDURE       reduce using rule 356 (rename_unit -> subprog_spec renames ; .)
    FUNCTION        reduce using rule 356 (rename_unit -> subprog_spec renames ; .)
    GENERIC         reduce using rule 356 (rename_unit -> subprog_spec renames ; .)
    IDENTIFIER      reduce using rule 356 (rename_unit -> subprog_spec renames ; .)
    BEGIN           reduce using rule 356 (rename_unit -> subprog_spec renames ; .)
    PRIVATE         reduce using rule 356 (rename_unit -> subprog_spec renames ; .)
    WITH            reduce using rule 356 (rename_unit -> subprog_spec renames ; .)
    SEPARATE        reduce using rule 356 (rename_unit -> subprog_spec renames ; .)
    $end            reduce using rule 356 (rename_unit -> subprog_spec renames ; .)
    END             reduce using rule 356 (rename_unit -> subprog_spec renames ; .)


state 182

    (359) renames -> RENAMES name .
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id

    ;               reduce using rule 359 (renames -> RENAMES name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 183

    (501) generic_inst -> NEW . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 328
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 184

    (499) generic_subp_inst -> subprog_spec IS generic_inst .

    ;               reduce using rule 499 (generic_subp_inst -> subprog_spec IS generic_inst .)


state 185

    (342) pkg_body -> PACKAGE BODY compound_name . IS decl_part body_opt END c_id_opt ;
    (163) compound_name -> compound_name . . simple_name

    IS              shift and go to state 329
    .               shift and go to state 119


state 186

    (355) rename_unit -> PACKAGE compound_name renames . ;

    ;               shift and go to state 330


state 187

    (337) pkg_spec -> PACKAGE compound_name IS . decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> PACKAGE compound_name IS . generic_inst
    (137) decl_item_s -> .
    (138) decl_item_s -> . decl_item_s1
    (501) generic_inst -> . NEW name
    (139) decl_item_s1 -> . decl_item
    (140) decl_item_s1 -> . decl_item_s1 decl_item
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (348) use_clause -> . USE name_s ;
    (349) use_clause -> . USE TYPE name_s ;
    (502) rep_spec -> . attrib_def
    (503) rep_spec -> . record_type_spec
    (504) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (312) subprog_decl -> . subprog_spec ;
    (313) subprog_decl -> . generic_subp_inst ;
    (314) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (335) pkg_decl -> . pkg_spec ;
    (336) pkg_decl -> . generic_pkg_inst ;
    (360) task_decl -> . task_spec ;
    (368) prot_decl -> . prot_spec ;
    (457) exception_decl -> . def_id_s : EXCEPTION ;
    (352) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (353) rename_decl -> . def_id_s : EXCEPTION renames ;
    (354) rename_decl -> . rename_unit
    (469) generic_decl -> . generic_formal_part subprog_spec ;
    (470) generic_decl -> . generic_formal_part pkg_spec ;
    (453) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (454) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (455) body_stub -> . subprog_spec IS SEPARATE ;
    (456) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (505) attrib_def -> . FOR mark USE expression ;
    (506) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (511) address_spec -> . FOR mark USE AT expression ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (315) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (316) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (317) subprog_spec -> . FUNCTION designator
    (499) generic_subp_inst -> . subprog_spec IS generic_inst
    (332) subprog_spec_is_push -> . subprog_spec IS
    (337) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (361) task_spec -> . TASK simple_name task_def
    (362) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (369) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (370) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (355) rename_unit -> . PACKAGE compound_name renames ;
    (356) rename_unit -> . subprog_spec renames ;
    (357) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (358) rename_unit -> . generic_formal_part subprog_spec renames ;
    (471) generic_formal_part -> . GENERIC
    (472) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    PRIVATE         reduce using rule 137 (decl_item_s -> .)
    END             reduce using rule 137 (decl_item_s -> .)
    NEW             shift and go to state 183
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    TASK            shift and go to state 336
    PACKAGE         shift and go to state 337
    PROTECTED       shift and go to state 333
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    task_decl                      shift and go to state 60
    subtype_decl                   shift and go to state 61
    generic_inst                   shift and go to state 331
    rep_spec                       shift and go to state 82
    decl_item_s1                   shift and go to state 332
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    decl_item                      shift and go to state 334
    subprog_spec_is_push           shift and go to state 338
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 339
    def_id_s                       shift and go to state 88
    task_spec                      shift and go to state 65
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    generic_subp_inst              shift and go to state 29
    def_id                         shift and go to state 89
    rename_decl                    shift and go to state 90
    type_decl                      shift and go to state 56
    rename_unit                    shift and go to state 91
    generic_formal_part            shift and go to state 33
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    subprog_decl                   shift and go to state 58
    decl_item_s                    shift and go to state 335
    pragma                         shift and go to state 74
    pkg_spec                       shift and go to state 37
    number_decl                    shift and go to state 93

state 188

    (321) formal_part_opt -> formal_part .

    ;               reduce using rule 321 (formal_part_opt -> formal_part .)
    DO              reduce using rule 321 (formal_part_opt -> formal_part .)
    WHEN            reduce using rule 321 (formal_part_opt -> formal_part .)
    RETURN          reduce using rule 321 (formal_part_opt -> formal_part .)
    IS              reduce using rule 321 (formal_part_opt -> formal_part .)
    RENAMES         reduce using rule 321 (formal_part_opt -> formal_part .)


state 189

    (322) formal_part -> ( . param_s )
    (323) param_s -> . param
    (324) param_s -> . param_s ; param
    (325) param -> . def_id_s : mode mark init_opt
    (326) param -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    error           shift and go to state 109
    IDENTIFIER      shift and go to state 76

    param_s                        shift and go to state 341
    param                          shift and go to state 340
    def_id                         shift and go to state 89
    def_id_s                       shift and go to state 105

state 190

    (315) subprog_spec -> PROCEDURE compound_name formal_part_opt .

    ;               reduce using rule 315 (subprog_spec -> PROCEDURE compound_name formal_part_opt .)
    IS              reduce using rule 315 (subprog_spec -> PROCEDURE compound_name formal_part_opt .)
    RENAMES         reduce using rule 315 (subprog_spec -> PROCEDURE compound_name formal_part_opt .)


state 191

    (476) generic_formal -> WITH FUNCTION . designator formal_part_opt RETURN name subp_default ;
    (318) designator -> . compound_name
    (319) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 342
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 192

    (477) generic_formal -> WITH PACKAGE . simple_name IS NEW name ( LESSMORE ) ;
    (478) generic_formal -> WITH PACKAGE . simple_name IS NEW name ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 343

state 193

    (475) generic_formal -> WITH PROCEDURE . simple_name formal_part_opt subp_default ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 344

state 194

    (473) generic_formal -> param ; .

    PACKAGE         reduce using rule 473 (generic_formal -> param ; .)
    PROCEDURE       reduce using rule 473 (generic_formal -> param ; .)
    FUNCTION        reduce using rule 473 (generic_formal -> param ; .)
    TYPE            reduce using rule 473 (generic_formal -> param ; .)
    WITH            reduce using rule 473 (generic_formal -> param ; .)
    error           reduce using rule 473 (generic_formal -> param ; .)
    USE             reduce using rule 473 (generic_formal -> param ; .)
    IDENTIFIER      reduce using rule 473 (generic_formal -> param ; .)


state 195

    (358) rename_unit -> generic_formal_part subprog_spec renames . ;

    ;               shift and go to state 345


state 196

    (469) generic_decl -> generic_formal_part subprog_spec ; .

    PACKAGE         reduce using rule 469 (generic_decl -> generic_formal_part subprog_spec ; .)
    TASK            reduce using rule 469 (generic_decl -> generic_formal_part subprog_spec ; .)
    PROTECTED       reduce using rule 469 (generic_decl -> generic_formal_part subprog_spec ; .)
    error           reduce using rule 469 (generic_decl -> generic_formal_part subprog_spec ; .)
    USE             reduce using rule 469 (generic_decl -> generic_formal_part subprog_spec ; .)
    PRAGMA          reduce using rule 469 (generic_decl -> generic_formal_part subprog_spec ; .)
    TYPE            reduce using rule 469 (generic_decl -> generic_formal_part subprog_spec ; .)
    SUBTYPE         reduce using rule 469 (generic_decl -> generic_formal_part subprog_spec ; .)
    FOR             reduce using rule 469 (generic_decl -> generic_formal_part subprog_spec ; .)
    PROCEDURE       reduce using rule 469 (generic_decl -> generic_formal_part subprog_spec ; .)
    FUNCTION        reduce using rule 469 (generic_decl -> generic_formal_part subprog_spec ; .)
    GENERIC         reduce using rule 469 (generic_decl -> generic_formal_part subprog_spec ; .)
    IDENTIFIER      reduce using rule 469 (generic_decl -> generic_formal_part subprog_spec ; .)
    BEGIN           reduce using rule 469 (generic_decl -> generic_formal_part subprog_spec ; .)
    PRIVATE         reduce using rule 469 (generic_decl -> generic_formal_part subprog_spec ; .)
    END             reduce using rule 469 (generic_decl -> generic_formal_part subprog_spec ; .)
    WITH            reduce using rule 469 (generic_decl -> generic_formal_part subprog_spec ; .)
    SEPARATE        reduce using rule 469 (generic_decl -> generic_formal_part subprog_spec ; .)
    $end            reduce using rule 469 (generic_decl -> generic_formal_part subprog_spec ; .)


state 197

    (325) param -> def_id_s : . mode mark init_opt
    (327) mode -> .
    (328) mode -> . IN
    (329) mode -> . OUT
    (330) mode -> . IN OUT
    (331) mode -> . ACCESS

    IDENTIFIER      reduce using rule 327 (mode -> .)
    IN              shift and go to state 348
    OUT             shift and go to state 347
    ACCESS          shift and go to state 346

    mode                           shift and go to state 349

state 198

    (357) rename_unit -> generic_formal_part PACKAGE compound_name . renames ;
    (337) pkg_spec -> PACKAGE compound_name . IS decl_item_s private_part END c_id_opt
    (163) compound_name -> compound_name . . simple_name
    (359) renames -> . RENAMES name

    IS              shift and go to state 351
    .               shift and go to state 119
    RENAMES         shift and go to state 95

    renames                        shift and go to state 350

state 199

    (470) generic_decl -> generic_formal_part pkg_spec ; .

    PACKAGE         reduce using rule 470 (generic_decl -> generic_formal_part pkg_spec ; .)
    TASK            reduce using rule 470 (generic_decl -> generic_formal_part pkg_spec ; .)
    PROTECTED       reduce using rule 470 (generic_decl -> generic_formal_part pkg_spec ; .)
    error           reduce using rule 470 (generic_decl -> generic_formal_part pkg_spec ; .)
    USE             reduce using rule 470 (generic_decl -> generic_formal_part pkg_spec ; .)
    PRAGMA          reduce using rule 470 (generic_decl -> generic_formal_part pkg_spec ; .)
    TYPE            reduce using rule 470 (generic_decl -> generic_formal_part pkg_spec ; .)
    SUBTYPE         reduce using rule 470 (generic_decl -> generic_formal_part pkg_spec ; .)
    FOR             reduce using rule 470 (generic_decl -> generic_formal_part pkg_spec ; .)
    PROCEDURE       reduce using rule 470 (generic_decl -> generic_formal_part pkg_spec ; .)
    FUNCTION        reduce using rule 470 (generic_decl -> generic_formal_part pkg_spec ; .)
    GENERIC         reduce using rule 470 (generic_decl -> generic_formal_part pkg_spec ; .)
    IDENTIFIER      reduce using rule 470 (generic_decl -> generic_formal_part pkg_spec ; .)
    BEGIN           reduce using rule 470 (generic_decl -> generic_formal_part pkg_spec ; .)
    PRIVATE         reduce using rule 470 (generic_decl -> generic_formal_part pkg_spec ; .)
    END             reduce using rule 470 (generic_decl -> generic_formal_part pkg_spec ; .)
    WITH            reduce using rule 470 (generic_decl -> generic_formal_part pkg_spec ; .)
    SEPARATE        reduce using rule 470 (generic_decl -> generic_formal_part pkg_spec ; .)
    $end            reduce using rule 470 (generic_decl -> generic_formal_part pkg_spec ; .)


state 200

    (474) generic_formal -> TYPE simple_name . generic_discrim_part_opt IS generic_type_def ;
    (480) generic_discrim_part_opt -> .
    (481) generic_discrim_part_opt -> . discrim_part
    (482) generic_discrim_part_opt -> . ( LESSMORE )
    (110) discrim_part -> . ( discrim_spec_s )

    IS              reduce using rule 480 (generic_discrim_part_opt -> .)
    (               shift and go to state 353

    generic_discrim_part_opt       shift and go to state 352
    discrim_part                   shift and go to state 354

state 201

    (316) subprog_spec -> FUNCTION designator formal_part_opt . RETURN name

    RETURN          shift and go to state 355


state 202

    (165) c_name_list -> c_name_list , compound_name .
    (163) compound_name -> compound_name . . simple_name

    ;               reduce using rule 165 (c_name_list -> c_name_list , compound_name .)
    ,               reduce using rule 165 (c_name_list -> c_name_list , compound_name .)
    .               shift and go to state 119


state 203

    (163) compound_name -> compound_name . simple_name .

    .               reduce using rule 163 (compound_name -> compound_name . simple_name .)
    ;               reduce using rule 163 (compound_name -> compound_name . simple_name .)
    (               reduce using rule 163 (compound_name -> compound_name . simple_name .)
    RETURN          reduce using rule 163 (compound_name -> compound_name . simple_name .)
    ,               reduce using rule 163 (compound_name -> compound_name . simple_name .)
    IS              reduce using rule 163 (compound_name -> compound_name . simple_name .)
    RENAMES         reduce using rule 163 (compound_name -> compound_name . simple_name .)
    )               reduce using rule 163 (compound_name -> compound_name . simple_name .)


state 204

    (233) factor -> primary STARSTAR . primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 147
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    primary                        shift and go to state 356
    used_char                      shift and go to state 144
    literal                        shift and go to state 135
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157

state 205

    (217) simple_expression -> unary term .
    (226) term -> term . multiplying factor
    (227) multiplying -> . *
    (228) multiplying -> . /
    (229) multiplying -> . MOD
    (230) multiplying -> . REM

    +               reduce using rule 217 (simple_expression -> unary term .)
    -               reduce using rule 217 (simple_expression -> unary term .)
    &               reduce using rule 217 (simple_expression -> unary term .)
    ,               reduce using rule 217 (simple_expression -> unary term .)
    ARROW           reduce using rule 217 (simple_expression -> unary term .)
    |               reduce using rule 217 (simple_expression -> unary term .)
    AND             reduce using rule 217 (simple_expression -> unary term .)
    OR              reduce using rule 217 (simple_expression -> unary term .)
    )               reduce using rule 217 (simple_expression -> unary term .)
    WITH            reduce using rule 217 (simple_expression -> unary term .)
    ;               reduce using rule 217 (simple_expression -> unary term .)
    IS              reduce using rule 217 (simple_expression -> unary term .)
    THEN            reduce using rule 217 (simple_expression -> unary term .)
    LOOP            reduce using rule 217 (simple_expression -> unary term .)
    RANGE           reduce using rule 217 (simple_expression -> unary term .)
    DIGITS          reduce using rule 217 (simple_expression -> unary term .)
    RENAMES         reduce using rule 217 (simple_expression -> unary term .)
    ASSIGNMENT      reduce using rule 217 (simple_expression -> unary term .)
    =               reduce using rule 217 (simple_expression -> unary term .)
    NOTEQUAL        reduce using rule 217 (simple_expression -> unary term .)
    <               reduce using rule 217 (simple_expression -> unary term .)
    LESSEQ          reduce using rule 217 (simple_expression -> unary term .)
    >               reduce using rule 217 (simple_expression -> unary term .)
    GREATEREQ       reduce using rule 217 (simple_expression -> unary term .)
    IN              reduce using rule 217 (simple_expression -> unary term .)
    NOT             reduce using rule 217 (simple_expression -> unary term .)
    DOTDOT          reduce using rule 217 (simple_expression -> unary term .)
    *               shift and go to state 240
    /               shift and go to state 241
    MOD             shift and go to state 242
    REM             shift and go to state 238

    multiplying                    shift and go to state 239

state 206

    (242) allocator -> NEW name .
    (241) qualified -> name . TICK parenthesized_primary
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id

    STARSTAR        reduce using rule 242 (allocator -> NEW name .)
    *               reduce using rule 242 (allocator -> NEW name .)
    /               reduce using rule 242 (allocator -> NEW name .)
    MOD             reduce using rule 242 (allocator -> NEW name .)
    REM             reduce using rule 242 (allocator -> NEW name .)
    =               reduce using rule 242 (allocator -> NEW name .)
    NOTEQUAL        reduce using rule 242 (allocator -> NEW name .)
    <               reduce using rule 242 (allocator -> NEW name .)
    LESSEQ          reduce using rule 242 (allocator -> NEW name .)
    >               reduce using rule 242 (allocator -> NEW name .)
    GREATEREQ       reduce using rule 242 (allocator -> NEW name .)
    IN              reduce using rule 242 (allocator -> NEW name .)
    NOT             reduce using rule 242 (allocator -> NEW name .)
    +               reduce using rule 242 (allocator -> NEW name .)
    -               reduce using rule 242 (allocator -> NEW name .)
    &               reduce using rule 242 (allocator -> NEW name .)
    AND             reduce using rule 242 (allocator -> NEW name .)
    OR              reduce using rule 242 (allocator -> NEW name .)
    LOOP            reduce using rule 242 (allocator -> NEW name .)
    DOTDOT          reduce using rule 242 (allocator -> NEW name .)
    ARROW           reduce using rule 242 (allocator -> NEW name .)
    |               reduce using rule 242 (allocator -> NEW name .)
    ;               reduce using rule 242 (allocator -> NEW name .)
    DIGITS          reduce using rule 242 (allocator -> NEW name .)
    RANGE           reduce using rule 242 (allocator -> NEW name .)
    )               reduce using rule 242 (allocator -> NEW name .)
    ,               reduce using rule 242 (allocator -> NEW name .)
    WITH            reduce using rule 242 (allocator -> NEW name .)
    IS              reduce using rule 242 (allocator -> NEW name .)
    THEN            reduce using rule 242 (allocator -> NEW name .)
    RENAMES         reduce using rule 242 (allocator -> NEW name .)
    ASSIGNMENT      reduce using rule 242 (allocator -> NEW name .)
    TICK            shift and go to state 245
    (               shift and go to state 243
    .               shift and go to state 244


state 207

    (243) allocator -> NEW qualified .

    STARSTAR        reduce using rule 243 (allocator -> NEW qualified .)
    *               reduce using rule 243 (allocator -> NEW qualified .)
    /               reduce using rule 243 (allocator -> NEW qualified .)
    MOD             reduce using rule 243 (allocator -> NEW qualified .)
    REM             reduce using rule 243 (allocator -> NEW qualified .)
    =               reduce using rule 243 (allocator -> NEW qualified .)
    NOTEQUAL        reduce using rule 243 (allocator -> NEW qualified .)
    <               reduce using rule 243 (allocator -> NEW qualified .)
    LESSEQ          reduce using rule 243 (allocator -> NEW qualified .)
    >               reduce using rule 243 (allocator -> NEW qualified .)
    GREATEREQ       reduce using rule 243 (allocator -> NEW qualified .)
    IN              reduce using rule 243 (allocator -> NEW qualified .)
    NOT             reduce using rule 243 (allocator -> NEW qualified .)
    +               reduce using rule 243 (allocator -> NEW qualified .)
    -               reduce using rule 243 (allocator -> NEW qualified .)
    &               reduce using rule 243 (allocator -> NEW qualified .)
    AND             reduce using rule 243 (allocator -> NEW qualified .)
    OR              reduce using rule 243 (allocator -> NEW qualified .)
    LOOP            reduce using rule 243 (allocator -> NEW qualified .)
    DOTDOT          reduce using rule 243 (allocator -> NEW qualified .)
    ARROW           reduce using rule 243 (allocator -> NEW qualified .)
    |               reduce using rule 243 (allocator -> NEW qualified .)
    ;               reduce using rule 243 (allocator -> NEW qualified .)
    DIGITS          reduce using rule 243 (allocator -> NEW qualified .)
    RANGE           reduce using rule 243 (allocator -> NEW qualified .)
    )               reduce using rule 243 (allocator -> NEW qualified .)
    ,               reduce using rule 243 (allocator -> NEW qualified .)
    WITH            reduce using rule 243 (allocator -> NEW qualified .)
    IS              reduce using rule 243 (allocator -> NEW qualified .)
    THEN            reduce using rule 243 (allocator -> NEW qualified .)
    RENAMES         reduce using rule 243 (allocator -> NEW qualified .)
    ASSIGNMENT      reduce using rule 243 (allocator -> NEW qualified .)


state 208

    (219) simple_expression -> simple_expression adding . term
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 357
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149

state 209

    (210) relational -> NOTEQUAL .

    +               reduce using rule 210 (relational -> NOTEQUAL .)
    -               reduce using rule 210 (relational -> NOTEQUAL .)
    NOT             reduce using rule 210 (relational -> NOTEQUAL .)
    INTEGER         reduce using rule 210 (relational -> NOTEQUAL .)
    BASE_INTEGER    reduce using rule 210 (relational -> NOTEQUAL .)
    FLOAT           reduce using rule 210 (relational -> NOTEQUAL .)
    BASE_FLOAT      reduce using rule 210 (relational -> NOTEQUAL .)
    NuLL            reduce using rule 210 (relational -> NOTEQUAL .)
    NEW             reduce using rule 210 (relational -> NOTEQUAL .)
    (               reduce using rule 210 (relational -> NOTEQUAL .)
    CHAR            reduce using rule 210 (relational -> NOTEQUAL .)
    IDENTIFIER      reduce using rule 210 (relational -> NOTEQUAL .)
    STRING          reduce using rule 210 (relational -> NOTEQUAL .)


state 210

    (222) adding -> + .

    NOT             reduce using rule 222 (adding -> + .)
    INTEGER         reduce using rule 222 (adding -> + .)
    BASE_INTEGER    reduce using rule 222 (adding -> + .)
    FLOAT           reduce using rule 222 (adding -> + .)
    BASE_FLOAT      reduce using rule 222 (adding -> + .)
    NuLL            reduce using rule 222 (adding -> + .)
    NEW             reduce using rule 222 (adding -> + .)
    (               reduce using rule 222 (adding -> + .)
    CHAR            reduce using rule 222 (adding -> + .)
    IDENTIFIER      reduce using rule 222 (adding -> + .)
    STRING          reduce using rule 222 (adding -> + .)


state 211

    (224) adding -> & .

    NOT             reduce using rule 224 (adding -> & .)
    INTEGER         reduce using rule 224 (adding -> & .)
    BASE_INTEGER    reduce using rule 224 (adding -> & .)
    FLOAT           reduce using rule 224 (adding -> & .)
    BASE_FLOAT      reduce using rule 224 (adding -> & .)
    NuLL            reduce using rule 224 (adding -> & .)
    NEW             reduce using rule 224 (adding -> & .)
    (               reduce using rule 224 (adding -> & .)
    CHAR            reduce using rule 224 (adding -> & .)
    IDENTIFIER      reduce using rule 224 (adding -> & .)
    STRING          reduce using rule 224 (adding -> & .)


state 212

    (223) adding -> - .

    NOT             reduce using rule 223 (adding -> - .)
    INTEGER         reduce using rule 223 (adding -> - .)
    BASE_INTEGER    reduce using rule 223 (adding -> - .)
    FLOAT           reduce using rule 223 (adding -> - .)
    BASE_FLOAT      reduce using rule 223 (adding -> - .)
    NuLL            reduce using rule 223 (adding -> - .)
    NEW             reduce using rule 223 (adding -> - .)
    (               reduce using rule 223 (adding -> - .)
    CHAR            reduce using rule 223 (adding -> - .)
    IDENTIFIER      reduce using rule 223 (adding -> - .)
    STRING          reduce using rule 223 (adding -> - .)


state 213

    (207) relation -> simple_expression membership . range
    (208) relation -> simple_expression membership . name
    (62) range -> . simple_expression DOTDOT simple_expression
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    simple_expression              shift and go to state 358
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 359
    operator_symbol                shift and go to state 149
    range                          shift and go to state 360

state 214

    (214) relational -> GREATEREQ .

    +               reduce using rule 214 (relational -> GREATEREQ .)
    -               reduce using rule 214 (relational -> GREATEREQ .)
    NOT             reduce using rule 214 (relational -> GREATEREQ .)
    INTEGER         reduce using rule 214 (relational -> GREATEREQ .)
    BASE_INTEGER    reduce using rule 214 (relational -> GREATEREQ .)
    FLOAT           reduce using rule 214 (relational -> GREATEREQ .)
    BASE_FLOAT      reduce using rule 214 (relational -> GREATEREQ .)
    NuLL            reduce using rule 214 (relational -> GREATEREQ .)
    NEW             reduce using rule 214 (relational -> GREATEREQ .)
    (               reduce using rule 214 (relational -> GREATEREQ .)
    CHAR            reduce using rule 214 (relational -> GREATEREQ .)
    IDENTIFIER      reduce using rule 214 (relational -> GREATEREQ .)
    STRING          reduce using rule 214 (relational -> GREATEREQ .)


state 215

    (212) relational -> LESSEQ .

    +               reduce using rule 212 (relational -> LESSEQ .)
    -               reduce using rule 212 (relational -> LESSEQ .)
    NOT             reduce using rule 212 (relational -> LESSEQ .)
    INTEGER         reduce using rule 212 (relational -> LESSEQ .)
    BASE_INTEGER    reduce using rule 212 (relational -> LESSEQ .)
    FLOAT           reduce using rule 212 (relational -> LESSEQ .)
    BASE_FLOAT      reduce using rule 212 (relational -> LESSEQ .)
    NuLL            reduce using rule 212 (relational -> LESSEQ .)
    NEW             reduce using rule 212 (relational -> LESSEQ .)
    (               reduce using rule 212 (relational -> LESSEQ .)
    CHAR            reduce using rule 212 (relational -> LESSEQ .)
    IDENTIFIER      reduce using rule 212 (relational -> LESSEQ .)
    STRING          reduce using rule 212 (relational -> LESSEQ .)


state 216

    (215) membership -> IN .

    IDENTIFIER      reduce using rule 215 (membership -> IN .)
    STRING          reduce using rule 215 (membership -> IN .)
    +               reduce using rule 215 (membership -> IN .)
    -               reduce using rule 215 (membership -> IN .)
    NOT             reduce using rule 215 (membership -> IN .)
    INTEGER         reduce using rule 215 (membership -> IN .)
    BASE_INTEGER    reduce using rule 215 (membership -> IN .)
    FLOAT           reduce using rule 215 (membership -> IN .)
    BASE_FLOAT      reduce using rule 215 (membership -> IN .)
    NuLL            reduce using rule 215 (membership -> IN .)
    NEW             reduce using rule 215 (membership -> IN .)
    (               reduce using rule 215 (membership -> IN .)
    CHAR            reduce using rule 215 (membership -> IN .)


state 217

    (216) membership -> NOT . IN

    IN              shift and go to state 361


state 218

    (206) relation -> simple_expression relational . simple_expression
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    simple_expression              shift and go to state 362
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149

state 219

    (209) relational -> = .

    +               reduce using rule 209 (relational -> = .)
    -               reduce using rule 209 (relational -> = .)
    NOT             reduce using rule 209 (relational -> = .)
    INTEGER         reduce using rule 209 (relational -> = .)
    BASE_INTEGER    reduce using rule 209 (relational -> = .)
    FLOAT           reduce using rule 209 (relational -> = .)
    BASE_FLOAT      reduce using rule 209 (relational -> = .)
    NuLL            reduce using rule 209 (relational -> = .)
    NEW             reduce using rule 209 (relational -> = .)
    (               reduce using rule 209 (relational -> = .)
    CHAR            reduce using rule 209 (relational -> = .)
    IDENTIFIER      reduce using rule 209 (relational -> = .)
    STRING          reduce using rule 209 (relational -> = .)


state 220

    (211) relational -> < .

    +               reduce using rule 211 (relational -> < .)
    -               reduce using rule 211 (relational -> < .)
    NOT             reduce using rule 211 (relational -> < .)
    INTEGER         reduce using rule 211 (relational -> < .)
    BASE_INTEGER    reduce using rule 211 (relational -> < .)
    FLOAT           reduce using rule 211 (relational -> < .)
    BASE_FLOAT      reduce using rule 211 (relational -> < .)
    NuLL            reduce using rule 211 (relational -> < .)
    NEW             reduce using rule 211 (relational -> < .)
    (               reduce using rule 211 (relational -> < .)
    CHAR            reduce using rule 211 (relational -> < .)
    IDENTIFIER      reduce using rule 211 (relational -> < .)
    STRING          reduce using rule 211 (relational -> < .)


state 221

    (213) relational -> > .

    +               reduce using rule 213 (relational -> > .)
    -               reduce using rule 213 (relational -> > .)
    NOT             reduce using rule 213 (relational -> > .)
    INTEGER         reduce using rule 213 (relational -> > .)
    BASE_INTEGER    reduce using rule 213 (relational -> > .)
    FLOAT           reduce using rule 213 (relational -> > .)
    BASE_FLOAT      reduce using rule 213 (relational -> > .)
    NuLL            reduce using rule 213 (relational -> > .)
    NEW             reduce using rule 213 (relational -> > .)
    (               reduce using rule 213 (relational -> > .)
    CHAR            reduce using rule 213 (relational -> > .)
    IDENTIFIER      reduce using rule 213 (relational -> > .)
    STRING          reduce using rule 213 (relational -> > .)


state 222

    (7) pragma_arg -> simple_name ARROW . expression
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 363

state 223

    (125) choice -> OTHERS .

    ARROW           reduce using rule 125 (choice -> OTHERS .)
    |               reduce using rule 125 (choice -> OTHERS .)


state 224

    (205) relation -> simple_expression .
    (206) relation -> simple_expression . relational simple_expression
    (207) relation -> simple_expression . membership range
    (208) relation -> simple_expression . membership name
    (219) simple_expression -> simple_expression . adding term
    (62) range -> simple_expression . DOTDOT simple_expression
    (209) relational -> . =
    (210) relational -> . NOTEQUAL
    (211) relational -> . <
    (212) relational -> . LESSEQ
    (213) relational -> . >
    (214) relational -> . GREATEREQ
    (215) membership -> . IN
    (216) membership -> . NOT IN
    (222) adding -> . +
    (223) adding -> . -
    (224) adding -> . &

    )               reduce using rule 205 (relation -> simple_expression .)
    WITH            reduce using rule 205 (relation -> simple_expression .)
    AND             reduce using rule 205 (relation -> simple_expression .)
    OR              reduce using rule 205 (relation -> simple_expression .)
    ,               reduce using rule 205 (relation -> simple_expression .)
    ARROW           reduce using rule 205 (relation -> simple_expression .)
    |               reduce using rule 205 (relation -> simple_expression .)
    DOTDOT          shift and go to state 364
    =               shift and go to state 219
    NOTEQUAL        shift and go to state 209
    <               shift and go to state 220
    LESSEQ          shift and go to state 215
    >               shift and go to state 221
    GREATEREQ       shift and go to state 214
    IN              shift and go to state 216
    NOT             shift and go to state 217
    +               shift and go to state 210
    -               shift and go to state 212
    &               shift and go to state 211

    adding                         shift and go to state 208
    membership                     shift and go to state 213
    relational                     shift and go to state 218

state 225

    (197) comp_assoc -> choice_s . ARROW expression
    (122) choice_s -> choice_s . | choice

    ARROW           shift and go to state 366
    |               shift and go to state 365


state 226

    (190) aggregate -> ( comp_assoc . )
    (172) value -> comp_assoc .

    )               shift and go to state 367
    ,               reduce using rule 172 (value -> comp_assoc .)


state 227

    (121) choice_s -> choice .

    ARROW           reduce using rule 121 (choice_s -> choice .)
    |               reduce using rule 121 (choice_s -> choice .)


state 228

    (191) aggregate -> ( value_s_2 . )
    (196) value_s_2 -> value_s_2 . , value

    )               shift and go to state 368
    ,               shift and go to state 369


state 229

    (173) value -> discrete_with_range .
    (124) choice -> discrete_with_range .

    )               reduce using rule 173 (value -> discrete_with_range .)
    ,               reduce using rule 173 (value -> discrete_with_range .)
    ARROW           reduce using rule 124 (choice -> discrete_with_range .)
    |               reduce using rule 124 (choice -> discrete_with_range .)


state 230

    (126) discrete_with_range -> name . range_constraint
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id
    (235) primary -> name .
    (241) qualified -> name . TICK parenthesized_primary
    (61) range_constraint -> . RANGE range

    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 370
    STARSTAR        reduce using rule 235 (primary -> name .)
    *               reduce using rule 235 (primary -> name .)
    /               reduce using rule 235 (primary -> name .)
    MOD             reduce using rule 235 (primary -> name .)
    REM             reduce using rule 235 (primary -> name .)
    DOTDOT          reduce using rule 235 (primary -> name .)
    =               reduce using rule 235 (primary -> name .)
    NOTEQUAL        reduce using rule 235 (primary -> name .)
    <               reduce using rule 235 (primary -> name .)
    LESSEQ          reduce using rule 235 (primary -> name .)
    >               reduce using rule 235 (primary -> name .)
    GREATEREQ       reduce using rule 235 (primary -> name .)
    IN              reduce using rule 235 (primary -> name .)
    NOT             reduce using rule 235 (primary -> name .)
    +               reduce using rule 235 (primary -> name .)
    -               reduce using rule 235 (primary -> name .)
    &               reduce using rule 235 (primary -> name .)
    AND             reduce using rule 235 (primary -> name .)
    OR              reduce using rule 235 (primary -> name .)
    )               reduce using rule 235 (primary -> name .)
    ,               reduce using rule 235 (primary -> name .)
    ARROW           reduce using rule 235 (primary -> name .)
    |               reduce using rule 235 (primary -> name .)
    WITH            reduce using rule 235 (primary -> name .)
    RANGE           shift and go to state 371

    range_constraint               shift and go to state 372

state 231

    (195) value_s_2 -> value . , value

    ,               shift and go to state 373


state 232

    (127) discrete_with_range -> range .

    )               reduce using rule 127 (discrete_with_range -> range .)
    ,               reduce using rule 127 (discrete_with_range -> range .)
    ARROW           reduce using rule 127 (discrete_with_range -> range .)
    |               reduce using rule 127 (discrete_with_range -> range .)


state 233

    (174) value -> error .

    )               reduce using rule 174 (value -> error .)
    ,               reduce using rule 174 (value -> error .)


state 234

    (194) aggregate -> ( NuLL . RECORD )
    (189) literal -> NuLL .

    RECORD          shift and go to state 374
    STARSTAR        reduce using rule 189 (literal -> NuLL .)
    *               reduce using rule 189 (literal -> NuLL .)
    /               reduce using rule 189 (literal -> NuLL .)
    MOD             reduce using rule 189 (literal -> NuLL .)
    REM             reduce using rule 189 (literal -> NuLL .)
    DOTDOT          reduce using rule 189 (literal -> NuLL .)
    =               reduce using rule 189 (literal -> NuLL .)
    NOTEQUAL        reduce using rule 189 (literal -> NuLL .)
    <               reduce using rule 189 (literal -> NuLL .)
    LESSEQ          reduce using rule 189 (literal -> NuLL .)
    >               reduce using rule 189 (literal -> NuLL .)
    GREATEREQ       reduce using rule 189 (literal -> NuLL .)
    IN              reduce using rule 189 (literal -> NuLL .)
    NOT             reduce using rule 189 (literal -> NuLL .)
    +               reduce using rule 189 (literal -> NuLL .)
    -               reduce using rule 189 (literal -> NuLL .)
    &               reduce using rule 189 (literal -> NuLL .)
    )               reduce using rule 189 (literal -> NuLL .)
    WITH            reduce using rule 189 (literal -> NuLL .)
    AND             reduce using rule 189 (literal -> NuLL .)
    OR              reduce using rule 189 (literal -> NuLL .)
    ,               reduce using rule 189 (literal -> NuLL .)
    ARROW           reduce using rule 189 (literal -> NuLL .)
    |               reduce using rule 189 (literal -> NuLL .)


state 235

    (240) parenthesized_primary -> ( expression . )
    (192) aggregate -> ( expression . WITH value_s )
    (193) aggregate -> ( expression . WITH NuLL RECORD )
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (171) value -> expression .
    (123) choice -> expression .
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    )               shift and go to state 375
    WITH            shift and go to state 376
    ,               reduce using rule 171 (value -> expression .)
    ARROW           reduce using rule 123 (choice -> expression .)
    |               reduce using rule 123 (choice -> expression .)
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 236

    (3) pragma -> PRAGMA simple_name ( pragma_arg_s ) . ;

    ;               shift and go to state 377


state 237

    (5) pragma_arg_s -> pragma_arg_s , . pragma_arg
    (6) pragma_arg -> . expression
    (7) pragma_arg -> . simple_name ARROW expression
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (161) simple_name -> . IDENTIFIER
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 39
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    pragma_arg                     shift and go to state 378
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 131
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    used_char                      shift and go to state 144
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 152

state 238

    (230) multiplying -> REM .

    NOT             reduce using rule 230 (multiplying -> REM .)
    INTEGER         reduce using rule 230 (multiplying -> REM .)
    BASE_INTEGER    reduce using rule 230 (multiplying -> REM .)
    FLOAT           reduce using rule 230 (multiplying -> REM .)
    BASE_FLOAT      reduce using rule 230 (multiplying -> REM .)
    NuLL            reduce using rule 230 (multiplying -> REM .)
    NEW             reduce using rule 230 (multiplying -> REM .)
    (               reduce using rule 230 (multiplying -> REM .)
    CHAR            reduce using rule 230 (multiplying -> REM .)
    IDENTIFIER      reduce using rule 230 (multiplying -> REM .)
    STRING          reduce using rule 230 (multiplying -> REM .)


state 239

    (226) term -> term multiplying . factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 147
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    literal                        shift and go to state 135
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    factor                         shift and go to state 379
    aggregate                      shift and go to state 143
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157

state 240

    (227) multiplying -> * .

    NOT             reduce using rule 227 (multiplying -> * .)
    INTEGER         reduce using rule 227 (multiplying -> * .)
    BASE_INTEGER    reduce using rule 227 (multiplying -> * .)
    FLOAT           reduce using rule 227 (multiplying -> * .)
    BASE_FLOAT      reduce using rule 227 (multiplying -> * .)
    NuLL            reduce using rule 227 (multiplying -> * .)
    NEW             reduce using rule 227 (multiplying -> * .)
    (               reduce using rule 227 (multiplying -> * .)
    CHAR            reduce using rule 227 (multiplying -> * .)
    IDENTIFIER      reduce using rule 227 (multiplying -> * .)
    STRING          reduce using rule 227 (multiplying -> * .)


state 241

    (228) multiplying -> / .

    NOT             reduce using rule 228 (multiplying -> / .)
    INTEGER         reduce using rule 228 (multiplying -> / .)
    BASE_INTEGER    reduce using rule 228 (multiplying -> / .)
    FLOAT           reduce using rule 228 (multiplying -> / .)
    BASE_FLOAT      reduce using rule 228 (multiplying -> / .)
    NuLL            reduce using rule 228 (multiplying -> / .)
    NEW             reduce using rule 228 (multiplying -> / .)
    (               reduce using rule 228 (multiplying -> / .)
    CHAR            reduce using rule 228 (multiplying -> / .)
    IDENTIFIER      reduce using rule 228 (multiplying -> / .)
    STRING          reduce using rule 228 (multiplying -> / .)


state 242

    (229) multiplying -> MOD .

    NOT             reduce using rule 229 (multiplying -> MOD .)
    INTEGER         reduce using rule 229 (multiplying -> MOD .)
    BASE_INTEGER    reduce using rule 229 (multiplying -> MOD .)
    FLOAT           reduce using rule 229 (multiplying -> MOD .)
    BASE_FLOAT      reduce using rule 229 (multiplying -> MOD .)
    NuLL            reduce using rule 229 (multiplying -> MOD .)
    NEW             reduce using rule 229 (multiplying -> MOD .)
    (               reduce using rule 229 (multiplying -> MOD .)
    CHAR            reduce using rule 229 (multiplying -> MOD .)
    IDENTIFIER      reduce using rule 229 (multiplying -> MOD .)
    STRING          reduce using rule 229 (multiplying -> MOD .)


state 243

    (168) indexed_comp -> name ( . value_s )
    (169) value_s -> . value
    (170) value_s -> . value_s , value
    (171) value -> . expression
    (172) value -> . comp_assoc
    (173) value -> . discrete_with_range
    (174) value -> . error
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (197) comp_assoc -> . choice_s ARROW expression
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 233
    OTHERS          shift and go to state 223
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    value_s                        shift and go to state 380
    simple_expression              shift and go to state 381
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    choice_s                       shift and go to state 225
    comp_assoc                     shift and go to state 382
    factor                         shift and go to state 137
    choice                         shift and go to state 227
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 146
    name                           shift and go to state 230
    operator_symbol                shift and go to state 149
    value                          shift and go to state 383
    range                          shift and go to state 232
    expression                     shift and go to state 384

state 244

    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (161) simple_name -> . IDENTIFIER
    (166) used_char -> . CHAR
    (167) operator_symbol -> . STRING

    ALL             shift and go to state 385
    IDENTIFIER      shift and go to state 39
    CHAR            shift and go to state 145
    STRING          shift and go to state 138

    used_char                      shift and go to state 387
    operator_symbol                shift and go to state 386
    simple_name                    shift and go to state 388

state 245

    (241) qualified -> name TICK . parenthesized_primary
    (179) attribute -> name TICK . attribute_id
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (180) attribute_id -> . IDENTIFIER
    (181) attribute_id -> . DIGITS
    (182) attribute_id -> . DELTA
    (183) attribute_id -> . ACCESS
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    (               shift and go to state 132
    IDENTIFIER      shift and go to state 390
    DIGITS          shift and go to state 389
    DELTA           shift and go to state 393
    ACCESS          shift and go to state 391

    attribute_id                   shift and go to state 392
    aggregate                      shift and go to state 143
    parenthesized_primary          shift and go to state 394

state 246

    (232) factor -> NOT primary .

    *               reduce using rule 232 (factor -> NOT primary .)
    /               reduce using rule 232 (factor -> NOT primary .)
    MOD             reduce using rule 232 (factor -> NOT primary .)
    REM             reduce using rule 232 (factor -> NOT primary .)
    =               reduce using rule 232 (factor -> NOT primary .)
    NOTEQUAL        reduce using rule 232 (factor -> NOT primary .)
    <               reduce using rule 232 (factor -> NOT primary .)
    LESSEQ          reduce using rule 232 (factor -> NOT primary .)
    >               reduce using rule 232 (factor -> NOT primary .)
    GREATEREQ       reduce using rule 232 (factor -> NOT primary .)
    IN              reduce using rule 232 (factor -> NOT primary .)
    NOT             reduce using rule 232 (factor -> NOT primary .)
    +               reduce using rule 232 (factor -> NOT primary .)
    -               reduce using rule 232 (factor -> NOT primary .)
    &               reduce using rule 232 (factor -> NOT primary .)
    AND             reduce using rule 232 (factor -> NOT primary .)
    OR              reduce using rule 232 (factor -> NOT primary .)
    )               reduce using rule 232 (factor -> NOT primary .)
    ,               reduce using rule 232 (factor -> NOT primary .)
    DOTDOT          reduce using rule 232 (factor -> NOT primary .)
    ARROW           reduce using rule 232 (factor -> NOT primary .)
    |               reduce using rule 232 (factor -> NOT primary .)
    RANGE           reduce using rule 232 (factor -> NOT primary .)
    ;               reduce using rule 232 (factor -> NOT primary .)
    WITH            reduce using rule 232 (factor -> NOT primary .)
    IS              reduce using rule 232 (factor -> NOT primary .)
    THEN            reduce using rule 232 (factor -> NOT primary .)
    LOOP            reduce using rule 232 (factor -> NOT primary .)
    DIGITS          reduce using rule 232 (factor -> NOT primary .)
    RENAMES         reduce using rule 232 (factor -> NOT primary .)
    ASSIGNMENT      reduce using rule 232 (factor -> NOT primary .)


state 247

    (201) logical -> AND .
    (203) short_circuit -> AND . THEN

    +               reduce using rule 201 (logical -> AND .)
    -               reduce using rule 201 (logical -> AND .)
    NOT             reduce using rule 201 (logical -> AND .)
    INTEGER         reduce using rule 201 (logical -> AND .)
    BASE_INTEGER    reduce using rule 201 (logical -> AND .)
    FLOAT           reduce using rule 201 (logical -> AND .)
    BASE_FLOAT      reduce using rule 201 (logical -> AND .)
    NuLL            reduce using rule 201 (logical -> AND .)
    NEW             reduce using rule 201 (logical -> AND .)
    (               reduce using rule 201 (logical -> AND .)
    CHAR            reduce using rule 201 (logical -> AND .)
    IDENTIFIER      reduce using rule 201 (logical -> AND .)
    STRING          reduce using rule 201 (logical -> AND .)
    THEN            shift and go to state 395


state 248

    (199) expression -> expression logical . relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 396
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149

state 249

    (200) expression -> expression short_circuit . relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 397
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149

state 250

    (202) logical -> OR .
    (204) short_circuit -> OR . ELSE

    +               reduce using rule 202 (logical -> OR .)
    -               reduce using rule 202 (logical -> OR .)
    NOT             reduce using rule 202 (logical -> OR .)
    INTEGER         reduce using rule 202 (logical -> OR .)
    BASE_INTEGER    reduce using rule 202 (logical -> OR .)
    FLOAT           reduce using rule 202 (logical -> OR .)
    BASE_FLOAT      reduce using rule 202 (logical -> OR .)
    NuLL            reduce using rule 202 (logical -> OR .)
    NEW             reduce using rule 202 (logical -> OR .)
    (               reduce using rule 202 (logical -> OR .)
    CHAR            reduce using rule 202 (logical -> OR .)
    IDENTIFIER      reduce using rule 202 (logical -> OR .)
    STRING          reduce using rule 202 (logical -> OR .)
    ELSE            shift and go to state 398


state 251

    (348) use_clause -> USE name_s ; .

    PACKAGE         reduce using rule 348 (use_clause -> USE name_s ; .)
    TASK            reduce using rule 348 (use_clause -> USE name_s ; .)
    PROTECTED       reduce using rule 348 (use_clause -> USE name_s ; .)
    error           reduce using rule 348 (use_clause -> USE name_s ; .)
    USE             reduce using rule 348 (use_clause -> USE name_s ; .)
    PRAGMA          reduce using rule 348 (use_clause -> USE name_s ; .)
    TYPE            reduce using rule 348 (use_clause -> USE name_s ; .)
    SUBTYPE         reduce using rule 348 (use_clause -> USE name_s ; .)
    FOR             reduce using rule 348 (use_clause -> USE name_s ; .)
    PROCEDURE       reduce using rule 348 (use_clause -> USE name_s ; .)
    FUNCTION        reduce using rule 348 (use_clause -> USE name_s ; .)
    GENERIC         reduce using rule 348 (use_clause -> USE name_s ; .)
    IDENTIFIER      reduce using rule 348 (use_clause -> USE name_s ; .)
    BEGIN           reduce using rule 348 (use_clause -> USE name_s ; .)
    PRIVATE         reduce using rule 348 (use_clause -> USE name_s ; .)
    WITH            reduce using rule 348 (use_clause -> USE name_s ; .)
    SEPARATE        reduce using rule 348 (use_clause -> USE name_s ; .)
    END             reduce using rule 348 (use_clause -> USE name_s ; .)


state 252

    (351) name_s -> name_s , . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 399
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 253

    (179) attribute -> name TICK . attribute_id
    (180) attribute_id -> . IDENTIFIER
    (181) attribute_id -> . DIGITS
    (182) attribute_id -> . DELTA
    (183) attribute_id -> . ACCESS

    IDENTIFIER      shift and go to state 390
    DIGITS          shift and go to state 389
    DELTA           shift and go to state 393
    ACCESS          shift and go to state 391

    attribute_id                   shift and go to state 392

state 254

    (349) use_clause -> USE TYPE name_s . ;
    (351) name_s -> name_s . , name

    ;               shift and go to state 400
    ,               shift and go to state 252


state 255

    (448) subunit -> SEPARATE ( compound_name ) . subunit_body
    (449) subunit_body -> . subprog_body
    (450) subunit_body -> . pkg_body
    (451) subunit_body -> . task_body
    (452) subunit_body -> . prot_body
    (333) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (342) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (367) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (384) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (332) subprog_spec_is_push -> . subprog_spec IS
    (315) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (316) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (317) subprog_spec -> . FUNCTION designator

    PACKAGE         shift and go to state 408
    TASK            shift and go to state 405
    PROTECTED       shift and go to state 403
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36

    subprog_body                   shift and go to state 401
    subprog_spec_is_push           shift and go to state 406
    prot_body                      shift and go to state 409
    pkg_body                       shift and go to state 410
    task_body                      shift and go to state 402
    subprog_spec                   shift and go to state 407
    subunit_body                   shift and go to state 404

state 256

    (384) prot_body -> PROTECTED BODY simple_name . IS prot_op_body_s END id_opt ;
    (456) body_stub -> PROTECTED BODY simple_name . IS SEPARATE ;

    IS              shift and go to state 411


state 257

    (371) prot_def -> IS . prot_op_decl_s prot_private_opt END id_opt
    (374) prot_op_decl_s -> .
    (375) prot_op_decl_s -> . prot_op_decl_s prot_op_decl

    PRIVATE         reduce using rule 374 (prot_op_decl_s -> .)
    ENTRY           reduce using rule 374 (prot_op_decl_s -> .)
    PROCEDURE       reduce using rule 374 (prot_op_decl_s -> .)
    FUNCTION        reduce using rule 374 (prot_op_decl_s -> .)
    PRAGMA          reduce using rule 374 (prot_op_decl_s -> .)
    FOR             reduce using rule 374 (prot_op_decl_s -> .)
    END             reduce using rule 374 (prot_op_decl_s -> .)

    prot_op_decl_s                 shift and go to state 412

state 258

    (369) prot_spec -> PROTECTED IDENTIFIER prot_def .

    ;               reduce using rule 369 (prot_spec -> PROTECTED IDENTIFIER prot_def .)


state 259

    (370) prot_spec -> PROTECTED TYPE simple_name . discrim_part_opt prot_def
    (37) discrim_part_opt -> .
    (38) discrim_part_opt -> . discrim_part
    (39) discrim_part_opt -> . ( LESSMORE )
    (110) discrim_part -> . ( discrim_spec_s )

    IS              reduce using rule 37 (discrim_part_opt -> .)
    (               shift and go to state 318

    discrim_part_opt               shift and go to state 413
    discrim_part                   shift and go to state 320

state 260

    (406) delay_stmt -> DELAY . expression ;
    (407) delay_stmt -> DELAY . UNTIL expression ;
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    UNTIL           shift and go to state 414
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 415

state 261

    (409) select_stmt -> async_select .

    LESSLESS        reduce using rule 409 (select_stmt -> async_select .)
    error           reduce using rule 409 (select_stmt -> async_select .)
    PRAGMA          reduce using rule 409 (select_stmt -> async_select .)
    NuLL            reduce using rule 409 (select_stmt -> async_select .)
    EXIT            reduce using rule 409 (select_stmt -> async_select .)
    RETURN          reduce using rule 409 (select_stmt -> async_select .)
    GOTO            reduce using rule 409 (select_stmt -> async_select .)
    DELAY           reduce using rule 409 (select_stmt -> async_select .)
    ABORT           reduce using rule 409 (select_stmt -> async_select .)
    RAISE           reduce using rule 409 (select_stmt -> async_select .)
    REQUEUE         reduce using rule 409 (select_stmt -> async_select .)
    IF              reduce using rule 409 (select_stmt -> async_select .)
    CASE            reduce using rule 409 (select_stmt -> async_select .)
    IDENTIFIER      reduce using rule 409 (select_stmt -> async_select .)
    ACCEPT          reduce using rule 409 (select_stmt -> async_select .)
    SELECT          reduce using rule 409 (select_stmt -> async_select .)
    STRING          reduce using rule 409 (select_stmt -> async_select .)
    WHILE           reduce using rule 409 (select_stmt -> async_select .)
    DECLARE         reduce using rule 409 (select_stmt -> async_select .)
    FOR             reduce using rule 409 (select_stmt -> async_select .)
    LOOP            reduce using rule 409 (select_stmt -> async_select .)
    BEGIN           reduce using rule 409 (select_stmt -> async_select .)
    OR              reduce using rule 409 (select_stmt -> async_select .)
    ELSE            reduce using rule 409 (select_stmt -> async_select .)
    THEN            reduce using rule 409 (select_stmt -> async_select .)
    END             reduce using rule 409 (select_stmt -> async_select .)
    WHEN            reduce using rule 409 (select_stmt -> async_select .)
    EXCEPTION       reduce using rule 409 (select_stmt -> async_select .)
    ELSIF           reduce using rule 409 (select_stmt -> async_select .)


state 262

    (268) compound_stmt -> select_stmt .

    LESSLESS        reduce using rule 268 (compound_stmt -> select_stmt .)
    error           reduce using rule 268 (compound_stmt -> select_stmt .)
    PRAGMA          reduce using rule 268 (compound_stmt -> select_stmt .)
    NuLL            reduce using rule 268 (compound_stmt -> select_stmt .)
    EXIT            reduce using rule 268 (compound_stmt -> select_stmt .)
    RETURN          reduce using rule 268 (compound_stmt -> select_stmt .)
    GOTO            reduce using rule 268 (compound_stmt -> select_stmt .)
    DELAY           reduce using rule 268 (compound_stmt -> select_stmt .)
    ABORT           reduce using rule 268 (compound_stmt -> select_stmt .)
    RAISE           reduce using rule 268 (compound_stmt -> select_stmt .)
    REQUEUE         reduce using rule 268 (compound_stmt -> select_stmt .)
    IF              reduce using rule 268 (compound_stmt -> select_stmt .)
    CASE            reduce using rule 268 (compound_stmt -> select_stmt .)
    IDENTIFIER      reduce using rule 268 (compound_stmt -> select_stmt .)
    ACCEPT          reduce using rule 268 (compound_stmt -> select_stmt .)
    SELECT          reduce using rule 268 (compound_stmt -> select_stmt .)
    STRING          reduce using rule 268 (compound_stmt -> select_stmt .)
    WHILE           reduce using rule 268 (compound_stmt -> select_stmt .)
    DECLARE         reduce using rule 268 (compound_stmt -> select_stmt .)
    FOR             reduce using rule 268 (compound_stmt -> select_stmt .)
    LOOP            reduce using rule 268 (compound_stmt -> select_stmt .)
    BEGIN           reduce using rule 268 (compound_stmt -> select_stmt .)
    OR              reduce using rule 268 (compound_stmt -> select_stmt .)
    ELSE            reduce using rule 268 (compound_stmt -> select_stmt .)
    END             reduce using rule 268 (compound_stmt -> select_stmt .)
    THEN            reduce using rule 268 (compound_stmt -> select_stmt .)
    WHEN            reduce using rule 268 (compound_stmt -> select_stmt .)
    EXCEPTION       reduce using rule 268 (compound_stmt -> select_stmt .)
    ELSIF           reduce using rule 268 (compound_stmt -> select_stmt .)


state 263

    (285) loop_stmt -> label_opt . iteration basic_loop id_opt ;
    (297) block -> label_opt . block_decl block_body END id_opt ;
    (288) iteration -> .
    (289) iteration -> . WHILE condition
    (290) iteration -> . iter_part reverse_opt discrete_range
    (298) block_decl -> .
    (299) block_decl -> . DECLARE decl_part
    (291) iter_part -> . FOR IDENTIFIER IN

    LOOP            reduce using rule 288 (iteration -> .)
    WHILE           shift and go to state 420
    BEGIN           reduce using rule 298 (block_decl -> .)
    DECLARE         shift and go to state 421
    FOR             shift and go to state 417

    iter_part                      shift and go to state 416
    block_decl                     shift and go to state 418
    iteration                      shift and go to state 419

state 264

    (311) goto_stmt -> GOTO . name ;
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 422
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 265

    (248) unlabeled -> simple_stmt .

    END             reduce using rule 248 (unlabeled -> simple_stmt .)
    LESSLESS        reduce using rule 248 (unlabeled -> simple_stmt .)
    error           reduce using rule 248 (unlabeled -> simple_stmt .)
    PRAGMA          reduce using rule 248 (unlabeled -> simple_stmt .)
    NuLL            reduce using rule 248 (unlabeled -> simple_stmt .)
    EXIT            reduce using rule 248 (unlabeled -> simple_stmt .)
    RETURN          reduce using rule 248 (unlabeled -> simple_stmt .)
    GOTO            reduce using rule 248 (unlabeled -> simple_stmt .)
    DELAY           reduce using rule 248 (unlabeled -> simple_stmt .)
    ABORT           reduce using rule 248 (unlabeled -> simple_stmt .)
    RAISE           reduce using rule 248 (unlabeled -> simple_stmt .)
    REQUEUE         reduce using rule 248 (unlabeled -> simple_stmt .)
    IF              reduce using rule 248 (unlabeled -> simple_stmt .)
    CASE            reduce using rule 248 (unlabeled -> simple_stmt .)
    IDENTIFIER      reduce using rule 248 (unlabeled -> simple_stmt .)
    ACCEPT          reduce using rule 248 (unlabeled -> simple_stmt .)
    SELECT          reduce using rule 248 (unlabeled -> simple_stmt .)
    STRING          reduce using rule 248 (unlabeled -> simple_stmt .)
    WHILE           reduce using rule 248 (unlabeled -> simple_stmt .)
    DECLARE         reduce using rule 248 (unlabeled -> simple_stmt .)
    FOR             reduce using rule 248 (unlabeled -> simple_stmt .)
    LOOP            reduce using rule 248 (unlabeled -> simple_stmt .)
    BEGIN           reduce using rule 248 (unlabeled -> simple_stmt .)
    EXCEPTION       reduce using rule 248 (unlabeled -> simple_stmt .)
    OR              reduce using rule 248 (unlabeled -> simple_stmt .)
    ELSE            reduce using rule 248 (unlabeled -> simple_stmt .)
    THEN            reduce using rule 248 (unlabeled -> simple_stmt .)
    ELSIF           reduce using rule 248 (unlabeled -> simple_stmt .)
    WHEN            reduce using rule 248 (unlabeled -> simple_stmt .)


state 266

    (265) compound_stmt -> loop_stmt .

    LESSLESS        reduce using rule 265 (compound_stmt -> loop_stmt .)
    error           reduce using rule 265 (compound_stmt -> loop_stmt .)
    PRAGMA          reduce using rule 265 (compound_stmt -> loop_stmt .)
    NuLL            reduce using rule 265 (compound_stmt -> loop_stmt .)
    EXIT            reduce using rule 265 (compound_stmt -> loop_stmt .)
    RETURN          reduce using rule 265 (compound_stmt -> loop_stmt .)
    GOTO            reduce using rule 265 (compound_stmt -> loop_stmt .)
    DELAY           reduce using rule 265 (compound_stmt -> loop_stmt .)
    ABORT           reduce using rule 265 (compound_stmt -> loop_stmt .)
    RAISE           reduce using rule 265 (compound_stmt -> loop_stmt .)
    REQUEUE         reduce using rule 265 (compound_stmt -> loop_stmt .)
    IF              reduce using rule 265 (compound_stmt -> loop_stmt .)
    CASE            reduce using rule 265 (compound_stmt -> loop_stmt .)
    IDENTIFIER      reduce using rule 265 (compound_stmt -> loop_stmt .)
    ACCEPT          reduce using rule 265 (compound_stmt -> loop_stmt .)
    SELECT          reduce using rule 265 (compound_stmt -> loop_stmt .)
    STRING          reduce using rule 265 (compound_stmt -> loop_stmt .)
    WHILE           reduce using rule 265 (compound_stmt -> loop_stmt .)
    DECLARE         reduce using rule 265 (compound_stmt -> loop_stmt .)
    FOR             reduce using rule 265 (compound_stmt -> loop_stmt .)
    LOOP            reduce using rule 265 (compound_stmt -> loop_stmt .)
    BEGIN           reduce using rule 265 (compound_stmt -> loop_stmt .)
    OR              reduce using rule 265 (compound_stmt -> loop_stmt .)
    ELSE            reduce using rule 265 (compound_stmt -> loop_stmt .)
    END             reduce using rule 265 (compound_stmt -> loop_stmt .)
    THEN            reduce using rule 265 (compound_stmt -> loop_stmt .)
    WHEN            reduce using rule 265 (compound_stmt -> loop_stmt .)
    EXCEPTION       reduce using rule 265 (compound_stmt -> loop_stmt .)
    ELSIF           reduce using rule 265 (compound_stmt -> loop_stmt .)


state 267

    (512) code_stmt -> qualified . ;

    ;               shift and go to state 423


state 268

    (263) compound_stmt -> if_stmt .

    LESSLESS        reduce using rule 263 (compound_stmt -> if_stmt .)
    error           reduce using rule 263 (compound_stmt -> if_stmt .)
    PRAGMA          reduce using rule 263 (compound_stmt -> if_stmt .)
    NuLL            reduce using rule 263 (compound_stmt -> if_stmt .)
    EXIT            reduce using rule 263 (compound_stmt -> if_stmt .)
    RETURN          reduce using rule 263 (compound_stmt -> if_stmt .)
    GOTO            reduce using rule 263 (compound_stmt -> if_stmt .)
    DELAY           reduce using rule 263 (compound_stmt -> if_stmt .)
    ABORT           reduce using rule 263 (compound_stmt -> if_stmt .)
    RAISE           reduce using rule 263 (compound_stmt -> if_stmt .)
    REQUEUE         reduce using rule 263 (compound_stmt -> if_stmt .)
    IF              reduce using rule 263 (compound_stmt -> if_stmt .)
    CASE            reduce using rule 263 (compound_stmt -> if_stmt .)
    IDENTIFIER      reduce using rule 263 (compound_stmt -> if_stmt .)
    ACCEPT          reduce using rule 263 (compound_stmt -> if_stmt .)
    SELECT          reduce using rule 263 (compound_stmt -> if_stmt .)
    STRING          reduce using rule 263 (compound_stmt -> if_stmt .)
    WHILE           reduce using rule 263 (compound_stmt -> if_stmt .)
    DECLARE         reduce using rule 263 (compound_stmt -> if_stmt .)
    FOR             reduce using rule 263 (compound_stmt -> if_stmt .)
    LOOP            reduce using rule 263 (compound_stmt -> if_stmt .)
    BEGIN           reduce using rule 263 (compound_stmt -> if_stmt .)
    OR              reduce using rule 263 (compound_stmt -> if_stmt .)
    ELSE            reduce using rule 263 (compound_stmt -> if_stmt .)
    END             reduce using rule 263 (compound_stmt -> if_stmt .)
    THEN            reduce using rule 263 (compound_stmt -> if_stmt .)
    WHEN            reduce using rule 263 (compound_stmt -> if_stmt .)
    EXCEPTION       reduce using rule 263 (compound_stmt -> if_stmt .)
    ELSIF           reduce using rule 263 (compound_stmt -> if_stmt .)


state 269

    (271) assign_stmt -> name . ASSIGNMENT expression ;
    (334) procedure_call -> name . ;
    (241) qualified -> name . TICK parenthesized_primary
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id

    ASSIGNMENT      shift and go to state 424
    ;               shift and go to state 425
    TICK            shift and go to state 245
    (               shift and go to state 243
    .               shift and go to state 244


state 270

    (427) abort_stmt -> ABORT . name_s ;
    (350) name_s -> . name
    (351) name_s -> . name_s , name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name_s                         shift and go to state 426
    name                           shift and go to state 155
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 271

    (270) null_stmt -> NuLL . ;

    ;               shift and go to state 427


state 272

    (269) label -> LESSLESS . IDENTIFIER MOREMORE

    IDENTIFIER      shift and go to state 428


state 273

    (267) compound_stmt -> accept_stmt .

    LESSLESS        reduce using rule 267 (compound_stmt -> accept_stmt .)
    error           reduce using rule 267 (compound_stmt -> accept_stmt .)
    PRAGMA          reduce using rule 267 (compound_stmt -> accept_stmt .)
    NuLL            reduce using rule 267 (compound_stmt -> accept_stmt .)
    EXIT            reduce using rule 267 (compound_stmt -> accept_stmt .)
    RETURN          reduce using rule 267 (compound_stmt -> accept_stmt .)
    GOTO            reduce using rule 267 (compound_stmt -> accept_stmt .)
    DELAY           reduce using rule 267 (compound_stmt -> accept_stmt .)
    ABORT           reduce using rule 267 (compound_stmt -> accept_stmt .)
    RAISE           reduce using rule 267 (compound_stmt -> accept_stmt .)
    REQUEUE         reduce using rule 267 (compound_stmt -> accept_stmt .)
    IF              reduce using rule 267 (compound_stmt -> accept_stmt .)
    CASE            reduce using rule 267 (compound_stmt -> accept_stmt .)
    IDENTIFIER      reduce using rule 267 (compound_stmt -> accept_stmt .)
    ACCEPT          reduce using rule 267 (compound_stmt -> accept_stmt .)
    SELECT          reduce using rule 267 (compound_stmt -> accept_stmt .)
    STRING          reduce using rule 267 (compound_stmt -> accept_stmt .)
    WHILE           reduce using rule 267 (compound_stmt -> accept_stmt .)
    DECLARE         reduce using rule 267 (compound_stmt -> accept_stmt .)
    FOR             reduce using rule 267 (compound_stmt -> accept_stmt .)
    LOOP            reduce using rule 267 (compound_stmt -> accept_stmt .)
    BEGIN           reduce using rule 267 (compound_stmt -> accept_stmt .)
    OR              reduce using rule 267 (compound_stmt -> accept_stmt .)
    ELSE            reduce using rule 267 (compound_stmt -> accept_stmt .)
    END             reduce using rule 267 (compound_stmt -> accept_stmt .)
    THEN            reduce using rule 267 (compound_stmt -> accept_stmt .)
    WHEN            reduce using rule 267 (compound_stmt -> accept_stmt .)
    EXCEPTION       reduce using rule 267 (compound_stmt -> accept_stmt .)
    ELSIF           reduce using rule 267 (compound_stmt -> accept_stmt .)


state 274

    (309) return_stmt -> RETURN . ;
    (310) return_stmt -> RETURN . expression ;
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    ;               shift and go to state 429
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 430

state 275

    (403) accept_hdr -> ACCEPT . entry_name formal_part_opt
    (404) entry_name -> . simple_name
    (405) entry_name -> . entry_name ( expression )
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    entry_name                     shift and go to state 431
    simple_name                    shift and go to state 432

state 276

    (256) simple_stmt -> procedure_call .

    END             reduce using rule 256 (simple_stmt -> procedure_call .)
    LESSLESS        reduce using rule 256 (simple_stmt -> procedure_call .)
    error           reduce using rule 256 (simple_stmt -> procedure_call .)
    PRAGMA          reduce using rule 256 (simple_stmt -> procedure_call .)
    NuLL            reduce using rule 256 (simple_stmt -> procedure_call .)
    EXIT            reduce using rule 256 (simple_stmt -> procedure_call .)
    RETURN          reduce using rule 256 (simple_stmt -> procedure_call .)
    GOTO            reduce using rule 256 (simple_stmt -> procedure_call .)
    DELAY           reduce using rule 256 (simple_stmt -> procedure_call .)
    ABORT           reduce using rule 256 (simple_stmt -> procedure_call .)
    RAISE           reduce using rule 256 (simple_stmt -> procedure_call .)
    REQUEUE         reduce using rule 256 (simple_stmt -> procedure_call .)
    IF              reduce using rule 256 (simple_stmt -> procedure_call .)
    CASE            reduce using rule 256 (simple_stmt -> procedure_call .)
    IDENTIFIER      reduce using rule 256 (simple_stmt -> procedure_call .)
    ACCEPT          reduce using rule 256 (simple_stmt -> procedure_call .)
    SELECT          reduce using rule 256 (simple_stmt -> procedure_call .)
    STRING          reduce using rule 256 (simple_stmt -> procedure_call .)
    WHILE           reduce using rule 256 (simple_stmt -> procedure_call .)
    DECLARE         reduce using rule 256 (simple_stmt -> procedure_call .)
    FOR             reduce using rule 256 (simple_stmt -> procedure_call .)
    LOOP            reduce using rule 256 (simple_stmt -> procedure_call .)
    BEGIN           reduce using rule 256 (simple_stmt -> procedure_call .)
    WHEN            reduce using rule 256 (simple_stmt -> procedure_call .)
    EXCEPTION       reduce using rule 256 (simple_stmt -> procedure_call .)
    OR              reduce using rule 256 (simple_stmt -> procedure_call .)
    ELSE            reduce using rule 256 (simple_stmt -> procedure_call .)
    THEN            reduce using rule 256 (simple_stmt -> procedure_call .)
    ELSIF           reduce using rule 256 (simple_stmt -> procedure_call .)


state 277

    (412) select_wait -> SELECT . guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> SELECT . delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> SELECT . entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> SELECT . entry_call stmts_opt ELSE statement_s END SELECT ;
    (413) guarded_select_alt -> . select_alt
    (414) guarded_select_alt -> . WHEN condition ARROW select_alt
    (420) delay_or_entry_alt -> . delay_stmt stmts_opt
    (421) delay_or_entry_alt -> . entry_call stmts_opt
    (400) entry_call -> . procedure_call
    (417) select_alt -> . accept_stmt stmts_opt
    (418) select_alt -> . delay_stmt stmts_opt
    (419) select_alt -> . TERMINATE ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (334) procedure_call -> . name ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    WHEN            shift and go to state 437
    TERMINATE       shift and go to state 442
    DELAY           shift and go to state 260
    ACCEPT          shift and go to state 275
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    accept_stmt                    shift and go to state 433
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    entry_call                     shift and go to state 434
    delay_or_entry_alt             shift and go to state 436
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157
    guarded_select_alt             shift and go to state 438
    select_alt                     shift and go to state 439
    delay_stmt                     shift and go to state 440
    accept_hdr                     shift and go to state 292
    name                           shift and go to state 441
    operator_symbol                shift and go to state 149
    procedure_call                 shift and go to state 435

state 278

    (264) compound_stmt -> case_stmt .

    LESSLESS        reduce using rule 264 (compound_stmt -> case_stmt .)
    error           reduce using rule 264 (compound_stmt -> case_stmt .)
    PRAGMA          reduce using rule 264 (compound_stmt -> case_stmt .)
    NuLL            reduce using rule 264 (compound_stmt -> case_stmt .)
    EXIT            reduce using rule 264 (compound_stmt -> case_stmt .)
    RETURN          reduce using rule 264 (compound_stmt -> case_stmt .)
    GOTO            reduce using rule 264 (compound_stmt -> case_stmt .)
    DELAY           reduce using rule 264 (compound_stmt -> case_stmt .)
    ABORT           reduce using rule 264 (compound_stmt -> case_stmt .)
    RAISE           reduce using rule 264 (compound_stmt -> case_stmt .)
    REQUEUE         reduce using rule 264 (compound_stmt -> case_stmt .)
    IF              reduce using rule 264 (compound_stmt -> case_stmt .)
    CASE            reduce using rule 264 (compound_stmt -> case_stmt .)
    IDENTIFIER      reduce using rule 264 (compound_stmt -> case_stmt .)
    ACCEPT          reduce using rule 264 (compound_stmt -> case_stmt .)
    SELECT          reduce using rule 264 (compound_stmt -> case_stmt .)
    STRING          reduce using rule 264 (compound_stmt -> case_stmt .)
    WHILE           reduce using rule 264 (compound_stmt -> case_stmt .)
    DECLARE         reduce using rule 264 (compound_stmt -> case_stmt .)
    FOR             reduce using rule 264 (compound_stmt -> case_stmt .)
    LOOP            reduce using rule 264 (compound_stmt -> case_stmt .)
    BEGIN           reduce using rule 264 (compound_stmt -> case_stmt .)
    OR              reduce using rule 264 (compound_stmt -> case_stmt .)
    ELSE            reduce using rule 264 (compound_stmt -> case_stmt .)
    END             reduce using rule 264 (compound_stmt -> case_stmt .)
    THEN            reduce using rule 264 (compound_stmt -> case_stmt .)
    WHEN            reduce using rule 264 (compound_stmt -> case_stmt .)
    EXCEPTION       reduce using rule 264 (compound_stmt -> case_stmt .)
    ELSIF           reduce using rule 264 (compound_stmt -> case_stmt .)


state 279

    (247) statement -> label . statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    accept_hdr                     shift and go to state 292
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 443
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 280

    (249) unlabeled -> compound_stmt .

    END             reduce using rule 249 (unlabeled -> compound_stmt .)
    LESSLESS        reduce using rule 249 (unlabeled -> compound_stmt .)
    error           reduce using rule 249 (unlabeled -> compound_stmt .)
    PRAGMA          reduce using rule 249 (unlabeled -> compound_stmt .)
    NuLL            reduce using rule 249 (unlabeled -> compound_stmt .)
    EXIT            reduce using rule 249 (unlabeled -> compound_stmt .)
    RETURN          reduce using rule 249 (unlabeled -> compound_stmt .)
    GOTO            reduce using rule 249 (unlabeled -> compound_stmt .)
    DELAY           reduce using rule 249 (unlabeled -> compound_stmt .)
    ABORT           reduce using rule 249 (unlabeled -> compound_stmt .)
    RAISE           reduce using rule 249 (unlabeled -> compound_stmt .)
    REQUEUE         reduce using rule 249 (unlabeled -> compound_stmt .)
    IF              reduce using rule 249 (unlabeled -> compound_stmt .)
    CASE            reduce using rule 249 (unlabeled -> compound_stmt .)
    IDENTIFIER      reduce using rule 249 (unlabeled -> compound_stmt .)
    ACCEPT          reduce using rule 249 (unlabeled -> compound_stmt .)
    SELECT          reduce using rule 249 (unlabeled -> compound_stmt .)
    STRING          reduce using rule 249 (unlabeled -> compound_stmt .)
    WHILE           reduce using rule 249 (unlabeled -> compound_stmt .)
    DECLARE         reduce using rule 249 (unlabeled -> compound_stmt .)
    FOR             reduce using rule 249 (unlabeled -> compound_stmt .)
    LOOP            reduce using rule 249 (unlabeled -> compound_stmt .)
    BEGIN           reduce using rule 249 (unlabeled -> compound_stmt .)
    EXCEPTION       reduce using rule 249 (unlabeled -> compound_stmt .)
    OR              reduce using rule 249 (unlabeled -> compound_stmt .)
    ELSE            reduce using rule 249 (unlabeled -> compound_stmt .)
    THEN            reduce using rule 249 (unlabeled -> compound_stmt .)
    ELSIF           reduce using rule 249 (unlabeled -> compound_stmt .)
    WHEN            reduce using rule 249 (unlabeled -> compound_stmt .)


state 281

    (255) simple_stmt -> goto_stmt .

    END             reduce using rule 255 (simple_stmt -> goto_stmt .)
    LESSLESS        reduce using rule 255 (simple_stmt -> goto_stmt .)
    error           reduce using rule 255 (simple_stmt -> goto_stmt .)
    PRAGMA          reduce using rule 255 (simple_stmt -> goto_stmt .)
    NuLL            reduce using rule 255 (simple_stmt -> goto_stmt .)
    EXIT            reduce using rule 255 (simple_stmt -> goto_stmt .)
    RETURN          reduce using rule 255 (simple_stmt -> goto_stmt .)
    GOTO            reduce using rule 255 (simple_stmt -> goto_stmt .)
    DELAY           reduce using rule 255 (simple_stmt -> goto_stmt .)
    ABORT           reduce using rule 255 (simple_stmt -> goto_stmt .)
    RAISE           reduce using rule 255 (simple_stmt -> goto_stmt .)
    REQUEUE         reduce using rule 255 (simple_stmt -> goto_stmt .)
    IF              reduce using rule 255 (simple_stmt -> goto_stmt .)
    CASE            reduce using rule 255 (simple_stmt -> goto_stmt .)
    IDENTIFIER      reduce using rule 255 (simple_stmt -> goto_stmt .)
    ACCEPT          reduce using rule 255 (simple_stmt -> goto_stmt .)
    SELECT          reduce using rule 255 (simple_stmt -> goto_stmt .)
    STRING          reduce using rule 255 (simple_stmt -> goto_stmt .)
    WHILE           reduce using rule 255 (simple_stmt -> goto_stmt .)
    DECLARE         reduce using rule 255 (simple_stmt -> goto_stmt .)
    FOR             reduce using rule 255 (simple_stmt -> goto_stmt .)
    LOOP            reduce using rule 255 (simple_stmt -> goto_stmt .)
    BEGIN           reduce using rule 255 (simple_stmt -> goto_stmt .)
    WHEN            reduce using rule 255 (simple_stmt -> goto_stmt .)
    EXCEPTION       reduce using rule 255 (simple_stmt -> goto_stmt .)
    OR              reduce using rule 255 (simple_stmt -> goto_stmt .)
    ELSE            reduce using rule 255 (simple_stmt -> goto_stmt .)
    THEN            reduce using rule 255 (simple_stmt -> goto_stmt .)
    ELSIF           reduce using rule 255 (simple_stmt -> goto_stmt .)


state 282

    (280) case_stmt -> case_hdr . pragma_s alternative_s END CASE ;
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 444

state 283

    (266) compound_stmt -> block .

    LESSLESS        reduce using rule 266 (compound_stmt -> block .)
    error           reduce using rule 266 (compound_stmt -> block .)
    PRAGMA          reduce using rule 266 (compound_stmt -> block .)
    NuLL            reduce using rule 266 (compound_stmt -> block .)
    EXIT            reduce using rule 266 (compound_stmt -> block .)
    RETURN          reduce using rule 266 (compound_stmt -> block .)
    GOTO            reduce using rule 266 (compound_stmt -> block .)
    DELAY           reduce using rule 266 (compound_stmt -> block .)
    ABORT           reduce using rule 266 (compound_stmt -> block .)
    RAISE           reduce using rule 266 (compound_stmt -> block .)
    REQUEUE         reduce using rule 266 (compound_stmt -> block .)
    IF              reduce using rule 266 (compound_stmt -> block .)
    CASE            reduce using rule 266 (compound_stmt -> block .)
    IDENTIFIER      reduce using rule 266 (compound_stmt -> block .)
    ACCEPT          reduce using rule 266 (compound_stmt -> block .)
    SELECT          reduce using rule 266 (compound_stmt -> block .)
    STRING          reduce using rule 266 (compound_stmt -> block .)
    WHILE           reduce using rule 266 (compound_stmt -> block .)
    DECLARE         reduce using rule 266 (compound_stmt -> block .)
    FOR             reduce using rule 266 (compound_stmt -> block .)
    LOOP            reduce using rule 266 (compound_stmt -> block .)
    BEGIN           reduce using rule 266 (compound_stmt -> block .)
    OR              reduce using rule 266 (compound_stmt -> block .)
    ELSE            reduce using rule 266 (compound_stmt -> block .)
    END             reduce using rule 266 (compound_stmt -> block .)
    THEN            reduce using rule 266 (compound_stmt -> block .)
    WHEN            reduce using rule 266 (compound_stmt -> block .)
    EXCEPTION       reduce using rule 266 (compound_stmt -> block .)
    ELSIF           reduce using rule 266 (compound_stmt -> block .)


state 284

    (466) raise_stmt -> RAISE . name_opt ;
    (305) name_opt -> .
    (306) name_opt -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    ;               reduce using rule 305 (name_opt -> .)
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 445
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    name_opt                       shift and go to state 446
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 285

    (254) simple_stmt -> return_stmt .

    END             reduce using rule 254 (simple_stmt -> return_stmt .)
    LESSLESS        reduce using rule 254 (simple_stmt -> return_stmt .)
    error           reduce using rule 254 (simple_stmt -> return_stmt .)
    PRAGMA          reduce using rule 254 (simple_stmt -> return_stmt .)
    NuLL            reduce using rule 254 (simple_stmt -> return_stmt .)
    EXIT            reduce using rule 254 (simple_stmt -> return_stmt .)
    RETURN          reduce using rule 254 (simple_stmt -> return_stmt .)
    GOTO            reduce using rule 254 (simple_stmt -> return_stmt .)
    DELAY           reduce using rule 254 (simple_stmt -> return_stmt .)
    ABORT           reduce using rule 254 (simple_stmt -> return_stmt .)
    RAISE           reduce using rule 254 (simple_stmt -> return_stmt .)
    REQUEUE         reduce using rule 254 (simple_stmt -> return_stmt .)
    IF              reduce using rule 254 (simple_stmt -> return_stmt .)
    CASE            reduce using rule 254 (simple_stmt -> return_stmt .)
    IDENTIFIER      reduce using rule 254 (simple_stmt -> return_stmt .)
    ACCEPT          reduce using rule 254 (simple_stmt -> return_stmt .)
    SELECT          reduce using rule 254 (simple_stmt -> return_stmt .)
    STRING          reduce using rule 254 (simple_stmt -> return_stmt .)
    WHILE           reduce using rule 254 (simple_stmt -> return_stmt .)
    DECLARE         reduce using rule 254 (simple_stmt -> return_stmt .)
    FOR             reduce using rule 254 (simple_stmt -> return_stmt .)
    LOOP            reduce using rule 254 (simple_stmt -> return_stmt .)
    BEGIN           reduce using rule 254 (simple_stmt -> return_stmt .)
    WHEN            reduce using rule 254 (simple_stmt -> return_stmt .)
    EXCEPTION       reduce using rule 254 (simple_stmt -> return_stmt .)
    OR              reduce using rule 254 (simple_stmt -> return_stmt .)
    ELSE            reduce using rule 254 (simple_stmt -> return_stmt .)
    THEN            reduce using rule 254 (simple_stmt -> return_stmt .)
    ELSIF           reduce using rule 254 (simple_stmt -> return_stmt .)


state 286

    (300) block_body -> BEGIN handled_stmt_s .

    END             reduce using rule 300 (block_body -> BEGIN handled_stmt_s .)


state 287

    (281) case_hdr -> CASE . expression IS
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 447

state 288

    (467) requeue_stmt -> REQUEUE . name ;
    (468) requeue_stmt -> REQUEUE . name WITH ABORT ;
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 448
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 289

    (244) statement_s -> statement .

    LESSLESS        reduce using rule 244 (statement_s -> statement .)
    error           reduce using rule 244 (statement_s -> statement .)
    PRAGMA          reduce using rule 244 (statement_s -> statement .)
    NuLL            reduce using rule 244 (statement_s -> statement .)
    EXIT            reduce using rule 244 (statement_s -> statement .)
    RETURN          reduce using rule 244 (statement_s -> statement .)
    GOTO            reduce using rule 244 (statement_s -> statement .)
    DELAY           reduce using rule 244 (statement_s -> statement .)
    ABORT           reduce using rule 244 (statement_s -> statement .)
    RAISE           reduce using rule 244 (statement_s -> statement .)
    REQUEUE         reduce using rule 244 (statement_s -> statement .)
    IF              reduce using rule 244 (statement_s -> statement .)
    CASE            reduce using rule 244 (statement_s -> statement .)
    IDENTIFIER      reduce using rule 244 (statement_s -> statement .)
    ACCEPT          reduce using rule 244 (statement_s -> statement .)
    SELECT          reduce using rule 244 (statement_s -> statement .)
    STRING          reduce using rule 244 (statement_s -> statement .)
    WHILE           reduce using rule 244 (statement_s -> statement .)
    DECLARE         reduce using rule 244 (statement_s -> statement .)
    FOR             reduce using rule 244 (statement_s -> statement .)
    LOOP            reduce using rule 244 (statement_s -> statement .)
    BEGIN           reduce using rule 244 (statement_s -> statement .)
    OR              reduce using rule 244 (statement_s -> statement .)
    ELSE            reduce using rule 244 (statement_s -> statement .)
    THEN            reduce using rule 244 (statement_s -> statement .)
    EXCEPTION       reduce using rule 244 (statement_s -> statement .)
    END             reduce using rule 244 (statement_s -> statement .)
    WHEN            reduce using rule 244 (statement_s -> statement .)
    ELSIF           reduce using rule 244 (statement_s -> statement .)


state 290

    (287) label_opt -> IDENTIFIER . :
    (161) simple_name -> IDENTIFIER .

    :               shift and go to state 449
    ASSIGNMENT      reduce using rule 161 (simple_name -> IDENTIFIER .)
    ;               reduce using rule 161 (simple_name -> IDENTIFIER .)
    TICK            reduce using rule 161 (simple_name -> IDENTIFIER .)
    (               reduce using rule 161 (simple_name -> IDENTIFIER .)
    .               reduce using rule 161 (simple_name -> IDENTIFIER .)


state 291

    (257) simple_stmt -> delay_stmt .

    END             reduce using rule 257 (simple_stmt -> delay_stmt .)
    LESSLESS        reduce using rule 257 (simple_stmt -> delay_stmt .)
    error           reduce using rule 257 (simple_stmt -> delay_stmt .)
    PRAGMA          reduce using rule 257 (simple_stmt -> delay_stmt .)
    NuLL            reduce using rule 257 (simple_stmt -> delay_stmt .)
    EXIT            reduce using rule 257 (simple_stmt -> delay_stmt .)
    RETURN          reduce using rule 257 (simple_stmt -> delay_stmt .)
    GOTO            reduce using rule 257 (simple_stmt -> delay_stmt .)
    DELAY           reduce using rule 257 (simple_stmt -> delay_stmt .)
    ABORT           reduce using rule 257 (simple_stmt -> delay_stmt .)
    RAISE           reduce using rule 257 (simple_stmt -> delay_stmt .)
    REQUEUE         reduce using rule 257 (simple_stmt -> delay_stmt .)
    IF              reduce using rule 257 (simple_stmt -> delay_stmt .)
    CASE            reduce using rule 257 (simple_stmt -> delay_stmt .)
    IDENTIFIER      reduce using rule 257 (simple_stmt -> delay_stmt .)
    ACCEPT          reduce using rule 257 (simple_stmt -> delay_stmt .)
    SELECT          reduce using rule 257 (simple_stmt -> delay_stmt .)
    STRING          reduce using rule 257 (simple_stmt -> delay_stmt .)
    WHILE           reduce using rule 257 (simple_stmt -> delay_stmt .)
    DECLARE         reduce using rule 257 (simple_stmt -> delay_stmt .)
    FOR             reduce using rule 257 (simple_stmt -> delay_stmt .)
    LOOP            reduce using rule 257 (simple_stmt -> delay_stmt .)
    BEGIN           reduce using rule 257 (simple_stmt -> delay_stmt .)
    WHEN            reduce using rule 257 (simple_stmt -> delay_stmt .)
    EXCEPTION       reduce using rule 257 (simple_stmt -> delay_stmt .)
    OR              reduce using rule 257 (simple_stmt -> delay_stmt .)
    ELSE            reduce using rule 257 (simple_stmt -> delay_stmt .)
    THEN            reduce using rule 257 (simple_stmt -> delay_stmt .)
    ELSIF           reduce using rule 257 (simple_stmt -> delay_stmt .)


state 292

    (401) accept_stmt -> accept_hdr . ;
    (402) accept_stmt -> accept_hdr . DO handled_stmt_s END id_opt ;

    ;               shift and go to state 451
    DO              shift and go to state 450


state 293

    (250) unlabeled -> pragma .

    END             reduce using rule 250 (unlabeled -> pragma .)
    LESSLESS        reduce using rule 250 (unlabeled -> pragma .)
    error           reduce using rule 250 (unlabeled -> pragma .)
    PRAGMA          reduce using rule 250 (unlabeled -> pragma .)
    NuLL            reduce using rule 250 (unlabeled -> pragma .)
    EXIT            reduce using rule 250 (unlabeled -> pragma .)
    RETURN          reduce using rule 250 (unlabeled -> pragma .)
    GOTO            reduce using rule 250 (unlabeled -> pragma .)
    DELAY           reduce using rule 250 (unlabeled -> pragma .)
    ABORT           reduce using rule 250 (unlabeled -> pragma .)
    RAISE           reduce using rule 250 (unlabeled -> pragma .)
    REQUEUE         reduce using rule 250 (unlabeled -> pragma .)
    IF              reduce using rule 250 (unlabeled -> pragma .)
    CASE            reduce using rule 250 (unlabeled -> pragma .)
    IDENTIFIER      reduce using rule 250 (unlabeled -> pragma .)
    ACCEPT          reduce using rule 250 (unlabeled -> pragma .)
    SELECT          reduce using rule 250 (unlabeled -> pragma .)
    STRING          reduce using rule 250 (unlabeled -> pragma .)
    WHILE           reduce using rule 250 (unlabeled -> pragma .)
    DECLARE         reduce using rule 250 (unlabeled -> pragma .)
    FOR             reduce using rule 250 (unlabeled -> pragma .)
    LOOP            reduce using rule 250 (unlabeled -> pragma .)
    BEGIN           reduce using rule 250 (unlabeled -> pragma .)
    EXCEPTION       reduce using rule 250 (unlabeled -> pragma .)
    OR              reduce using rule 250 (unlabeled -> pragma .)
    ELSE            reduce using rule 250 (unlabeled -> pragma .)
    THEN            reduce using rule 250 (unlabeled -> pragma .)
    ELSIF           reduce using rule 250 (unlabeled -> pragma .)
    WHEN            reduce using rule 250 (unlabeled -> pragma .)


state 294

    (261) simple_stmt -> requeue_stmt .

    END             reduce using rule 261 (simple_stmt -> requeue_stmt .)
    LESSLESS        reduce using rule 261 (simple_stmt -> requeue_stmt .)
    error           reduce using rule 261 (simple_stmt -> requeue_stmt .)
    PRAGMA          reduce using rule 261 (simple_stmt -> requeue_stmt .)
    NuLL            reduce using rule 261 (simple_stmt -> requeue_stmt .)
    EXIT            reduce using rule 261 (simple_stmt -> requeue_stmt .)
    RETURN          reduce using rule 261 (simple_stmt -> requeue_stmt .)
    GOTO            reduce using rule 261 (simple_stmt -> requeue_stmt .)
    DELAY           reduce using rule 261 (simple_stmt -> requeue_stmt .)
    ABORT           reduce using rule 261 (simple_stmt -> requeue_stmt .)
    RAISE           reduce using rule 261 (simple_stmt -> requeue_stmt .)
    REQUEUE         reduce using rule 261 (simple_stmt -> requeue_stmt .)
    IF              reduce using rule 261 (simple_stmt -> requeue_stmt .)
    CASE            reduce using rule 261 (simple_stmt -> requeue_stmt .)
    IDENTIFIER      reduce using rule 261 (simple_stmt -> requeue_stmt .)
    ACCEPT          reduce using rule 261 (simple_stmt -> requeue_stmt .)
    SELECT          reduce using rule 261 (simple_stmt -> requeue_stmt .)
    STRING          reduce using rule 261 (simple_stmt -> requeue_stmt .)
    WHILE           reduce using rule 261 (simple_stmt -> requeue_stmt .)
    DECLARE         reduce using rule 261 (simple_stmt -> requeue_stmt .)
    FOR             reduce using rule 261 (simple_stmt -> requeue_stmt .)
    LOOP            reduce using rule 261 (simple_stmt -> requeue_stmt .)
    BEGIN           reduce using rule 261 (simple_stmt -> requeue_stmt .)
    WHEN            reduce using rule 261 (simple_stmt -> requeue_stmt .)
    EXCEPTION       reduce using rule 261 (simple_stmt -> requeue_stmt .)
    OR              reduce using rule 261 (simple_stmt -> requeue_stmt .)
    ELSE            reduce using rule 261 (simple_stmt -> requeue_stmt .)
    THEN            reduce using rule 261 (simple_stmt -> requeue_stmt .)
    ELSIF           reduce using rule 261 (simple_stmt -> requeue_stmt .)


state 295

    (259) simple_stmt -> raise_stmt .

    END             reduce using rule 259 (simple_stmt -> raise_stmt .)
    LESSLESS        reduce using rule 259 (simple_stmt -> raise_stmt .)
    error           reduce using rule 259 (simple_stmt -> raise_stmt .)
    PRAGMA          reduce using rule 259 (simple_stmt -> raise_stmt .)
    NuLL            reduce using rule 259 (simple_stmt -> raise_stmt .)
    EXIT            reduce using rule 259 (simple_stmt -> raise_stmt .)
    RETURN          reduce using rule 259 (simple_stmt -> raise_stmt .)
    GOTO            reduce using rule 259 (simple_stmt -> raise_stmt .)
    DELAY           reduce using rule 259 (simple_stmt -> raise_stmt .)
    ABORT           reduce using rule 259 (simple_stmt -> raise_stmt .)
    RAISE           reduce using rule 259 (simple_stmt -> raise_stmt .)
    REQUEUE         reduce using rule 259 (simple_stmt -> raise_stmt .)
    IF              reduce using rule 259 (simple_stmt -> raise_stmt .)
    CASE            reduce using rule 259 (simple_stmt -> raise_stmt .)
    IDENTIFIER      reduce using rule 259 (simple_stmt -> raise_stmt .)
    ACCEPT          reduce using rule 259 (simple_stmt -> raise_stmt .)
    SELECT          reduce using rule 259 (simple_stmt -> raise_stmt .)
    STRING          reduce using rule 259 (simple_stmt -> raise_stmt .)
    WHILE           reduce using rule 259 (simple_stmt -> raise_stmt .)
    DECLARE         reduce using rule 259 (simple_stmt -> raise_stmt .)
    FOR             reduce using rule 259 (simple_stmt -> raise_stmt .)
    LOOP            reduce using rule 259 (simple_stmt -> raise_stmt .)
    BEGIN           reduce using rule 259 (simple_stmt -> raise_stmt .)
    WHEN            reduce using rule 259 (simple_stmt -> raise_stmt .)
    EXCEPTION       reduce using rule 259 (simple_stmt -> raise_stmt .)
    OR              reduce using rule 259 (simple_stmt -> raise_stmt .)
    ELSE            reduce using rule 259 (simple_stmt -> raise_stmt .)
    THEN            reduce using rule 259 (simple_stmt -> raise_stmt .)
    ELSIF           reduce using rule 259 (simple_stmt -> raise_stmt .)


state 296

    (410) select_stmt -> timed_entry_call .

    LESSLESS        reduce using rule 410 (select_stmt -> timed_entry_call .)
    error           reduce using rule 410 (select_stmt -> timed_entry_call .)
    PRAGMA          reduce using rule 410 (select_stmt -> timed_entry_call .)
    NuLL            reduce using rule 410 (select_stmt -> timed_entry_call .)
    EXIT            reduce using rule 410 (select_stmt -> timed_entry_call .)
    RETURN          reduce using rule 410 (select_stmt -> timed_entry_call .)
    GOTO            reduce using rule 410 (select_stmt -> timed_entry_call .)
    DELAY           reduce using rule 410 (select_stmt -> timed_entry_call .)
    ABORT           reduce using rule 410 (select_stmt -> timed_entry_call .)
    RAISE           reduce using rule 410 (select_stmt -> timed_entry_call .)
    REQUEUE         reduce using rule 410 (select_stmt -> timed_entry_call .)
    IF              reduce using rule 410 (select_stmt -> timed_entry_call .)
    CASE            reduce using rule 410 (select_stmt -> timed_entry_call .)
    IDENTIFIER      reduce using rule 410 (select_stmt -> timed_entry_call .)
    ACCEPT          reduce using rule 410 (select_stmt -> timed_entry_call .)
    SELECT          reduce using rule 410 (select_stmt -> timed_entry_call .)
    STRING          reduce using rule 410 (select_stmt -> timed_entry_call .)
    WHILE           reduce using rule 410 (select_stmt -> timed_entry_call .)
    DECLARE         reduce using rule 410 (select_stmt -> timed_entry_call .)
    FOR             reduce using rule 410 (select_stmt -> timed_entry_call .)
    LOOP            reduce using rule 410 (select_stmt -> timed_entry_call .)
    BEGIN           reduce using rule 410 (select_stmt -> timed_entry_call .)
    OR              reduce using rule 410 (select_stmt -> timed_entry_call .)
    ELSE            reduce using rule 410 (select_stmt -> timed_entry_call .)
    THEN            reduce using rule 410 (select_stmt -> timed_entry_call .)
    END             reduce using rule 410 (select_stmt -> timed_entry_call .)
    WHEN            reduce using rule 410 (select_stmt -> timed_entry_call .)
    EXCEPTION       reduce using rule 410 (select_stmt -> timed_entry_call .)
    ELSIF           reduce using rule 410 (select_stmt -> timed_entry_call .)


state 297

    (304) exit_stmt -> EXIT . name_opt when_opt ;
    (305) name_opt -> .
    (306) name_opt -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    WHEN            reduce using rule 305 (name_opt -> .)
    ;               reduce using rule 305 (name_opt -> .)
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 445
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    name_opt                       shift and go to state 452
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 298

    (262) simple_stmt -> error . ;

    ;               shift and go to state 453


state 299

    (258) simple_stmt -> abort_stmt .

    END             reduce using rule 258 (simple_stmt -> abort_stmt .)
    LESSLESS        reduce using rule 258 (simple_stmt -> abort_stmt .)
    error           reduce using rule 258 (simple_stmt -> abort_stmt .)
    PRAGMA          reduce using rule 258 (simple_stmt -> abort_stmt .)
    NuLL            reduce using rule 258 (simple_stmt -> abort_stmt .)
    EXIT            reduce using rule 258 (simple_stmt -> abort_stmt .)
    RETURN          reduce using rule 258 (simple_stmt -> abort_stmt .)
    GOTO            reduce using rule 258 (simple_stmt -> abort_stmt .)
    DELAY           reduce using rule 258 (simple_stmt -> abort_stmt .)
    ABORT           reduce using rule 258 (simple_stmt -> abort_stmt .)
    RAISE           reduce using rule 258 (simple_stmt -> abort_stmt .)
    REQUEUE         reduce using rule 258 (simple_stmt -> abort_stmt .)
    IF              reduce using rule 258 (simple_stmt -> abort_stmt .)
    CASE            reduce using rule 258 (simple_stmt -> abort_stmt .)
    IDENTIFIER      reduce using rule 258 (simple_stmt -> abort_stmt .)
    ACCEPT          reduce using rule 258 (simple_stmt -> abort_stmt .)
    SELECT          reduce using rule 258 (simple_stmt -> abort_stmt .)
    STRING          reduce using rule 258 (simple_stmt -> abort_stmt .)
    WHILE           reduce using rule 258 (simple_stmt -> abort_stmt .)
    DECLARE         reduce using rule 258 (simple_stmt -> abort_stmt .)
    FOR             reduce using rule 258 (simple_stmt -> abort_stmt .)
    LOOP            reduce using rule 258 (simple_stmt -> abort_stmt .)
    BEGIN           reduce using rule 258 (simple_stmt -> abort_stmt .)
    WHEN            reduce using rule 258 (simple_stmt -> abort_stmt .)
    EXCEPTION       reduce using rule 258 (simple_stmt -> abort_stmt .)
    OR              reduce using rule 258 (simple_stmt -> abort_stmt .)
    ELSE            reduce using rule 258 (simple_stmt -> abort_stmt .)
    THEN            reduce using rule 258 (simple_stmt -> abort_stmt .)
    ELSIF           reduce using rule 258 (simple_stmt -> abort_stmt .)


state 300

    (301) handled_stmt_s -> statement_s . except_handler_part_opt
    (245) statement_s -> statement_s . statement
    (302) except_handler_part_opt -> .
    (303) except_handler_part_opt -> . except_handler_part
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (458) except_handler_part -> . EXCEPTION exception_handler
    (459) except_handler_part -> . except_handler_part exception_handler
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    END             reduce using rule 302 (except_handler_part_opt -> .)
    EXCEPTION       shift and go to state 457
    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    except_handler_part_opt        shift and go to state 455
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 456
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    except_handler_part            shift and go to state 454
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    label_opt                      shift and go to state 263
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 301

    (260) simple_stmt -> code_stmt .

    END             reduce using rule 260 (simple_stmt -> code_stmt .)
    LESSLESS        reduce using rule 260 (simple_stmt -> code_stmt .)
    error           reduce using rule 260 (simple_stmt -> code_stmt .)
    PRAGMA          reduce using rule 260 (simple_stmt -> code_stmt .)
    NuLL            reduce using rule 260 (simple_stmt -> code_stmt .)
    EXIT            reduce using rule 260 (simple_stmt -> code_stmt .)
    RETURN          reduce using rule 260 (simple_stmt -> code_stmt .)
    GOTO            reduce using rule 260 (simple_stmt -> code_stmt .)
    DELAY           reduce using rule 260 (simple_stmt -> code_stmt .)
    ABORT           reduce using rule 260 (simple_stmt -> code_stmt .)
    RAISE           reduce using rule 260 (simple_stmt -> code_stmt .)
    REQUEUE         reduce using rule 260 (simple_stmt -> code_stmt .)
    IF              reduce using rule 260 (simple_stmt -> code_stmt .)
    CASE            reduce using rule 260 (simple_stmt -> code_stmt .)
    IDENTIFIER      reduce using rule 260 (simple_stmt -> code_stmt .)
    ACCEPT          reduce using rule 260 (simple_stmt -> code_stmt .)
    SELECT          reduce using rule 260 (simple_stmt -> code_stmt .)
    STRING          reduce using rule 260 (simple_stmt -> code_stmt .)
    WHILE           reduce using rule 260 (simple_stmt -> code_stmt .)
    DECLARE         reduce using rule 260 (simple_stmt -> code_stmt .)
    FOR             reduce using rule 260 (simple_stmt -> code_stmt .)
    LOOP            reduce using rule 260 (simple_stmt -> code_stmt .)
    BEGIN           reduce using rule 260 (simple_stmt -> code_stmt .)
    WHEN            reduce using rule 260 (simple_stmt -> code_stmt .)
    EXCEPTION       reduce using rule 260 (simple_stmt -> code_stmt .)
    OR              reduce using rule 260 (simple_stmt -> code_stmt .)
    ELSE            reduce using rule 260 (simple_stmt -> code_stmt .)
    THEN            reduce using rule 260 (simple_stmt -> code_stmt .)
    ELSIF           reduce using rule 260 (simple_stmt -> code_stmt .)


state 302

    (246) statement -> unlabeled .

    END             reduce using rule 246 (statement -> unlabeled .)
    LESSLESS        reduce using rule 246 (statement -> unlabeled .)
    error           reduce using rule 246 (statement -> unlabeled .)
    PRAGMA          reduce using rule 246 (statement -> unlabeled .)
    NuLL            reduce using rule 246 (statement -> unlabeled .)
    EXIT            reduce using rule 246 (statement -> unlabeled .)
    RETURN          reduce using rule 246 (statement -> unlabeled .)
    GOTO            reduce using rule 246 (statement -> unlabeled .)
    DELAY           reduce using rule 246 (statement -> unlabeled .)
    ABORT           reduce using rule 246 (statement -> unlabeled .)
    RAISE           reduce using rule 246 (statement -> unlabeled .)
    REQUEUE         reduce using rule 246 (statement -> unlabeled .)
    IF              reduce using rule 246 (statement -> unlabeled .)
    CASE            reduce using rule 246 (statement -> unlabeled .)
    IDENTIFIER      reduce using rule 246 (statement -> unlabeled .)
    ACCEPT          reduce using rule 246 (statement -> unlabeled .)
    SELECT          reduce using rule 246 (statement -> unlabeled .)
    STRING          reduce using rule 246 (statement -> unlabeled .)
    WHILE           reduce using rule 246 (statement -> unlabeled .)
    DECLARE         reduce using rule 246 (statement -> unlabeled .)
    FOR             reduce using rule 246 (statement -> unlabeled .)
    LOOP            reduce using rule 246 (statement -> unlabeled .)
    BEGIN           reduce using rule 246 (statement -> unlabeled .)
    WHEN            reduce using rule 246 (statement -> unlabeled .)
    OR              reduce using rule 246 (statement -> unlabeled .)
    ELSE            reduce using rule 246 (statement -> unlabeled .)
    ELSIF           reduce using rule 246 (statement -> unlabeled .)
    EXCEPTION       reduce using rule 246 (statement -> unlabeled .)
    THEN            reduce using rule 246 (statement -> unlabeled .)


state 303

    (253) simple_stmt -> exit_stmt .

    END             reduce using rule 253 (simple_stmt -> exit_stmt .)
    LESSLESS        reduce using rule 253 (simple_stmt -> exit_stmt .)
    error           reduce using rule 253 (simple_stmt -> exit_stmt .)
    PRAGMA          reduce using rule 253 (simple_stmt -> exit_stmt .)
    NuLL            reduce using rule 253 (simple_stmt -> exit_stmt .)
    EXIT            reduce using rule 253 (simple_stmt -> exit_stmt .)
    RETURN          reduce using rule 253 (simple_stmt -> exit_stmt .)
    GOTO            reduce using rule 253 (simple_stmt -> exit_stmt .)
    DELAY           reduce using rule 253 (simple_stmt -> exit_stmt .)
    ABORT           reduce using rule 253 (simple_stmt -> exit_stmt .)
    RAISE           reduce using rule 253 (simple_stmt -> exit_stmt .)
    REQUEUE         reduce using rule 253 (simple_stmt -> exit_stmt .)
    IF              reduce using rule 253 (simple_stmt -> exit_stmt .)
    CASE            reduce using rule 253 (simple_stmt -> exit_stmt .)
    IDENTIFIER      reduce using rule 253 (simple_stmt -> exit_stmt .)
    ACCEPT          reduce using rule 253 (simple_stmt -> exit_stmt .)
    SELECT          reduce using rule 253 (simple_stmt -> exit_stmt .)
    STRING          reduce using rule 253 (simple_stmt -> exit_stmt .)
    WHILE           reduce using rule 253 (simple_stmt -> exit_stmt .)
    DECLARE         reduce using rule 253 (simple_stmt -> exit_stmt .)
    FOR             reduce using rule 253 (simple_stmt -> exit_stmt .)
    LOOP            reduce using rule 253 (simple_stmt -> exit_stmt .)
    BEGIN           reduce using rule 253 (simple_stmt -> exit_stmt .)
    WHEN            reduce using rule 253 (simple_stmt -> exit_stmt .)
    EXCEPTION       reduce using rule 253 (simple_stmt -> exit_stmt .)
    OR              reduce using rule 253 (simple_stmt -> exit_stmt .)
    ELSE            reduce using rule 253 (simple_stmt -> exit_stmt .)
    THEN            reduce using rule 253 (simple_stmt -> exit_stmt .)
    ELSIF           reduce using rule 253 (simple_stmt -> exit_stmt .)


state 304

    (408) select_stmt -> select_wait .

    LESSLESS        reduce using rule 408 (select_stmt -> select_wait .)
    error           reduce using rule 408 (select_stmt -> select_wait .)
    PRAGMA          reduce using rule 408 (select_stmt -> select_wait .)
    NuLL            reduce using rule 408 (select_stmt -> select_wait .)
    EXIT            reduce using rule 408 (select_stmt -> select_wait .)
    RETURN          reduce using rule 408 (select_stmt -> select_wait .)
    GOTO            reduce using rule 408 (select_stmt -> select_wait .)
    DELAY           reduce using rule 408 (select_stmt -> select_wait .)
    ABORT           reduce using rule 408 (select_stmt -> select_wait .)
    RAISE           reduce using rule 408 (select_stmt -> select_wait .)
    REQUEUE         reduce using rule 408 (select_stmt -> select_wait .)
    IF              reduce using rule 408 (select_stmt -> select_wait .)
    CASE            reduce using rule 408 (select_stmt -> select_wait .)
    IDENTIFIER      reduce using rule 408 (select_stmt -> select_wait .)
    ACCEPT          reduce using rule 408 (select_stmt -> select_wait .)
    SELECT          reduce using rule 408 (select_stmt -> select_wait .)
    STRING          reduce using rule 408 (select_stmt -> select_wait .)
    WHILE           reduce using rule 408 (select_stmt -> select_wait .)
    DECLARE         reduce using rule 408 (select_stmt -> select_wait .)
    FOR             reduce using rule 408 (select_stmt -> select_wait .)
    LOOP            reduce using rule 408 (select_stmt -> select_wait .)
    BEGIN           reduce using rule 408 (select_stmt -> select_wait .)
    OR              reduce using rule 408 (select_stmt -> select_wait .)
    ELSE            reduce using rule 408 (select_stmt -> select_wait .)
    THEN            reduce using rule 408 (select_stmt -> select_wait .)
    END             reduce using rule 408 (select_stmt -> select_wait .)
    WHEN            reduce using rule 408 (select_stmt -> select_wait .)
    EXCEPTION       reduce using rule 408 (select_stmt -> select_wait .)
    ELSIF           reduce using rule 408 (select_stmt -> select_wait .)


state 305

    (272) if_stmt -> IF . cond_clause_s else_opt END IF ;
    (273) cond_clause_s -> . cond_clause
    (274) cond_clause_s -> . cond_clause_s ELSIF cond_clause
    (275) cond_clause -> . cond_part statement_s
    (276) cond_part -> . condition THEN
    (277) condition -> . expression
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    cond_clause_s                  shift and go to state 458
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157
    cond_clause                    shift and go to state 459
    cond_part                      shift and go to state 460
    literal                        shift and go to state 135
    allocator                      shift and go to state 130
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    condition                      shift and go to state 461
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 462

state 306

    (411) select_stmt -> cond_entry_call .

    LESSLESS        reduce using rule 411 (select_stmt -> cond_entry_call .)
    error           reduce using rule 411 (select_stmt -> cond_entry_call .)
    PRAGMA          reduce using rule 411 (select_stmt -> cond_entry_call .)
    NuLL            reduce using rule 411 (select_stmt -> cond_entry_call .)
    EXIT            reduce using rule 411 (select_stmt -> cond_entry_call .)
    RETURN          reduce using rule 411 (select_stmt -> cond_entry_call .)
    GOTO            reduce using rule 411 (select_stmt -> cond_entry_call .)
    DELAY           reduce using rule 411 (select_stmt -> cond_entry_call .)
    ABORT           reduce using rule 411 (select_stmt -> cond_entry_call .)
    RAISE           reduce using rule 411 (select_stmt -> cond_entry_call .)
    REQUEUE         reduce using rule 411 (select_stmt -> cond_entry_call .)
    IF              reduce using rule 411 (select_stmt -> cond_entry_call .)
    CASE            reduce using rule 411 (select_stmt -> cond_entry_call .)
    IDENTIFIER      reduce using rule 411 (select_stmt -> cond_entry_call .)
    ACCEPT          reduce using rule 411 (select_stmt -> cond_entry_call .)
    SELECT          reduce using rule 411 (select_stmt -> cond_entry_call .)
    STRING          reduce using rule 411 (select_stmt -> cond_entry_call .)
    WHILE           reduce using rule 411 (select_stmt -> cond_entry_call .)
    DECLARE         reduce using rule 411 (select_stmt -> cond_entry_call .)
    FOR             reduce using rule 411 (select_stmt -> cond_entry_call .)
    LOOP            reduce using rule 411 (select_stmt -> cond_entry_call .)
    BEGIN           reduce using rule 411 (select_stmt -> cond_entry_call .)
    OR              reduce using rule 411 (select_stmt -> cond_entry_call .)
    ELSE            reduce using rule 411 (select_stmt -> cond_entry_call .)
    THEN            reduce using rule 411 (select_stmt -> cond_entry_call .)
    END             reduce using rule 411 (select_stmt -> cond_entry_call .)
    WHEN            reduce using rule 411 (select_stmt -> cond_entry_call .)
    EXCEPTION       reduce using rule 411 (select_stmt -> cond_entry_call .)
    ELSIF           reduce using rule 411 (select_stmt -> cond_entry_call .)


state 307

    (251) simple_stmt -> null_stmt .

    END             reduce using rule 251 (simple_stmt -> null_stmt .)
    LESSLESS        reduce using rule 251 (simple_stmt -> null_stmt .)
    error           reduce using rule 251 (simple_stmt -> null_stmt .)
    PRAGMA          reduce using rule 251 (simple_stmt -> null_stmt .)
    NuLL            reduce using rule 251 (simple_stmt -> null_stmt .)
    EXIT            reduce using rule 251 (simple_stmt -> null_stmt .)
    RETURN          reduce using rule 251 (simple_stmt -> null_stmt .)
    GOTO            reduce using rule 251 (simple_stmt -> null_stmt .)
    DELAY           reduce using rule 251 (simple_stmt -> null_stmt .)
    ABORT           reduce using rule 251 (simple_stmt -> null_stmt .)
    RAISE           reduce using rule 251 (simple_stmt -> null_stmt .)
    REQUEUE         reduce using rule 251 (simple_stmt -> null_stmt .)
    IF              reduce using rule 251 (simple_stmt -> null_stmt .)
    CASE            reduce using rule 251 (simple_stmt -> null_stmt .)
    IDENTIFIER      reduce using rule 251 (simple_stmt -> null_stmt .)
    ACCEPT          reduce using rule 251 (simple_stmt -> null_stmt .)
    SELECT          reduce using rule 251 (simple_stmt -> null_stmt .)
    STRING          reduce using rule 251 (simple_stmt -> null_stmt .)
    WHILE           reduce using rule 251 (simple_stmt -> null_stmt .)
    DECLARE         reduce using rule 251 (simple_stmt -> null_stmt .)
    FOR             reduce using rule 251 (simple_stmt -> null_stmt .)
    LOOP            reduce using rule 251 (simple_stmt -> null_stmt .)
    BEGIN           reduce using rule 251 (simple_stmt -> null_stmt .)
    WHEN            reduce using rule 251 (simple_stmt -> null_stmt .)
    EXCEPTION       reduce using rule 251 (simple_stmt -> null_stmt .)
    OR              reduce using rule 251 (simple_stmt -> null_stmt .)
    ELSE            reduce using rule 251 (simple_stmt -> null_stmt .)
    THEN            reduce using rule 251 (simple_stmt -> null_stmt .)
    ELSIF           reduce using rule 251 (simple_stmt -> null_stmt .)


state 308

    (252) simple_stmt -> assign_stmt .

    END             reduce using rule 252 (simple_stmt -> assign_stmt .)
    LESSLESS        reduce using rule 252 (simple_stmt -> assign_stmt .)
    error           reduce using rule 252 (simple_stmt -> assign_stmt .)
    PRAGMA          reduce using rule 252 (simple_stmt -> assign_stmt .)
    NuLL            reduce using rule 252 (simple_stmt -> assign_stmt .)
    EXIT            reduce using rule 252 (simple_stmt -> assign_stmt .)
    RETURN          reduce using rule 252 (simple_stmt -> assign_stmt .)
    GOTO            reduce using rule 252 (simple_stmt -> assign_stmt .)
    DELAY           reduce using rule 252 (simple_stmt -> assign_stmt .)
    ABORT           reduce using rule 252 (simple_stmt -> assign_stmt .)
    RAISE           reduce using rule 252 (simple_stmt -> assign_stmt .)
    REQUEUE         reduce using rule 252 (simple_stmt -> assign_stmt .)
    IF              reduce using rule 252 (simple_stmt -> assign_stmt .)
    CASE            reduce using rule 252 (simple_stmt -> assign_stmt .)
    IDENTIFIER      reduce using rule 252 (simple_stmt -> assign_stmt .)
    ACCEPT          reduce using rule 252 (simple_stmt -> assign_stmt .)
    SELECT          reduce using rule 252 (simple_stmt -> assign_stmt .)
    STRING          reduce using rule 252 (simple_stmt -> assign_stmt .)
    WHILE           reduce using rule 252 (simple_stmt -> assign_stmt .)
    DECLARE         reduce using rule 252 (simple_stmt -> assign_stmt .)
    FOR             reduce using rule 252 (simple_stmt -> assign_stmt .)
    LOOP            reduce using rule 252 (simple_stmt -> assign_stmt .)
    BEGIN           reduce using rule 252 (simple_stmt -> assign_stmt .)
    WHEN            reduce using rule 252 (simple_stmt -> assign_stmt .)
    EXCEPTION       reduce using rule 252 (simple_stmt -> assign_stmt .)
    OR              reduce using rule 252 (simple_stmt -> assign_stmt .)
    ELSE            reduce using rule 252 (simple_stmt -> assign_stmt .)
    THEN            reduce using rule 252 (simple_stmt -> assign_stmt .)
    ELSIF           reduce using rule 252 (simple_stmt -> assign_stmt .)


state 309

    (333) subprog_body -> subprog_spec_is_push decl_part block_body END . id_opt ;
    (295) id_opt -> .
    (296) id_opt -> . designator
    (318) designator -> . compound_name
    (319) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 295 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 463
    id_opt                         shift and go to state 464
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 310

    (505) attrib_def -> FOR mark USE . expression ;
    (506) record_type_spec -> FOR mark USE . RECORD align_opt comp_loc_s END RECORD ;
    (511) address_spec -> FOR mark USE . AT expression ;
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    RECORD          shift and go to state 465
    AT              shift and go to state 466
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 467

state 311

    (160) mark -> mark . . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 468

state 312

    (159) mark -> mark TICK . attribute_id
    (180) attribute_id -> . IDENTIFIER
    (181) attribute_id -> . DIGITS
    (182) attribute_id -> . DELTA
    (183) attribute_id -> . ACCESS

    IDENTIFIER      shift and go to state 390
    DIGITS          shift and go to state 389
    DELTA           shift and go to state 393
    ACCESS          shift and go to state 391

    attribute_id                   shift and go to state 469

state 313

    (367) task_body -> TASK BODY simple_name . IS decl_part block_body END id_opt ;
    (453) body_stub -> TASK BODY simple_name . IS SEPARATE ;

    IS              shift and go to state 470


state 314

    (362) task_spec -> TASK TYPE simple_name . discrim_part_opt task_def
    (37) discrim_part_opt -> .
    (38) discrim_part_opt -> . discrim_part
    (39) discrim_part_opt -> . ( LESSMORE )
    (110) discrim_part -> . ( discrim_spec_s )

    IS              reduce using rule 37 (discrim_part_opt -> .)
    ;               reduce using rule 37 (discrim_part_opt -> .)
    (               shift and go to state 318

    discrim_part_opt               shift and go to state 471
    discrim_part                   shift and go to state 320

state 315

    (364) task_def -> IS . entry_decl_s rep_spec_s task_private_opt END id_opt
    (390) entry_decl_s -> . pragma_s
    (391) entry_decl_s -> . entry_decl_s entry_decl pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    FOR             reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)

    entry_decl_s                   shift and go to state 472
    pragma_s                       shift and go to state 473

state 316

    (361) task_spec -> TASK simple_name task_def .

    ;               reduce using rule 361 (task_spec -> TASK simple_name task_def .)


state 317

    (342) pkg_body -> PACKAGE BODY compound_name . IS decl_part body_opt END c_id_opt ;
    (454) body_stub -> PACKAGE BODY compound_name . IS SEPARATE ;
    (163) compound_name -> compound_name . . simple_name

    IS              shift and go to state 474
    .               shift and go to state 119


state 318

    (39) discrim_part_opt -> ( . LESSMORE )
    (110) discrim_part -> ( . discrim_spec_s )
    (111) discrim_spec_s -> . discrim_spec
    (112) discrim_spec_s -> . discrim_spec_s ; discrim_spec
    (113) discrim_spec -> . def_id_s : access_opt mark init_opt
    (114) discrim_spec -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    LESSMORE        shift and go to state 479
    error           shift and go to state 475
    IDENTIFIER      shift and go to state 76

    discrim_spec                   shift and go to state 478
    discrim_spec_s                 shift and go to state 476
    def_id                         shift and go to state 89
    def_id_s                       shift and go to state 477

state 319

    (36) type_decl -> TYPE IDENTIFIER discrim_part_opt . type_completion ;
    (40) type_completion -> .
    (41) type_completion -> . IS type_def

    ;               reduce using rule 40 (type_completion -> .)
    IS              shift and go to state 480

    type_completion                shift and go to state 481

state 320

    (38) discrim_part_opt -> discrim_part .

    IS              reduce using rule 38 (discrim_part_opt -> discrim_part .)
    ;               reduce using rule 38 (discrim_part_opt -> discrim_part .)


state 321

    (50) subtype_decl -> SUBTYPE IDENTIFIER IS . subtype_ind ;
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 482
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    subtype_ind                    shift and go to state 483
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 322

    (455) body_stub -> subprog_spec IS SEPARATE . ;

    ;               shift and go to state 484


state 323

    (25) def_id_s -> def_id_s , def_id .

    :               reduce using rule 25 (def_id_s -> def_id_s , def_id .)
    ,               reduce using rule 25 (def_id_s -> def_id_s , def_id .)


state 324

    (457) exception_decl -> def_id_s : EXCEPTION . ;
    (353) rename_decl -> def_id_s : EXCEPTION . renames ;
    (359) renames -> . RENAMES name

    ;               shift and go to state 486
    RENAMES         shift and go to state 95

    renames                        shift and go to state 485

state 325

    (35) number_decl -> def_id_s : CONSTANT . ASSIGNMENT expression ;
    (30) object_qualifier_opt -> CONSTANT .

    ASSIGNMENT      shift and go to state 487
    ARRAY           reduce using rule 30 (object_qualifier_opt -> CONSTANT .)
    IDENTIFIER      reduce using rule 30 (object_qualifier_opt -> CONSTANT .)
    STRING          reduce using rule 30 (object_qualifier_opt -> CONSTANT .)


state 326

    (28) object_qualifier_opt -> ALIASED .
    (29) object_qualifier_opt -> ALIASED . CONSTANT

    ARRAY           reduce using rule 28 (object_qualifier_opt -> ALIASED .)
    IDENTIFIER      reduce using rule 28 (object_qualifier_opt -> ALIASED .)
    STRING          reduce using rule 28 (object_qualifier_opt -> ALIASED .)
    CONSTANT        shift and go to state 488


state 327

    (23) object_decl -> def_id_s : object_qualifier_opt . object_subtype_def init_opt ;
    (352) rename_decl -> def_id_s : object_qualifier_opt . subtype_ind renames ;
    (31) object_subtype_def -> . subtype_ind
    (32) object_subtype_def -> . array_type
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (78) array_type -> . unconstr_array_type
    (79) array_type -> . constr_array_type
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (80) unconstr_array_type -> . ARRAY ( index_s ) OF component_subtype_def
    (81) constr_array_type -> . ARRAY iter_index_constraint OF component_subtype_def
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    ARRAY           shift and go to state 490
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157
    array_type                     shift and go to state 489
    name                           shift and go to state 482
    object_subtype_def             shift and go to state 491
    constr_array_type              shift and go to state 492
    operator_symbol                shift and go to state 149
    subtype_ind                    shift and go to state 493
    unconstr_array_type            shift and go to state 494

state 328

    (501) generic_inst -> NEW name .
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id

    ;               reduce using rule 501 (generic_inst -> NEW name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 329

    (342) pkg_body -> PACKAGE BODY compound_name IS . decl_part body_opt END c_id_opt ;
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (333) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (342) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (367) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (384) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (348) use_clause -> . USE name_s ;
    (349) use_clause -> . USE TYPE name_s ;
    (502) rep_spec -> . attrib_def
    (503) rep_spec -> . record_type_spec
    (504) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (332) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (312) subprog_decl -> . subprog_spec ;
    (313) subprog_decl -> . generic_subp_inst ;
    (314) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (335) pkg_decl -> . pkg_spec ;
    (336) pkg_decl -> . generic_pkg_inst ;
    (360) task_decl -> . task_spec ;
    (368) prot_decl -> . prot_spec ;
    (457) exception_decl -> . def_id_s : EXCEPTION ;
    (352) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (353) rename_decl -> . def_id_s : EXCEPTION renames ;
    (354) rename_decl -> . rename_unit
    (469) generic_decl -> . generic_formal_part subprog_spec ;
    (470) generic_decl -> . generic_formal_part pkg_spec ;
    (453) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (454) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (455) body_stub -> . subprog_spec IS SEPARATE ;
    (456) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (505) attrib_def -> . FOR mark USE expression ;
    (506) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (511) address_spec -> . FOR mark USE AT expression ;
    (315) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (316) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (317) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (499) generic_subp_inst -> . subprog_spec IS generic_inst
    (337) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (361) task_spec -> . TASK simple_name task_def
    (362) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (369) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (370) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (355) rename_unit -> . PACKAGE compound_name renames ;
    (356) rename_unit -> . subprog_spec renames ;
    (357) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (358) rename_unit -> . generic_formal_part subprog_spec renames ;
    (471) generic_formal_part -> . GENERIC
    (472) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 135 (decl_part -> .)
    END             reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 495
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 330

    (355) rename_unit -> PACKAGE compound_name renames ; .

    PACKAGE         reduce using rule 355 (rename_unit -> PACKAGE compound_name renames ; .)
    TASK            reduce using rule 355 (rename_unit -> PACKAGE compound_name renames ; .)
    PROTECTED       reduce using rule 355 (rename_unit -> PACKAGE compound_name renames ; .)
    error           reduce using rule 355 (rename_unit -> PACKAGE compound_name renames ; .)
    USE             reduce using rule 355 (rename_unit -> PACKAGE compound_name renames ; .)
    PRAGMA          reduce using rule 355 (rename_unit -> PACKAGE compound_name renames ; .)
    TYPE            reduce using rule 355 (rename_unit -> PACKAGE compound_name renames ; .)
    SUBTYPE         reduce using rule 355 (rename_unit -> PACKAGE compound_name renames ; .)
    FOR             reduce using rule 355 (rename_unit -> PACKAGE compound_name renames ; .)
    PROCEDURE       reduce using rule 355 (rename_unit -> PACKAGE compound_name renames ; .)
    FUNCTION        reduce using rule 355 (rename_unit -> PACKAGE compound_name renames ; .)
    GENERIC         reduce using rule 355 (rename_unit -> PACKAGE compound_name renames ; .)
    IDENTIFIER      reduce using rule 355 (rename_unit -> PACKAGE compound_name renames ; .)
    BEGIN           reduce using rule 355 (rename_unit -> PACKAGE compound_name renames ; .)
    PRIVATE         reduce using rule 355 (rename_unit -> PACKAGE compound_name renames ; .)
    WITH            reduce using rule 355 (rename_unit -> PACKAGE compound_name renames ; .)
    SEPARATE        reduce using rule 355 (rename_unit -> PACKAGE compound_name renames ; .)
    $end            reduce using rule 355 (rename_unit -> PACKAGE compound_name renames ; .)
    END             reduce using rule 355 (rename_unit -> PACKAGE compound_name renames ; .)


state 331

    (500) generic_pkg_inst -> PACKAGE compound_name IS generic_inst .

    ;               reduce using rule 500 (generic_pkg_inst -> PACKAGE compound_name IS generic_inst .)


state 332

    (138) decl_item_s -> decl_item_s1 .
    (140) decl_item_s1 -> decl_item_s1 . decl_item
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (348) use_clause -> . USE name_s ;
    (349) use_clause -> . USE TYPE name_s ;
    (502) rep_spec -> . attrib_def
    (503) rep_spec -> . record_type_spec
    (504) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (312) subprog_decl -> . subprog_spec ;
    (313) subprog_decl -> . generic_subp_inst ;
    (314) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (335) pkg_decl -> . pkg_spec ;
    (336) pkg_decl -> . generic_pkg_inst ;
    (360) task_decl -> . task_spec ;
    (368) prot_decl -> . prot_spec ;
    (457) exception_decl -> . def_id_s : EXCEPTION ;
    (352) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (353) rename_decl -> . def_id_s : EXCEPTION renames ;
    (354) rename_decl -> . rename_unit
    (469) generic_decl -> . generic_formal_part subprog_spec ;
    (470) generic_decl -> . generic_formal_part pkg_spec ;
    (453) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (454) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (455) body_stub -> . subprog_spec IS SEPARATE ;
    (456) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (505) attrib_def -> . FOR mark USE expression ;
    (506) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (511) address_spec -> . FOR mark USE AT expression ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (315) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (316) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (317) subprog_spec -> . FUNCTION designator
    (499) generic_subp_inst -> . subprog_spec IS generic_inst
    (332) subprog_spec_is_push -> . subprog_spec IS
    (337) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (361) task_spec -> . TASK simple_name task_def
    (362) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (369) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (370) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (355) rename_unit -> . PACKAGE compound_name renames ;
    (356) rename_unit -> . subprog_spec renames ;
    (357) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (358) rename_unit -> . generic_formal_part subprog_spec renames ;
    (471) generic_formal_part -> . GENERIC
    (472) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    END             reduce using rule 138 (decl_item_s -> decl_item_s1 .)
    PRIVATE         reduce using rule 138 (decl_item_s -> decl_item_s1 .)
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    TASK            shift and go to state 336
    PACKAGE         shift and go to state 337
    PROTECTED       shift and go to state 333
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    task_decl                      shift and go to state 60
    subtype_decl                   shift and go to state 61
    rep_spec                       shift and go to state 82
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    decl_item                      shift and go to state 496
    subprog_spec_is_push           shift and go to state 338
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 339
    def_id_s                       shift and go to state 88
    task_spec                      shift and go to state 65
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    generic_subp_inst              shift and go to state 29
    def_id                         shift and go to state 89
    rename_decl                    shift and go to state 90
    type_decl                      shift and go to state 56
    rename_unit                    shift and go to state 91
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    subprog_decl                   shift and go to state 58
    pragma                         shift and go to state 74
    pkg_spec                       shift and go to state 37
    number_decl                    shift and go to state 93

state 333

    (456) body_stub -> PROTECTED . BODY simple_name IS SEPARATE ;
    (369) prot_spec -> PROTECTED . IDENTIFIER prot_def
    (370) prot_spec -> PROTECTED . TYPE simple_name discrim_part_opt prot_def

    BODY            shift and go to state 497
    IDENTIFIER      shift and go to state 160
    TYPE            shift and go to state 161


state 334

    (139) decl_item_s1 -> decl_item .

    error           reduce using rule 139 (decl_item_s1 -> decl_item .)
    USE             reduce using rule 139 (decl_item_s1 -> decl_item .)
    PRAGMA          reduce using rule 139 (decl_item_s1 -> decl_item .)
    TYPE            reduce using rule 139 (decl_item_s1 -> decl_item .)
    SUBTYPE         reduce using rule 139 (decl_item_s1 -> decl_item .)
    TASK            reduce using rule 139 (decl_item_s1 -> decl_item .)
    PACKAGE         reduce using rule 139 (decl_item_s1 -> decl_item .)
    PROTECTED       reduce using rule 139 (decl_item_s1 -> decl_item .)
    FOR             reduce using rule 139 (decl_item_s1 -> decl_item .)
    PROCEDURE       reduce using rule 139 (decl_item_s1 -> decl_item .)
    FUNCTION        reduce using rule 139 (decl_item_s1 -> decl_item .)
    GENERIC         reduce using rule 139 (decl_item_s1 -> decl_item .)
    IDENTIFIER      reduce using rule 139 (decl_item_s1 -> decl_item .)
    END             reduce using rule 139 (decl_item_s1 -> decl_item .)
    PRIVATE         reduce using rule 139 (decl_item_s1 -> decl_item .)


state 335

    (337) pkg_spec -> PACKAGE compound_name IS decl_item_s . private_part END c_id_opt
    (338) private_part -> .
    (339) private_part -> . PRIVATE decl_item_s

    END             reduce using rule 338 (private_part -> .)
    PRIVATE         shift and go to state 498

    private_part                   shift and go to state 499

state 336

    (453) body_stub -> TASK . BODY simple_name IS SEPARATE ;
    (361) task_spec -> TASK . simple_name task_def
    (362) task_spec -> TASK . TYPE simple_name discrim_part_opt task_def
    (161) simple_name -> . IDENTIFIER

    BODY            shift and go to state 500
    TYPE            shift and go to state 168
    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 169

state 337

    (454) body_stub -> PACKAGE . BODY compound_name IS SEPARATE ;
    (337) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> PACKAGE . compound_name IS generic_inst
    (355) rename_unit -> PACKAGE . compound_name renames ;
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    BODY            shift and go to state 501
    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 41
    compound_name                  shift and go to state 172

state 338

    (314) subprog_decl -> subprog_spec_is_push . ABSTRACT ;

    ABSTRACT        shift and go to state 81


state 339

    (312) subprog_decl -> subprog_spec . ;
    (455) body_stub -> subprog_spec . IS SEPARATE ;
    (499) generic_subp_inst -> subprog_spec . IS generic_inst
    (332) subprog_spec_is_push -> subprog_spec . IS
    (356) rename_unit -> subprog_spec . renames ;
    (359) renames -> . RENAMES name

    ;               shift and go to state 97
    IS              shift and go to state 502
    RENAMES         shift and go to state 95

    renames                        shift and go to state 94

state 340

    (323) param_s -> param .

    )               reduce using rule 323 (param_s -> param .)
    ;               reduce using rule 323 (param_s -> param .)


state 341

    (322) formal_part -> ( param_s . )
    (324) param_s -> param_s . ; param

    )               shift and go to state 503
    ;               shift and go to state 504


state 342

    (476) generic_formal -> WITH FUNCTION designator . formal_part_opt RETURN name subp_default ;
    (320) formal_part_opt -> .
    (321) formal_part_opt -> . formal_part
    (322) formal_part -> . ( param_s )

    RETURN          reduce using rule 320 (formal_part_opt -> .)
    (               shift and go to state 189

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 505

state 343

    (477) generic_formal -> WITH PACKAGE simple_name . IS NEW name ( LESSMORE ) ;
    (478) generic_formal -> WITH PACKAGE simple_name . IS NEW name ;

    IS              shift and go to state 506


state 344

    (475) generic_formal -> WITH PROCEDURE simple_name . formal_part_opt subp_default ;
    (320) formal_part_opt -> .
    (321) formal_part_opt -> . formal_part
    (322) formal_part -> . ( param_s )

    IS              reduce using rule 320 (formal_part_opt -> .)
    ;               reduce using rule 320 (formal_part_opt -> .)
    (               shift and go to state 189

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 507

state 345

    (358) rename_unit -> generic_formal_part subprog_spec renames ; .

    PACKAGE         reduce using rule 358 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    TASK            reduce using rule 358 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    PROTECTED       reduce using rule 358 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    error           reduce using rule 358 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    USE             reduce using rule 358 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    PRAGMA          reduce using rule 358 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    TYPE            reduce using rule 358 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    SUBTYPE         reduce using rule 358 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    FOR             reduce using rule 358 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    PROCEDURE       reduce using rule 358 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    FUNCTION        reduce using rule 358 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    GENERIC         reduce using rule 358 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    IDENTIFIER      reduce using rule 358 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    BEGIN           reduce using rule 358 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    PRIVATE         reduce using rule 358 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    WITH            reduce using rule 358 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    SEPARATE        reduce using rule 358 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    $end            reduce using rule 358 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    END             reduce using rule 358 (rename_unit -> generic_formal_part subprog_spec renames ; .)


state 346

    (331) mode -> ACCESS .

    IDENTIFIER      reduce using rule 331 (mode -> ACCESS .)


state 347

    (329) mode -> OUT .

    IDENTIFIER      reduce using rule 329 (mode -> OUT .)


state 348

    (328) mode -> IN .
    (330) mode -> IN . OUT

    IDENTIFIER      reduce using rule 328 (mode -> IN .)
    OUT             shift and go to state 508


state 349

    (325) param -> def_id_s : mode . mark init_opt
    (158) mark -> . simple_name
    (159) mark -> . mark TICK attribute_id
    (160) mark -> . mark . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    mark                           shift and go to state 509
    simple_name                    shift and go to state 165

state 350

    (357) rename_unit -> generic_formal_part PACKAGE compound_name renames . ;

    ;               shift and go to state 510


state 351

    (337) pkg_spec -> PACKAGE compound_name IS . decl_item_s private_part END c_id_opt
    (137) decl_item_s -> .
    (138) decl_item_s -> . decl_item_s1
    (139) decl_item_s1 -> . decl_item
    (140) decl_item_s1 -> . decl_item_s1 decl_item
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (348) use_clause -> . USE name_s ;
    (349) use_clause -> . USE TYPE name_s ;
    (502) rep_spec -> . attrib_def
    (503) rep_spec -> . record_type_spec
    (504) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (312) subprog_decl -> . subprog_spec ;
    (313) subprog_decl -> . generic_subp_inst ;
    (314) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (335) pkg_decl -> . pkg_spec ;
    (336) pkg_decl -> . generic_pkg_inst ;
    (360) task_decl -> . task_spec ;
    (368) prot_decl -> . prot_spec ;
    (457) exception_decl -> . def_id_s : EXCEPTION ;
    (352) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (353) rename_decl -> . def_id_s : EXCEPTION renames ;
    (354) rename_decl -> . rename_unit
    (469) generic_decl -> . generic_formal_part subprog_spec ;
    (470) generic_decl -> . generic_formal_part pkg_spec ;
    (453) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (454) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (455) body_stub -> . subprog_spec IS SEPARATE ;
    (456) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (505) attrib_def -> . FOR mark USE expression ;
    (506) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (511) address_spec -> . FOR mark USE AT expression ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (315) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (316) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (317) subprog_spec -> . FUNCTION designator
    (499) generic_subp_inst -> . subprog_spec IS generic_inst
    (332) subprog_spec_is_push -> . subprog_spec IS
    (337) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (361) task_spec -> . TASK simple_name task_def
    (362) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (369) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (370) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (355) rename_unit -> . PACKAGE compound_name renames ;
    (356) rename_unit -> . subprog_spec renames ;
    (357) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (358) rename_unit -> . generic_formal_part subprog_spec renames ;
    (471) generic_formal_part -> . GENERIC
    (472) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    PRIVATE         reduce using rule 137 (decl_item_s -> .)
    END             reduce using rule 137 (decl_item_s -> .)
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    TASK            shift and go to state 336
    PACKAGE         shift and go to state 337
    PROTECTED       shift and go to state 333
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    task_decl                      shift and go to state 60
    subtype_decl                   shift and go to state 61
    rep_spec                       shift and go to state 82
    decl_item_s1                   shift and go to state 332
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 338
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 339
    def_id_s                       shift and go to state 88
    decl_item                      shift and go to state 334
    task_spec                      shift and go to state 65
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    generic_subp_inst              shift and go to state 29
    def_id                         shift and go to state 89
    rename_decl                    shift and go to state 90
    type_decl                      shift and go to state 56
    rename_unit                    shift and go to state 91
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    subprog_decl                   shift and go to state 58
    decl_item_s                    shift and go to state 335
    pragma                         shift and go to state 74
    pkg_spec                       shift and go to state 37
    number_decl                    shift and go to state 93

state 352

    (474) generic_formal -> TYPE simple_name generic_discrim_part_opt . IS generic_type_def ;

    IS              shift and go to state 511


state 353

    (482) generic_discrim_part_opt -> ( . LESSMORE )
    (110) discrim_part -> ( . discrim_spec_s )
    (111) discrim_spec_s -> . discrim_spec
    (112) discrim_spec_s -> . discrim_spec_s ; discrim_spec
    (113) discrim_spec -> . def_id_s : access_opt mark init_opt
    (114) discrim_spec -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    LESSMORE        shift and go to state 512
    error           shift and go to state 475
    IDENTIFIER      shift and go to state 76

    discrim_spec                   shift and go to state 478
    discrim_spec_s                 shift and go to state 476
    def_id                         shift and go to state 89
    def_id_s                       shift and go to state 477

state 354

    (481) generic_discrim_part_opt -> discrim_part .

    IS              reduce using rule 481 (generic_discrim_part_opt -> discrim_part .)


state 355

    (316) subprog_spec -> FUNCTION designator formal_part_opt RETURN . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 513
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    indexed_comp                   shift and go to state 129
    operator_symbol                shift and go to state 149
    simple_name                    shift and go to state 157

state 356

    (233) factor -> primary STARSTAR primary .

    *               reduce using rule 233 (factor -> primary STARSTAR primary .)
    /               reduce using rule 233 (factor -> primary STARSTAR primary .)
    MOD             reduce using rule 233 (factor -> primary STARSTAR primary .)
    REM             reduce using rule 233 (factor -> primary STARSTAR primary .)
    =               reduce using rule 233 (factor -> primary STARSTAR primary .)
    NOTEQUAL        reduce using rule 233 (factor -> primary STARSTAR primary .)
    <               reduce using rule 233 (factor -> primary STARSTAR primary .)
    LESSEQ          reduce using rule 233 (factor -> primary STARSTAR primary .)
    >               reduce using rule 233 (factor -> primary STARSTAR primary .)
    GREATEREQ       reduce using rule 233 (factor -> primary STARSTAR primary .)
    IN              reduce using rule 233 (factor -> primary STARSTAR primary .)
    NOT             reduce using rule 233 (factor -> primary STARSTAR primary .)
    +               reduce using rule 233 (factor -> primary STARSTAR primary .)
    -               reduce using rule 233 (factor -> primary STARSTAR primary .)
    &               reduce using rule 233 (factor -> primary STARSTAR primary .)
    AND             reduce using rule 233 (factor -> primary STARSTAR primary .)
    OR              reduce using rule 233 (factor -> primary STARSTAR primary .)
    )               reduce using rule 233 (factor -> primary STARSTAR primary .)
    ,               reduce using rule 233 (factor -> primary STARSTAR primary .)
    DOTDOT          reduce using rule 233 (factor -> primary STARSTAR primary .)
    ARROW           reduce using rule 233 (factor -> primary STARSTAR primary .)
    |               reduce using rule 233 (factor -> primary STARSTAR primary .)
    RANGE           reduce using rule 233 (factor -> primary STARSTAR primary .)
    ;               reduce using rule 233 (factor -> primary STARSTAR primary .)
    WITH            reduce using rule 233 (factor -> primary STARSTAR primary .)
    IS              reduce using rule 233 (factor -> primary STARSTAR primary .)
    THEN            reduce using rule 233 (factor -> primary STARSTAR primary .)
    LOOP            reduce using rule 233 (factor -> primary STARSTAR primary .)
    DIGITS          reduce using rule 233 (factor -> primary STARSTAR primary .)
    RENAMES         reduce using rule 233 (factor -> primary STARSTAR primary .)
    ASSIGNMENT      reduce using rule 233 (factor -> primary STARSTAR primary .)


state 357

    (219) simple_expression -> simple_expression adding term .
    (226) term -> term . multiplying factor
    (227) multiplying -> . *
    (228) multiplying -> . /
    (229) multiplying -> . MOD
    (230) multiplying -> . REM

    +               reduce using rule 219 (simple_expression -> simple_expression adding term .)
    -               reduce using rule 219 (simple_expression -> simple_expression adding term .)
    &               reduce using rule 219 (simple_expression -> simple_expression adding term .)
    ,               reduce using rule 219 (simple_expression -> simple_expression adding term .)
    ARROW           reduce using rule 219 (simple_expression -> simple_expression adding term .)
    |               reduce using rule 219 (simple_expression -> simple_expression adding term .)
    AND             reduce using rule 219 (simple_expression -> simple_expression adding term .)
    OR              reduce using rule 219 (simple_expression -> simple_expression adding term .)
    )               reduce using rule 219 (simple_expression -> simple_expression adding term .)
    WITH            reduce using rule 219 (simple_expression -> simple_expression adding term .)
    ;               reduce using rule 219 (simple_expression -> simple_expression adding term .)
    IS              reduce using rule 219 (simple_expression -> simple_expression adding term .)
    THEN            reduce using rule 219 (simple_expression -> simple_expression adding term .)
    LOOP            reduce using rule 219 (simple_expression -> simple_expression adding term .)
    RANGE           reduce using rule 219 (simple_expression -> simple_expression adding term .)
    DIGITS          reduce using rule 219 (simple_expression -> simple_expression adding term .)
    RENAMES         reduce using rule 219 (simple_expression -> simple_expression adding term .)
    ASSIGNMENT      reduce using rule 219 (simple_expression -> simple_expression adding term .)
    =               reduce using rule 219 (simple_expression -> simple_expression adding term .)
    NOTEQUAL        reduce using rule 219 (simple_expression -> simple_expression adding term .)
    <               reduce using rule 219 (simple_expression -> simple_expression adding term .)
    LESSEQ          reduce using rule 219 (simple_expression -> simple_expression adding term .)
    >               reduce using rule 219 (simple_expression -> simple_expression adding term .)
    GREATEREQ       reduce using rule 219 (simple_expression -> simple_expression adding term .)
    IN              reduce using rule 219 (simple_expression -> simple_expression adding term .)
    NOT             reduce using rule 219 (simple_expression -> simple_expression adding term .)
    DOTDOT          reduce using rule 219 (simple_expression -> simple_expression adding term .)
    *               shift and go to state 240
    /               shift and go to state 241
    MOD             shift and go to state 242
    REM             shift and go to state 238

    multiplying                    shift and go to state 239

state 358

    (62) range -> simple_expression . DOTDOT simple_expression
    (219) simple_expression -> simple_expression . adding term
    (222) adding -> . +
    (223) adding -> . -
    (224) adding -> . &

    DOTDOT          shift and go to state 364
    +               shift and go to state 210
    -               shift and go to state 212
    &               shift and go to state 211

    adding                         shift and go to state 208

state 359

    (208) relation -> simple_expression membership name .
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id
    (235) primary -> name .
    (241) qualified -> name . TICK parenthesized_primary

    AND             reduce using rule 208 (relation -> simple_expression membership name .)
    OR              reduce using rule 208 (relation -> simple_expression membership name .)
    )               reduce using rule 208 (relation -> simple_expression membership name .)
    ,               reduce using rule 208 (relation -> simple_expression membership name .)
    ARROW           reduce using rule 208 (relation -> simple_expression membership name .)
    |               reduce using rule 208 (relation -> simple_expression membership name .)
    WITH            reduce using rule 208 (relation -> simple_expression membership name .)
    ;               reduce using rule 208 (relation -> simple_expression membership name .)
    IS              reduce using rule 208 (relation -> simple_expression membership name .)
    THEN            reduce using rule 208 (relation -> simple_expression membership name .)
    LOOP            reduce using rule 208 (relation -> simple_expression membership name .)
    RANGE           reduce using rule 208 (relation -> simple_expression membership name .)
    DIGITS          reduce using rule 208 (relation -> simple_expression membership name .)
    RENAMES         reduce using rule 208 (relation -> simple_expression membership name .)
    ASSIGNMENT      reduce using rule 208 (relation -> simple_expression membership name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 370
    STARSTAR        reduce using rule 235 (primary -> name .)
    *               reduce using rule 235 (primary -> name .)
    /               reduce using rule 235 (primary -> name .)
    MOD             reduce using rule 235 (primary -> name .)
    REM             reduce using rule 235 (primary -> name .)
    DOTDOT          reduce using rule 235 (primary -> name .)
    +               reduce using rule 235 (primary -> name .)
    -               reduce using rule 235 (primary -> name .)
    &               reduce using rule 235 (primary -> name .)


state 360

    (207) relation -> simple_expression membership range .

    AND             reduce using rule 207 (relation -> simple_expression membership range .)
    OR              reduce using rule 207 (relation -> simple_expression membership range .)
    )               reduce using rule 207 (relation -> simple_expression membership range .)
    ,               reduce using rule 207 (relation -> simple_expression membership range .)
    ARROW           reduce using rule 207 (relation -> simple_expression membership range .)
    |               reduce using rule 207 (relation -> simple_expression membership range .)
    WITH            reduce using rule 207 (relation -> simple_expression membership range .)
    ;               reduce using rule 207 (relation -> simple_expression membership range .)
    IS              reduce using rule 207 (relation -> simple_expression membership range .)
    THEN            reduce using rule 207 (relation -> simple_expression membership range .)
    LOOP            reduce using rule 207 (relation -> simple_expression membership range .)
    RANGE           reduce using rule 207 (relation -> simple_expression membership range .)
    DIGITS          reduce using rule 207 (relation -> simple_expression membership range .)
    RENAMES         reduce using rule 207 (relation -> simple_expression membership range .)
    ASSIGNMENT      reduce using rule 207 (relation -> simple_expression membership range .)


state 361

    (216) membership -> NOT IN .

    IDENTIFIER      reduce using rule 216 (membership -> NOT IN .)
    STRING          reduce using rule 216 (membership -> NOT IN .)
    +               reduce using rule 216 (membership -> NOT IN .)
    -               reduce using rule 216 (membership -> NOT IN .)
    NOT             reduce using rule 216 (membership -> NOT IN .)
    INTEGER         reduce using rule 216 (membership -> NOT IN .)
    BASE_INTEGER    reduce using rule 216 (membership -> NOT IN .)
    FLOAT           reduce using rule 216 (membership -> NOT IN .)
    BASE_FLOAT      reduce using rule 216 (membership -> NOT IN .)
    NuLL            reduce using rule 216 (membership -> NOT IN .)
    NEW             reduce using rule 216 (membership -> NOT IN .)
    (               reduce using rule 216 (membership -> NOT IN .)
    CHAR            reduce using rule 216 (membership -> NOT IN .)


state 362

    (206) relation -> simple_expression relational simple_expression .
    (219) simple_expression -> simple_expression . adding term
    (222) adding -> . +
    (223) adding -> . -
    (224) adding -> . &

    AND             reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    OR              reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    )               reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    ,               reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    ARROW           reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    |               reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    WITH            reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    ;               reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    IS              reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    THEN            reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    LOOP            reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    RANGE           reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    DIGITS          reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    RENAMES         reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    ASSIGNMENT      reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    +               shift and go to state 210
    -               shift and go to state 212
    &               shift and go to state 211

    adding                         shift and go to state 208

state 363

    (7) pragma_arg -> simple_name ARROW expression .
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    )               reduce using rule 7 (pragma_arg -> simple_name ARROW expression .)
    ,               reduce using rule 7 (pragma_arg -> simple_name ARROW expression .)
    AND             shift and go to state 247
    OR              shift and go to state 250

    short_circuit                  shift and go to state 249
    logical                        shift and go to state 248

state 364

    (62) range -> simple_expression DOTDOT . simple_expression
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    simple_expression              shift and go to state 514
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149

state 365

    (122) choice_s -> choice_s | . choice
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    OTHERS          shift and go to state 223
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 381
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    choice                         shift and go to state 515
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    discrete_with_range            shift and go to state 516
    term                           shift and go to state 146
    name                           shift and go to state 230
    operator_symbol                shift and go to state 149
    range                          shift and go to state 232
    expression                     shift and go to state 517

state 366

    (197) comp_assoc -> choice_s ARROW . expression
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 518

state 367

    (190) aggregate -> ( comp_assoc ) .

    STARSTAR        reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    *               reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    /               reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    MOD             reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    REM             reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    =               reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    NOTEQUAL        reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    <               reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    LESSEQ          reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    >               reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    GREATEREQ       reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    IN              reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    NOT             reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    +               reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    -               reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    &               reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    AND             reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    OR              reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    )               reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    ,               reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    DOTDOT          reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    WITH            reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    ARROW           reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    |               reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    ;               reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    IS              reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    THEN            reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    LOOP            reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    RANGE           reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    DIGITS          reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    RENAMES         reduce using rule 190 (aggregate -> ( comp_assoc ) .)
    ASSIGNMENT      reduce using rule 190 (aggregate -> ( comp_assoc ) .)


state 368

    (191) aggregate -> ( value_s_2 ) .

    STARSTAR        reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    *               reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    /               reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    MOD             reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    REM             reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    =               reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    NOTEQUAL        reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    <               reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    LESSEQ          reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    >               reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    GREATEREQ       reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    IN              reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    NOT             reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    +               reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    -               reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    &               reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    AND             reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    OR              reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    )               reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    ,               reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    DOTDOT          reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    WITH            reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    ARROW           reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    |               reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    ;               reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    IS              reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    THEN            reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    LOOP            reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    RANGE           reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    DIGITS          reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    RENAMES         reduce using rule 191 (aggregate -> ( value_s_2 ) .)
    ASSIGNMENT      reduce using rule 191 (aggregate -> ( value_s_2 ) .)


state 369

    (196) value_s_2 -> value_s_2 , . value
    (171) value -> . expression
    (172) value -> . comp_assoc
    (173) value -> . discrete_with_range
    (174) value -> . error
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (197) comp_assoc -> . choice_s ARROW expression
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 233
    OTHERS          shift and go to state 223
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 381
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    choice_s                       shift and go to state 225
    comp_assoc                     shift and go to state 382
    factor                         shift and go to state 137
    choice                         shift and go to state 227
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 146
    name                           shift and go to state 230
    operator_symbol                shift and go to state 149
    value                          shift and go to state 519
    range                          shift and go to state 232
    expression                     shift and go to state 384

state 370

    (179) attribute -> name TICK . attribute_id
    (241) qualified -> name TICK . parenthesized_primary
    (180) attribute_id -> . IDENTIFIER
    (181) attribute_id -> . DIGITS
    (182) attribute_id -> . DELTA
    (183) attribute_id -> . ACCESS
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 390
    DIGITS          shift and go to state 389
    DELTA           shift and go to state 393
    ACCESS          shift and go to state 391
    (               shift and go to state 132

    parenthesized_primary          shift and go to state 394
    aggregate                      shift and go to state 143
    attribute_id                   shift and go to state 392

state 371

    (61) range_constraint -> RANGE . range
    (62) range -> . simple_expression DOTDOT simple_expression
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    simple_expression              shift and go to state 358
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    range                          shift and go to state 520

state 372

    (126) discrete_with_range -> name range_constraint .

    )               reduce using rule 126 (discrete_with_range -> name range_constraint .)
    ,               reduce using rule 126 (discrete_with_range -> name range_constraint .)
    ARROW           reduce using rule 126 (discrete_with_range -> name range_constraint .)
    |               reduce using rule 126 (discrete_with_range -> name range_constraint .)


state 373

    (195) value_s_2 -> value , . value
    (171) value -> . expression
    (172) value -> . comp_assoc
    (173) value -> . discrete_with_range
    (174) value -> . error
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (197) comp_assoc -> . choice_s ARROW expression
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 233
    OTHERS          shift and go to state 223
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 381
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    choice_s                       shift and go to state 225
    comp_assoc                     shift and go to state 382
    factor                         shift and go to state 137
    choice                         shift and go to state 227
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 146
    name                           shift and go to state 230
    operator_symbol                shift and go to state 149
    value                          shift and go to state 521
    range                          shift and go to state 232
    expression                     shift and go to state 384

state 374

    (194) aggregate -> ( NuLL RECORD . )

    )               shift and go to state 522


state 375

    (240) parenthesized_primary -> ( expression ) .

    STARSTAR        reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    *               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    /               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    MOD             reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    REM             reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    =               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    NOTEQUAL        reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    <               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    LESSEQ          reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    >               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    GREATEREQ       reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    IN              reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    NOT             reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    +               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    -               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    &               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    AND             reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    OR              reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    )               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    ,               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    ;               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    IS              reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    DOTDOT          reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    WITH            reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    ARROW           reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    |               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    THEN            reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    LOOP            reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    RANGE           reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    DIGITS          reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    RENAMES         reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    ASSIGNMENT      reduce using rule 240 (parenthesized_primary -> ( expression ) .)


state 376

    (192) aggregate -> ( expression WITH . value_s )
    (193) aggregate -> ( expression WITH . NuLL RECORD )
    (169) value_s -> . value
    (170) value_s -> . value_s , value
    (171) value -> . expression
    (172) value -> . comp_assoc
    (173) value -> . discrete_with_range
    (174) value -> . error
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (197) comp_assoc -> . choice_s ARROW expression
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    NuLL            shift and go to state 524
    error           shift and go to state 233
    OTHERS          shift and go to state 223
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    value_s                        shift and go to state 523
    simple_expression              shift and go to state 381
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    choice_s                       shift and go to state 225
    comp_assoc                     shift and go to state 382
    factor                         shift and go to state 137
    choice                         shift and go to state 227
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 146
    name                           shift and go to state 230
    operator_symbol                shift and go to state 149
    value                          shift and go to state 383
    range                          shift and go to state 232
    expression                     shift and go to state 384

state 377

    (3) pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .

    PRAGMA          reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    PRIVATE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    WITH            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    PACKAGE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    SEPARATE        reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    PROCEDURE       reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    FUNCTION        reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    GENERIC         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    $end            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    TASK            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    PROTECTED       reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    error           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    USE             reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    TYPE            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    SUBTYPE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    FOR             reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    IDENTIFIER      reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    BEGIN           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    END             reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    LESSLESS        reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    NuLL            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    EXIT            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    RETURN          reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    GOTO            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    DELAY           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    ABORT           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    RAISE           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    REQUEUE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    IF              reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    CASE            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    ACCEPT          reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    SELECT          reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    STRING          reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    WHILE           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    DECLARE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    LOOP            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    WHEN            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    ENTRY           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    EXCEPTION       reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    ELSIF           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    ELSE            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    OR              reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    THEN            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)


state 378

    (5) pragma_arg_s -> pragma_arg_s , pragma_arg .

    )               reduce using rule 5 (pragma_arg_s -> pragma_arg_s , pragma_arg .)
    ,               reduce using rule 5 (pragma_arg_s -> pragma_arg_s , pragma_arg .)


state 379

    (226) term -> term multiplying factor .

    *               reduce using rule 226 (term -> term multiplying factor .)
    /               reduce using rule 226 (term -> term multiplying factor .)
    MOD             reduce using rule 226 (term -> term multiplying factor .)
    REM             reduce using rule 226 (term -> term multiplying factor .)
    =               reduce using rule 226 (term -> term multiplying factor .)
    NOTEQUAL        reduce using rule 226 (term -> term multiplying factor .)
    <               reduce using rule 226 (term -> term multiplying factor .)
    LESSEQ          reduce using rule 226 (term -> term multiplying factor .)
    >               reduce using rule 226 (term -> term multiplying factor .)
    GREATEREQ       reduce using rule 226 (term -> term multiplying factor .)
    IN              reduce using rule 226 (term -> term multiplying factor .)
    NOT             reduce using rule 226 (term -> term multiplying factor .)
    +               reduce using rule 226 (term -> term multiplying factor .)
    -               reduce using rule 226 (term -> term multiplying factor .)
    &               reduce using rule 226 (term -> term multiplying factor .)
    IS              reduce using rule 226 (term -> term multiplying factor .)
    AND             reduce using rule 226 (term -> term multiplying factor .)
    OR              reduce using rule 226 (term -> term multiplying factor .)
    )               reduce using rule 226 (term -> term multiplying factor .)
    ,               reduce using rule 226 (term -> term multiplying factor .)
    DOTDOT          reduce using rule 226 (term -> term multiplying factor .)
    WITH            reduce using rule 226 (term -> term multiplying factor .)
    ARROW           reduce using rule 226 (term -> term multiplying factor .)
    |               reduce using rule 226 (term -> term multiplying factor .)
    ;               reduce using rule 226 (term -> term multiplying factor .)
    THEN            reduce using rule 226 (term -> term multiplying factor .)
    LOOP            reduce using rule 226 (term -> term multiplying factor .)
    RANGE           reduce using rule 226 (term -> term multiplying factor .)
    DIGITS          reduce using rule 226 (term -> term multiplying factor .)
    RENAMES         reduce using rule 226 (term -> term multiplying factor .)
    ASSIGNMENT      reduce using rule 226 (term -> term multiplying factor .)


state 380

    (168) indexed_comp -> name ( value_s . )
    (170) value_s -> value_s . , value

    )               shift and go to state 525
    ,               shift and go to state 526


state 381

    (205) relation -> simple_expression .
    (206) relation -> simple_expression . relational simple_expression
    (207) relation -> simple_expression . membership range
    (208) relation -> simple_expression . membership name
    (62) range -> simple_expression . DOTDOT simple_expression
    (219) simple_expression -> simple_expression . adding term
    (209) relational -> . =
    (210) relational -> . NOTEQUAL
    (211) relational -> . <
    (212) relational -> . LESSEQ
    (213) relational -> . >
    (214) relational -> . GREATEREQ
    (215) membership -> . IN
    (216) membership -> . NOT IN
    (222) adding -> . +
    (223) adding -> . -
    (224) adding -> . &

    AND             reduce using rule 205 (relation -> simple_expression .)
    OR              reduce using rule 205 (relation -> simple_expression .)
    )               reduce using rule 205 (relation -> simple_expression .)
    ,               reduce using rule 205 (relation -> simple_expression .)
    ARROW           reduce using rule 205 (relation -> simple_expression .)
    |               reduce using rule 205 (relation -> simple_expression .)
    DOTDOT          shift and go to state 364
    =               shift and go to state 219
    NOTEQUAL        shift and go to state 209
    <               shift and go to state 220
    LESSEQ          shift and go to state 215
    >               shift and go to state 221
    GREATEREQ       shift and go to state 214
    IN              shift and go to state 216
    NOT             shift and go to state 217
    +               shift and go to state 210
    -               shift and go to state 212
    &               shift and go to state 211

    adding                         shift and go to state 208
    membership                     shift and go to state 213
    relational                     shift and go to state 218

state 382

    (172) value -> comp_assoc .

    )               reduce using rule 172 (value -> comp_assoc .)
    ,               reduce using rule 172 (value -> comp_assoc .)


state 383

    (169) value_s -> value .

    )               reduce using rule 169 (value_s -> value .)
    ,               reduce using rule 169 (value_s -> value .)


state 384

    (171) value -> expression .
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (123) choice -> expression .
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    )               reduce using rule 171 (value -> expression .)
    ,               reduce using rule 171 (value -> expression .)
    ARROW           reduce using rule 123 (choice -> expression .)
    |               reduce using rule 123 (choice -> expression .)
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 385

    (178) selected_comp -> name . ALL .

    ASSIGNMENT      reduce using rule 178 (selected_comp -> name . ALL .)
    ;               reduce using rule 178 (selected_comp -> name . ALL .)
    TICK            reduce using rule 178 (selected_comp -> name . ALL .)
    (               reduce using rule 178 (selected_comp -> name . ALL .)
    .               reduce using rule 178 (selected_comp -> name . ALL .)
    RANGE           reduce using rule 178 (selected_comp -> name . ALL .)
    STARSTAR        reduce using rule 178 (selected_comp -> name . ALL .)
    *               reduce using rule 178 (selected_comp -> name . ALL .)
    /               reduce using rule 178 (selected_comp -> name . ALL .)
    MOD             reduce using rule 178 (selected_comp -> name . ALL .)
    REM             reduce using rule 178 (selected_comp -> name . ALL .)
    DOTDOT          reduce using rule 178 (selected_comp -> name . ALL .)
    =               reduce using rule 178 (selected_comp -> name . ALL .)
    NOTEQUAL        reduce using rule 178 (selected_comp -> name . ALL .)
    <               reduce using rule 178 (selected_comp -> name . ALL .)
    LESSEQ          reduce using rule 178 (selected_comp -> name . ALL .)
    >               reduce using rule 178 (selected_comp -> name . ALL .)
    GREATEREQ       reduce using rule 178 (selected_comp -> name . ALL .)
    IN              reduce using rule 178 (selected_comp -> name . ALL .)
    NOT             reduce using rule 178 (selected_comp -> name . ALL .)
    +               reduce using rule 178 (selected_comp -> name . ALL .)
    -               reduce using rule 178 (selected_comp -> name . ALL .)
    &               reduce using rule 178 (selected_comp -> name . ALL .)
    AND             reduce using rule 178 (selected_comp -> name . ALL .)
    OR              reduce using rule 178 (selected_comp -> name . ALL .)
    )               reduce using rule 178 (selected_comp -> name . ALL .)
    ,               reduce using rule 178 (selected_comp -> name . ALL .)
    ARROW           reduce using rule 178 (selected_comp -> name . ALL .)
    |               reduce using rule 178 (selected_comp -> name . ALL .)
    DIGITS          reduce using rule 178 (selected_comp -> name . ALL .)
    WITH            reduce using rule 178 (selected_comp -> name . ALL .)
    IS              reduce using rule 178 (selected_comp -> name . ALL .)
    THEN            reduce using rule 178 (selected_comp -> name . ALL .)
    LOOP            reduce using rule 178 (selected_comp -> name . ALL .)
    RENAMES         reduce using rule 178 (selected_comp -> name . ALL .)
    WHEN            reduce using rule 178 (selected_comp -> name . ALL .)


state 386

    (177) selected_comp -> name . operator_symbol .

    ASSIGNMENT      reduce using rule 177 (selected_comp -> name . operator_symbol .)
    ;               reduce using rule 177 (selected_comp -> name . operator_symbol .)
    TICK            reduce using rule 177 (selected_comp -> name . operator_symbol .)
    (               reduce using rule 177 (selected_comp -> name . operator_symbol .)
    .               reduce using rule 177 (selected_comp -> name . operator_symbol .)
    RANGE           reduce using rule 177 (selected_comp -> name . operator_symbol .)
    STARSTAR        reduce using rule 177 (selected_comp -> name . operator_symbol .)
    *               reduce using rule 177 (selected_comp -> name . operator_symbol .)
    /               reduce using rule 177 (selected_comp -> name . operator_symbol .)
    MOD             reduce using rule 177 (selected_comp -> name . operator_symbol .)
    REM             reduce using rule 177 (selected_comp -> name . operator_symbol .)
    DOTDOT          reduce using rule 177 (selected_comp -> name . operator_symbol .)
    =               reduce using rule 177 (selected_comp -> name . operator_symbol .)
    NOTEQUAL        reduce using rule 177 (selected_comp -> name . operator_symbol .)
    <               reduce using rule 177 (selected_comp -> name . operator_symbol .)
    LESSEQ          reduce using rule 177 (selected_comp -> name . operator_symbol .)
    >               reduce using rule 177 (selected_comp -> name . operator_symbol .)
    GREATEREQ       reduce using rule 177 (selected_comp -> name . operator_symbol .)
    IN              reduce using rule 177 (selected_comp -> name . operator_symbol .)
    NOT             reduce using rule 177 (selected_comp -> name . operator_symbol .)
    +               reduce using rule 177 (selected_comp -> name . operator_symbol .)
    -               reduce using rule 177 (selected_comp -> name . operator_symbol .)
    &               reduce using rule 177 (selected_comp -> name . operator_symbol .)
    AND             reduce using rule 177 (selected_comp -> name . operator_symbol .)
    OR              reduce using rule 177 (selected_comp -> name . operator_symbol .)
    )               reduce using rule 177 (selected_comp -> name . operator_symbol .)
    ,               reduce using rule 177 (selected_comp -> name . operator_symbol .)
    ARROW           reduce using rule 177 (selected_comp -> name . operator_symbol .)
    |               reduce using rule 177 (selected_comp -> name . operator_symbol .)
    DIGITS          reduce using rule 177 (selected_comp -> name . operator_symbol .)
    WITH            reduce using rule 177 (selected_comp -> name . operator_symbol .)
    IS              reduce using rule 177 (selected_comp -> name . operator_symbol .)
    THEN            reduce using rule 177 (selected_comp -> name . operator_symbol .)
    LOOP            reduce using rule 177 (selected_comp -> name . operator_symbol .)
    RENAMES         reduce using rule 177 (selected_comp -> name . operator_symbol .)
    WHEN            reduce using rule 177 (selected_comp -> name . operator_symbol .)


state 387

    (176) selected_comp -> name . used_char .

    ASSIGNMENT      reduce using rule 176 (selected_comp -> name . used_char .)
    ;               reduce using rule 176 (selected_comp -> name . used_char .)
    TICK            reduce using rule 176 (selected_comp -> name . used_char .)
    (               reduce using rule 176 (selected_comp -> name . used_char .)
    .               reduce using rule 176 (selected_comp -> name . used_char .)
    RANGE           reduce using rule 176 (selected_comp -> name . used_char .)
    STARSTAR        reduce using rule 176 (selected_comp -> name . used_char .)
    *               reduce using rule 176 (selected_comp -> name . used_char .)
    /               reduce using rule 176 (selected_comp -> name . used_char .)
    MOD             reduce using rule 176 (selected_comp -> name . used_char .)
    REM             reduce using rule 176 (selected_comp -> name . used_char .)
    DOTDOT          reduce using rule 176 (selected_comp -> name . used_char .)
    =               reduce using rule 176 (selected_comp -> name . used_char .)
    NOTEQUAL        reduce using rule 176 (selected_comp -> name . used_char .)
    <               reduce using rule 176 (selected_comp -> name . used_char .)
    LESSEQ          reduce using rule 176 (selected_comp -> name . used_char .)
    >               reduce using rule 176 (selected_comp -> name . used_char .)
    GREATEREQ       reduce using rule 176 (selected_comp -> name . used_char .)
    IN              reduce using rule 176 (selected_comp -> name . used_char .)
    NOT             reduce using rule 176 (selected_comp -> name . used_char .)
    +               reduce using rule 176 (selected_comp -> name . used_char .)
    -               reduce using rule 176 (selected_comp -> name . used_char .)
    &               reduce using rule 176 (selected_comp -> name . used_char .)
    AND             reduce using rule 176 (selected_comp -> name . used_char .)
    OR              reduce using rule 176 (selected_comp -> name . used_char .)
    )               reduce using rule 176 (selected_comp -> name . used_char .)
    ,               reduce using rule 176 (selected_comp -> name . used_char .)
    ARROW           reduce using rule 176 (selected_comp -> name . used_char .)
    |               reduce using rule 176 (selected_comp -> name . used_char .)
    DIGITS          reduce using rule 176 (selected_comp -> name . used_char .)
    WITH            reduce using rule 176 (selected_comp -> name . used_char .)
    IS              reduce using rule 176 (selected_comp -> name . used_char .)
    THEN            reduce using rule 176 (selected_comp -> name . used_char .)
    LOOP            reduce using rule 176 (selected_comp -> name . used_char .)
    RENAMES         reduce using rule 176 (selected_comp -> name . used_char .)
    WHEN            reduce using rule 176 (selected_comp -> name . used_char .)


state 388

    (175) selected_comp -> name . simple_name .

    ASSIGNMENT      reduce using rule 175 (selected_comp -> name . simple_name .)
    ;               reduce using rule 175 (selected_comp -> name . simple_name .)
    TICK            reduce using rule 175 (selected_comp -> name . simple_name .)
    (               reduce using rule 175 (selected_comp -> name . simple_name .)
    .               reduce using rule 175 (selected_comp -> name . simple_name .)
    RANGE           reduce using rule 175 (selected_comp -> name . simple_name .)
    STARSTAR        reduce using rule 175 (selected_comp -> name . simple_name .)
    *               reduce using rule 175 (selected_comp -> name . simple_name .)
    /               reduce using rule 175 (selected_comp -> name . simple_name .)
    MOD             reduce using rule 175 (selected_comp -> name . simple_name .)
    REM             reduce using rule 175 (selected_comp -> name . simple_name .)
    DOTDOT          reduce using rule 175 (selected_comp -> name . simple_name .)
    =               reduce using rule 175 (selected_comp -> name . simple_name .)
    NOTEQUAL        reduce using rule 175 (selected_comp -> name . simple_name .)
    <               reduce using rule 175 (selected_comp -> name . simple_name .)
    LESSEQ          reduce using rule 175 (selected_comp -> name . simple_name .)
    >               reduce using rule 175 (selected_comp -> name . simple_name .)
    GREATEREQ       reduce using rule 175 (selected_comp -> name . simple_name .)
    IN              reduce using rule 175 (selected_comp -> name . simple_name .)
    NOT             reduce using rule 175 (selected_comp -> name . simple_name .)
    +               reduce using rule 175 (selected_comp -> name . simple_name .)
    -               reduce using rule 175 (selected_comp -> name . simple_name .)
    &               reduce using rule 175 (selected_comp -> name . simple_name .)
    AND             reduce using rule 175 (selected_comp -> name . simple_name .)
    OR              reduce using rule 175 (selected_comp -> name . simple_name .)
    )               reduce using rule 175 (selected_comp -> name . simple_name .)
    ,               reduce using rule 175 (selected_comp -> name . simple_name .)
    ARROW           reduce using rule 175 (selected_comp -> name . simple_name .)
    |               reduce using rule 175 (selected_comp -> name . simple_name .)
    DIGITS          reduce using rule 175 (selected_comp -> name . simple_name .)
    WITH            reduce using rule 175 (selected_comp -> name . simple_name .)
    IS              reduce using rule 175 (selected_comp -> name . simple_name .)
    THEN            reduce using rule 175 (selected_comp -> name . simple_name .)
    LOOP            reduce using rule 175 (selected_comp -> name . simple_name .)
    RENAMES         reduce using rule 175 (selected_comp -> name . simple_name .)
    WHEN            reduce using rule 175 (selected_comp -> name . simple_name .)


state 389

    (181) attribute_id -> DIGITS .

    USE             reduce using rule 181 (attribute_id -> DIGITS .)
    TICK            reduce using rule 181 (attribute_id -> DIGITS .)
    .               reduce using rule 181 (attribute_id -> DIGITS .)
    ASSIGNMENT      reduce using rule 181 (attribute_id -> DIGITS .)
    ;               reduce using rule 181 (attribute_id -> DIGITS .)
    )               reduce using rule 181 (attribute_id -> DIGITS .)
    AT              reduce using rule 181 (attribute_id -> DIGITS .)
    (               reduce using rule 181 (attribute_id -> DIGITS .)
    STARSTAR        reduce using rule 181 (attribute_id -> DIGITS .)
    *               reduce using rule 181 (attribute_id -> DIGITS .)
    /               reduce using rule 181 (attribute_id -> DIGITS .)
    MOD             reduce using rule 181 (attribute_id -> DIGITS .)
    REM             reduce using rule 181 (attribute_id -> DIGITS .)
    =               reduce using rule 181 (attribute_id -> DIGITS .)
    NOTEQUAL        reduce using rule 181 (attribute_id -> DIGITS .)
    <               reduce using rule 181 (attribute_id -> DIGITS .)
    LESSEQ          reduce using rule 181 (attribute_id -> DIGITS .)
    >               reduce using rule 181 (attribute_id -> DIGITS .)
    GREATEREQ       reduce using rule 181 (attribute_id -> DIGITS .)
    IN              reduce using rule 181 (attribute_id -> DIGITS .)
    NOT             reduce using rule 181 (attribute_id -> DIGITS .)
    +               reduce using rule 181 (attribute_id -> DIGITS .)
    -               reduce using rule 181 (attribute_id -> DIGITS .)
    &               reduce using rule 181 (attribute_id -> DIGITS .)
    AND             reduce using rule 181 (attribute_id -> DIGITS .)
    OR              reduce using rule 181 (attribute_id -> DIGITS .)
    ,               reduce using rule 181 (attribute_id -> DIGITS .)
    DOTDOT          reduce using rule 181 (attribute_id -> DIGITS .)
    WITH            reduce using rule 181 (attribute_id -> DIGITS .)
    ARROW           reduce using rule 181 (attribute_id -> DIGITS .)
    |               reduce using rule 181 (attribute_id -> DIGITS .)
    IS              reduce using rule 181 (attribute_id -> DIGITS .)
    THEN            reduce using rule 181 (attribute_id -> DIGITS .)
    LOOP            reduce using rule 181 (attribute_id -> DIGITS .)
    RANGE           reduce using rule 181 (attribute_id -> DIGITS .)
    DIGITS          reduce using rule 181 (attribute_id -> DIGITS .)
    RENAMES         reduce using rule 181 (attribute_id -> DIGITS .)
    WHEN            reduce using rule 181 (attribute_id -> DIGITS .)


state 390

    (180) attribute_id -> IDENTIFIER .

    USE             reduce using rule 180 (attribute_id -> IDENTIFIER .)
    TICK            reduce using rule 180 (attribute_id -> IDENTIFIER .)
    .               reduce using rule 180 (attribute_id -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 180 (attribute_id -> IDENTIFIER .)
    ;               reduce using rule 180 (attribute_id -> IDENTIFIER .)
    )               reduce using rule 180 (attribute_id -> IDENTIFIER .)
    AT              reduce using rule 180 (attribute_id -> IDENTIFIER .)
    (               reduce using rule 180 (attribute_id -> IDENTIFIER .)
    STARSTAR        reduce using rule 180 (attribute_id -> IDENTIFIER .)
    *               reduce using rule 180 (attribute_id -> IDENTIFIER .)
    /               reduce using rule 180 (attribute_id -> IDENTIFIER .)
    MOD             reduce using rule 180 (attribute_id -> IDENTIFIER .)
    REM             reduce using rule 180 (attribute_id -> IDENTIFIER .)
    =               reduce using rule 180 (attribute_id -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 180 (attribute_id -> IDENTIFIER .)
    <               reduce using rule 180 (attribute_id -> IDENTIFIER .)
    LESSEQ          reduce using rule 180 (attribute_id -> IDENTIFIER .)
    >               reduce using rule 180 (attribute_id -> IDENTIFIER .)
    GREATEREQ       reduce using rule 180 (attribute_id -> IDENTIFIER .)
    IN              reduce using rule 180 (attribute_id -> IDENTIFIER .)
    NOT             reduce using rule 180 (attribute_id -> IDENTIFIER .)
    +               reduce using rule 180 (attribute_id -> IDENTIFIER .)
    -               reduce using rule 180 (attribute_id -> IDENTIFIER .)
    &               reduce using rule 180 (attribute_id -> IDENTIFIER .)
    AND             reduce using rule 180 (attribute_id -> IDENTIFIER .)
    OR              reduce using rule 180 (attribute_id -> IDENTIFIER .)
    ,               reduce using rule 180 (attribute_id -> IDENTIFIER .)
    DOTDOT          reduce using rule 180 (attribute_id -> IDENTIFIER .)
    WITH            reduce using rule 180 (attribute_id -> IDENTIFIER .)
    ARROW           reduce using rule 180 (attribute_id -> IDENTIFIER .)
    |               reduce using rule 180 (attribute_id -> IDENTIFIER .)
    IS              reduce using rule 180 (attribute_id -> IDENTIFIER .)
    THEN            reduce using rule 180 (attribute_id -> IDENTIFIER .)
    LOOP            reduce using rule 180 (attribute_id -> IDENTIFIER .)
    RANGE           reduce using rule 180 (attribute_id -> IDENTIFIER .)
    DIGITS          reduce using rule 180 (attribute_id -> IDENTIFIER .)
    RENAMES         reduce using rule 180 (attribute_id -> IDENTIFIER .)
    WHEN            reduce using rule 180 (attribute_id -> IDENTIFIER .)


state 391

    (183) attribute_id -> ACCESS .

    USE             reduce using rule 183 (attribute_id -> ACCESS .)
    TICK            reduce using rule 183 (attribute_id -> ACCESS .)
    .               reduce using rule 183 (attribute_id -> ACCESS .)
    ASSIGNMENT      reduce using rule 183 (attribute_id -> ACCESS .)
    ;               reduce using rule 183 (attribute_id -> ACCESS .)
    )               reduce using rule 183 (attribute_id -> ACCESS .)
    AT              reduce using rule 183 (attribute_id -> ACCESS .)
    (               reduce using rule 183 (attribute_id -> ACCESS .)
    STARSTAR        reduce using rule 183 (attribute_id -> ACCESS .)
    *               reduce using rule 183 (attribute_id -> ACCESS .)
    /               reduce using rule 183 (attribute_id -> ACCESS .)
    MOD             reduce using rule 183 (attribute_id -> ACCESS .)
    REM             reduce using rule 183 (attribute_id -> ACCESS .)
    =               reduce using rule 183 (attribute_id -> ACCESS .)
    NOTEQUAL        reduce using rule 183 (attribute_id -> ACCESS .)
    <               reduce using rule 183 (attribute_id -> ACCESS .)
    LESSEQ          reduce using rule 183 (attribute_id -> ACCESS .)
    >               reduce using rule 183 (attribute_id -> ACCESS .)
    GREATEREQ       reduce using rule 183 (attribute_id -> ACCESS .)
    IN              reduce using rule 183 (attribute_id -> ACCESS .)
    NOT             reduce using rule 183 (attribute_id -> ACCESS .)
    +               reduce using rule 183 (attribute_id -> ACCESS .)
    -               reduce using rule 183 (attribute_id -> ACCESS .)
    &               reduce using rule 183 (attribute_id -> ACCESS .)
    AND             reduce using rule 183 (attribute_id -> ACCESS .)
    OR              reduce using rule 183 (attribute_id -> ACCESS .)
    ,               reduce using rule 183 (attribute_id -> ACCESS .)
    DOTDOT          reduce using rule 183 (attribute_id -> ACCESS .)
    WITH            reduce using rule 183 (attribute_id -> ACCESS .)
    ARROW           reduce using rule 183 (attribute_id -> ACCESS .)
    |               reduce using rule 183 (attribute_id -> ACCESS .)
    IS              reduce using rule 183 (attribute_id -> ACCESS .)
    THEN            reduce using rule 183 (attribute_id -> ACCESS .)
    LOOP            reduce using rule 183 (attribute_id -> ACCESS .)
    RANGE           reduce using rule 183 (attribute_id -> ACCESS .)
    DIGITS          reduce using rule 183 (attribute_id -> ACCESS .)
    RENAMES         reduce using rule 183 (attribute_id -> ACCESS .)
    WHEN            reduce using rule 183 (attribute_id -> ACCESS .)


state 392

    (179) attribute -> name TICK attribute_id .

    TICK            reduce using rule 179 (attribute -> name TICK attribute_id .)
    (               reduce using rule 179 (attribute -> name TICK attribute_id .)
    .               reduce using rule 179 (attribute -> name TICK attribute_id .)
    STARSTAR        reduce using rule 179 (attribute -> name TICK attribute_id .)
    *               reduce using rule 179 (attribute -> name TICK attribute_id .)
    /               reduce using rule 179 (attribute -> name TICK attribute_id .)
    MOD             reduce using rule 179 (attribute -> name TICK attribute_id .)
    REM             reduce using rule 179 (attribute -> name TICK attribute_id .)
    +               reduce using rule 179 (attribute -> name TICK attribute_id .)
    -               reduce using rule 179 (attribute -> name TICK attribute_id .)
    &               reduce using rule 179 (attribute -> name TICK attribute_id .)
    AND             reduce using rule 179 (attribute -> name TICK attribute_id .)
    OR              reduce using rule 179 (attribute -> name TICK attribute_id .)
    )               reduce using rule 179 (attribute -> name TICK attribute_id .)
    ,               reduce using rule 179 (attribute -> name TICK attribute_id .)
    WITH            reduce using rule 179 (attribute -> name TICK attribute_id .)
    ARROW           reduce using rule 179 (attribute -> name TICK attribute_id .)
    |               reduce using rule 179 (attribute -> name TICK attribute_id .)
    ;               reduce using rule 179 (attribute -> name TICK attribute_id .)
    IS              reduce using rule 179 (attribute -> name TICK attribute_id .)
    THEN            reduce using rule 179 (attribute -> name TICK attribute_id .)
    LOOP            reduce using rule 179 (attribute -> name TICK attribute_id .)
    RANGE           reduce using rule 179 (attribute -> name TICK attribute_id .)
    DIGITS          reduce using rule 179 (attribute -> name TICK attribute_id .)
    RENAMES         reduce using rule 179 (attribute -> name TICK attribute_id .)
    ASSIGNMENT      reduce using rule 179 (attribute -> name TICK attribute_id .)
    DOTDOT          reduce using rule 179 (attribute -> name TICK attribute_id .)
    =               reduce using rule 179 (attribute -> name TICK attribute_id .)
    NOTEQUAL        reduce using rule 179 (attribute -> name TICK attribute_id .)
    <               reduce using rule 179 (attribute -> name TICK attribute_id .)
    LESSEQ          reduce using rule 179 (attribute -> name TICK attribute_id .)
    >               reduce using rule 179 (attribute -> name TICK attribute_id .)
    GREATEREQ       reduce using rule 179 (attribute -> name TICK attribute_id .)
    IN              reduce using rule 179 (attribute -> name TICK attribute_id .)
    NOT             reduce using rule 179 (attribute -> name TICK attribute_id .)
    WHEN            reduce using rule 179 (attribute -> name TICK attribute_id .)


state 393

    (182) attribute_id -> DELTA .

    USE             reduce using rule 182 (attribute_id -> DELTA .)
    TICK            reduce using rule 182 (attribute_id -> DELTA .)
    .               reduce using rule 182 (attribute_id -> DELTA .)
    ASSIGNMENT      reduce using rule 182 (attribute_id -> DELTA .)
    ;               reduce using rule 182 (attribute_id -> DELTA .)
    )               reduce using rule 182 (attribute_id -> DELTA .)
    AT              reduce using rule 182 (attribute_id -> DELTA .)
    (               reduce using rule 182 (attribute_id -> DELTA .)
    STARSTAR        reduce using rule 182 (attribute_id -> DELTA .)
    *               reduce using rule 182 (attribute_id -> DELTA .)
    /               reduce using rule 182 (attribute_id -> DELTA .)
    MOD             reduce using rule 182 (attribute_id -> DELTA .)
    REM             reduce using rule 182 (attribute_id -> DELTA .)
    =               reduce using rule 182 (attribute_id -> DELTA .)
    NOTEQUAL        reduce using rule 182 (attribute_id -> DELTA .)
    <               reduce using rule 182 (attribute_id -> DELTA .)
    LESSEQ          reduce using rule 182 (attribute_id -> DELTA .)
    >               reduce using rule 182 (attribute_id -> DELTA .)
    GREATEREQ       reduce using rule 182 (attribute_id -> DELTA .)
    IN              reduce using rule 182 (attribute_id -> DELTA .)
    NOT             reduce using rule 182 (attribute_id -> DELTA .)
    +               reduce using rule 182 (attribute_id -> DELTA .)
    -               reduce using rule 182 (attribute_id -> DELTA .)
    &               reduce using rule 182 (attribute_id -> DELTA .)
    AND             reduce using rule 182 (attribute_id -> DELTA .)
    OR              reduce using rule 182 (attribute_id -> DELTA .)
    ,               reduce using rule 182 (attribute_id -> DELTA .)
    DOTDOT          reduce using rule 182 (attribute_id -> DELTA .)
    WITH            reduce using rule 182 (attribute_id -> DELTA .)
    ARROW           reduce using rule 182 (attribute_id -> DELTA .)
    |               reduce using rule 182 (attribute_id -> DELTA .)
    IS              reduce using rule 182 (attribute_id -> DELTA .)
    THEN            reduce using rule 182 (attribute_id -> DELTA .)
    LOOP            reduce using rule 182 (attribute_id -> DELTA .)
    RANGE           reduce using rule 182 (attribute_id -> DELTA .)
    DIGITS          reduce using rule 182 (attribute_id -> DELTA .)
    RENAMES         reduce using rule 182 (attribute_id -> DELTA .)
    WHEN            reduce using rule 182 (attribute_id -> DELTA .)


state 394

    (241) qualified -> name TICK parenthesized_primary .

    STARSTAR        reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    *               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    /               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    MOD             reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    REM             reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    =               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    NOTEQUAL        reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    <               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    LESSEQ          reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    >               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    GREATEREQ       reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    IN              reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    NOT             reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    +               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    -               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    &               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    AND             reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    OR              reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    )               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    ,               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    DOTDOT          reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    WITH            reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    ARROW           reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    |               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    ;               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    IS              reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    THEN            reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    LOOP            reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    RANGE           reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    DIGITS          reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    RENAMES         reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    ASSIGNMENT      reduce using rule 241 (qualified -> name TICK parenthesized_primary .)


state 395

    (203) short_circuit -> AND THEN .

    +               reduce using rule 203 (short_circuit -> AND THEN .)
    -               reduce using rule 203 (short_circuit -> AND THEN .)
    NOT             reduce using rule 203 (short_circuit -> AND THEN .)
    INTEGER         reduce using rule 203 (short_circuit -> AND THEN .)
    BASE_INTEGER    reduce using rule 203 (short_circuit -> AND THEN .)
    FLOAT           reduce using rule 203 (short_circuit -> AND THEN .)
    BASE_FLOAT      reduce using rule 203 (short_circuit -> AND THEN .)
    NuLL            reduce using rule 203 (short_circuit -> AND THEN .)
    NEW             reduce using rule 203 (short_circuit -> AND THEN .)
    (               reduce using rule 203 (short_circuit -> AND THEN .)
    CHAR            reduce using rule 203 (short_circuit -> AND THEN .)
    IDENTIFIER      reduce using rule 203 (short_circuit -> AND THEN .)
    STRING          reduce using rule 203 (short_circuit -> AND THEN .)


state 396

    (199) expression -> expression logical relation .

    AND             reduce using rule 199 (expression -> expression logical relation .)
    OR              reduce using rule 199 (expression -> expression logical relation .)
    )               reduce using rule 199 (expression -> expression logical relation .)
    ,               reduce using rule 199 (expression -> expression logical relation .)
    ARROW           reduce using rule 199 (expression -> expression logical relation .)
    |               reduce using rule 199 (expression -> expression logical relation .)
    ;               reduce using rule 199 (expression -> expression logical relation .)
    IS              reduce using rule 199 (expression -> expression logical relation .)
    RANGE           reduce using rule 199 (expression -> expression logical relation .)
    THEN            reduce using rule 199 (expression -> expression logical relation .)
    RENAMES         reduce using rule 199 (expression -> expression logical relation .)
    ASSIGNMENT      reduce using rule 199 (expression -> expression logical relation .)
    WITH            reduce using rule 199 (expression -> expression logical relation .)
    LOOP            reduce using rule 199 (expression -> expression logical relation .)
    DIGITS          reduce using rule 199 (expression -> expression logical relation .)


state 397

    (200) expression -> expression short_circuit relation .

    AND             reduce using rule 200 (expression -> expression short_circuit relation .)
    OR              reduce using rule 200 (expression -> expression short_circuit relation .)
    )               reduce using rule 200 (expression -> expression short_circuit relation .)
    ,               reduce using rule 200 (expression -> expression short_circuit relation .)
    ARROW           reduce using rule 200 (expression -> expression short_circuit relation .)
    |               reduce using rule 200 (expression -> expression short_circuit relation .)
    ;               reduce using rule 200 (expression -> expression short_circuit relation .)
    IS              reduce using rule 200 (expression -> expression short_circuit relation .)
    RANGE           reduce using rule 200 (expression -> expression short_circuit relation .)
    THEN            reduce using rule 200 (expression -> expression short_circuit relation .)
    RENAMES         reduce using rule 200 (expression -> expression short_circuit relation .)
    ASSIGNMENT      reduce using rule 200 (expression -> expression short_circuit relation .)
    WITH            reduce using rule 200 (expression -> expression short_circuit relation .)
    LOOP            reduce using rule 200 (expression -> expression short_circuit relation .)
    DIGITS          reduce using rule 200 (expression -> expression short_circuit relation .)


state 398

    (204) short_circuit -> OR ELSE .

    +               reduce using rule 204 (short_circuit -> OR ELSE .)
    -               reduce using rule 204 (short_circuit -> OR ELSE .)
    NOT             reduce using rule 204 (short_circuit -> OR ELSE .)
    INTEGER         reduce using rule 204 (short_circuit -> OR ELSE .)
    BASE_INTEGER    reduce using rule 204 (short_circuit -> OR ELSE .)
    FLOAT           reduce using rule 204 (short_circuit -> OR ELSE .)
    BASE_FLOAT      reduce using rule 204 (short_circuit -> OR ELSE .)
    NuLL            reduce using rule 204 (short_circuit -> OR ELSE .)
    NEW             reduce using rule 204 (short_circuit -> OR ELSE .)
    (               reduce using rule 204 (short_circuit -> OR ELSE .)
    CHAR            reduce using rule 204 (short_circuit -> OR ELSE .)
    IDENTIFIER      reduce using rule 204 (short_circuit -> OR ELSE .)
    STRING          reduce using rule 204 (short_circuit -> OR ELSE .)


state 399

    (351) name_s -> name_s , name .
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id

    ;               reduce using rule 351 (name_s -> name_s , name .)
    ,               reduce using rule 351 (name_s -> name_s , name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 400

    (349) use_clause -> USE TYPE name_s ; .

    PACKAGE         reduce using rule 349 (use_clause -> USE TYPE name_s ; .)
    TASK            reduce using rule 349 (use_clause -> USE TYPE name_s ; .)
    PROTECTED       reduce using rule 349 (use_clause -> USE TYPE name_s ; .)
    error           reduce using rule 349 (use_clause -> USE TYPE name_s ; .)
    USE             reduce using rule 349 (use_clause -> USE TYPE name_s ; .)
    PRAGMA          reduce using rule 349 (use_clause -> USE TYPE name_s ; .)
    TYPE            reduce using rule 349 (use_clause -> USE TYPE name_s ; .)
    SUBTYPE         reduce using rule 349 (use_clause -> USE TYPE name_s ; .)
    FOR             reduce using rule 349 (use_clause -> USE TYPE name_s ; .)
    PROCEDURE       reduce using rule 349 (use_clause -> USE TYPE name_s ; .)
    FUNCTION        reduce using rule 349 (use_clause -> USE TYPE name_s ; .)
    GENERIC         reduce using rule 349 (use_clause -> USE TYPE name_s ; .)
    IDENTIFIER      reduce using rule 349 (use_clause -> USE TYPE name_s ; .)
    BEGIN           reduce using rule 349 (use_clause -> USE TYPE name_s ; .)
    PRIVATE         reduce using rule 349 (use_clause -> USE TYPE name_s ; .)
    WITH            reduce using rule 349 (use_clause -> USE TYPE name_s ; .)
    SEPARATE        reduce using rule 349 (use_clause -> USE TYPE name_s ; .)
    END             reduce using rule 349 (use_clause -> USE TYPE name_s ; .)


state 401

    (449) subunit_body -> subprog_body .

    PRAGMA          reduce using rule 449 (subunit_body -> subprog_body .)
    PRIVATE         reduce using rule 449 (subunit_body -> subprog_body .)
    WITH            reduce using rule 449 (subunit_body -> subprog_body .)
    PACKAGE         reduce using rule 449 (subunit_body -> subprog_body .)
    SEPARATE        reduce using rule 449 (subunit_body -> subprog_body .)
    PROCEDURE       reduce using rule 449 (subunit_body -> subprog_body .)
    FUNCTION        reduce using rule 449 (subunit_body -> subprog_body .)
    GENERIC         reduce using rule 449 (subunit_body -> subprog_body .)
    $end            reduce using rule 449 (subunit_body -> subprog_body .)


state 402

    (451) subunit_body -> task_body .

    PRAGMA          reduce using rule 451 (subunit_body -> task_body .)
    PRIVATE         reduce using rule 451 (subunit_body -> task_body .)
    WITH            reduce using rule 451 (subunit_body -> task_body .)
    PACKAGE         reduce using rule 451 (subunit_body -> task_body .)
    SEPARATE        reduce using rule 451 (subunit_body -> task_body .)
    PROCEDURE       reduce using rule 451 (subunit_body -> task_body .)
    FUNCTION        reduce using rule 451 (subunit_body -> task_body .)
    GENERIC         reduce using rule 451 (subunit_body -> task_body .)
    $end            reduce using rule 451 (subunit_body -> task_body .)


state 403

    (384) prot_body -> PROTECTED . BODY simple_name IS prot_op_body_s END id_opt ;

    BODY            shift and go to state 527


state 404

    (448) subunit -> SEPARATE ( compound_name ) subunit_body .

    PRAGMA          reduce using rule 448 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    PRIVATE         reduce using rule 448 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    WITH            reduce using rule 448 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    PACKAGE         reduce using rule 448 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    SEPARATE        reduce using rule 448 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    PROCEDURE       reduce using rule 448 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    FUNCTION        reduce using rule 448 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    GENERIC         reduce using rule 448 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    $end            reduce using rule 448 (subunit -> SEPARATE ( compound_name ) subunit_body .)


state 405

    (367) task_body -> TASK . BODY simple_name IS decl_part block_body END id_opt ;

    BODY            shift and go to state 528


state 406

    (333) subprog_body -> subprog_spec_is_push . decl_part block_body END id_opt ;
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (333) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (342) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (367) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (384) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (348) use_clause -> . USE name_s ;
    (349) use_clause -> . USE TYPE name_s ;
    (502) rep_spec -> . attrib_def
    (503) rep_spec -> . record_type_spec
    (504) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (332) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (312) subprog_decl -> . subprog_spec ;
    (313) subprog_decl -> . generic_subp_inst ;
    (314) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (335) pkg_decl -> . pkg_spec ;
    (336) pkg_decl -> . generic_pkg_inst ;
    (360) task_decl -> . task_spec ;
    (368) prot_decl -> . prot_spec ;
    (457) exception_decl -> . def_id_s : EXCEPTION ;
    (352) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (353) rename_decl -> . def_id_s : EXCEPTION renames ;
    (354) rename_decl -> . rename_unit
    (469) generic_decl -> . generic_formal_part subprog_spec ;
    (470) generic_decl -> . generic_formal_part pkg_spec ;
    (453) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (454) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (455) body_stub -> . subprog_spec IS SEPARATE ;
    (456) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (505) attrib_def -> . FOR mark USE expression ;
    (506) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (511) address_spec -> . FOR mark USE AT expression ;
    (315) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (316) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (317) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (499) generic_subp_inst -> . subprog_spec IS generic_inst
    (337) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (361) task_spec -> . TASK simple_name task_def
    (362) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (369) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (370) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (355) rename_unit -> . PACKAGE compound_name renames ;
    (356) rename_unit -> . subprog_spec renames ;
    (357) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (358) rename_unit -> . generic_formal_part subprog_spec renames ;
    (471) generic_formal_part -> . GENERIC
    (472) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 54
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 407

    (332) subprog_spec_is_push -> subprog_spec . IS

    IS              shift and go to state 529


state 408

    (342) pkg_body -> PACKAGE . BODY compound_name IS decl_part body_opt END c_id_opt ;

    BODY            shift and go to state 98


state 409

    (452) subunit_body -> prot_body .

    PRAGMA          reduce using rule 452 (subunit_body -> prot_body .)
    PRIVATE         reduce using rule 452 (subunit_body -> prot_body .)
    WITH            reduce using rule 452 (subunit_body -> prot_body .)
    PACKAGE         reduce using rule 452 (subunit_body -> prot_body .)
    SEPARATE        reduce using rule 452 (subunit_body -> prot_body .)
    PROCEDURE       reduce using rule 452 (subunit_body -> prot_body .)
    FUNCTION        reduce using rule 452 (subunit_body -> prot_body .)
    GENERIC         reduce using rule 452 (subunit_body -> prot_body .)
    $end            reduce using rule 452 (subunit_body -> prot_body .)


state 410

    (450) subunit_body -> pkg_body .

    PRAGMA          reduce using rule 450 (subunit_body -> pkg_body .)
    PRIVATE         reduce using rule 450 (subunit_body -> pkg_body .)
    WITH            reduce using rule 450 (subunit_body -> pkg_body .)
    PACKAGE         reduce using rule 450 (subunit_body -> pkg_body .)
    SEPARATE        reduce using rule 450 (subunit_body -> pkg_body .)
    PROCEDURE       reduce using rule 450 (subunit_body -> pkg_body .)
    FUNCTION        reduce using rule 450 (subunit_body -> pkg_body .)
    GENERIC         reduce using rule 450 (subunit_body -> pkg_body .)
    $end            reduce using rule 450 (subunit_body -> pkg_body .)


state 411

    (384) prot_body -> PROTECTED BODY simple_name IS . prot_op_body_s END id_opt ;
    (456) body_stub -> PROTECTED BODY simple_name IS . SEPARATE ;
    (385) prot_op_body_s -> . pragma_s
    (386) prot_op_body_s -> . prot_op_body_s prot_op_body pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    SEPARATE        shift and go to state 530
    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)

    prot_op_body_s                 shift and go to state 531
    pragma_s                       shift and go to state 532

state 412

    (371) prot_def -> IS prot_op_decl_s . prot_private_opt END id_opt
    (375) prot_op_decl_s -> prot_op_decl_s . prot_op_decl
    (372) prot_private_opt -> .
    (373) prot_private_opt -> . PRIVATE prot_elem_decl_s
    (376) prot_op_decl -> . entry_decl
    (377) prot_op_decl -> . subprog_spec ;
    (378) prot_op_decl -> . rep_spec
    (379) prot_op_decl -> . pragma
    (392) entry_decl -> . ENTRY IDENTIFIER formal_part_opt ;
    (393) entry_decl -> . ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ;
    (315) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (316) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (317) subprog_spec -> . FUNCTION designator
    (502) rep_spec -> . attrib_def
    (503) rep_spec -> . record_type_spec
    (504) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (505) attrib_def -> . FOR mark USE expression ;
    (506) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (511) address_spec -> . FOR mark USE AT expression ;

    END             reduce using rule 372 (prot_private_opt -> .)
    PRIVATE         shift and go to state 535
    ENTRY           shift and go to state 539
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    PRAGMA          shift and go to state 4
    FOR             shift and go to state 63

    rep_spec                       shift and go to state 533
    entry_decl                     shift and go to state 534
    address_spec                   shift and go to state 52
    record_type_spec               shift and go to state 68
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 536
    prot_private_opt               shift and go to state 537
    pragma                         shift and go to state 538
    prot_op_decl                   shift and go to state 540

state 413

    (370) prot_spec -> PROTECTED TYPE simple_name discrim_part_opt . prot_def
    (371) prot_def -> . IS prot_op_decl_s prot_private_opt END id_opt

    IS              shift and go to state 257

    prot_def                       shift and go to state 541

state 414

    (407) delay_stmt -> DELAY UNTIL . expression ;
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 542

state 415

    (406) delay_stmt -> DELAY expression . ;
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ;               shift and go to state 543
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 416

    (290) iteration -> iter_part . reverse_opt discrete_range
    (292) reverse_opt -> .
    (293) reverse_opt -> . REVERSE

    IDENTIFIER      reduce using rule 292 (reverse_opt -> .)
    STRING          reduce using rule 292 (reverse_opt -> .)
    +               reduce using rule 292 (reverse_opt -> .)
    -               reduce using rule 292 (reverse_opt -> .)
    NOT             reduce using rule 292 (reverse_opt -> .)
    INTEGER         reduce using rule 292 (reverse_opt -> .)
    BASE_INTEGER    reduce using rule 292 (reverse_opt -> .)
    FLOAT           reduce using rule 292 (reverse_opt -> .)
    BASE_FLOAT      reduce using rule 292 (reverse_opt -> .)
    NuLL            reduce using rule 292 (reverse_opt -> .)
    NEW             reduce using rule 292 (reverse_opt -> .)
    (               reduce using rule 292 (reverse_opt -> .)
    CHAR            reduce using rule 292 (reverse_opt -> .)
    REVERSE         shift and go to state 545

    reverse_opt                    shift and go to state 544

state 417

    (291) iter_part -> FOR . IDENTIFIER IN

    IDENTIFIER      shift and go to state 546


state 418

    (297) block -> label_opt block_decl . block_body END id_opt ;
    (300) block_body -> . BEGIN handled_stmt_s

    BEGIN           shift and go to state 162

    block_body                     shift and go to state 547

state 419

    (285) loop_stmt -> label_opt iteration . basic_loop id_opt ;
    (294) basic_loop -> . LOOP statement_s END LOOP

    LOOP            shift and go to state 549

    basic_loop                     shift and go to state 548

state 420

    (289) iteration -> WHILE . condition
    (277) condition -> . expression
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    condition                      shift and go to state 550
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 462

state 421

    (299) block_decl -> DECLARE . decl_part
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (333) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (342) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (367) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (384) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (348) use_clause -> . USE name_s ;
    (349) use_clause -> . USE TYPE name_s ;
    (502) rep_spec -> . attrib_def
    (503) rep_spec -> . record_type_spec
    (504) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (332) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (312) subprog_decl -> . subprog_spec ;
    (313) subprog_decl -> . generic_subp_inst ;
    (314) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (335) pkg_decl -> . pkg_spec ;
    (336) pkg_decl -> . generic_pkg_inst ;
    (360) task_decl -> . task_spec ;
    (368) prot_decl -> . prot_spec ;
    (457) exception_decl -> . def_id_s : EXCEPTION ;
    (352) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (353) rename_decl -> . def_id_s : EXCEPTION renames ;
    (354) rename_decl -> . rename_unit
    (469) generic_decl -> . generic_formal_part subprog_spec ;
    (470) generic_decl -> . generic_formal_part pkg_spec ;
    (453) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (454) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (455) body_stub -> . subprog_spec IS SEPARATE ;
    (456) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (505) attrib_def -> . FOR mark USE expression ;
    (506) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (511) address_spec -> . FOR mark USE AT expression ;
    (315) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (316) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (317) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (499) generic_subp_inst -> . subprog_spec IS generic_inst
    (337) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (361) task_spec -> . TASK simple_name task_def
    (362) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (369) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (370) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (355) rename_unit -> . PACKAGE compound_name renames ;
    (356) rename_unit -> . subprog_spec renames ;
    (357) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (358) rename_unit -> . generic_formal_part subprog_spec renames ;
    (471) generic_formal_part -> . GENERIC
    (472) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 551
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 422

    (311) goto_stmt -> GOTO name . ;
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id

    ;               shift and go to state 552
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 423

    (512) code_stmt -> qualified ; .

    LESSLESS        reduce using rule 512 (code_stmt -> qualified ; .)
    error           reduce using rule 512 (code_stmt -> qualified ; .)
    PRAGMA          reduce using rule 512 (code_stmt -> qualified ; .)
    NuLL            reduce using rule 512 (code_stmt -> qualified ; .)
    EXIT            reduce using rule 512 (code_stmt -> qualified ; .)
    RETURN          reduce using rule 512 (code_stmt -> qualified ; .)
    GOTO            reduce using rule 512 (code_stmt -> qualified ; .)
    DELAY           reduce using rule 512 (code_stmt -> qualified ; .)
    ABORT           reduce using rule 512 (code_stmt -> qualified ; .)
    RAISE           reduce using rule 512 (code_stmt -> qualified ; .)
    REQUEUE         reduce using rule 512 (code_stmt -> qualified ; .)
    IF              reduce using rule 512 (code_stmt -> qualified ; .)
    CASE            reduce using rule 512 (code_stmt -> qualified ; .)
    IDENTIFIER      reduce using rule 512 (code_stmt -> qualified ; .)
    ACCEPT          reduce using rule 512 (code_stmt -> qualified ; .)
    SELECT          reduce using rule 512 (code_stmt -> qualified ; .)
    STRING          reduce using rule 512 (code_stmt -> qualified ; .)
    WHILE           reduce using rule 512 (code_stmt -> qualified ; .)
    DECLARE         reduce using rule 512 (code_stmt -> qualified ; .)
    FOR             reduce using rule 512 (code_stmt -> qualified ; .)
    LOOP            reduce using rule 512 (code_stmt -> qualified ; .)
    BEGIN           reduce using rule 512 (code_stmt -> qualified ; .)
    WHEN            reduce using rule 512 (code_stmt -> qualified ; .)
    END             reduce using rule 512 (code_stmt -> qualified ; .)
    OR              reduce using rule 512 (code_stmt -> qualified ; .)
    ELSE            reduce using rule 512 (code_stmt -> qualified ; .)
    EXCEPTION       reduce using rule 512 (code_stmt -> qualified ; .)
    THEN            reduce using rule 512 (code_stmt -> qualified ; .)
    ELSIF           reduce using rule 512 (code_stmt -> qualified ; .)


state 424

    (271) assign_stmt -> name ASSIGNMENT . expression ;
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 553

state 425

    (334) procedure_call -> name ; .

    LESSLESS        reduce using rule 334 (procedure_call -> name ; .)
    error           reduce using rule 334 (procedure_call -> name ; .)
    PRAGMA          reduce using rule 334 (procedure_call -> name ; .)
    NuLL            reduce using rule 334 (procedure_call -> name ; .)
    EXIT            reduce using rule 334 (procedure_call -> name ; .)
    RETURN          reduce using rule 334 (procedure_call -> name ; .)
    GOTO            reduce using rule 334 (procedure_call -> name ; .)
    DELAY           reduce using rule 334 (procedure_call -> name ; .)
    ABORT           reduce using rule 334 (procedure_call -> name ; .)
    RAISE           reduce using rule 334 (procedure_call -> name ; .)
    REQUEUE         reduce using rule 334 (procedure_call -> name ; .)
    IF              reduce using rule 334 (procedure_call -> name ; .)
    CASE            reduce using rule 334 (procedure_call -> name ; .)
    IDENTIFIER      reduce using rule 334 (procedure_call -> name ; .)
    ACCEPT          reduce using rule 334 (procedure_call -> name ; .)
    SELECT          reduce using rule 334 (procedure_call -> name ; .)
    STRING          reduce using rule 334 (procedure_call -> name ; .)
    WHILE           reduce using rule 334 (procedure_call -> name ; .)
    DECLARE         reduce using rule 334 (procedure_call -> name ; .)
    FOR             reduce using rule 334 (procedure_call -> name ; .)
    LOOP            reduce using rule 334 (procedure_call -> name ; .)
    BEGIN           reduce using rule 334 (procedure_call -> name ; .)
    END             reduce using rule 334 (procedure_call -> name ; .)
    ELSIF           reduce using rule 334 (procedure_call -> name ; .)
    ELSE            reduce using rule 334 (procedure_call -> name ; .)
    WHEN            reduce using rule 334 (procedure_call -> name ; .)
    OR              reduce using rule 334 (procedure_call -> name ; .)
    THEN            reduce using rule 334 (procedure_call -> name ; .)
    EXCEPTION       reduce using rule 334 (procedure_call -> name ; .)


state 426

    (427) abort_stmt -> ABORT name_s . ;
    (351) name_s -> name_s . , name

    ;               shift and go to state 554
    ,               shift and go to state 252


state 427

    (270) null_stmt -> NuLL ; .

    LESSLESS        reduce using rule 270 (null_stmt -> NuLL ; .)
    error           reduce using rule 270 (null_stmt -> NuLL ; .)
    PRAGMA          reduce using rule 270 (null_stmt -> NuLL ; .)
    NuLL            reduce using rule 270 (null_stmt -> NuLL ; .)
    EXIT            reduce using rule 270 (null_stmt -> NuLL ; .)
    RETURN          reduce using rule 270 (null_stmt -> NuLL ; .)
    GOTO            reduce using rule 270 (null_stmt -> NuLL ; .)
    DELAY           reduce using rule 270 (null_stmt -> NuLL ; .)
    ABORT           reduce using rule 270 (null_stmt -> NuLL ; .)
    RAISE           reduce using rule 270 (null_stmt -> NuLL ; .)
    REQUEUE         reduce using rule 270 (null_stmt -> NuLL ; .)
    IF              reduce using rule 270 (null_stmt -> NuLL ; .)
    CASE            reduce using rule 270 (null_stmt -> NuLL ; .)
    IDENTIFIER      reduce using rule 270 (null_stmt -> NuLL ; .)
    ACCEPT          reduce using rule 270 (null_stmt -> NuLL ; .)
    SELECT          reduce using rule 270 (null_stmt -> NuLL ; .)
    STRING          reduce using rule 270 (null_stmt -> NuLL ; .)
    WHILE           reduce using rule 270 (null_stmt -> NuLL ; .)
    DECLARE         reduce using rule 270 (null_stmt -> NuLL ; .)
    FOR             reduce using rule 270 (null_stmt -> NuLL ; .)
    LOOP            reduce using rule 270 (null_stmt -> NuLL ; .)
    BEGIN           reduce using rule 270 (null_stmt -> NuLL ; .)
    OR              reduce using rule 270 (null_stmt -> NuLL ; .)
    ELSE            reduce using rule 270 (null_stmt -> NuLL ; .)
    END             reduce using rule 270 (null_stmt -> NuLL ; .)
    THEN            reduce using rule 270 (null_stmt -> NuLL ; .)
    EXCEPTION       reduce using rule 270 (null_stmt -> NuLL ; .)
    WHEN            reduce using rule 270 (null_stmt -> NuLL ; .)
    ELSIF           reduce using rule 270 (null_stmt -> NuLL ; .)


state 428

    (269) label -> LESSLESS IDENTIFIER . MOREMORE

    MOREMORE        shift and go to state 555


state 429

    (309) return_stmt -> RETURN ; .

    END             reduce using rule 309 (return_stmt -> RETURN ; .)
    LESSLESS        reduce using rule 309 (return_stmt -> RETURN ; .)
    error           reduce using rule 309 (return_stmt -> RETURN ; .)
    PRAGMA          reduce using rule 309 (return_stmt -> RETURN ; .)
    NuLL            reduce using rule 309 (return_stmt -> RETURN ; .)
    EXIT            reduce using rule 309 (return_stmt -> RETURN ; .)
    RETURN          reduce using rule 309 (return_stmt -> RETURN ; .)
    GOTO            reduce using rule 309 (return_stmt -> RETURN ; .)
    DELAY           reduce using rule 309 (return_stmt -> RETURN ; .)
    ABORT           reduce using rule 309 (return_stmt -> RETURN ; .)
    RAISE           reduce using rule 309 (return_stmt -> RETURN ; .)
    REQUEUE         reduce using rule 309 (return_stmt -> RETURN ; .)
    IF              reduce using rule 309 (return_stmt -> RETURN ; .)
    CASE            reduce using rule 309 (return_stmt -> RETURN ; .)
    IDENTIFIER      reduce using rule 309 (return_stmt -> RETURN ; .)
    ACCEPT          reduce using rule 309 (return_stmt -> RETURN ; .)
    SELECT          reduce using rule 309 (return_stmt -> RETURN ; .)
    STRING          reduce using rule 309 (return_stmt -> RETURN ; .)
    WHILE           reduce using rule 309 (return_stmt -> RETURN ; .)
    DECLARE         reduce using rule 309 (return_stmt -> RETURN ; .)
    FOR             reduce using rule 309 (return_stmt -> RETURN ; .)
    LOOP            reduce using rule 309 (return_stmt -> RETURN ; .)
    BEGIN           reduce using rule 309 (return_stmt -> RETURN ; .)
    EXCEPTION       reduce using rule 309 (return_stmt -> RETURN ; .)
    ELSIF           reduce using rule 309 (return_stmt -> RETURN ; .)
    ELSE            reduce using rule 309 (return_stmt -> RETURN ; .)
    WHEN            reduce using rule 309 (return_stmt -> RETURN ; .)
    OR              reduce using rule 309 (return_stmt -> RETURN ; .)
    THEN            reduce using rule 309 (return_stmt -> RETURN ; .)


state 430

    (310) return_stmt -> RETURN expression . ;
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ;               shift and go to state 556
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 431

    (403) accept_hdr -> ACCEPT entry_name . formal_part_opt
    (405) entry_name -> entry_name . ( expression )
    (320) formal_part_opt -> .
    (321) formal_part_opt -> . formal_part
    (322) formal_part -> . ( param_s )

    (               shift and go to state 557
    ;               reduce using rule 320 (formal_part_opt -> .)
    DO              reduce using rule 320 (formal_part_opt -> .)

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 558

state 432

    (404) entry_name -> simple_name .

    (               reduce using rule 404 (entry_name -> simple_name .)
    ;               reduce using rule 404 (entry_name -> simple_name .)
    DO              reduce using rule 404 (entry_name -> simple_name .)


state 433

    (417) select_alt -> accept_stmt . stmts_opt
    (425) stmts_opt -> .
    (426) stmts_opt -> . statement_s
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    OR              reduce using rule 425 (stmts_opt -> .)
    ELSE            reduce using rule 425 (stmts_opt -> .)
    END             reduce using rule 425 (stmts_opt -> .)
    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 560
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    stmts_opt                      shift and go to state 559
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 434

    (423) timed_entry_call -> SELECT entry_call . stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> SELECT entry_call . stmts_opt ELSE statement_s END SELECT ;
    (421) delay_or_entry_alt -> entry_call . stmts_opt
    (425) stmts_opt -> .
    (426) stmts_opt -> . statement_s
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    OR              reduce using rule 425 (stmts_opt -> .)
    ELSE            reduce using rule 425 (stmts_opt -> .)
    THEN            reduce using rule 425 (stmts_opt -> .)
    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 560
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    stmts_opt                      shift and go to state 561
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 435

    (400) entry_call -> procedure_call .

    LESSLESS        reduce using rule 400 (entry_call -> procedure_call .)
    error           reduce using rule 400 (entry_call -> procedure_call .)
    PRAGMA          reduce using rule 400 (entry_call -> procedure_call .)
    NuLL            reduce using rule 400 (entry_call -> procedure_call .)
    EXIT            reduce using rule 400 (entry_call -> procedure_call .)
    RETURN          reduce using rule 400 (entry_call -> procedure_call .)
    GOTO            reduce using rule 400 (entry_call -> procedure_call .)
    DELAY           reduce using rule 400 (entry_call -> procedure_call .)
    ABORT           reduce using rule 400 (entry_call -> procedure_call .)
    RAISE           reduce using rule 400 (entry_call -> procedure_call .)
    REQUEUE         reduce using rule 400 (entry_call -> procedure_call .)
    IF              reduce using rule 400 (entry_call -> procedure_call .)
    CASE            reduce using rule 400 (entry_call -> procedure_call .)
    IDENTIFIER      reduce using rule 400 (entry_call -> procedure_call .)
    ACCEPT          reduce using rule 400 (entry_call -> procedure_call .)
    SELECT          reduce using rule 400 (entry_call -> procedure_call .)
    STRING          reduce using rule 400 (entry_call -> procedure_call .)
    OR              reduce using rule 400 (entry_call -> procedure_call .)
    ELSE            reduce using rule 400 (entry_call -> procedure_call .)
    WHILE           reduce using rule 400 (entry_call -> procedure_call .)
    DECLARE         reduce using rule 400 (entry_call -> procedure_call .)
    FOR             reduce using rule 400 (entry_call -> procedure_call .)
    LOOP            reduce using rule 400 (entry_call -> procedure_call .)
    BEGIN           reduce using rule 400 (entry_call -> procedure_call .)
    THEN            reduce using rule 400 (entry_call -> procedure_call .)


state 436

    (422) async_select -> SELECT delay_or_entry_alt . THEN ABORT statement_s END SELECT ;

    THEN            shift and go to state 562


state 437

    (414) guarded_select_alt -> WHEN . condition ARROW select_alt
    (277) condition -> . expression
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    condition                      shift and go to state 563
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 462

state 438

    (412) select_wait -> SELECT guarded_select_alt . or_select else_opt END SELECT ;
    (415) or_select -> .
    (416) or_select -> . or_select OR guarded_select_alt

    OR              reduce using rule 415 (or_select -> .)
    ELSE            reduce using rule 415 (or_select -> .)
    END             reduce using rule 415 (or_select -> .)

    or_select                      shift and go to state 564

state 439

    (413) guarded_select_alt -> select_alt .

    OR              reduce using rule 413 (guarded_select_alt -> select_alt .)
    ELSE            reduce using rule 413 (guarded_select_alt -> select_alt .)
    END             reduce using rule 413 (guarded_select_alt -> select_alt .)


state 440

    (420) delay_or_entry_alt -> delay_stmt . stmts_opt
    (418) select_alt -> delay_stmt . stmts_opt
    (425) stmts_opt -> .
    (426) stmts_opt -> . statement_s
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    THEN            reduce using rule 425 (stmts_opt -> .)
    OR              reduce using rule 425 (stmts_opt -> .)
    ELSE            reduce using rule 425 (stmts_opt -> .)
    END             reduce using rule 425 (stmts_opt -> .)
    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 560
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    stmts_opt                      shift and go to state 565
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 441

    (334) procedure_call -> name . ;
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id

    ;               shift and go to state 425
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 442

    (419) select_alt -> TERMINATE . ;

    ;               shift and go to state 566


state 443

    (247) statement -> label statement .

    END             reduce using rule 247 (statement -> label statement .)
    LESSLESS        reduce using rule 247 (statement -> label statement .)
    error           reduce using rule 247 (statement -> label statement .)
    PRAGMA          reduce using rule 247 (statement -> label statement .)
    NuLL            reduce using rule 247 (statement -> label statement .)
    EXIT            reduce using rule 247 (statement -> label statement .)
    RETURN          reduce using rule 247 (statement -> label statement .)
    GOTO            reduce using rule 247 (statement -> label statement .)
    DELAY           reduce using rule 247 (statement -> label statement .)
    ABORT           reduce using rule 247 (statement -> label statement .)
    RAISE           reduce using rule 247 (statement -> label statement .)
    REQUEUE         reduce using rule 247 (statement -> label statement .)
    IF              reduce using rule 247 (statement -> label statement .)
    CASE            reduce using rule 247 (statement -> label statement .)
    IDENTIFIER      reduce using rule 247 (statement -> label statement .)
    ACCEPT          reduce using rule 247 (statement -> label statement .)
    SELECT          reduce using rule 247 (statement -> label statement .)
    STRING          reduce using rule 247 (statement -> label statement .)
    WHILE           reduce using rule 247 (statement -> label statement .)
    DECLARE         reduce using rule 247 (statement -> label statement .)
    FOR             reduce using rule 247 (statement -> label statement .)
    LOOP            reduce using rule 247 (statement -> label statement .)
    BEGIN           reduce using rule 247 (statement -> label statement .)
    WHEN            reduce using rule 247 (statement -> label statement .)
    OR              reduce using rule 247 (statement -> label statement .)
    ELSE            reduce using rule 247 (statement -> label statement .)
    ELSIF           reduce using rule 247 (statement -> label statement .)
    EXCEPTION       reduce using rule 247 (statement -> label statement .)
    THEN            reduce using rule 247 (statement -> label statement .)


state 444

    (280) case_stmt -> case_hdr pragma_s . alternative_s END CASE ;
    (9) pragma_s -> pragma_s . pragma
    (282) alternative_s -> .
    (283) alternative_s -> . alternative_s alternative
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 282 (alternative_s -> .)
    WHEN            reduce using rule 282 (alternative_s -> .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14
    alternative_s                  shift and go to state 567

state 445

    (306) name_opt -> name .
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id

    ;               reduce using rule 306 (name_opt -> name .)
    WHEN            reduce using rule 306 (name_opt -> name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 446

    (466) raise_stmt -> RAISE name_opt . ;

    ;               shift and go to state 568


state 447

    (281) case_hdr -> CASE expression . IS
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    IS              shift and go to state 569
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 448

    (467) requeue_stmt -> REQUEUE name . ;
    (468) requeue_stmt -> REQUEUE name . WITH ABORT ;
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id

    ;               shift and go to state 570
    WITH            shift and go to state 571
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 449

    (287) label_opt -> IDENTIFIER : .

    WHILE           reduce using rule 287 (label_opt -> IDENTIFIER : .)
    DECLARE         reduce using rule 287 (label_opt -> IDENTIFIER : .)
    FOR             reduce using rule 287 (label_opt -> IDENTIFIER : .)
    LOOP            reduce using rule 287 (label_opt -> IDENTIFIER : .)
    BEGIN           reduce using rule 287 (label_opt -> IDENTIFIER : .)


state 450

    (402) accept_stmt -> accept_hdr DO . handled_stmt_s END id_opt ;
    (301) handled_stmt_s -> . statement_s except_handler_part_opt
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    label                          shift and go to state 279
    statement_s                    shift and go to state 300
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    handled_stmt_s                 shift and go to state 572
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    assign_stmt                    shift and go to state 308
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    accept_hdr                     shift and go to state 292
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    qualified                      shift and go to state 267
    label_opt                      shift and go to state 263
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 451

    (401) accept_stmt -> accept_hdr ; .

    LESSLESS        reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    error           reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    PRAGMA          reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    NuLL            reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    EXIT            reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    RETURN          reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    GOTO            reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    DELAY           reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    ABORT           reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    RAISE           reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    REQUEUE         reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    IF              reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    CASE            reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    IDENTIFIER      reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    ACCEPT          reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    SELECT          reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    STRING          reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    WHILE           reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    DECLARE         reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    FOR             reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    LOOP            reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    BEGIN           reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    THEN            reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    OR              reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    ELSE            reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    END             reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    EXCEPTION       reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    WHEN            reduce using rule 401 (accept_stmt -> accept_hdr ; .)
    ELSIF           reduce using rule 401 (accept_stmt -> accept_hdr ; .)


state 452

    (304) exit_stmt -> EXIT name_opt . when_opt ;
    (307) when_opt -> .
    (308) when_opt -> . WHEN condition

    ;               reduce using rule 307 (when_opt -> .)
    WHEN            shift and go to state 574

    when_opt                       shift and go to state 573

state 453

    (262) simple_stmt -> error ; .

    END             reduce using rule 262 (simple_stmt -> error ; .)
    LESSLESS        reduce using rule 262 (simple_stmt -> error ; .)
    error           reduce using rule 262 (simple_stmt -> error ; .)
    PRAGMA          reduce using rule 262 (simple_stmt -> error ; .)
    NuLL            reduce using rule 262 (simple_stmt -> error ; .)
    EXIT            reduce using rule 262 (simple_stmt -> error ; .)
    RETURN          reduce using rule 262 (simple_stmt -> error ; .)
    GOTO            reduce using rule 262 (simple_stmt -> error ; .)
    DELAY           reduce using rule 262 (simple_stmt -> error ; .)
    ABORT           reduce using rule 262 (simple_stmt -> error ; .)
    RAISE           reduce using rule 262 (simple_stmt -> error ; .)
    REQUEUE         reduce using rule 262 (simple_stmt -> error ; .)
    IF              reduce using rule 262 (simple_stmt -> error ; .)
    CASE            reduce using rule 262 (simple_stmt -> error ; .)
    IDENTIFIER      reduce using rule 262 (simple_stmt -> error ; .)
    ACCEPT          reduce using rule 262 (simple_stmt -> error ; .)
    SELECT          reduce using rule 262 (simple_stmt -> error ; .)
    STRING          reduce using rule 262 (simple_stmt -> error ; .)
    WHILE           reduce using rule 262 (simple_stmt -> error ; .)
    DECLARE         reduce using rule 262 (simple_stmt -> error ; .)
    FOR             reduce using rule 262 (simple_stmt -> error ; .)
    LOOP            reduce using rule 262 (simple_stmt -> error ; .)
    BEGIN           reduce using rule 262 (simple_stmt -> error ; .)
    WHEN            reduce using rule 262 (simple_stmt -> error ; .)
    EXCEPTION       reduce using rule 262 (simple_stmt -> error ; .)
    OR              reduce using rule 262 (simple_stmt -> error ; .)
    ELSE            reduce using rule 262 (simple_stmt -> error ; .)
    THEN            reduce using rule 262 (simple_stmt -> error ; .)
    ELSIF           reduce using rule 262 (simple_stmt -> error ; .)


state 454

    (303) except_handler_part_opt -> except_handler_part .
    (459) except_handler_part -> except_handler_part . exception_handler
    (460) exception_handler -> . WHEN except_choice_s ARROW statement_s
    (461) exception_handler -> . WHEN IDENTIFIER : except_choice_s ARROW statement_s

    END             reduce using rule 303 (except_handler_part_opt -> except_handler_part .)
    WHEN            shift and go to state 576

    exception_handler              shift and go to state 575

state 455

    (301) handled_stmt_s -> statement_s except_handler_part_opt .

    END             reduce using rule 301 (handled_stmt_s -> statement_s except_handler_part_opt .)


state 456

    (245) statement_s -> statement_s statement .

    LESSLESS        reduce using rule 245 (statement_s -> statement_s statement .)
    error           reduce using rule 245 (statement_s -> statement_s statement .)
    PRAGMA          reduce using rule 245 (statement_s -> statement_s statement .)
    NuLL            reduce using rule 245 (statement_s -> statement_s statement .)
    EXIT            reduce using rule 245 (statement_s -> statement_s statement .)
    RETURN          reduce using rule 245 (statement_s -> statement_s statement .)
    GOTO            reduce using rule 245 (statement_s -> statement_s statement .)
    DELAY           reduce using rule 245 (statement_s -> statement_s statement .)
    ABORT           reduce using rule 245 (statement_s -> statement_s statement .)
    RAISE           reduce using rule 245 (statement_s -> statement_s statement .)
    REQUEUE         reduce using rule 245 (statement_s -> statement_s statement .)
    IF              reduce using rule 245 (statement_s -> statement_s statement .)
    CASE            reduce using rule 245 (statement_s -> statement_s statement .)
    IDENTIFIER      reduce using rule 245 (statement_s -> statement_s statement .)
    ACCEPT          reduce using rule 245 (statement_s -> statement_s statement .)
    SELECT          reduce using rule 245 (statement_s -> statement_s statement .)
    STRING          reduce using rule 245 (statement_s -> statement_s statement .)
    WHILE           reduce using rule 245 (statement_s -> statement_s statement .)
    DECLARE         reduce using rule 245 (statement_s -> statement_s statement .)
    FOR             reduce using rule 245 (statement_s -> statement_s statement .)
    LOOP            reduce using rule 245 (statement_s -> statement_s statement .)
    BEGIN           reduce using rule 245 (statement_s -> statement_s statement .)
    OR              reduce using rule 245 (statement_s -> statement_s statement .)
    ELSE            reduce using rule 245 (statement_s -> statement_s statement .)
    THEN            reduce using rule 245 (statement_s -> statement_s statement .)
    EXCEPTION       reduce using rule 245 (statement_s -> statement_s statement .)
    END             reduce using rule 245 (statement_s -> statement_s statement .)
    WHEN            reduce using rule 245 (statement_s -> statement_s statement .)
    ELSIF           reduce using rule 245 (statement_s -> statement_s statement .)


state 457

    (458) except_handler_part -> EXCEPTION . exception_handler
    (460) exception_handler -> . WHEN except_choice_s ARROW statement_s
    (461) exception_handler -> . WHEN IDENTIFIER : except_choice_s ARROW statement_s

    WHEN            shift and go to state 576

    exception_handler              shift and go to state 577

state 458

    (272) if_stmt -> IF cond_clause_s . else_opt END IF ;
    (274) cond_clause_s -> cond_clause_s . ELSIF cond_clause
    (278) else_opt -> .
    (279) else_opt -> . ELSE statement_s

    ELSIF           shift and go to state 580
    END             reduce using rule 278 (else_opt -> .)
    ELSE            shift and go to state 578

    else_opt                       shift and go to state 579

state 459

    (273) cond_clause_s -> cond_clause .

    ELSIF           reduce using rule 273 (cond_clause_s -> cond_clause .)
    ELSE            reduce using rule 273 (cond_clause_s -> cond_clause .)
    END             reduce using rule 273 (cond_clause_s -> cond_clause .)


state 460

    (275) cond_clause -> cond_part . statement_s
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 581
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 461

    (276) cond_part -> condition . THEN

    THEN            shift and go to state 582


state 462

    (277) condition -> expression .
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ;               reduce using rule 277 (condition -> expression .)
    THEN            reduce using rule 277 (condition -> expression .)
    ARROW           reduce using rule 277 (condition -> expression .)
    LOOP            reduce using rule 277 (condition -> expression .)
    IS              reduce using rule 277 (condition -> expression .)
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 463

    (296) id_opt -> designator .

    ;               reduce using rule 296 (id_opt -> designator .)


state 464

    (333) subprog_body -> subprog_spec_is_push decl_part block_body END id_opt . ;

    ;               shift and go to state 583


state 465

    (506) record_type_spec -> FOR mark USE RECORD . align_opt comp_loc_s END RECORD ;
    (507) align_opt -> .
    (508) align_opt -> . AT MOD expression ;

    END             reduce using rule 507 (align_opt -> .)
    IDENTIFIER      reduce using rule 507 (align_opt -> .)
    AT              shift and go to state 585

    align_opt                      shift and go to state 584

state 466

    (511) address_spec -> FOR mark USE AT . expression ;
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 586

state 467

    (505) attrib_def -> FOR mark USE expression . ;
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ;               shift and go to state 587
    AND             shift and go to state 247
    OR              shift and go to state 250

    short_circuit                  shift and go to state 249
    logical                        shift and go to state 248

state 468

    (160) mark -> mark . simple_name .

    AT              reduce using rule 160 (mark -> mark . simple_name .)
    TICK            reduce using rule 160 (mark -> mark . simple_name .)
    .               reduce using rule 160 (mark -> mark . simple_name .)
    ;               reduce using rule 160 (mark -> mark . simple_name .)
    USE             reduce using rule 160 (mark -> mark . simple_name .)
    ASSIGNMENT      reduce using rule 160 (mark -> mark . simple_name .)
    )               reduce using rule 160 (mark -> mark . simple_name .)


state 469

    (159) mark -> mark TICK attribute_id .

    AT              reduce using rule 159 (mark -> mark TICK attribute_id .)
    TICK            reduce using rule 159 (mark -> mark TICK attribute_id .)
    .               reduce using rule 159 (mark -> mark TICK attribute_id .)
    ;               reduce using rule 159 (mark -> mark TICK attribute_id .)
    USE             reduce using rule 159 (mark -> mark TICK attribute_id .)
    ASSIGNMENT      reduce using rule 159 (mark -> mark TICK attribute_id .)
    )               reduce using rule 159 (mark -> mark TICK attribute_id .)


state 470

    (367) task_body -> TASK BODY simple_name IS . decl_part block_body END id_opt ;
    (453) body_stub -> TASK BODY simple_name IS . SEPARATE ;
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (333) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (342) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (367) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (384) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (348) use_clause -> . USE name_s ;
    (349) use_clause -> . USE TYPE name_s ;
    (502) rep_spec -> . attrib_def
    (503) rep_spec -> . record_type_spec
    (504) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (332) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (312) subprog_decl -> . subprog_spec ;
    (313) subprog_decl -> . generic_subp_inst ;
    (314) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (335) pkg_decl -> . pkg_spec ;
    (336) pkg_decl -> . generic_pkg_inst ;
    (360) task_decl -> . task_spec ;
    (368) prot_decl -> . prot_spec ;
    (457) exception_decl -> . def_id_s : EXCEPTION ;
    (352) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (353) rename_decl -> . def_id_s : EXCEPTION renames ;
    (354) rename_decl -> . rename_unit
    (469) generic_decl -> . generic_formal_part subprog_spec ;
    (470) generic_decl -> . generic_formal_part pkg_spec ;
    (453) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (454) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (455) body_stub -> . subprog_spec IS SEPARATE ;
    (456) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (505) attrib_def -> . FOR mark USE expression ;
    (506) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (511) address_spec -> . FOR mark USE AT expression ;
    (315) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (316) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (317) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (499) generic_subp_inst -> . subprog_spec IS generic_inst
    (337) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (361) task_spec -> . TASK simple_name task_def
    (362) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (369) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (370) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (355) rename_unit -> . PACKAGE compound_name renames ;
    (356) rename_unit -> . subprog_spec renames ;
    (357) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (358) rename_unit -> . generic_formal_part subprog_spec renames ;
    (471) generic_formal_part -> . GENERIC
    (472) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    SEPARATE        shift and go to state 588
    BEGIN           reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    decl_item                      shift and go to state 53
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 589
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 471

    (362) task_spec -> TASK TYPE simple_name discrim_part_opt . task_def
    (363) task_def -> .
    (364) task_def -> . IS entry_decl_s rep_spec_s task_private_opt END id_opt

    ;               reduce using rule 363 (task_def -> .)
    IS              shift and go to state 315

    task_def                       shift and go to state 590

state 472

    (364) task_def -> IS entry_decl_s . rep_spec_s task_private_opt END id_opt
    (391) entry_decl_s -> entry_decl_s . entry_decl pragma_s
    (398) rep_spec_s -> .
    (399) rep_spec_s -> . rep_spec_s rep_spec pragma_s
    (392) entry_decl -> . ENTRY IDENTIFIER formal_part_opt ;
    (393) entry_decl -> . ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ;

    PRIVATE         reduce using rule 398 (rep_spec_s -> .)
    FOR             reduce using rule 398 (rep_spec_s -> .)
    END             reduce using rule 398 (rep_spec_s -> .)
    ENTRY           shift and go to state 539

    rep_spec_s                     shift and go to state 591
    entry_decl                     shift and go to state 592

state 473

    (390) entry_decl_s -> pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    ENTRY           reduce using rule 390 (entry_decl_s -> pragma_s .)
    FOR             reduce using rule 390 (entry_decl_s -> pragma_s .)
    END             reduce using rule 390 (entry_decl_s -> pragma_s .)
    PRIVATE         reduce using rule 390 (entry_decl_s -> pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 474

    (342) pkg_body -> PACKAGE BODY compound_name IS . decl_part body_opt END c_id_opt ;
    (454) body_stub -> PACKAGE BODY compound_name IS . SEPARATE ;
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (333) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (342) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (367) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (384) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (348) use_clause -> . USE name_s ;
    (349) use_clause -> . USE TYPE name_s ;
    (502) rep_spec -> . attrib_def
    (503) rep_spec -> . record_type_spec
    (504) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (332) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (312) subprog_decl -> . subprog_spec ;
    (313) subprog_decl -> . generic_subp_inst ;
    (314) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (335) pkg_decl -> . pkg_spec ;
    (336) pkg_decl -> . generic_pkg_inst ;
    (360) task_decl -> . task_spec ;
    (368) prot_decl -> . prot_spec ;
    (457) exception_decl -> . def_id_s : EXCEPTION ;
    (352) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (353) rename_decl -> . def_id_s : EXCEPTION renames ;
    (354) rename_decl -> . rename_unit
    (469) generic_decl -> . generic_formal_part subprog_spec ;
    (470) generic_decl -> . generic_formal_part pkg_spec ;
    (453) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (454) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (455) body_stub -> . subprog_spec IS SEPARATE ;
    (456) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (505) attrib_def -> . FOR mark USE expression ;
    (506) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (511) address_spec -> . FOR mark USE AT expression ;
    (315) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (316) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (317) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (499) generic_subp_inst -> . subprog_spec IS generic_inst
    (337) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (361) task_spec -> . TASK simple_name task_def
    (362) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (369) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (370) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (355) rename_unit -> . PACKAGE compound_name renames ;
    (356) rename_unit -> . subprog_spec renames ;
    (357) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (358) rename_unit -> . generic_formal_part subprog_spec renames ;
    (471) generic_formal_part -> . GENERIC
    (472) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    SEPARATE        shift and go to state 593
    BEGIN           reduce using rule 135 (decl_part -> .)
    END             reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 495
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 475

    (114) discrim_spec -> error .

    )               reduce using rule 114 (discrim_spec -> error .)
    ;               reduce using rule 114 (discrim_spec -> error .)


state 476

    (110) discrim_part -> ( discrim_spec_s . )
    (112) discrim_spec_s -> discrim_spec_s . ; discrim_spec

    )               shift and go to state 594
    ;               shift and go to state 595


state 477

    (113) discrim_spec -> def_id_s . : access_opt mark init_opt
    (25) def_id_s -> def_id_s . , def_id

    :               shift and go to state 596
    ,               shift and go to state 179


state 478

    (111) discrim_spec_s -> discrim_spec .

    )               reduce using rule 111 (discrim_spec_s -> discrim_spec .)
    ;               reduce using rule 111 (discrim_spec_s -> discrim_spec .)


state 479

    (39) discrim_part_opt -> ( LESSMORE . )

    )               shift and go to state 597


state 480

    (41) type_completion -> IS . type_def
    (42) type_def -> . enumeration_type
    (43) type_def -> . integer_type
    (44) type_def -> . real_type
    (45) type_def -> . array_type
    (46) type_def -> . record_type
    (47) type_def -> . access_type
    (48) type_def -> . derived_type
    (49) type_def -> . private_type
    (63) enumeration_type -> . ( enum_id_s )
    (68) integer_type -> . range_spec
    (69) integer_type -> . MOD expression
    (73) real_type -> . float_type
    (74) real_type -> . fixed_type
    (78) array_type -> . unconstr_array_type
    (79) array_type -> . constr_array_type
    (95) record_type -> . tagged_opt limited_opt record_def
    (128) access_type -> . ACCESS subtype_ind
    (129) access_type -> . ACCESS CONSTANT subtype_ind
    (130) access_type -> . ACCESS ALL subtype_ind
    (131) access_type -> . ACCESS prot_opt PROCEDURE formal_part_opt
    (132) access_type -> . ACCESS prot_opt FUNCTION formal_part_opt RETURN mark
    (56) derived_type -> . NEW subtype_ind
    (57) derived_type -> . NEW subtype_ind WITH PRIVATE
    (58) derived_type -> . NEW subtype_ind WITH record_def
    (59) derived_type -> . ABSTRACT NEW subtype_ind WITH PRIVATE
    (60) derived_type -> . ABSTRACT NEW subtype_ind WITH record_def
    (345) private_type -> . tagged_opt limited_opt PRIVATE
    (70) range_spec -> . range_constraint
    (75) float_type -> . DIGITS expression range_spec_opt
    (76) fixed_type -> . DELTA expression range_spec
    (77) fixed_type -> . DELTA expression DIGITS expression range_spec_opt
    (80) unconstr_array_type -> . ARRAY ( index_s ) OF component_subtype_def
    (81) constr_array_type -> . ARRAY iter_index_constraint OF component_subtype_def
    (98) tagged_opt -> .
    (99) tagged_opt -> . TAGGED
    (100) tagged_opt -> . ABSTRACT TAGGED
    (61) range_constraint -> . RANGE range

    (               shift and go to state 607
    MOD             shift and go to state 619
    ACCESS          shift and go to state 615
    NEW             shift and go to state 603
    ABSTRACT        shift and go to state 598
    DIGITS          shift and go to state 608
    DELTA           shift and go to state 610
    ARRAY           shift and go to state 490
    LIMITED         reduce using rule 98 (tagged_opt -> .)
    PRIVATE         reduce using rule 98 (tagged_opt -> .)
    RECORD          reduce using rule 98 (tagged_opt -> .)
    NuLL            reduce using rule 98 (tagged_opt -> .)
    TAGGED          shift and go to state 609
    RANGE           shift and go to state 371

    access_type                    shift and go to state 600
    record_type                    shift and go to state 601
    real_type                      shift and go to state 602
    range_constraint               shift and go to state 599
    enumeration_type               shift and go to state 604
    private_type                   shift and go to state 605
    float_type                     shift and go to state 606
    tagged_opt                     shift and go to state 616
    integer_type                   shift and go to state 611
    array_type                     shift and go to state 612
    range_spec                     shift and go to state 613
    type_def                       shift and go to state 614
    constr_array_type              shift and go to state 492
    derived_type                   shift and go to state 617
    fixed_type                     shift and go to state 618
    unconstr_array_type            shift and go to state 494

state 481

    (36) type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion . ;

    ;               shift and go to state 620


state 482

    (51) subtype_ind -> name . constraint
    (52) subtype_ind -> name .
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id
    (53) constraint -> . range_constraint
    (54) constraint -> . decimal_digits_constraint
    (61) range_constraint -> . RANGE range
    (55) decimal_digits_constraint -> . DIGITS expression range_constr_opt

    ;               reduce using rule 52 (subtype_ind -> name .)
    WITH            reduce using rule 52 (subtype_ind -> name .)
    ASSIGNMENT      reduce using rule 52 (subtype_ind -> name .)
    RENAMES         reduce using rule 52 (subtype_ind -> name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253
    RANGE           shift and go to state 371
    DIGITS          shift and go to state 621

    constraint                     shift and go to state 622
    range_constraint               shift and go to state 623
    decimal_digits_constraint      shift and go to state 624

state 483

    (50) subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind . ;

    ;               shift and go to state 625


state 484

    (455) body_stub -> subprog_spec IS SEPARATE ; .

    PACKAGE         reduce using rule 455 (body_stub -> subprog_spec IS SEPARATE ; .)
    TASK            reduce using rule 455 (body_stub -> subprog_spec IS SEPARATE ; .)
    PROTECTED       reduce using rule 455 (body_stub -> subprog_spec IS SEPARATE ; .)
    error           reduce using rule 455 (body_stub -> subprog_spec IS SEPARATE ; .)
    USE             reduce using rule 455 (body_stub -> subprog_spec IS SEPARATE ; .)
    PRAGMA          reduce using rule 455 (body_stub -> subprog_spec IS SEPARATE ; .)
    TYPE            reduce using rule 455 (body_stub -> subprog_spec IS SEPARATE ; .)
    SUBTYPE         reduce using rule 455 (body_stub -> subprog_spec IS SEPARATE ; .)
    FOR             reduce using rule 455 (body_stub -> subprog_spec IS SEPARATE ; .)
    PROCEDURE       reduce using rule 455 (body_stub -> subprog_spec IS SEPARATE ; .)
    FUNCTION        reduce using rule 455 (body_stub -> subprog_spec IS SEPARATE ; .)
    GENERIC         reduce using rule 455 (body_stub -> subprog_spec IS SEPARATE ; .)
    IDENTIFIER      reduce using rule 455 (body_stub -> subprog_spec IS SEPARATE ; .)
    BEGIN           reduce using rule 455 (body_stub -> subprog_spec IS SEPARATE ; .)
    END             reduce using rule 455 (body_stub -> subprog_spec IS SEPARATE ; .)
    PRIVATE         reduce using rule 455 (body_stub -> subprog_spec IS SEPARATE ; .)


state 485

    (353) rename_decl -> def_id_s : EXCEPTION renames . ;

    ;               shift and go to state 626


state 486

    (457) exception_decl -> def_id_s : EXCEPTION ; .

    PACKAGE         reduce using rule 457 (exception_decl -> def_id_s : EXCEPTION ; .)
    TASK            reduce using rule 457 (exception_decl -> def_id_s : EXCEPTION ; .)
    PROTECTED       reduce using rule 457 (exception_decl -> def_id_s : EXCEPTION ; .)
    error           reduce using rule 457 (exception_decl -> def_id_s : EXCEPTION ; .)
    USE             reduce using rule 457 (exception_decl -> def_id_s : EXCEPTION ; .)
    PRAGMA          reduce using rule 457 (exception_decl -> def_id_s : EXCEPTION ; .)
    TYPE            reduce using rule 457 (exception_decl -> def_id_s : EXCEPTION ; .)
    SUBTYPE         reduce using rule 457 (exception_decl -> def_id_s : EXCEPTION ; .)
    FOR             reduce using rule 457 (exception_decl -> def_id_s : EXCEPTION ; .)
    PROCEDURE       reduce using rule 457 (exception_decl -> def_id_s : EXCEPTION ; .)
    FUNCTION        reduce using rule 457 (exception_decl -> def_id_s : EXCEPTION ; .)
    GENERIC         reduce using rule 457 (exception_decl -> def_id_s : EXCEPTION ; .)
    IDENTIFIER      reduce using rule 457 (exception_decl -> def_id_s : EXCEPTION ; .)
    BEGIN           reduce using rule 457 (exception_decl -> def_id_s : EXCEPTION ; .)
    END             reduce using rule 457 (exception_decl -> def_id_s : EXCEPTION ; .)
    PRIVATE         reduce using rule 457 (exception_decl -> def_id_s : EXCEPTION ; .)


state 487

    (35) number_decl -> def_id_s : CONSTANT ASSIGNMENT . expression ;
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 627

state 488

    (29) object_qualifier_opt -> ALIASED CONSTANT .

    ARRAY           reduce using rule 29 (object_qualifier_opt -> ALIASED CONSTANT .)
    IDENTIFIER      reduce using rule 29 (object_qualifier_opt -> ALIASED CONSTANT .)
    STRING          reduce using rule 29 (object_qualifier_opt -> ALIASED CONSTANT .)


state 489

    (32) object_subtype_def -> array_type .

    ASSIGNMENT      reduce using rule 32 (object_subtype_def -> array_type .)
    ;               reduce using rule 32 (object_subtype_def -> array_type .)


state 490

    (80) unconstr_array_type -> ARRAY . ( index_s ) OF component_subtype_def
    (81) constr_array_type -> ARRAY . iter_index_constraint OF component_subtype_def
    (88) iter_index_constraint -> . ( iter_discrete_range_s )

    (               shift and go to state 628

    iter_index_constraint          shift and go to state 629

state 491

    (23) object_decl -> def_id_s : object_qualifier_opt object_subtype_def . init_opt ;
    (33) init_opt -> .
    (34) init_opt -> . ASSIGNMENT expression

    ;               reduce using rule 33 (init_opt -> .)
    ASSIGNMENT      shift and go to state 630

    init_opt                       shift and go to state 631

state 492

    (79) array_type -> constr_array_type .

    ASSIGNMENT      reduce using rule 79 (array_type -> constr_array_type .)
    ;               reduce using rule 79 (array_type -> constr_array_type .)


state 493

    (352) rename_decl -> def_id_s : object_qualifier_opt subtype_ind . renames ;
    (31) object_subtype_def -> subtype_ind .
    (359) renames -> . RENAMES name

    ASSIGNMENT      reduce using rule 31 (object_subtype_def -> subtype_ind .)
    ;               reduce using rule 31 (object_subtype_def -> subtype_ind .)
    RENAMES         shift and go to state 95

    renames                        shift and go to state 632

state 494

    (78) array_type -> unconstr_array_type .

    ASSIGNMENT      reduce using rule 78 (array_type -> unconstr_array_type .)
    ;               reduce using rule 78 (array_type -> unconstr_array_type .)


state 495

    (342) pkg_body -> PACKAGE BODY compound_name IS decl_part . body_opt END c_id_opt ;
    (343) body_opt -> .
    (344) body_opt -> . block_body
    (300) block_body -> . BEGIN handled_stmt_s

    END             reduce using rule 343 (body_opt -> .)
    BEGIN           shift and go to state 162

    body_opt                       shift and go to state 633
    block_body                     shift and go to state 634

state 496

    (140) decl_item_s1 -> decl_item_s1 decl_item .

    error           reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    USE             reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    PRAGMA          reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    TYPE            reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    SUBTYPE         reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    TASK            reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    PACKAGE         reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    PROTECTED       reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    FOR             reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    PROCEDURE       reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    FUNCTION        reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    GENERIC         reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    IDENTIFIER      reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    END             reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    PRIVATE         reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)


state 497

    (456) body_stub -> PROTECTED BODY . simple_name IS SEPARATE ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 635

state 498

    (339) private_part -> PRIVATE . decl_item_s
    (137) decl_item_s -> .
    (138) decl_item_s -> . decl_item_s1
    (139) decl_item_s1 -> . decl_item
    (140) decl_item_s1 -> . decl_item_s1 decl_item
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (348) use_clause -> . USE name_s ;
    (349) use_clause -> . USE TYPE name_s ;
    (502) rep_spec -> . attrib_def
    (503) rep_spec -> . record_type_spec
    (504) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (312) subprog_decl -> . subprog_spec ;
    (313) subprog_decl -> . generic_subp_inst ;
    (314) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (335) pkg_decl -> . pkg_spec ;
    (336) pkg_decl -> . generic_pkg_inst ;
    (360) task_decl -> . task_spec ;
    (368) prot_decl -> . prot_spec ;
    (457) exception_decl -> . def_id_s : EXCEPTION ;
    (352) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (353) rename_decl -> . def_id_s : EXCEPTION renames ;
    (354) rename_decl -> . rename_unit
    (469) generic_decl -> . generic_formal_part subprog_spec ;
    (470) generic_decl -> . generic_formal_part pkg_spec ;
    (453) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (454) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (455) body_stub -> . subprog_spec IS SEPARATE ;
    (456) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (505) attrib_def -> . FOR mark USE expression ;
    (506) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (511) address_spec -> . FOR mark USE AT expression ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (315) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (316) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (317) subprog_spec -> . FUNCTION designator
    (499) generic_subp_inst -> . subprog_spec IS generic_inst
    (332) subprog_spec_is_push -> . subprog_spec IS
    (337) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (361) task_spec -> . TASK simple_name task_def
    (362) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (369) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (370) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (355) rename_unit -> . PACKAGE compound_name renames ;
    (356) rename_unit -> . subprog_spec renames ;
    (357) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (358) rename_unit -> . generic_formal_part subprog_spec renames ;
    (471) generic_formal_part -> . GENERIC
    (472) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    END             reduce using rule 137 (decl_item_s -> .)
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    TASK            shift and go to state 336
    PACKAGE         shift and go to state 337
    PROTECTED       shift and go to state 333
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    task_decl                      shift and go to state 60
    subtype_decl                   shift and go to state 61
    rep_spec                       shift and go to state 82
    decl_item_s1                   shift and go to state 332
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    decl_item                      shift and go to state 334
    subprog_spec_is_push           shift and go to state 338
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 339
    def_id_s                       shift and go to state 88
    task_spec                      shift and go to state 65
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    generic_subp_inst              shift and go to state 29
    def_id                         shift and go to state 89
    rename_decl                    shift and go to state 90
    type_decl                      shift and go to state 56
    rename_unit                    shift and go to state 91
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    subprog_decl                   shift and go to state 58
    decl_item_s                    shift and go to state 636
    pragma                         shift and go to state 74
    pkg_spec                       shift and go to state 37
    number_decl                    shift and go to state 93

state 499

    (337) pkg_spec -> PACKAGE compound_name IS decl_item_s private_part . END c_id_opt

    END             shift and go to state 637


state 500

    (453) body_stub -> TASK BODY . simple_name IS SEPARATE ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 638

state 501

    (454) body_stub -> PACKAGE BODY . compound_name IS SEPARATE ;
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 639
    simple_name                    shift and go to state 41

state 502

    (455) body_stub -> subprog_spec IS . SEPARATE ;
    (499) generic_subp_inst -> subprog_spec IS . generic_inst
    (332) subprog_spec_is_push -> subprog_spec IS .
    (501) generic_inst -> . NEW name

    SEPARATE        shift and go to state 322
    ABSTRACT        reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    NEW             shift and go to state 183

    generic_inst                   shift and go to state 184

state 503

    (322) formal_part -> ( param_s ) .

    ;               reduce using rule 322 (formal_part -> ( param_s ) .)
    RETURN          reduce using rule 322 (formal_part -> ( param_s ) .)
    DO              reduce using rule 322 (formal_part -> ( param_s ) .)
    IS              reduce using rule 322 (formal_part -> ( param_s ) .)
    RENAMES         reduce using rule 322 (formal_part -> ( param_s ) .)
    WHEN            reduce using rule 322 (formal_part -> ( param_s ) .)


state 504

    (324) param_s -> param_s ; . param
    (325) param -> . def_id_s : mode mark init_opt
    (326) param -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    error           shift and go to state 109
    IDENTIFIER      shift and go to state 76

    param                          shift and go to state 640
    def_id                         shift and go to state 89
    def_id_s                       shift and go to state 105

state 505

    (476) generic_formal -> WITH FUNCTION designator formal_part_opt . RETURN name subp_default ;

    RETURN          shift and go to state 641


state 506

    (477) generic_formal -> WITH PACKAGE simple_name IS . NEW name ( LESSMORE ) ;
    (478) generic_formal -> WITH PACKAGE simple_name IS . NEW name ;

    NEW             shift and go to state 642


state 507

    (475) generic_formal -> WITH PROCEDURE simple_name formal_part_opt . subp_default ;
    (483) subp_default -> .
    (484) subp_default -> . IS name
    (485) subp_default -> . IS LESSMORE

    ;               reduce using rule 483 (subp_default -> .)
    IS              shift and go to state 643

    subp_default                   shift and go to state 644

state 508

    (330) mode -> IN OUT .

    IDENTIFIER      reduce using rule 330 (mode -> IN OUT .)


state 509

    (325) param -> def_id_s : mode mark . init_opt
    (159) mark -> mark . TICK attribute_id
    (160) mark -> mark . . simple_name
    (33) init_opt -> .
    (34) init_opt -> . ASSIGNMENT expression

    TICK            shift and go to state 312
    .               shift and go to state 311
    ;               reduce using rule 33 (init_opt -> .)
    )               reduce using rule 33 (init_opt -> .)
    ASSIGNMENT      shift and go to state 630

    init_opt                       shift and go to state 645

state 510

    (357) rename_unit -> generic_formal_part PACKAGE compound_name renames ; .

    PACKAGE         reduce using rule 357 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    TASK            reduce using rule 357 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    PROTECTED       reduce using rule 357 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    error           reduce using rule 357 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    USE             reduce using rule 357 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    PRAGMA          reduce using rule 357 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    TYPE            reduce using rule 357 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    SUBTYPE         reduce using rule 357 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    FOR             reduce using rule 357 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    PROCEDURE       reduce using rule 357 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    FUNCTION        reduce using rule 357 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    GENERIC         reduce using rule 357 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    IDENTIFIER      reduce using rule 357 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    BEGIN           reduce using rule 357 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    PRIVATE         reduce using rule 357 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    WITH            reduce using rule 357 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    SEPARATE        reduce using rule 357 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    $end            reduce using rule 357 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    END             reduce using rule 357 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)


state 511

    (474) generic_formal -> TYPE simple_name generic_discrim_part_opt IS . generic_type_def ;
    (486) generic_type_def -> . ( LESSMORE )
    (487) generic_type_def -> . RANGE LESSMORE
    (488) generic_type_def -> . MOD LESSMORE
    (489) generic_type_def -> . DELTA LESSMORE
    (490) generic_type_def -> . DELTA LESSMORE DIGITS LESSMORE
    (491) generic_type_def -> . DIGITS LESSMORE
    (492) generic_type_def -> . array_type
    (493) generic_type_def -> . access_type
    (494) generic_type_def -> . private_type
    (495) generic_type_def -> . generic_derived_type
    (78) array_type -> . unconstr_array_type
    (79) array_type -> . constr_array_type
    (128) access_type -> . ACCESS subtype_ind
    (129) access_type -> . ACCESS CONSTANT subtype_ind
    (130) access_type -> . ACCESS ALL subtype_ind
    (131) access_type -> . ACCESS prot_opt PROCEDURE formal_part_opt
    (132) access_type -> . ACCESS prot_opt FUNCTION formal_part_opt RETURN mark
    (345) private_type -> . tagged_opt limited_opt PRIVATE
    (496) generic_derived_type -> . NEW subtype_ind
    (497) generic_derived_type -> . NEW subtype_ind WITH PRIVATE
    (498) generic_derived_type -> . ABSTRACT NEW subtype_ind WITH PRIVATE
    (80) unconstr_array_type -> . ARRAY ( index_s ) OF component_subtype_def
    (81) constr_array_type -> . ARRAY iter_index_constraint OF component_subtype_def
    (98) tagged_opt -> .
    (99) tagged_opt -> . TAGGED
    (100) tagged_opt -> . ABSTRACT TAGGED

    (               shift and go to state 651
    RANGE           shift and go to state 653
    MOD             shift and go to state 658
    DELTA           shift and go to state 657
    DIGITS          shift and go to state 650
    ACCESS          shift and go to state 615
    NEW             shift and go to state 648
    ABSTRACT        shift and go to state 646
    ARRAY           shift and go to state 490
    LIMITED         reduce using rule 98 (tagged_opt -> .)
    PRIVATE         reduce using rule 98 (tagged_opt -> .)
    TAGGED          shift and go to state 609

    private_type                   shift and go to state 652
    tagged_opt                     shift and go to state 656
    constr_array_type              shift and go to state 492
    access_type                    shift and go to state 654
    generic_derived_type           shift and go to state 649
    generic_type_def               shift and go to state 647
    array_type                     shift and go to state 655
    unconstr_array_type            shift and go to state 494

state 512

    (482) generic_discrim_part_opt -> ( LESSMORE . )

    )               shift and go to state 659


state 513

    (316) subprog_spec -> FUNCTION designator formal_part_opt RETURN name .
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id

    ;               reduce using rule 316 (subprog_spec -> FUNCTION designator formal_part_opt RETURN name .)
    IS              reduce using rule 316 (subprog_spec -> FUNCTION designator formal_part_opt RETURN name .)
    RENAMES         reduce using rule 316 (subprog_spec -> FUNCTION designator formal_part_opt RETURN name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 514

    (62) range -> simple_expression DOTDOT simple_expression .
    (219) simple_expression -> simple_expression . adding term
    (222) adding -> . +
    (223) adding -> . -
    (224) adding -> . &

    )               reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    ,               reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    ARROW           reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    |               reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    ;               reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    AND             reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    OR              reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    WITH            reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    IS              reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    THEN            reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    LOOP            reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    RANGE           reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    DIGITS          reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    RENAMES         reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    ASSIGNMENT      reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    +               shift and go to state 210
    -               shift and go to state 212
    &               shift and go to state 211

    adding                         shift and go to state 208

state 515

    (122) choice_s -> choice_s | choice .

    ARROW           reduce using rule 122 (choice_s -> choice_s | choice .)
    |               reduce using rule 122 (choice_s -> choice_s | choice .)


state 516

    (124) choice -> discrete_with_range .

    ARROW           reduce using rule 124 (choice -> discrete_with_range .)
    |               reduce using rule 124 (choice -> discrete_with_range .)


state 517

    (123) choice -> expression .
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ARROW           reduce using rule 123 (choice -> expression .)
    |               reduce using rule 123 (choice -> expression .)
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 518

    (197) comp_assoc -> choice_s ARROW expression .
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    )               reduce using rule 197 (comp_assoc -> choice_s ARROW expression .)
    ,               reduce using rule 197 (comp_assoc -> choice_s ARROW expression .)
    AND             shift and go to state 247
    OR              shift and go to state 250

    short_circuit                  shift and go to state 249
    logical                        shift and go to state 248

state 519

    (196) value_s_2 -> value_s_2 , value .

    )               reduce using rule 196 (value_s_2 -> value_s_2 , value .)
    ,               reduce using rule 196 (value_s_2 -> value_s_2 , value .)


state 520

    (61) range_constraint -> RANGE range .

    ;               reduce using rule 61 (range_constraint -> RANGE range .)
    RENAMES         reduce using rule 61 (range_constraint -> RANGE range .)
    ASSIGNMENT      reduce using rule 61 (range_constraint -> RANGE range .)
    WITH            reduce using rule 61 (range_constraint -> RANGE range .)
    )               reduce using rule 61 (range_constraint -> RANGE range .)
    ,               reduce using rule 61 (range_constraint -> RANGE range .)
    LOOP            reduce using rule 61 (range_constraint -> RANGE range .)
    ARROW           reduce using rule 61 (range_constraint -> RANGE range .)
    |               reduce using rule 61 (range_constraint -> RANGE range .)


state 521

    (195) value_s_2 -> value , value .

    )               reduce using rule 195 (value_s_2 -> value , value .)
    ,               reduce using rule 195 (value_s_2 -> value , value .)


state 522

    (194) aggregate -> ( NuLL RECORD ) .

    STARSTAR        reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    *               reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    /               reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    MOD             reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    REM             reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    =               reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    NOTEQUAL        reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    <               reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    LESSEQ          reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    >               reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    GREATEREQ       reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    IN              reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    NOT             reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    +               reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    -               reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    &               reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    AND             reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    OR              reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    )               reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    ,               reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    DOTDOT          reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    WITH            reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    ARROW           reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    |               reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    ;               reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    IS              reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    THEN            reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    LOOP            reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    RANGE           reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    DIGITS          reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    RENAMES         reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)
    ASSIGNMENT      reduce using rule 194 (aggregate -> ( NuLL RECORD ) .)


state 523

    (192) aggregate -> ( expression WITH value_s . )
    (170) value_s -> value_s . , value

    )               shift and go to state 660
    ,               shift and go to state 526


state 524

    (193) aggregate -> ( expression WITH NuLL . RECORD )
    (189) literal -> NuLL .

    RECORD          shift and go to state 661
    STARSTAR        reduce using rule 189 (literal -> NuLL .)
    *               reduce using rule 189 (literal -> NuLL .)
    /               reduce using rule 189 (literal -> NuLL .)
    MOD             reduce using rule 189 (literal -> NuLL .)
    REM             reduce using rule 189 (literal -> NuLL .)
    DOTDOT          reduce using rule 189 (literal -> NuLL .)
    =               reduce using rule 189 (literal -> NuLL .)
    NOTEQUAL        reduce using rule 189 (literal -> NuLL .)
    <               reduce using rule 189 (literal -> NuLL .)
    LESSEQ          reduce using rule 189 (literal -> NuLL .)
    >               reduce using rule 189 (literal -> NuLL .)
    GREATEREQ       reduce using rule 189 (literal -> NuLL .)
    IN              reduce using rule 189 (literal -> NuLL .)
    NOT             reduce using rule 189 (literal -> NuLL .)
    +               reduce using rule 189 (literal -> NuLL .)
    -               reduce using rule 189 (literal -> NuLL .)
    &               reduce using rule 189 (literal -> NuLL .)
    AND             reduce using rule 189 (literal -> NuLL .)
    OR              reduce using rule 189 (literal -> NuLL .)
    )               reduce using rule 189 (literal -> NuLL .)
    ,               reduce using rule 189 (literal -> NuLL .)
    ARROW           reduce using rule 189 (literal -> NuLL .)
    |               reduce using rule 189 (literal -> NuLL .)


state 525

    (168) indexed_comp -> name ( value_s ) .

    (               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    .               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    TICK            reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    RANGE           reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    DIGITS          reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    ASSIGNMENT      reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    ;               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    WITH            reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    STARSTAR        reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    *               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    /               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    MOD             reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    REM             reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    DOTDOT          reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    =               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    NOTEQUAL        reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    <               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    LESSEQ          reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    >               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    GREATEREQ       reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    IN              reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    NOT             reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    +               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    -               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    &               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    AND             reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    OR              reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    ARROW           reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    |               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    )               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    ,               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    IS              reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    THEN            reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    LOOP            reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    RENAMES         reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    WHEN            reduce using rule 168 (indexed_comp -> name ( value_s ) .)


state 526

    (170) value_s -> value_s , . value
    (171) value -> . expression
    (172) value -> . comp_assoc
    (173) value -> . discrete_with_range
    (174) value -> . error
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (197) comp_assoc -> . choice_s ARROW expression
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 233
    OTHERS          shift and go to state 223
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 381
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    choice_s                       shift and go to state 225
    comp_assoc                     shift and go to state 382
    factor                         shift and go to state 137
    choice                         shift and go to state 227
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 146
    name                           shift and go to state 230
    operator_symbol                shift and go to state 149
    value                          shift and go to state 662
    range                          shift and go to state 232
    expression                     shift and go to state 384

state 527

    (384) prot_body -> PROTECTED BODY . simple_name IS prot_op_body_s END id_opt ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 663

state 528

    (367) task_body -> TASK BODY . simple_name IS decl_part block_body END id_opt ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 664

state 529

    (332) subprog_spec_is_push -> subprog_spec IS .

    PACKAGE         reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    TASK            reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    PROTECTED       reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    error           reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    USE             reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    PRAGMA          reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    TYPE            reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    SUBTYPE         reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    FOR             reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    PROCEDURE       reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    FUNCTION        reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    GENERIC         reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    IDENTIFIER      reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)
    BEGIN           reduce using rule 332 (subprog_spec_is_push -> subprog_spec IS .)


state 530

    (456) body_stub -> PROTECTED BODY simple_name IS SEPARATE . ;

    ;               shift and go to state 665


state 531

    (384) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s . END id_opt ;
    (386) prot_op_body_s -> prot_op_body_s . prot_op_body pragma_s
    (387) prot_op_body -> . entry_body
    (388) prot_op_body -> . subprog_body
    (389) prot_op_body -> . subprog_spec ;
    (394) entry_body -> . ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part
    (395) entry_body -> . ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part
    (333) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (315) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (316) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (317) subprog_spec -> . FUNCTION designator
    (332) subprog_spec_is_push -> . subprog_spec IS

    END             shift and go to state 668
    ENTRY           shift and go to state 671
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36

    subprog_body                   shift and go to state 666
    prot_op_body                   shift and go to state 670
    entry_body                     shift and go to state 669
    subprog_spec                   shift and go to state 667
    subprog_spec_is_push           shift and go to state 406

state 532

    (385) prot_op_body_s -> pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 385 (prot_op_body_s -> pragma_s .)
    ENTRY           reduce using rule 385 (prot_op_body_s -> pragma_s .)
    PROCEDURE       reduce using rule 385 (prot_op_body_s -> pragma_s .)
    FUNCTION        reduce using rule 385 (prot_op_body_s -> pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 533

    (378) prot_op_decl -> rep_spec .

    error           reduce using rule 378 (prot_op_decl -> rep_spec .)
    ENTRY           reduce using rule 378 (prot_op_decl -> rep_spec .)
    PROCEDURE       reduce using rule 378 (prot_op_decl -> rep_spec .)
    FUNCTION        reduce using rule 378 (prot_op_decl -> rep_spec .)
    PRAGMA          reduce using rule 378 (prot_op_decl -> rep_spec .)
    FOR             reduce using rule 378 (prot_op_decl -> rep_spec .)
    IDENTIFIER      reduce using rule 378 (prot_op_decl -> rep_spec .)
    END             reduce using rule 378 (prot_op_decl -> rep_spec .)
    PRIVATE         reduce using rule 378 (prot_op_decl -> rep_spec .)


state 534

    (376) prot_op_decl -> entry_decl .

    error           reduce using rule 376 (prot_op_decl -> entry_decl .)
    ENTRY           reduce using rule 376 (prot_op_decl -> entry_decl .)
    PROCEDURE       reduce using rule 376 (prot_op_decl -> entry_decl .)
    FUNCTION        reduce using rule 376 (prot_op_decl -> entry_decl .)
    PRAGMA          reduce using rule 376 (prot_op_decl -> entry_decl .)
    FOR             reduce using rule 376 (prot_op_decl -> entry_decl .)
    IDENTIFIER      reduce using rule 376 (prot_op_decl -> entry_decl .)
    END             reduce using rule 376 (prot_op_decl -> entry_decl .)
    PRIVATE         reduce using rule 376 (prot_op_decl -> entry_decl .)


state 535

    (373) prot_private_opt -> PRIVATE . prot_elem_decl_s
    (380) prot_elem_decl_s -> .
    (381) prot_elem_decl_s -> . prot_elem_decl_s prot_elem_decl

    error           reduce using rule 380 (prot_elem_decl_s -> .)
    ENTRY           reduce using rule 380 (prot_elem_decl_s -> .)
    PROCEDURE       reduce using rule 380 (prot_elem_decl_s -> .)
    FUNCTION        reduce using rule 380 (prot_elem_decl_s -> .)
    PRAGMA          reduce using rule 380 (prot_elem_decl_s -> .)
    FOR             reduce using rule 380 (prot_elem_decl_s -> .)
    IDENTIFIER      reduce using rule 380 (prot_elem_decl_s -> .)
    END             reduce using rule 380 (prot_elem_decl_s -> .)

    prot_elem_decl_s               shift and go to state 672

state 536

    (377) prot_op_decl -> subprog_spec . ;

    ;               shift and go to state 673


state 537

    (371) prot_def -> IS prot_op_decl_s prot_private_opt . END id_opt

    END             shift and go to state 674


state 538

    (379) prot_op_decl -> pragma .

    error           reduce using rule 379 (prot_op_decl -> pragma .)
    ENTRY           reduce using rule 379 (prot_op_decl -> pragma .)
    PROCEDURE       reduce using rule 379 (prot_op_decl -> pragma .)
    FUNCTION        reduce using rule 379 (prot_op_decl -> pragma .)
    PRAGMA          reduce using rule 379 (prot_op_decl -> pragma .)
    FOR             reduce using rule 379 (prot_op_decl -> pragma .)
    IDENTIFIER      reduce using rule 379 (prot_op_decl -> pragma .)
    END             reduce using rule 379 (prot_op_decl -> pragma .)
    PRIVATE         reduce using rule 379 (prot_op_decl -> pragma .)


state 539

    (392) entry_decl -> ENTRY . IDENTIFIER formal_part_opt ;
    (393) entry_decl -> ENTRY . IDENTIFIER ( discrete_range ) formal_part_opt ;

    IDENTIFIER      shift and go to state 675


state 540

    (375) prot_op_decl_s -> prot_op_decl_s prot_op_decl .

    PRIVATE         reduce using rule 375 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    ENTRY           reduce using rule 375 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    PROCEDURE       reduce using rule 375 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    FUNCTION        reduce using rule 375 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    PRAGMA          reduce using rule 375 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    FOR             reduce using rule 375 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    END             reduce using rule 375 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)


state 541

    (370) prot_spec -> PROTECTED TYPE simple_name discrim_part_opt prot_def .

    ;               reduce using rule 370 (prot_spec -> PROTECTED TYPE simple_name discrim_part_opt prot_def .)


state 542

    (407) delay_stmt -> DELAY UNTIL expression . ;
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ;               shift and go to state 676
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 543

    (406) delay_stmt -> DELAY expression ; .

    EXCEPTION       reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    LESSLESS        reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    error           reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    PRAGMA          reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    NuLL            reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    EXIT            reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    RETURN          reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    GOTO            reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    DELAY           reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    ABORT           reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    RAISE           reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    REQUEUE         reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    IF              reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    CASE            reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    IDENTIFIER      reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    ACCEPT          reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    SELECT          reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    STRING          reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    WHILE           reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    DECLARE         reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    FOR             reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    LOOP            reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    BEGIN           reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    END             reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    OR              reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    ELSE            reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    THEN            reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    ELSIF           reduce using rule 406 (delay_stmt -> DELAY expression ; .)
    WHEN            reduce using rule 406 (delay_stmt -> DELAY expression ; .)


state 544

    (290) iteration -> iter_part reverse_opt . discrete_range
    (91) discrete_range -> . name range_constr_opt
    (92) discrete_range -> . range
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    simple_expression              shift and go to state 358
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    parenthesized_primary          shift and go to state 141
    discrete_range                 shift and go to state 677
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 678
    operator_symbol                shift and go to state 149
    range                          shift and go to state 679
    qualified                      shift and go to state 140

state 545

    (293) reverse_opt -> REVERSE .

    IDENTIFIER      reduce using rule 293 (reverse_opt -> REVERSE .)
    STRING          reduce using rule 293 (reverse_opt -> REVERSE .)
    +               reduce using rule 293 (reverse_opt -> REVERSE .)
    -               reduce using rule 293 (reverse_opt -> REVERSE .)
    NOT             reduce using rule 293 (reverse_opt -> REVERSE .)
    INTEGER         reduce using rule 293 (reverse_opt -> REVERSE .)
    BASE_INTEGER    reduce using rule 293 (reverse_opt -> REVERSE .)
    FLOAT           reduce using rule 293 (reverse_opt -> REVERSE .)
    BASE_FLOAT      reduce using rule 293 (reverse_opt -> REVERSE .)
    NuLL            reduce using rule 293 (reverse_opt -> REVERSE .)
    NEW             reduce using rule 293 (reverse_opt -> REVERSE .)
    (               reduce using rule 293 (reverse_opt -> REVERSE .)
    CHAR            reduce using rule 293 (reverse_opt -> REVERSE .)


state 546

    (291) iter_part -> FOR IDENTIFIER . IN

    IN              shift and go to state 680


state 547

    (297) block -> label_opt block_decl block_body . END id_opt ;

    END             shift and go to state 681


state 548

    (285) loop_stmt -> label_opt iteration basic_loop . id_opt ;
    (295) id_opt -> .
    (296) id_opt -> . designator
    (318) designator -> . compound_name
    (319) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 295 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 463
    id_opt                         shift and go to state 682
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 549

    (294) basic_loop -> LOOP . statement_s END LOOP
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 683
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 550

    (289) iteration -> WHILE condition .

    LOOP            reduce using rule 289 (iteration -> WHILE condition .)


state 551

    (299) block_decl -> DECLARE decl_part .

    BEGIN           reduce using rule 299 (block_decl -> DECLARE decl_part .)


state 552

    (311) goto_stmt -> GOTO name ; .

    EXCEPTION       reduce using rule 311 (goto_stmt -> GOTO name ; .)
    LESSLESS        reduce using rule 311 (goto_stmt -> GOTO name ; .)
    error           reduce using rule 311 (goto_stmt -> GOTO name ; .)
    PRAGMA          reduce using rule 311 (goto_stmt -> GOTO name ; .)
    NuLL            reduce using rule 311 (goto_stmt -> GOTO name ; .)
    EXIT            reduce using rule 311 (goto_stmt -> GOTO name ; .)
    RETURN          reduce using rule 311 (goto_stmt -> GOTO name ; .)
    GOTO            reduce using rule 311 (goto_stmt -> GOTO name ; .)
    DELAY           reduce using rule 311 (goto_stmt -> GOTO name ; .)
    ABORT           reduce using rule 311 (goto_stmt -> GOTO name ; .)
    RAISE           reduce using rule 311 (goto_stmt -> GOTO name ; .)
    REQUEUE         reduce using rule 311 (goto_stmt -> GOTO name ; .)
    IF              reduce using rule 311 (goto_stmt -> GOTO name ; .)
    CASE            reduce using rule 311 (goto_stmt -> GOTO name ; .)
    IDENTIFIER      reduce using rule 311 (goto_stmt -> GOTO name ; .)
    ACCEPT          reduce using rule 311 (goto_stmt -> GOTO name ; .)
    SELECT          reduce using rule 311 (goto_stmt -> GOTO name ; .)
    STRING          reduce using rule 311 (goto_stmt -> GOTO name ; .)
    WHILE           reduce using rule 311 (goto_stmt -> GOTO name ; .)
    DECLARE         reduce using rule 311 (goto_stmt -> GOTO name ; .)
    FOR             reduce using rule 311 (goto_stmt -> GOTO name ; .)
    LOOP            reduce using rule 311 (goto_stmt -> GOTO name ; .)
    BEGIN           reduce using rule 311 (goto_stmt -> GOTO name ; .)
    END             reduce using rule 311 (goto_stmt -> GOTO name ; .)
    OR              reduce using rule 311 (goto_stmt -> GOTO name ; .)
    ELSE            reduce using rule 311 (goto_stmt -> GOTO name ; .)
    THEN            reduce using rule 311 (goto_stmt -> GOTO name ; .)
    ELSIF           reduce using rule 311 (goto_stmt -> GOTO name ; .)
    WHEN            reduce using rule 311 (goto_stmt -> GOTO name ; .)


state 553

    (271) assign_stmt -> name ASSIGNMENT expression . ;
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ;               shift and go to state 684
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 554

    (427) abort_stmt -> ABORT name_s ; .

    LESSLESS        reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    error           reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    PRAGMA          reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    NuLL            reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    EXIT            reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    RETURN          reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    GOTO            reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    DELAY           reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    ABORT           reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    RAISE           reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    REQUEUE         reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    IF              reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    CASE            reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    IDENTIFIER      reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    ACCEPT          reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    SELECT          reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    STRING          reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    WHILE           reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    DECLARE         reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    FOR             reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    LOOP            reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    BEGIN           reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    OR              reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    ELSE            reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    THEN            reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    END             reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    ELSIF           reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    EXCEPTION       reduce using rule 427 (abort_stmt -> ABORT name_s ; .)
    WHEN            reduce using rule 427 (abort_stmt -> ABORT name_s ; .)


state 555

    (269) label -> LESSLESS IDENTIFIER MOREMORE .

    LESSLESS        reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    error           reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    PRAGMA          reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    NuLL            reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    EXIT            reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    RETURN          reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    GOTO            reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    DELAY           reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    ABORT           reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    RAISE           reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    REQUEUE         reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    IF              reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    CASE            reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    IDENTIFIER      reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    ACCEPT          reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    SELECT          reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    STRING          reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    WHILE           reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    DECLARE         reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    FOR             reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    LOOP            reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    BEGIN           reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)


state 556

    (310) return_stmt -> RETURN expression ; .

    END             reduce using rule 310 (return_stmt -> RETURN expression ; .)
    LESSLESS        reduce using rule 310 (return_stmt -> RETURN expression ; .)
    error           reduce using rule 310 (return_stmt -> RETURN expression ; .)
    PRAGMA          reduce using rule 310 (return_stmt -> RETURN expression ; .)
    NuLL            reduce using rule 310 (return_stmt -> RETURN expression ; .)
    EXIT            reduce using rule 310 (return_stmt -> RETURN expression ; .)
    RETURN          reduce using rule 310 (return_stmt -> RETURN expression ; .)
    GOTO            reduce using rule 310 (return_stmt -> RETURN expression ; .)
    DELAY           reduce using rule 310 (return_stmt -> RETURN expression ; .)
    ABORT           reduce using rule 310 (return_stmt -> RETURN expression ; .)
    RAISE           reduce using rule 310 (return_stmt -> RETURN expression ; .)
    REQUEUE         reduce using rule 310 (return_stmt -> RETURN expression ; .)
    IF              reduce using rule 310 (return_stmt -> RETURN expression ; .)
    CASE            reduce using rule 310 (return_stmt -> RETURN expression ; .)
    IDENTIFIER      reduce using rule 310 (return_stmt -> RETURN expression ; .)
    ACCEPT          reduce using rule 310 (return_stmt -> RETURN expression ; .)
    SELECT          reduce using rule 310 (return_stmt -> RETURN expression ; .)
    STRING          reduce using rule 310 (return_stmt -> RETURN expression ; .)
    WHILE           reduce using rule 310 (return_stmt -> RETURN expression ; .)
    DECLARE         reduce using rule 310 (return_stmt -> RETURN expression ; .)
    FOR             reduce using rule 310 (return_stmt -> RETURN expression ; .)
    LOOP            reduce using rule 310 (return_stmt -> RETURN expression ; .)
    BEGIN           reduce using rule 310 (return_stmt -> RETURN expression ; .)
    EXCEPTION       reduce using rule 310 (return_stmt -> RETURN expression ; .)
    ELSIF           reduce using rule 310 (return_stmt -> RETURN expression ; .)
    ELSE            reduce using rule 310 (return_stmt -> RETURN expression ; .)
    WHEN            reduce using rule 310 (return_stmt -> RETURN expression ; .)
    OR              reduce using rule 310 (return_stmt -> RETURN expression ; .)
    THEN            reduce using rule 310 (return_stmt -> RETURN expression ; .)


state 557

    (405) entry_name -> entry_name ( . expression )
    (322) formal_part -> ( . param_s )
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (323) param_s -> . param
    (324) param_s -> . param_s ; param
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (325) param -> . def_id_s : mode mark init_opt
    (326) param -> . error
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (26) def_id -> . IDENTIFIER
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 109
    +               shift and go to state 133
    -               shift and go to state 134
    IDENTIFIER      shift and go to state 685
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    param                          shift and go to state 340
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    param_s                        shift and go to state 341
    literal                        shift and go to state 135
    def_id_s                       shift and go to state 105
    factor                         shift and go to state 137
    def_id                         shift and go to state 89
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    relation                       shift and go to state 125
    expression                     shift and go to state 686

state 558

    (403) accept_hdr -> ACCEPT entry_name formal_part_opt .

    ;               reduce using rule 403 (accept_hdr -> ACCEPT entry_name formal_part_opt .)
    DO              reduce using rule 403 (accept_hdr -> ACCEPT entry_name formal_part_opt .)


state 559

    (417) select_alt -> accept_stmt stmts_opt .

    OR              reduce using rule 417 (select_alt -> accept_stmt stmts_opt .)
    ELSE            reduce using rule 417 (select_alt -> accept_stmt stmts_opt .)
    END             reduce using rule 417 (select_alt -> accept_stmt stmts_opt .)


state 560

    (426) stmts_opt -> statement_s .
    (245) statement_s -> statement_s . statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    OR              reduce using rule 426 (stmts_opt -> statement_s .)
    ELSE            reduce using rule 426 (stmts_opt -> statement_s .)
    END             reduce using rule 426 (stmts_opt -> statement_s .)
    THEN            reduce using rule 426 (stmts_opt -> statement_s .)
    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 456
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 561

    (423) timed_entry_call -> SELECT entry_call stmts_opt . OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> SELECT entry_call stmts_opt . ELSE statement_s END SELECT ;
    (421) delay_or_entry_alt -> entry_call stmts_opt .

    OR              shift and go to state 688
    ELSE            shift and go to state 687
    THEN            reduce using rule 421 (delay_or_entry_alt -> entry_call stmts_opt .)


state 562

    (422) async_select -> SELECT delay_or_entry_alt THEN . ABORT statement_s END SELECT ;

    ABORT           shift and go to state 689


state 563

    (414) guarded_select_alt -> WHEN condition . ARROW select_alt

    ARROW           shift and go to state 690


state 564

    (412) select_wait -> SELECT guarded_select_alt or_select . else_opt END SELECT ;
    (416) or_select -> or_select . OR guarded_select_alt
    (278) else_opt -> .
    (279) else_opt -> . ELSE statement_s

    OR              shift and go to state 692
    END             reduce using rule 278 (else_opt -> .)
    ELSE            shift and go to state 578

    else_opt                       shift and go to state 691

state 565

    (420) delay_or_entry_alt -> delay_stmt stmts_opt .
    (418) select_alt -> delay_stmt stmts_opt .

    THEN            reduce using rule 420 (delay_or_entry_alt -> delay_stmt stmts_opt .)
    OR              reduce using rule 418 (select_alt -> delay_stmt stmts_opt .)
    ELSE            reduce using rule 418 (select_alt -> delay_stmt stmts_opt .)
    END             reduce using rule 418 (select_alt -> delay_stmt stmts_opt .)


state 566

    (419) select_alt -> TERMINATE ; .

    OR              reduce using rule 419 (select_alt -> TERMINATE ; .)
    ELSE            reduce using rule 419 (select_alt -> TERMINATE ; .)
    END             reduce using rule 419 (select_alt -> TERMINATE ; .)


state 567

    (280) case_stmt -> case_hdr pragma_s alternative_s . END CASE ;
    (283) alternative_s -> alternative_s . alternative
    (284) alternative -> . WHEN choice_s ARROW statement_s

    END             shift and go to state 694
    WHEN            shift and go to state 695

    alternative                    shift and go to state 693

state 568

    (466) raise_stmt -> RAISE name_opt ; .

    LESSLESS        reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    error           reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    PRAGMA          reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    NuLL            reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    EXIT            reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    RETURN          reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    GOTO            reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    DELAY           reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    ABORT           reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    RAISE           reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    REQUEUE         reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    IF              reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    CASE            reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    IDENTIFIER      reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    ACCEPT          reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    SELECT          reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    STRING          reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    WHILE           reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    DECLARE         reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    FOR             reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    LOOP            reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    BEGIN           reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    END             reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    WHEN            reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    ELSIF           reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    ELSE            reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    EXCEPTION       reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    OR              reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)
    THEN            reduce using rule 466 (raise_stmt -> RAISE name_opt ; .)


state 569

    (281) case_hdr -> CASE expression IS .

    PRAGMA          reduce using rule 281 (case_hdr -> CASE expression IS .)
    END             reduce using rule 281 (case_hdr -> CASE expression IS .)
    WHEN            reduce using rule 281 (case_hdr -> CASE expression IS .)


state 570

    (467) requeue_stmt -> REQUEUE name ; .

    LESSLESS        reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    error           reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    PRAGMA          reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    NuLL            reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    EXIT            reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    RETURN          reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    GOTO            reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    DELAY           reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    ABORT           reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    RAISE           reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    REQUEUE         reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    IF              reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    CASE            reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    IDENTIFIER      reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    ACCEPT          reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    SELECT          reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    STRING          reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    WHILE           reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    DECLARE         reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    FOR             reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    LOOP            reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    BEGIN           reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    WHEN            reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    END             reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    OR              reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    ELSE            reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    THEN            reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    EXCEPTION       reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)
    ELSIF           reduce using rule 467 (requeue_stmt -> REQUEUE name ; .)


state 571

    (468) requeue_stmt -> REQUEUE name WITH . ABORT ;

    ABORT           shift and go to state 696


state 572

    (402) accept_stmt -> accept_hdr DO handled_stmt_s . END id_opt ;

    END             shift and go to state 697


state 573

    (304) exit_stmt -> EXIT name_opt when_opt . ;

    ;               shift and go to state 698


state 574

    (308) when_opt -> WHEN . condition
    (277) condition -> . expression
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    condition                      shift and go to state 699
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 462

state 575

    (459) except_handler_part -> except_handler_part exception_handler .

    WHEN            reduce using rule 459 (except_handler_part -> except_handler_part exception_handler .)
    END             reduce using rule 459 (except_handler_part -> except_handler_part exception_handler .)


state 576

    (460) exception_handler -> WHEN . except_choice_s ARROW statement_s
    (461) exception_handler -> WHEN . IDENTIFIER : except_choice_s ARROW statement_s
    (462) except_choice_s -> . except_choice
    (463) except_choice_s -> . except_choice_s | except_choice
    (464) except_choice -> . name
    (465) except_choice -> . OTHERS
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 701
    OTHERS          shift and go to state 703
    STRING          shift and go to state 138

    name                           shift and go to state 704
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    except_choice_s                shift and go to state 700
    except_choice                  shift and go to state 702
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 577

    (458) except_handler_part -> EXCEPTION exception_handler .

    WHEN            reduce using rule 458 (except_handler_part -> EXCEPTION exception_handler .)
    END             reduce using rule 458 (except_handler_part -> EXCEPTION exception_handler .)


state 578

    (279) else_opt -> ELSE . statement_s
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 705
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 579

    (272) if_stmt -> IF cond_clause_s else_opt . END IF ;

    END             shift and go to state 706


state 580

    (274) cond_clause_s -> cond_clause_s ELSIF . cond_clause
    (275) cond_clause -> . cond_part statement_s
    (276) cond_part -> . condition THEN
    (277) condition -> . expression
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    cond_clause                    shift and go to state 707
    cond_part                      shift and go to state 460
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    condition                      shift and go to state 461
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 462

state 581

    (275) cond_clause -> cond_part statement_s .
    (245) statement_s -> statement_s . statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    ELSIF           reduce using rule 275 (cond_clause -> cond_part statement_s .)
    ELSE            reduce using rule 275 (cond_clause -> cond_part statement_s .)
    END             reduce using rule 275 (cond_clause -> cond_part statement_s .)
    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 456
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 582

    (276) cond_part -> condition THEN .

    LESSLESS        reduce using rule 276 (cond_part -> condition THEN .)
    error           reduce using rule 276 (cond_part -> condition THEN .)
    PRAGMA          reduce using rule 276 (cond_part -> condition THEN .)
    NuLL            reduce using rule 276 (cond_part -> condition THEN .)
    EXIT            reduce using rule 276 (cond_part -> condition THEN .)
    RETURN          reduce using rule 276 (cond_part -> condition THEN .)
    GOTO            reduce using rule 276 (cond_part -> condition THEN .)
    DELAY           reduce using rule 276 (cond_part -> condition THEN .)
    ABORT           reduce using rule 276 (cond_part -> condition THEN .)
    RAISE           reduce using rule 276 (cond_part -> condition THEN .)
    REQUEUE         reduce using rule 276 (cond_part -> condition THEN .)
    IF              reduce using rule 276 (cond_part -> condition THEN .)
    CASE            reduce using rule 276 (cond_part -> condition THEN .)
    IDENTIFIER      reduce using rule 276 (cond_part -> condition THEN .)
    ACCEPT          reduce using rule 276 (cond_part -> condition THEN .)
    SELECT          reduce using rule 276 (cond_part -> condition THEN .)
    STRING          reduce using rule 276 (cond_part -> condition THEN .)
    WHILE           reduce using rule 276 (cond_part -> condition THEN .)
    DECLARE         reduce using rule 276 (cond_part -> condition THEN .)
    FOR             reduce using rule 276 (cond_part -> condition THEN .)
    LOOP            reduce using rule 276 (cond_part -> condition THEN .)
    BEGIN           reduce using rule 276 (cond_part -> condition THEN .)


state 583

    (333) subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .

    PACKAGE         reduce using rule 333 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    TASK            reduce using rule 333 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    PROTECTED       reduce using rule 333 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    error           reduce using rule 333 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    USE             reduce using rule 333 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    PRAGMA          reduce using rule 333 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    TYPE            reduce using rule 333 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    SUBTYPE         reduce using rule 333 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    FOR             reduce using rule 333 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    PROCEDURE       reduce using rule 333 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    FUNCTION        reduce using rule 333 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    GENERIC         reduce using rule 333 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    IDENTIFIER      reduce using rule 333 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    BEGIN           reduce using rule 333 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    END             reduce using rule 333 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    PRIVATE         reduce using rule 333 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    WITH            reduce using rule 333 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    SEPARATE        reduce using rule 333 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    $end            reduce using rule 333 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    ENTRY           reduce using rule 333 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)


state 584

    (506) record_type_spec -> FOR mark USE RECORD align_opt . comp_loc_s END RECORD ;
    (509) comp_loc_s -> .
    (510) comp_loc_s -> . comp_loc_s mark AT expression RANGE range ;

    END             reduce using rule 509 (comp_loc_s -> .)
    IDENTIFIER      reduce using rule 509 (comp_loc_s -> .)

    comp_loc_s                     shift and go to state 708

state 585

    (508) align_opt -> AT . MOD expression ;

    MOD             shift and go to state 709


state 586

    (511) address_spec -> FOR mark USE AT expression . ;
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ;               shift and go to state 710
    AND             shift and go to state 247
    OR              shift and go to state 250

    short_circuit                  shift and go to state 249
    logical                        shift and go to state 248

state 587

    (505) attrib_def -> FOR mark USE expression ; .

    PACKAGE         reduce using rule 505 (attrib_def -> FOR mark USE expression ; .)
    TASK            reduce using rule 505 (attrib_def -> FOR mark USE expression ; .)
    PROTECTED       reduce using rule 505 (attrib_def -> FOR mark USE expression ; .)
    error           reduce using rule 505 (attrib_def -> FOR mark USE expression ; .)
    USE             reduce using rule 505 (attrib_def -> FOR mark USE expression ; .)
    PRAGMA          reduce using rule 505 (attrib_def -> FOR mark USE expression ; .)
    TYPE            reduce using rule 505 (attrib_def -> FOR mark USE expression ; .)
    SUBTYPE         reduce using rule 505 (attrib_def -> FOR mark USE expression ; .)
    FOR             reduce using rule 505 (attrib_def -> FOR mark USE expression ; .)
    PROCEDURE       reduce using rule 505 (attrib_def -> FOR mark USE expression ; .)
    FUNCTION        reduce using rule 505 (attrib_def -> FOR mark USE expression ; .)
    GENERIC         reduce using rule 505 (attrib_def -> FOR mark USE expression ; .)
    IDENTIFIER      reduce using rule 505 (attrib_def -> FOR mark USE expression ; .)
    BEGIN           reduce using rule 505 (attrib_def -> FOR mark USE expression ; .)
    PRIVATE         reduce using rule 505 (attrib_def -> FOR mark USE expression ; .)
    END             reduce using rule 505 (attrib_def -> FOR mark USE expression ; .)
    ENTRY           reduce using rule 505 (attrib_def -> FOR mark USE expression ; .)


state 588

    (453) body_stub -> TASK BODY simple_name IS SEPARATE . ;

    ;               shift and go to state 711


state 589

    (367) task_body -> TASK BODY simple_name IS decl_part . block_body END id_opt ;
    (300) block_body -> . BEGIN handled_stmt_s

    BEGIN           shift and go to state 162

    block_body                     shift and go to state 712

state 590

    (362) task_spec -> TASK TYPE simple_name discrim_part_opt task_def .

    ;               reduce using rule 362 (task_spec -> TASK TYPE simple_name discrim_part_opt task_def .)


state 591

    (364) task_def -> IS entry_decl_s rep_spec_s . task_private_opt END id_opt
    (399) rep_spec_s -> rep_spec_s . rep_spec pragma_s
    (365) task_private_opt -> .
    (366) task_private_opt -> . PRIVATE entry_decl_s rep_spec_s
    (502) rep_spec -> . attrib_def
    (503) rep_spec -> . record_type_spec
    (504) rep_spec -> . address_spec
    (505) attrib_def -> . FOR mark USE expression ;
    (506) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (511) address_spec -> . FOR mark USE AT expression ;

    END             reduce using rule 365 (task_private_opt -> .)
    PRIVATE         shift and go to state 714
    FOR             shift and go to state 63

    record_type_spec               shift and go to state 68
    rep_spec                       shift and go to state 713
    attrib_def                     shift and go to state 70
    address_spec                   shift and go to state 52
    task_private_opt               shift and go to state 715

state 592

    (391) entry_decl_s -> entry_decl_s entry_decl . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    FOR             reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 716

state 593

    (454) body_stub -> PACKAGE BODY compound_name IS SEPARATE . ;

    ;               shift and go to state 717


state 594

    (110) discrim_part -> ( discrim_spec_s ) .

    IS              reduce using rule 110 (discrim_part -> ( discrim_spec_s ) .)
    ;               reduce using rule 110 (discrim_part -> ( discrim_spec_s ) .)


state 595

    (112) discrim_spec_s -> discrim_spec_s ; . discrim_spec
    (113) discrim_spec -> . def_id_s : access_opt mark init_opt
    (114) discrim_spec -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    error           shift and go to state 475
    IDENTIFIER      shift and go to state 76

    discrim_spec                   shift and go to state 718
    def_id                         shift and go to state 89
    def_id_s                       shift and go to state 477

state 596

    (113) discrim_spec -> def_id_s : . access_opt mark init_opt
    (115) access_opt -> .
    (116) access_opt -> . ACCESS

    IDENTIFIER      reduce using rule 115 (access_opt -> .)
    ACCESS          shift and go to state 719

    access_opt                     shift and go to state 720

state 597

    (39) discrim_part_opt -> ( LESSMORE ) .

    IS              reduce using rule 39 (discrim_part_opt -> ( LESSMORE ) .)
    ;               reduce using rule 39 (discrim_part_opt -> ( LESSMORE ) .)


state 598

    (59) derived_type -> ABSTRACT . NEW subtype_ind WITH PRIVATE
    (60) derived_type -> ABSTRACT . NEW subtype_ind WITH record_def
    (100) tagged_opt -> ABSTRACT . TAGGED

    NEW             shift and go to state 722
    TAGGED          shift and go to state 721


state 599

    (70) range_spec -> range_constraint .

    ;               reduce using rule 70 (range_spec -> range_constraint .)


state 600

    (47) type_def -> access_type .

    ;               reduce using rule 47 (type_def -> access_type .)


state 601

    (46) type_def -> record_type .

    ;               reduce using rule 46 (type_def -> record_type .)


state 602

    (44) type_def -> real_type .

    ;               reduce using rule 44 (type_def -> real_type .)


state 603

    (56) derived_type -> NEW . subtype_ind
    (57) derived_type -> NEW . subtype_ind WITH PRIVATE
    (58) derived_type -> NEW . subtype_ind WITH record_def
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 482
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    subtype_ind                    shift and go to state 723
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 604

    (42) type_def -> enumeration_type .

    ;               reduce using rule 42 (type_def -> enumeration_type .)


state 605

    (49) type_def -> private_type .

    ;               reduce using rule 49 (type_def -> private_type .)


state 606

    (73) real_type -> float_type .

    ;               reduce using rule 73 (real_type -> float_type .)


state 607

    (63) enumeration_type -> ( . enum_id_s )
    (64) enum_id_s -> . enum_id
    (65) enum_id_s -> . enum_id_s , enum_id
    (66) enum_id -> . IDENTIFIER
    (67) enum_id -> . CHAR

    IDENTIFIER      shift and go to state 726
    CHAR            shift and go to state 725

    enum_id                        shift and go to state 727
    enum_id_s                      shift and go to state 724

state 608

    (75) float_type -> DIGITS . expression range_spec_opt
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 728

state 609

    (99) tagged_opt -> TAGGED .

    LIMITED         reduce using rule 99 (tagged_opt -> TAGGED .)
    PRIVATE         reduce using rule 99 (tagged_opt -> TAGGED .)
    RECORD          reduce using rule 99 (tagged_opt -> TAGGED .)
    NuLL            reduce using rule 99 (tagged_opt -> TAGGED .)


state 610

    (76) fixed_type -> DELTA . expression range_spec
    (77) fixed_type -> DELTA . expression DIGITS expression range_spec_opt
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 729

state 611

    (43) type_def -> integer_type .

    ;               reduce using rule 43 (type_def -> integer_type .)


state 612

    (45) type_def -> array_type .

    ;               reduce using rule 45 (type_def -> array_type .)


state 613

    (68) integer_type -> range_spec .

    ;               reduce using rule 68 (integer_type -> range_spec .)


state 614

    (41) type_completion -> IS type_def .

    ;               reduce using rule 41 (type_completion -> IS type_def .)


state 615

    (128) access_type -> ACCESS . subtype_ind
    (129) access_type -> ACCESS . CONSTANT subtype_ind
    (130) access_type -> ACCESS . ALL subtype_ind
    (131) access_type -> ACCESS . prot_opt PROCEDURE formal_part_opt
    (132) access_type -> ACCESS . prot_opt FUNCTION formal_part_opt RETURN mark
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (133) prot_opt -> .
    (134) prot_opt -> . PROTECTED
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    CONSTANT        shift and go to state 730
    ALL             shift and go to state 733
    PROCEDURE       reduce using rule 133 (prot_opt -> .)
    FUNCTION        reduce using rule 133 (prot_opt -> .)
    PROTECTED       shift and go to state 732
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 482
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    prot_opt                       shift and go to state 731
    subtype_ind                    shift and go to state 734
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 616

    (95) record_type -> tagged_opt . limited_opt record_def
    (345) private_type -> tagged_opt . limited_opt PRIVATE
    (346) limited_opt -> .
    (347) limited_opt -> . LIMITED

    PRIVATE         reduce using rule 346 (limited_opt -> .)
    RECORD          reduce using rule 346 (limited_opt -> .)
    NuLL            reduce using rule 346 (limited_opt -> .)
    LIMITED         shift and go to state 735

    limited_opt                    shift and go to state 736

state 617

    (48) type_def -> derived_type .

    ;               reduce using rule 48 (type_def -> derived_type .)


state 618

    (74) real_type -> fixed_type .

    ;               reduce using rule 74 (real_type -> fixed_type .)


state 619

    (69) integer_type -> MOD . expression
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 737

state 620

    (36) type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .

    PACKAGE         reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    TASK            reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    PROTECTED       reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    error           reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    USE             reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    PRAGMA          reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    TYPE            reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    SUBTYPE         reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    FOR             reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    PROCEDURE       reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    FUNCTION        reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    GENERIC         reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    IDENTIFIER      reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    BEGIN           reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    END             reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    PRIVATE         reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)


state 621

    (55) decimal_digits_constraint -> DIGITS . expression range_constr_opt
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 738

state 622

    (51) subtype_ind -> name constraint .

    ;               reduce using rule 51 (subtype_ind -> name constraint .)
    WITH            reduce using rule 51 (subtype_ind -> name constraint .)
    ASSIGNMENT      reduce using rule 51 (subtype_ind -> name constraint .)
    RENAMES         reduce using rule 51 (subtype_ind -> name constraint .)


state 623

    (53) constraint -> range_constraint .

    ;               reduce using rule 53 (constraint -> range_constraint .)
    RENAMES         reduce using rule 53 (constraint -> range_constraint .)
    ASSIGNMENT      reduce using rule 53 (constraint -> range_constraint .)
    WITH            reduce using rule 53 (constraint -> range_constraint .)


state 624

    (54) constraint -> decimal_digits_constraint .

    ;               reduce using rule 54 (constraint -> decimal_digits_constraint .)
    RENAMES         reduce using rule 54 (constraint -> decimal_digits_constraint .)
    ASSIGNMENT      reduce using rule 54 (constraint -> decimal_digits_constraint .)
    WITH            reduce using rule 54 (constraint -> decimal_digits_constraint .)


state 625

    (50) subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .

    PACKAGE         reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    TASK            reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    PROTECTED       reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    error           reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    USE             reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    PRAGMA          reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    TYPE            reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    SUBTYPE         reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    FOR             reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    PROCEDURE       reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    FUNCTION        reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    GENERIC         reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    IDENTIFIER      reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    BEGIN           reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    PRIVATE         reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    END             reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)


state 626

    (353) rename_decl -> def_id_s : EXCEPTION renames ; .

    PACKAGE         reduce using rule 353 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    TASK            reduce using rule 353 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    PROTECTED       reduce using rule 353 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    error           reduce using rule 353 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    USE             reduce using rule 353 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    PRAGMA          reduce using rule 353 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    TYPE            reduce using rule 353 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    SUBTYPE         reduce using rule 353 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    FOR             reduce using rule 353 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    PROCEDURE       reduce using rule 353 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    FUNCTION        reduce using rule 353 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    GENERIC         reduce using rule 353 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    IDENTIFIER      reduce using rule 353 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    BEGIN           reduce using rule 353 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    END             reduce using rule 353 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    PRIVATE         reduce using rule 353 (rename_decl -> def_id_s : EXCEPTION renames ; .)


state 627

    (35) number_decl -> def_id_s : CONSTANT ASSIGNMENT expression . ;
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ;               shift and go to state 739
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 628

    (80) unconstr_array_type -> ARRAY ( . index_s ) OF component_subtype_def
    (88) iter_index_constraint -> ( . iter_discrete_range_s )
    (85) index_s -> . index
    (86) index_s -> . index_s , index
    (89) iter_discrete_range_s -> . discrete_range
    (90) iter_discrete_range_s -> . iter_discrete_range_s , discrete_range
    (87) index -> . name RANGE LESSMORE
    (91) discrete_range -> . name range_constr_opt
    (92) discrete_range -> . range
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    iter_discrete_range_s          shift and go to state 740
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    simple_expression              shift and go to state 358
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    index                          shift and go to state 741
    index_s                        shift and go to state 742
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    primary                        shift and go to state 122
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    discrete_range                 shift and go to state 743
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 744
    operator_symbol                shift and go to state 149
    range                          shift and go to state 679

state 629

    (81) constr_array_type -> ARRAY iter_index_constraint . OF component_subtype_def

    OF              shift and go to state 745


state 630

    (34) init_opt -> ASSIGNMENT . expression
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 746

state 631

    (23) object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt . ;

    ;               shift and go to state 747


state 632

    (352) rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames . ;

    ;               shift and go to state 748


state 633

    (342) pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt . END c_id_opt ;

    END             shift and go to state 749


state 634

    (344) body_opt -> block_body .

    END             reduce using rule 344 (body_opt -> block_body .)


state 635

    (456) body_stub -> PROTECTED BODY simple_name . IS SEPARATE ;

    IS              shift and go to state 750


state 636

    (339) private_part -> PRIVATE decl_item_s .

    END             reduce using rule 339 (private_part -> PRIVATE decl_item_s .)


state 637

    (337) pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END . c_id_opt
    (340) c_id_opt -> .
    (341) c_id_opt -> . compound_name
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 340 (c_id_opt -> .)
    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 41
    compound_name                  shift and go to state 751
    c_id_opt                       shift and go to state 752

state 638

    (453) body_stub -> TASK BODY simple_name . IS SEPARATE ;

    IS              shift and go to state 753


state 639

    (454) body_stub -> PACKAGE BODY compound_name . IS SEPARATE ;
    (163) compound_name -> compound_name . . simple_name

    IS              shift and go to state 754
    .               shift and go to state 119


state 640

    (324) param_s -> param_s ; param .

    )               reduce using rule 324 (param_s -> param_s ; param .)
    ;               reduce using rule 324 (param_s -> param_s ; param .)


state 641

    (476) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN . name subp_default ;
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 755
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    indexed_comp                   shift and go to state 129
    operator_symbol                shift and go to state 149
    simple_name                    shift and go to state 157

state 642

    (477) generic_formal -> WITH PACKAGE simple_name IS NEW . name ( LESSMORE ) ;
    (478) generic_formal -> WITH PACKAGE simple_name IS NEW . name ;
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 756
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 643

    (484) subp_default -> IS . name
    (485) subp_default -> IS . LESSMORE
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSMORE        shift and go to state 758
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 757
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 644

    (475) generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default . ;

    ;               shift and go to state 759


state 645

    (325) param -> def_id_s : mode mark init_opt .

    )               reduce using rule 325 (param -> def_id_s : mode mark init_opt .)
    ;               reduce using rule 325 (param -> def_id_s : mode mark init_opt .)


state 646

    (498) generic_derived_type -> ABSTRACT . NEW subtype_ind WITH PRIVATE
    (100) tagged_opt -> ABSTRACT . TAGGED

    NEW             shift and go to state 760
    TAGGED          shift and go to state 721


state 647

    (474) generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def . ;

    ;               shift and go to state 761


state 648

    (496) generic_derived_type -> NEW . subtype_ind
    (497) generic_derived_type -> NEW . subtype_ind WITH PRIVATE
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 482
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    subtype_ind                    shift and go to state 762
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 649

    (495) generic_type_def -> generic_derived_type .

    ;               reduce using rule 495 (generic_type_def -> generic_derived_type .)


state 650

    (491) generic_type_def -> DIGITS . LESSMORE

    LESSMORE        shift and go to state 763


state 651

    (486) generic_type_def -> ( . LESSMORE )

    LESSMORE        shift and go to state 764


state 652

    (494) generic_type_def -> private_type .

    ;               reduce using rule 494 (generic_type_def -> private_type .)


state 653

    (487) generic_type_def -> RANGE . LESSMORE

    LESSMORE        shift and go to state 765


state 654

    (493) generic_type_def -> access_type .

    ;               reduce using rule 493 (generic_type_def -> access_type .)


state 655

    (492) generic_type_def -> array_type .

    ;               reduce using rule 492 (generic_type_def -> array_type .)


state 656

    (345) private_type -> tagged_opt . limited_opt PRIVATE
    (346) limited_opt -> .
    (347) limited_opt -> . LIMITED

    PRIVATE         reduce using rule 346 (limited_opt -> .)
    LIMITED         shift and go to state 735

    limited_opt                    shift and go to state 766

state 657

    (489) generic_type_def -> DELTA . LESSMORE
    (490) generic_type_def -> DELTA . LESSMORE DIGITS LESSMORE

    LESSMORE        shift and go to state 767


state 658

    (488) generic_type_def -> MOD . LESSMORE

    LESSMORE        shift and go to state 768


state 659

    (482) generic_discrim_part_opt -> ( LESSMORE ) .

    IS              reduce using rule 482 (generic_discrim_part_opt -> ( LESSMORE ) .)


state 660

    (192) aggregate -> ( expression WITH value_s ) .

    STARSTAR        reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    *               reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    /               reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    MOD             reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    REM             reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    =               reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    NOTEQUAL        reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    <               reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    LESSEQ          reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    >               reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    GREATEREQ       reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    IN              reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    NOT             reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    +               reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    -               reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    &               reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    AND             reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    OR              reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    )               reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    ,               reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    DOTDOT          reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    WITH            reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    ARROW           reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    |               reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    ;               reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    IS              reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    THEN            reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    LOOP            reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    RANGE           reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    DIGITS          reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    RENAMES         reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)
    ASSIGNMENT      reduce using rule 192 (aggregate -> ( expression WITH value_s ) .)


state 661

    (193) aggregate -> ( expression WITH NuLL RECORD . )

    )               shift and go to state 769


state 662

    (170) value_s -> value_s , value .

    )               reduce using rule 170 (value_s -> value_s , value .)
    ,               reduce using rule 170 (value_s -> value_s , value .)


state 663

    (384) prot_body -> PROTECTED BODY simple_name . IS prot_op_body_s END id_opt ;

    IS              shift and go to state 770


state 664

    (367) task_body -> TASK BODY simple_name . IS decl_part block_body END id_opt ;

    IS              shift and go to state 771


state 665

    (456) body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .

    PACKAGE         reduce using rule 456 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    TASK            reduce using rule 456 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    PROTECTED       reduce using rule 456 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    error           reduce using rule 456 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    USE             reduce using rule 456 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    PRAGMA          reduce using rule 456 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    TYPE            reduce using rule 456 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    SUBTYPE         reduce using rule 456 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    FOR             reduce using rule 456 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    PROCEDURE       reduce using rule 456 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    FUNCTION        reduce using rule 456 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    GENERIC         reduce using rule 456 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    IDENTIFIER      reduce using rule 456 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    BEGIN           reduce using rule 456 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    END             reduce using rule 456 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    PRIVATE         reduce using rule 456 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)


state 666

    (388) prot_op_body -> subprog_body .

    PRAGMA          reduce using rule 388 (prot_op_body -> subprog_body .)
    END             reduce using rule 388 (prot_op_body -> subprog_body .)
    ENTRY           reduce using rule 388 (prot_op_body -> subprog_body .)
    PROCEDURE       reduce using rule 388 (prot_op_body -> subprog_body .)
    FUNCTION        reduce using rule 388 (prot_op_body -> subprog_body .)


state 667

    (389) prot_op_body -> subprog_spec . ;
    (332) subprog_spec_is_push -> subprog_spec . IS

    ;               shift and go to state 772
    IS              shift and go to state 529


state 668

    (384) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END . id_opt ;
    (295) id_opt -> .
    (296) id_opt -> . designator
    (318) designator -> . compound_name
    (319) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 295 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 114
    id_opt                         shift and go to state 773
    designator                     shift and go to state 463
    simple_name                    shift and go to state 41

state 669

    (387) prot_op_body -> entry_body .

    PRAGMA          reduce using rule 387 (prot_op_body -> entry_body .)
    END             reduce using rule 387 (prot_op_body -> entry_body .)
    ENTRY           reduce using rule 387 (prot_op_body -> entry_body .)
    PROCEDURE       reduce using rule 387 (prot_op_body -> entry_body .)
    FUNCTION        reduce using rule 387 (prot_op_body -> entry_body .)


state 670

    (386) prot_op_body_s -> prot_op_body_s prot_op_body . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 774

state 671

    (394) entry_body -> ENTRY . IDENTIFIER formal_part_opt WHEN condition entry_body_part
    (395) entry_body -> ENTRY . IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part

    IDENTIFIER      shift and go to state 775


state 672

    (373) prot_private_opt -> PRIVATE prot_elem_decl_s .
    (381) prot_elem_decl_s -> prot_elem_decl_s . prot_elem_decl
    (382) prot_elem_decl -> . prot_op_decl
    (383) prot_elem_decl -> . comp_decl
    (376) prot_op_decl -> . entry_decl
    (377) prot_op_decl -> . subprog_spec ;
    (378) prot_op_decl -> . rep_spec
    (379) prot_op_decl -> . pragma
    (108) comp_decl -> . def_id_s : component_subtype_def init_opt ;
    (109) comp_decl -> . error ;
    (392) entry_decl -> . ENTRY IDENTIFIER formal_part_opt ;
    (393) entry_decl -> . ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ;
    (315) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (316) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (317) subprog_spec -> . FUNCTION designator
    (502) rep_spec -> . attrib_def
    (503) rep_spec -> . record_type_spec
    (504) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (505) attrib_def -> . FOR mark USE expression ;
    (506) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (511) address_spec -> . FOR mark USE AT expression ;
    (26) def_id -> . IDENTIFIER

    END             reduce using rule 373 (prot_private_opt -> PRIVATE prot_elem_decl_s .)
    error           shift and go to state 780
    ENTRY           shift and go to state 539
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    PRAGMA          shift and go to state 4
    FOR             shift and go to state 63
    IDENTIFIER      shift and go to state 76

    rep_spec                       shift and go to state 533
    entry_decl                     shift and go to state 534
    address_spec                   shift and go to state 52
    record_type_spec               shift and go to state 68
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 536
    def_id_s                       shift and go to state 776
    comp_decl                      shift and go to state 777
    def_id                         shift and go to state 89
    pragma                         shift and go to state 538
    prot_op_decl                   shift and go to state 778
    prot_elem_decl                 shift and go to state 779

state 673

    (377) prot_op_decl -> subprog_spec ; .

    error           reduce using rule 377 (prot_op_decl -> subprog_spec ; .)
    ENTRY           reduce using rule 377 (prot_op_decl -> subprog_spec ; .)
    PROCEDURE       reduce using rule 377 (prot_op_decl -> subprog_spec ; .)
    FUNCTION        reduce using rule 377 (prot_op_decl -> subprog_spec ; .)
    PRAGMA          reduce using rule 377 (prot_op_decl -> subprog_spec ; .)
    FOR             reduce using rule 377 (prot_op_decl -> subprog_spec ; .)
    IDENTIFIER      reduce using rule 377 (prot_op_decl -> subprog_spec ; .)
    END             reduce using rule 377 (prot_op_decl -> subprog_spec ; .)
    PRIVATE         reduce using rule 377 (prot_op_decl -> subprog_spec ; .)


state 674

    (371) prot_def -> IS prot_op_decl_s prot_private_opt END . id_opt
    (295) id_opt -> .
    (296) id_opt -> . designator
    (318) designator -> . compound_name
    (319) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 295 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 463
    id_opt                         shift and go to state 781
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 675

    (392) entry_decl -> ENTRY IDENTIFIER . formal_part_opt ;
    (393) entry_decl -> ENTRY IDENTIFIER . ( discrete_range ) formal_part_opt ;
    (320) formal_part_opt -> .
    (321) formal_part_opt -> . formal_part
    (322) formal_part -> . ( param_s )

    (               shift and go to state 782
    ;               reduce using rule 320 (formal_part_opt -> .)

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 783

state 676

    (407) delay_stmt -> DELAY UNTIL expression ; .

    EXCEPTION       reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    LESSLESS        reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    error           reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    PRAGMA          reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    NuLL            reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    EXIT            reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    RETURN          reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    GOTO            reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    DELAY           reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    ABORT           reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    RAISE           reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    REQUEUE         reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    IF              reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    CASE            reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    IDENTIFIER      reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    ACCEPT          reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    SELECT          reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    STRING          reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    WHILE           reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    DECLARE         reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    FOR             reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    LOOP            reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    BEGIN           reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    END             reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    OR              reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    ELSE            reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    THEN            reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    ELSIF           reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)
    WHEN            reduce using rule 407 (delay_stmt -> DELAY UNTIL expression ; .)


state 677

    (290) iteration -> iter_part reverse_opt discrete_range .

    LOOP            reduce using rule 290 (iteration -> iter_part reverse_opt discrete_range .)


state 678

    (91) discrete_range -> name . range_constr_opt
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id
    (235) primary -> name .
    (241) qualified -> name . TICK parenthesized_primary
    (93) range_constr_opt -> .
    (94) range_constr_opt -> . range_constraint
    (61) range_constraint -> . RANGE range

    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 370
    STARSTAR        reduce using rule 235 (primary -> name .)
    *               reduce using rule 235 (primary -> name .)
    /               reduce using rule 235 (primary -> name .)
    MOD             reduce using rule 235 (primary -> name .)
    REM             reduce using rule 235 (primary -> name .)
    DOTDOT          reduce using rule 235 (primary -> name .)
    +               reduce using rule 235 (primary -> name .)
    -               reduce using rule 235 (primary -> name .)
    &               reduce using rule 235 (primary -> name .)
    LOOP            reduce using rule 93 (range_constr_opt -> .)
    )               reduce using rule 93 (range_constr_opt -> .)
    ,               reduce using rule 93 (range_constr_opt -> .)
    RANGE           shift and go to state 371

    range_constr_opt               shift and go to state 784
    range_constraint               shift and go to state 785

state 679

    (92) discrete_range -> range .

    )               reduce using rule 92 (discrete_range -> range .)
    ,               reduce using rule 92 (discrete_range -> range .)
    LOOP            reduce using rule 92 (discrete_range -> range .)


state 680

    (291) iter_part -> FOR IDENTIFIER IN .

    IDENTIFIER      reduce using rule 291 (iter_part -> FOR IDENTIFIER IN .)
    STRING          reduce using rule 291 (iter_part -> FOR IDENTIFIER IN .)
    +               reduce using rule 291 (iter_part -> FOR IDENTIFIER IN .)
    -               reduce using rule 291 (iter_part -> FOR IDENTIFIER IN .)
    NOT             reduce using rule 291 (iter_part -> FOR IDENTIFIER IN .)
    INTEGER         reduce using rule 291 (iter_part -> FOR IDENTIFIER IN .)
    BASE_INTEGER    reduce using rule 291 (iter_part -> FOR IDENTIFIER IN .)
    FLOAT           reduce using rule 291 (iter_part -> FOR IDENTIFIER IN .)
    BASE_FLOAT      reduce using rule 291 (iter_part -> FOR IDENTIFIER IN .)
    NuLL            reduce using rule 291 (iter_part -> FOR IDENTIFIER IN .)
    NEW             reduce using rule 291 (iter_part -> FOR IDENTIFIER IN .)
    (               reduce using rule 291 (iter_part -> FOR IDENTIFIER IN .)
    CHAR            reduce using rule 291 (iter_part -> FOR IDENTIFIER IN .)
    REVERSE         reduce using rule 291 (iter_part -> FOR IDENTIFIER IN .)


state 681

    (297) block -> label_opt block_decl block_body END . id_opt ;
    (295) id_opt -> .
    (296) id_opt -> . designator
    (318) designator -> . compound_name
    (319) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 295 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 463
    id_opt                         shift and go to state 786
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 682

    (285) loop_stmt -> label_opt iteration basic_loop id_opt . ;

    ;               shift and go to state 787


state 683

    (294) basic_loop -> LOOP statement_s . END LOOP
    (245) statement_s -> statement_s . statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    END             shift and go to state 788
    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 456
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 684

    (271) assign_stmt -> name ASSIGNMENT expression ; .

    EXCEPTION       reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    LESSLESS        reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    error           reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    PRAGMA          reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    NuLL            reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    EXIT            reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    RETURN          reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    GOTO            reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    DELAY           reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    ABORT           reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    RAISE           reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    REQUEUE         reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    IF              reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    CASE            reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    IDENTIFIER      reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    ACCEPT          reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    SELECT          reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    STRING          reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    WHILE           reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    DECLARE         reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    FOR             reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    LOOP            reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    BEGIN           reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    END             reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    ELSIF           reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    ELSE            reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    WHEN            reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    OR              reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    THEN            reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)


state 685

    (26) def_id -> IDENTIFIER .
    (161) simple_name -> IDENTIFIER .

    :               reduce using rule 26 (def_id -> IDENTIFIER .)
    ,               reduce using rule 26 (def_id -> IDENTIFIER .)
    TICK            reduce using rule 161 (simple_name -> IDENTIFIER .)
    (               reduce using rule 161 (simple_name -> IDENTIFIER .)
    .               reduce using rule 161 (simple_name -> IDENTIFIER .)
    STARSTAR        reduce using rule 161 (simple_name -> IDENTIFIER .)
    *               reduce using rule 161 (simple_name -> IDENTIFIER .)
    /               reduce using rule 161 (simple_name -> IDENTIFIER .)
    MOD             reduce using rule 161 (simple_name -> IDENTIFIER .)
    REM             reduce using rule 161 (simple_name -> IDENTIFIER .)
    =               reduce using rule 161 (simple_name -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 161 (simple_name -> IDENTIFIER .)
    <               reduce using rule 161 (simple_name -> IDENTIFIER .)
    LESSEQ          reduce using rule 161 (simple_name -> IDENTIFIER .)
    >               reduce using rule 161 (simple_name -> IDENTIFIER .)
    GREATEREQ       reduce using rule 161 (simple_name -> IDENTIFIER .)
    IN              reduce using rule 161 (simple_name -> IDENTIFIER .)
    NOT             reduce using rule 161 (simple_name -> IDENTIFIER .)
    +               reduce using rule 161 (simple_name -> IDENTIFIER .)
    -               reduce using rule 161 (simple_name -> IDENTIFIER .)
    &               reduce using rule 161 (simple_name -> IDENTIFIER .)
    )               reduce using rule 161 (simple_name -> IDENTIFIER .)
    AND             reduce using rule 161 (simple_name -> IDENTIFIER .)
    OR              reduce using rule 161 (simple_name -> IDENTIFIER .)


state 686

    (405) entry_name -> entry_name ( expression . )
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    )               shift and go to state 789
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 687

    (424) cond_entry_call -> SELECT entry_call stmts_opt ELSE . statement_s END SELECT ;
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 790
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 688

    (423) timed_entry_call -> SELECT entry_call stmts_opt OR . delay_stmt stmts_opt END SELECT ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;

    DELAY           shift and go to state 260

    delay_stmt                     shift and go to state 791

state 689

    (422) async_select -> SELECT delay_or_entry_alt THEN ABORT . statement_s END SELECT ;
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 792
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    procedure_call                 shift and go to state 276
    block                          shift and go to state 283

state 690

    (414) guarded_select_alt -> WHEN condition ARROW . select_alt
    (417) select_alt -> . accept_stmt stmts_opt
    (418) select_alt -> . delay_stmt stmts_opt
    (419) select_alt -> . TERMINATE ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt

    TERMINATE       shift and go to state 442
    DELAY           shift and go to state 260
    ACCEPT          shift and go to state 275

    delay_stmt                     shift and go to state 793
    accept_hdr                     shift and go to state 292
    accept_stmt                    shift and go to state 433
    select_alt                     shift and go to state 794

state 691

    (412) select_wait -> SELECT guarded_select_alt or_select else_opt . END SELECT ;

    END             shift and go to state 795


state 692

    (416) or_select -> or_select OR . guarded_select_alt
    (413) guarded_select_alt -> . select_alt
    (414) guarded_select_alt -> . WHEN condition ARROW select_alt
    (417) select_alt -> . accept_stmt stmts_opt
    (418) select_alt -> . delay_stmt stmts_opt
    (419) select_alt -> . TERMINATE ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt

    WHEN            shift and go to state 437
    TERMINATE       shift and go to state 442
    DELAY           shift and go to state 260
    ACCEPT          shift and go to state 275

    delay_stmt                     shift and go to state 793
    accept_hdr                     shift and go to state 292
    accept_stmt                    shift and go to state 433
    guarded_select_alt             shift and go to state 796
    select_alt                     shift and go to state 439

state 693

    (283) alternative_s -> alternative_s alternative .

    END             reduce using rule 283 (alternative_s -> alternative_s alternative .)
    WHEN            reduce using rule 283 (alternative_s -> alternative_s alternative .)


state 694

    (280) case_stmt -> case_hdr pragma_s alternative_s END . CASE ;

    CASE            shift and go to state 797


state 695

    (284) alternative -> WHEN . choice_s ARROW statement_s
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    OTHERS          shift and go to state 223
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 381
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    allocator                      shift and go to state 130
    choice_s                       shift and go to state 798
    factor                         shift and go to state 137
    choice                         shift and go to state 227
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    discrete_with_range            shift and go to state 516
    term                           shift and go to state 146
    name                           shift and go to state 230
    operator_symbol                shift and go to state 149
    range                          shift and go to state 232
    expression                     shift and go to state 517

state 696

    (468) requeue_stmt -> REQUEUE name WITH ABORT . ;

    ;               shift and go to state 799


state 697

    (402) accept_stmt -> accept_hdr DO handled_stmt_s END . id_opt ;
    (295) id_opt -> .
    (296) id_opt -> . designator
    (318) designator -> . compound_name
    (319) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 295 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 463
    id_opt                         shift and go to state 800
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 698

    (304) exit_stmt -> EXIT name_opt when_opt ; .

    LESSLESS        reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    error           reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    PRAGMA          reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    NuLL            reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    EXIT            reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    RETURN          reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    GOTO            reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    DELAY           reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    ABORT           reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    RAISE           reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    REQUEUE         reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    IF              reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    CASE            reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    IDENTIFIER      reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    ACCEPT          reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    SELECT          reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    STRING          reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    WHILE           reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    DECLARE         reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    FOR             reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    LOOP            reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    BEGIN           reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    WHEN            reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    END             reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    OR              reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    ELSE            reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    THEN            reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    ELSIF           reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)
    EXCEPTION       reduce using rule 304 (exit_stmt -> EXIT name_opt when_opt ; .)


state 699

    (308) when_opt -> WHEN condition .

    ;               reduce using rule 308 (when_opt -> WHEN condition .)


state 700

    (460) exception_handler -> WHEN except_choice_s . ARROW statement_s
    (463) except_choice_s -> except_choice_s . | except_choice

    ARROW           shift and go to state 801
    |               shift and go to state 802


state 701

    (461) exception_handler -> WHEN IDENTIFIER . : except_choice_s ARROW statement_s
    (161) simple_name -> IDENTIFIER .

    :               shift and go to state 803
    (               reduce using rule 161 (simple_name -> IDENTIFIER .)
    .               reduce using rule 161 (simple_name -> IDENTIFIER .)
    TICK            reduce using rule 161 (simple_name -> IDENTIFIER .)
    ARROW           reduce using rule 161 (simple_name -> IDENTIFIER .)
    |               reduce using rule 161 (simple_name -> IDENTIFIER .)


state 702

    (462) except_choice_s -> except_choice .

    ARROW           reduce using rule 462 (except_choice_s -> except_choice .)
    |               reduce using rule 462 (except_choice_s -> except_choice .)


state 703

    (465) except_choice -> OTHERS .

    ARROW           reduce using rule 465 (except_choice -> OTHERS .)
    |               reduce using rule 465 (except_choice -> OTHERS .)


state 704

    (464) except_choice -> name .
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id

    ARROW           reduce using rule 464 (except_choice -> name .)
    |               reduce using rule 464 (except_choice -> name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 705

    (279) else_opt -> ELSE statement_s .
    (245) statement_s -> statement_s . statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    END             reduce using rule 279 (else_opt -> ELSE statement_s .)
    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 456
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 706

    (272) if_stmt -> IF cond_clause_s else_opt END . IF ;

    IF              shift and go to state 804


state 707

    (274) cond_clause_s -> cond_clause_s ELSIF cond_clause .

    ELSIF           reduce using rule 274 (cond_clause_s -> cond_clause_s ELSIF cond_clause .)
    ELSE            reduce using rule 274 (cond_clause_s -> cond_clause_s ELSIF cond_clause .)
    END             reduce using rule 274 (cond_clause_s -> cond_clause_s ELSIF cond_clause .)


state 708

    (506) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s . END RECORD ;
    (510) comp_loc_s -> comp_loc_s . mark AT expression RANGE range ;
    (158) mark -> . simple_name
    (159) mark -> . mark TICK attribute_id
    (160) mark -> . mark . simple_name
    (161) simple_name -> . IDENTIFIER

    END             shift and go to state 805
    IDENTIFIER      shift and go to state 39

    mark                           shift and go to state 806
    simple_name                    shift and go to state 165

state 709

    (508) align_opt -> AT MOD . expression ;
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 807

state 710

    (511) address_spec -> FOR mark USE AT expression ; .

    PACKAGE         reduce using rule 511 (address_spec -> FOR mark USE AT expression ; .)
    TASK            reduce using rule 511 (address_spec -> FOR mark USE AT expression ; .)
    PROTECTED       reduce using rule 511 (address_spec -> FOR mark USE AT expression ; .)
    error           reduce using rule 511 (address_spec -> FOR mark USE AT expression ; .)
    USE             reduce using rule 511 (address_spec -> FOR mark USE AT expression ; .)
    PRAGMA          reduce using rule 511 (address_spec -> FOR mark USE AT expression ; .)
    TYPE            reduce using rule 511 (address_spec -> FOR mark USE AT expression ; .)
    SUBTYPE         reduce using rule 511 (address_spec -> FOR mark USE AT expression ; .)
    FOR             reduce using rule 511 (address_spec -> FOR mark USE AT expression ; .)
    PROCEDURE       reduce using rule 511 (address_spec -> FOR mark USE AT expression ; .)
    FUNCTION        reduce using rule 511 (address_spec -> FOR mark USE AT expression ; .)
    GENERIC         reduce using rule 511 (address_spec -> FOR mark USE AT expression ; .)
    IDENTIFIER      reduce using rule 511 (address_spec -> FOR mark USE AT expression ; .)
    BEGIN           reduce using rule 511 (address_spec -> FOR mark USE AT expression ; .)
    END             reduce using rule 511 (address_spec -> FOR mark USE AT expression ; .)
    PRIVATE         reduce using rule 511 (address_spec -> FOR mark USE AT expression ; .)
    ENTRY           reduce using rule 511 (address_spec -> FOR mark USE AT expression ; .)


state 711

    (453) body_stub -> TASK BODY simple_name IS SEPARATE ; .

    PACKAGE         reduce using rule 453 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    TASK            reduce using rule 453 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    PROTECTED       reduce using rule 453 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    error           reduce using rule 453 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    USE             reduce using rule 453 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    PRAGMA          reduce using rule 453 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    TYPE            reduce using rule 453 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    SUBTYPE         reduce using rule 453 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    FOR             reduce using rule 453 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    PROCEDURE       reduce using rule 453 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    FUNCTION        reduce using rule 453 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    GENERIC         reduce using rule 453 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    IDENTIFIER      reduce using rule 453 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    BEGIN           reduce using rule 453 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    END             reduce using rule 453 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    PRIVATE         reduce using rule 453 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)


state 712

    (367) task_body -> TASK BODY simple_name IS decl_part block_body . END id_opt ;

    END             shift and go to state 808


state 713

    (399) rep_spec_s -> rep_spec_s rep_spec . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    FOR             reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 809

state 714

    (366) task_private_opt -> PRIVATE . entry_decl_s rep_spec_s
    (390) entry_decl_s -> . pragma_s
    (391) entry_decl_s -> . entry_decl_s entry_decl pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    FOR             reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)

    entry_decl_s                   shift and go to state 810
    pragma_s                       shift and go to state 473

state 715

    (364) task_def -> IS entry_decl_s rep_spec_s task_private_opt . END id_opt

    END             shift and go to state 811


state 716

    (391) entry_decl_s -> entry_decl_s entry_decl pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    ENTRY           reduce using rule 391 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
    FOR             reduce using rule 391 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
    END             reduce using rule 391 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
    PRIVATE         reduce using rule 391 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 717

    (454) body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .

    PACKAGE         reduce using rule 454 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    TASK            reduce using rule 454 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    PROTECTED       reduce using rule 454 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    error           reduce using rule 454 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    USE             reduce using rule 454 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    PRAGMA          reduce using rule 454 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    TYPE            reduce using rule 454 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    SUBTYPE         reduce using rule 454 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    FOR             reduce using rule 454 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    PROCEDURE       reduce using rule 454 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    FUNCTION        reduce using rule 454 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    GENERIC         reduce using rule 454 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    IDENTIFIER      reduce using rule 454 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    BEGIN           reduce using rule 454 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    END             reduce using rule 454 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    PRIVATE         reduce using rule 454 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)


state 718

    (112) discrim_spec_s -> discrim_spec_s ; discrim_spec .

    )               reduce using rule 112 (discrim_spec_s -> discrim_spec_s ; discrim_spec .)
    ;               reduce using rule 112 (discrim_spec_s -> discrim_spec_s ; discrim_spec .)


state 719

    (116) access_opt -> ACCESS .

    IDENTIFIER      reduce using rule 116 (access_opt -> ACCESS .)


state 720

    (113) discrim_spec -> def_id_s : access_opt . mark init_opt
    (158) mark -> . simple_name
    (159) mark -> . mark TICK attribute_id
    (160) mark -> . mark . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    mark                           shift and go to state 812
    simple_name                    shift and go to state 165

state 721

    (100) tagged_opt -> ABSTRACT TAGGED .

    LIMITED         reduce using rule 100 (tagged_opt -> ABSTRACT TAGGED .)
    PRIVATE         reduce using rule 100 (tagged_opt -> ABSTRACT TAGGED .)
    RECORD          reduce using rule 100 (tagged_opt -> ABSTRACT TAGGED .)
    NuLL            reduce using rule 100 (tagged_opt -> ABSTRACT TAGGED .)


state 722

    (59) derived_type -> ABSTRACT NEW . subtype_ind WITH PRIVATE
    (60) derived_type -> ABSTRACT NEW . subtype_ind WITH record_def
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 482
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    subtype_ind                    shift and go to state 813
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 723

    (56) derived_type -> NEW subtype_ind .
    (57) derived_type -> NEW subtype_ind . WITH PRIVATE
    (58) derived_type -> NEW subtype_ind . WITH record_def

    ;               reduce using rule 56 (derived_type -> NEW subtype_ind .)
    WITH            shift and go to state 814


state 724

    (63) enumeration_type -> ( enum_id_s . )
    (65) enum_id_s -> enum_id_s . , enum_id

    )               shift and go to state 815
    ,               shift and go to state 816


state 725

    (67) enum_id -> CHAR .

    )               reduce using rule 67 (enum_id -> CHAR .)
    ,               reduce using rule 67 (enum_id -> CHAR .)


state 726

    (66) enum_id -> IDENTIFIER .

    )               reduce using rule 66 (enum_id -> IDENTIFIER .)
    ,               reduce using rule 66 (enum_id -> IDENTIFIER .)


state 727

    (64) enum_id_s -> enum_id .

    )               reduce using rule 64 (enum_id_s -> enum_id .)
    ,               reduce using rule 64 (enum_id_s -> enum_id .)


state 728

    (75) float_type -> DIGITS expression . range_spec_opt
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (71) range_spec_opt -> .
    (72) range_spec_opt -> . range_spec
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE
    (70) range_spec -> . range_constraint
    (61) range_constraint -> . RANGE range

    ;               reduce using rule 71 (range_spec_opt -> .)
    AND             shift and go to state 247
    OR              shift and go to state 250
    RANGE           shift and go to state 371

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249
    range_constraint               shift and go to state 599
    range_spec                     shift and go to state 817
    range_spec_opt                 shift and go to state 818

state 729

    (76) fixed_type -> DELTA expression . range_spec
    (77) fixed_type -> DELTA expression . DIGITS expression range_spec_opt
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (70) range_spec -> . range_constraint
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE
    (61) range_constraint -> . RANGE range

    DIGITS          shift and go to state 819
    AND             shift and go to state 247
    OR              shift and go to state 250
    RANGE           shift and go to state 371

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249
    range_constraint               shift and go to state 599
    range_spec                     shift and go to state 820

state 730

    (129) access_type -> ACCESS CONSTANT . subtype_ind
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 482
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    subtype_ind                    shift and go to state 821
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 731

    (131) access_type -> ACCESS prot_opt . PROCEDURE formal_part_opt
    (132) access_type -> ACCESS prot_opt . FUNCTION formal_part_opt RETURN mark

    PROCEDURE       shift and go to state 823
    FUNCTION        shift and go to state 822


state 732

    (134) prot_opt -> PROTECTED .

    PROCEDURE       reduce using rule 134 (prot_opt -> PROTECTED .)
    FUNCTION        reduce using rule 134 (prot_opt -> PROTECTED .)


state 733

    (130) access_type -> ACCESS ALL . subtype_ind
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 482
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    subtype_ind                    shift and go to state 824
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 734

    (128) access_type -> ACCESS subtype_ind .

    ;               reduce using rule 128 (access_type -> ACCESS subtype_ind .)


state 735

    (347) limited_opt -> LIMITED .

    PRIVATE         reduce using rule 347 (limited_opt -> LIMITED .)
    RECORD          reduce using rule 347 (limited_opt -> LIMITED .)
    NuLL            reduce using rule 347 (limited_opt -> LIMITED .)


state 736

    (95) record_type -> tagged_opt limited_opt . record_def
    (345) private_type -> tagged_opt limited_opt . PRIVATE
    (96) record_def -> . RECORD pragma_s comp_list END RECORD
    (97) record_def -> . NuLL RECORD

    PRIVATE         shift and go to state 825
    RECORD          shift and go to state 826
    NuLL            shift and go to state 827

    record_def                     shift and go to state 828

state 737

    (69) integer_type -> MOD expression .
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ;               reduce using rule 69 (integer_type -> MOD expression .)
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 738

    (55) decimal_digits_constraint -> DIGITS expression . range_constr_opt
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (93) range_constr_opt -> .
    (94) range_constr_opt -> . range_constraint
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE
    (61) range_constraint -> . RANGE range

    ;               reduce using rule 93 (range_constr_opt -> .)
    RENAMES         reduce using rule 93 (range_constr_opt -> .)
    ASSIGNMENT      reduce using rule 93 (range_constr_opt -> .)
    WITH            reduce using rule 93 (range_constr_opt -> .)
    AND             shift and go to state 247
    OR              shift and go to state 250
    RANGE           shift and go to state 371

    range_constr_opt               shift and go to state 829
    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249
    range_constraint               shift and go to state 785

state 739

    (35) number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .

    PACKAGE         reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    TASK            reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    PROTECTED       reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    error           reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    USE             reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    PRAGMA          reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    TYPE            reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    SUBTYPE         reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    FOR             reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    PROCEDURE       reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    FUNCTION        reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    GENERIC         reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    IDENTIFIER      reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    BEGIN           reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    PRIVATE         reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    END             reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)


state 740

    (88) iter_index_constraint -> ( iter_discrete_range_s . )
    (90) iter_discrete_range_s -> iter_discrete_range_s . , discrete_range

    )               shift and go to state 830
    ,               shift and go to state 831


state 741

    (85) index_s -> index .

    )               reduce using rule 85 (index_s -> index .)
    ,               reduce using rule 85 (index_s -> index .)


state 742

    (80) unconstr_array_type -> ARRAY ( index_s . ) OF component_subtype_def
    (86) index_s -> index_s . , index

    )               shift and go to state 832
    ,               shift and go to state 833


state 743

    (89) iter_discrete_range_s -> discrete_range .

    )               reduce using rule 89 (iter_discrete_range_s -> discrete_range .)
    ,               reduce using rule 89 (iter_discrete_range_s -> discrete_range .)


state 744

    (87) index -> name . RANGE LESSMORE
    (91) discrete_range -> name . range_constr_opt
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id
    (235) primary -> name .
    (241) qualified -> name . TICK parenthesized_primary
    (93) range_constr_opt -> .
    (94) range_constr_opt -> . range_constraint
    (61) range_constraint -> . RANGE range

    RANGE           shift and go to state 834
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 370
    STARSTAR        reduce using rule 235 (primary -> name .)
    *               reduce using rule 235 (primary -> name .)
    /               reduce using rule 235 (primary -> name .)
    MOD             reduce using rule 235 (primary -> name .)
    REM             reduce using rule 235 (primary -> name .)
    DOTDOT          reduce using rule 235 (primary -> name .)
    +               reduce using rule 235 (primary -> name .)
    -               reduce using rule 235 (primary -> name .)
    &               reduce using rule 235 (primary -> name .)
    )               reduce using rule 93 (range_constr_opt -> .)
    ,               reduce using rule 93 (range_constr_opt -> .)

    range_constr_opt               shift and go to state 784
    range_constraint               shift and go to state 785

state 745

    (81) constr_array_type -> ARRAY iter_index_constraint OF . component_subtype_def
    (82) component_subtype_def -> . aliased_opt subtype_ind
    (83) aliased_opt -> .
    (84) aliased_opt -> . ALIASED

    IDENTIFIER      reduce using rule 83 (aliased_opt -> .)
    STRING          reduce using rule 83 (aliased_opt -> .)
    ALIASED         shift and go to state 835

    aliased_opt                    shift and go to state 836
    component_subtype_def          shift and go to state 837

state 746

    (34) init_opt -> ASSIGNMENT expression .
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ;               reduce using rule 34 (init_opt -> ASSIGNMENT expression .)
    )               reduce using rule 34 (init_opt -> ASSIGNMENT expression .)
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 747

    (23) object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .

    error           reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    USE             reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    PRAGMA          reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    TYPE            reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    SUBTYPE         reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    TASK            reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    PACKAGE         reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    PROTECTED       reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    FOR             reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    PROCEDURE       reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    FUNCTION        reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    GENERIC         reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    IDENTIFIER      reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    PRIVATE         reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    END             reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    BEGIN           reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)


state 748

    (352) rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .

    PACKAGE         reduce using rule 352 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    TASK            reduce using rule 352 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    PROTECTED       reduce using rule 352 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    error           reduce using rule 352 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    USE             reduce using rule 352 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    PRAGMA          reduce using rule 352 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    TYPE            reduce using rule 352 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    SUBTYPE         reduce using rule 352 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    FOR             reduce using rule 352 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    PROCEDURE       reduce using rule 352 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    FUNCTION        reduce using rule 352 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    GENERIC         reduce using rule 352 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    IDENTIFIER      reduce using rule 352 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    BEGIN           reduce using rule 352 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    END             reduce using rule 352 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    PRIVATE         reduce using rule 352 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)


state 749

    (342) pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END . c_id_opt ;
    (340) c_id_opt -> .
    (341) c_id_opt -> . compound_name
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 340 (c_id_opt -> .)
    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 751
    c_id_opt                       shift and go to state 838
    simple_name                    shift and go to state 41

state 750

    (456) body_stub -> PROTECTED BODY simple_name IS . SEPARATE ;

    SEPARATE        shift and go to state 530


state 751

    (341) c_id_opt -> compound_name .
    (163) compound_name -> compound_name . . simple_name

    ;               reduce using rule 341 (c_id_opt -> compound_name .)
    .               shift and go to state 119


state 752

    (337) pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END c_id_opt .

    ;               reduce using rule 337 (pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END c_id_opt .)


state 753

    (453) body_stub -> TASK BODY simple_name IS . SEPARATE ;

    SEPARATE        shift and go to state 588


state 754

    (454) body_stub -> PACKAGE BODY compound_name IS . SEPARATE ;

    SEPARATE        shift and go to state 593


state 755

    (476) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name . subp_default ;
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id
    (483) subp_default -> .
    (484) subp_default -> . IS name
    (485) subp_default -> . IS LESSMORE

    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253
    ;               reduce using rule 483 (subp_default -> .)
    IS              shift and go to state 643

    subp_default                   shift and go to state 839

state 756

    (477) generic_formal -> WITH PACKAGE simple_name IS NEW name . ( LESSMORE ) ;
    (478) generic_formal -> WITH PACKAGE simple_name IS NEW name . ;
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id

    (               shift and go to state 840
    ;               shift and go to state 841
    .               shift and go to state 244
    TICK            shift and go to state 253


state 757

    (484) subp_default -> IS name .
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id

    ;               reduce using rule 484 (subp_default -> IS name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 758

    (485) subp_default -> IS LESSMORE .

    ;               reduce using rule 485 (subp_default -> IS LESSMORE .)


state 759

    (475) generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .

    PACKAGE         reduce using rule 475 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    PROCEDURE       reduce using rule 475 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    FUNCTION        reduce using rule 475 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    TYPE            reduce using rule 475 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    WITH            reduce using rule 475 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    error           reduce using rule 475 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    USE             reduce using rule 475 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    IDENTIFIER      reduce using rule 475 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)


state 760

    (498) generic_derived_type -> ABSTRACT NEW . subtype_ind WITH PRIVATE
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 482
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    subtype_ind                    shift and go to state 842
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 761

    (474) generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .

    PACKAGE         reduce using rule 474 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    PROCEDURE       reduce using rule 474 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    FUNCTION        reduce using rule 474 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    TYPE            reduce using rule 474 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    WITH            reduce using rule 474 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    error           reduce using rule 474 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    USE             reduce using rule 474 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    IDENTIFIER      reduce using rule 474 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)


state 762

    (496) generic_derived_type -> NEW subtype_ind .
    (497) generic_derived_type -> NEW subtype_ind . WITH PRIVATE

    ;               reduce using rule 496 (generic_derived_type -> NEW subtype_ind .)
    WITH            shift and go to state 843


state 763

    (491) generic_type_def -> DIGITS LESSMORE .

    ;               reduce using rule 491 (generic_type_def -> DIGITS LESSMORE .)


state 764

    (486) generic_type_def -> ( LESSMORE . )

    )               shift and go to state 844


state 765

    (487) generic_type_def -> RANGE LESSMORE .

    ;               reduce using rule 487 (generic_type_def -> RANGE LESSMORE .)


state 766

    (345) private_type -> tagged_opt limited_opt . PRIVATE

    PRIVATE         shift and go to state 825


state 767

    (489) generic_type_def -> DELTA LESSMORE .
    (490) generic_type_def -> DELTA LESSMORE . DIGITS LESSMORE

    ;               reduce using rule 489 (generic_type_def -> DELTA LESSMORE .)
    DIGITS          shift and go to state 845


state 768

    (488) generic_type_def -> MOD LESSMORE .

    ;               reduce using rule 488 (generic_type_def -> MOD LESSMORE .)


state 769

    (193) aggregate -> ( expression WITH NuLL RECORD ) .

    STARSTAR        reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    *               reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    /               reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    MOD             reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    REM             reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    =               reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    NOTEQUAL        reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    <               reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    LESSEQ          reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    >               reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    GREATEREQ       reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    IN              reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    NOT             reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    +               reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    -               reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    &               reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    AND             reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    OR              reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    )               reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    ,               reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    DOTDOT          reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    WITH            reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    ARROW           reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    |               reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    ;               reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    IS              reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    THEN            reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    LOOP            reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    RANGE           reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    DIGITS          reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    RENAMES         reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)
    ASSIGNMENT      reduce using rule 193 (aggregate -> ( expression WITH NuLL RECORD ) .)


state 770

    (384) prot_body -> PROTECTED BODY simple_name IS . prot_op_body_s END id_opt ;
    (385) prot_op_body_s -> . pragma_s
    (386) prot_op_body_s -> . prot_op_body_s prot_op_body pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)

    prot_op_body_s                 shift and go to state 531
    pragma_s                       shift and go to state 532

state 771

    (367) task_body -> TASK BODY simple_name IS . decl_part block_body END id_opt ;
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (333) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (342) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (367) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (384) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (348) use_clause -> . USE name_s ;
    (349) use_clause -> . USE TYPE name_s ;
    (502) rep_spec -> . attrib_def
    (503) rep_spec -> . record_type_spec
    (504) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (332) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (312) subprog_decl -> . subprog_spec ;
    (313) subprog_decl -> . generic_subp_inst ;
    (314) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (335) pkg_decl -> . pkg_spec ;
    (336) pkg_decl -> . generic_pkg_inst ;
    (360) task_decl -> . task_spec ;
    (368) prot_decl -> . prot_spec ;
    (457) exception_decl -> . def_id_s : EXCEPTION ;
    (352) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (353) rename_decl -> . def_id_s : EXCEPTION renames ;
    (354) rename_decl -> . rename_unit
    (469) generic_decl -> . generic_formal_part subprog_spec ;
    (470) generic_decl -> . generic_formal_part pkg_spec ;
    (453) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (454) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (455) body_stub -> . subprog_spec IS SEPARATE ;
    (456) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (505) attrib_def -> . FOR mark USE expression ;
    (506) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (511) address_spec -> . FOR mark USE AT expression ;
    (315) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (316) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (317) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (499) generic_subp_inst -> . subprog_spec IS generic_inst
    (337) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (361) task_spec -> . TASK simple_name task_def
    (362) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (369) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (370) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (355) rename_unit -> . PACKAGE compound_name renames ;
    (356) rename_unit -> . subprog_spec renames ;
    (357) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (358) rename_unit -> . generic_formal_part subprog_spec renames ;
    (471) generic_formal_part -> . GENERIC
    (472) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    decl_item                      shift and go to state 53
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 589
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 772

    (389) prot_op_body -> subprog_spec ; .

    PRAGMA          reduce using rule 389 (prot_op_body -> subprog_spec ; .)
    END             reduce using rule 389 (prot_op_body -> subprog_spec ; .)
    ENTRY           reduce using rule 389 (prot_op_body -> subprog_spec ; .)
    PROCEDURE       reduce using rule 389 (prot_op_body -> subprog_spec ; .)
    FUNCTION        reduce using rule 389 (prot_op_body -> subprog_spec ; .)


state 773

    (384) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt . ;

    ;               shift and go to state 846


state 774

    (386) prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 386 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
    ENTRY           reduce using rule 386 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
    PROCEDURE       reduce using rule 386 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
    FUNCTION        reduce using rule 386 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 775

    (394) entry_body -> ENTRY IDENTIFIER . formal_part_opt WHEN condition entry_body_part
    (395) entry_body -> ENTRY IDENTIFIER . ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part
    (320) formal_part_opt -> .
    (321) formal_part_opt -> . formal_part
    (322) formal_part -> . ( param_s )

    (               shift and go to state 847
    WHEN            reduce using rule 320 (formal_part_opt -> .)

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 848

state 776

    (108) comp_decl -> def_id_s . : component_subtype_def init_opt ;
    (25) def_id_s -> def_id_s . , def_id

    :               shift and go to state 849
    ,               shift and go to state 179


state 777

    (383) prot_elem_decl -> comp_decl .

    error           reduce using rule 383 (prot_elem_decl -> comp_decl .)
    ENTRY           reduce using rule 383 (prot_elem_decl -> comp_decl .)
    PROCEDURE       reduce using rule 383 (prot_elem_decl -> comp_decl .)
    FUNCTION        reduce using rule 383 (prot_elem_decl -> comp_decl .)
    PRAGMA          reduce using rule 383 (prot_elem_decl -> comp_decl .)
    FOR             reduce using rule 383 (prot_elem_decl -> comp_decl .)
    IDENTIFIER      reduce using rule 383 (prot_elem_decl -> comp_decl .)
    END             reduce using rule 383 (prot_elem_decl -> comp_decl .)


state 778

    (382) prot_elem_decl -> prot_op_decl .

    error           reduce using rule 382 (prot_elem_decl -> prot_op_decl .)
    ENTRY           reduce using rule 382 (prot_elem_decl -> prot_op_decl .)
    PROCEDURE       reduce using rule 382 (prot_elem_decl -> prot_op_decl .)
    FUNCTION        reduce using rule 382 (prot_elem_decl -> prot_op_decl .)
    PRAGMA          reduce using rule 382 (prot_elem_decl -> prot_op_decl .)
    FOR             reduce using rule 382 (prot_elem_decl -> prot_op_decl .)
    IDENTIFIER      reduce using rule 382 (prot_elem_decl -> prot_op_decl .)
    END             reduce using rule 382 (prot_elem_decl -> prot_op_decl .)


state 779

    (381) prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .

    error           reduce using rule 381 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    ENTRY           reduce using rule 381 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    PROCEDURE       reduce using rule 381 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    FUNCTION        reduce using rule 381 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    PRAGMA          reduce using rule 381 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    FOR             reduce using rule 381 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    IDENTIFIER      reduce using rule 381 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    END             reduce using rule 381 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)


state 780

    (109) comp_decl -> error . ;

    ;               shift and go to state 850


state 781

    (371) prot_def -> IS prot_op_decl_s prot_private_opt END id_opt .

    ;               reduce using rule 371 (prot_def -> IS prot_op_decl_s prot_private_opt END id_opt .)


state 782

    (393) entry_decl -> ENTRY IDENTIFIER ( . discrete_range ) formal_part_opt ;
    (322) formal_part -> ( . param_s )
    (91) discrete_range -> . name range_constr_opt
    (92) discrete_range -> . range
    (323) param_s -> . param
    (324) param_s -> . param_s ; param
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (325) param -> . def_id_s : mode mark init_opt
    (326) param -> . error
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (26) def_id -> . IDENTIFIER
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 109
    IDENTIFIER      shift and go to state 852
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    param                          shift and go to state 340
    simple_expression              shift and go to state 358
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    param_s                        shift and go to state 341
    literal                        shift and go to state 135
    def_id_s                       shift and go to state 105
    factor                         shift and go to state 137
    def_id                         shift and go to state 89
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    discrete_range                 shift and go to state 851
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 678
    operator_symbol                shift and go to state 149
    range                          shift and go to state 679

state 783

    (392) entry_decl -> ENTRY IDENTIFIER formal_part_opt . ;

    ;               shift and go to state 853


state 784

    (91) discrete_range -> name range_constr_opt .

    )               reduce using rule 91 (discrete_range -> name range_constr_opt .)
    ,               reduce using rule 91 (discrete_range -> name range_constr_opt .)
    LOOP            reduce using rule 91 (discrete_range -> name range_constr_opt .)


state 785

    (94) range_constr_opt -> range_constraint .

    )               reduce using rule 94 (range_constr_opt -> range_constraint .)
    ,               reduce using rule 94 (range_constr_opt -> range_constraint .)
    ;               reduce using rule 94 (range_constr_opt -> range_constraint .)
    RENAMES         reduce using rule 94 (range_constr_opt -> range_constraint .)
    ASSIGNMENT      reduce using rule 94 (range_constr_opt -> range_constraint .)
    WITH            reduce using rule 94 (range_constr_opt -> range_constraint .)
    LOOP            reduce using rule 94 (range_constr_opt -> range_constraint .)


state 786

    (297) block -> label_opt block_decl block_body END id_opt . ;

    ;               shift and go to state 854


state 787

    (285) loop_stmt -> label_opt iteration basic_loop id_opt ; .

    LESSLESS        reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    error           reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    PRAGMA          reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    NuLL            reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    EXIT            reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    RETURN          reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    GOTO            reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    DELAY           reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    ABORT           reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    RAISE           reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    REQUEUE         reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    IF              reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    CASE            reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    IDENTIFIER      reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    ACCEPT          reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    SELECT          reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    STRING          reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    WHILE           reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    DECLARE         reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    FOR             reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    LOOP            reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    BEGIN           reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    THEN            reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    OR              reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    ELSE            reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    END             reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    WHEN            reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    EXCEPTION       reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)
    ELSIF           reduce using rule 285 (loop_stmt -> label_opt iteration basic_loop id_opt ; .)


state 788

    (294) basic_loop -> LOOP statement_s END . LOOP

    LOOP            shift and go to state 855


state 789

    (405) entry_name -> entry_name ( expression ) .

    (               reduce using rule 405 (entry_name -> entry_name ( expression ) .)
    ;               reduce using rule 405 (entry_name -> entry_name ( expression ) .)
    DO              reduce using rule 405 (entry_name -> entry_name ( expression ) .)


state 790

    (424) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s . END SELECT ;
    (245) statement_s -> statement_s . statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    END             shift and go to state 856
    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 456
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 791

    (423) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt . stmts_opt END SELECT ;
    (425) stmts_opt -> .
    (426) stmts_opt -> . statement_s
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    END             reduce using rule 425 (stmts_opt -> .)
    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 560
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    stmts_opt                      shift and go to state 857
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 792

    (422) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s . END SELECT ;
    (245) statement_s -> statement_s . statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    END             shift and go to state 858
    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    assign_stmt                    shift and go to state 308
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 456
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    procedure_call                 shift and go to state 276
    block                          shift and go to state 283

state 793

    (418) select_alt -> delay_stmt . stmts_opt
    (425) stmts_opt -> .
    (426) stmts_opt -> . statement_s
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    OR              reduce using rule 425 (stmts_opt -> .)
    ELSE            reduce using rule 425 (stmts_opt -> .)
    END             reduce using rule 425 (stmts_opt -> .)
    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 560
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    stmts_opt                      shift and go to state 859
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 794

    (414) guarded_select_alt -> WHEN condition ARROW select_alt .

    OR              reduce using rule 414 (guarded_select_alt -> WHEN condition ARROW select_alt .)
    ELSE            reduce using rule 414 (guarded_select_alt -> WHEN condition ARROW select_alt .)
    END             reduce using rule 414 (guarded_select_alt -> WHEN condition ARROW select_alt .)


state 795

    (412) select_wait -> SELECT guarded_select_alt or_select else_opt END . SELECT ;

    SELECT          shift and go to state 860


state 796

    (416) or_select -> or_select OR guarded_select_alt .

    OR              reduce using rule 416 (or_select -> or_select OR guarded_select_alt .)
    ELSE            reduce using rule 416 (or_select -> or_select OR guarded_select_alt .)
    END             reduce using rule 416 (or_select -> or_select OR guarded_select_alt .)


state 797

    (280) case_stmt -> case_hdr pragma_s alternative_s END CASE . ;

    ;               shift and go to state 861


state 798

    (284) alternative -> WHEN choice_s . ARROW statement_s
    (122) choice_s -> choice_s . | choice

    ARROW           shift and go to state 862
    |               shift and go to state 365


state 799

    (468) requeue_stmt -> REQUEUE name WITH ABORT ; .

    LESSLESS        reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    error           reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    PRAGMA          reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    NuLL            reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    EXIT            reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    RETURN          reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    GOTO            reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    DELAY           reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    ABORT           reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    RAISE           reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    REQUEUE         reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    IF              reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    CASE            reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    IDENTIFIER      reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    ACCEPT          reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    SELECT          reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    STRING          reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    WHILE           reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    DECLARE         reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    FOR             reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    LOOP            reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    BEGIN           reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    WHEN            reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    END             reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    OR              reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    ELSE            reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    THEN            reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    EXCEPTION       reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    ELSIF           reduce using rule 468 (requeue_stmt -> REQUEUE name WITH ABORT ; .)


state 800

    (402) accept_stmt -> accept_hdr DO handled_stmt_s END id_opt . ;

    ;               shift and go to state 863


state 801

    (460) exception_handler -> WHEN except_choice_s ARROW . statement_s
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 864
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 802

    (463) except_choice_s -> except_choice_s | . except_choice
    (464) except_choice -> . name
    (465) except_choice -> . OTHERS
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    OTHERS          shift and go to state 703
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 704
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    except_choice                  shift and go to state 865
    simple_name                    shift and go to state 157

state 803

    (461) exception_handler -> WHEN IDENTIFIER : . except_choice_s ARROW statement_s
    (462) except_choice_s -> . except_choice
    (463) except_choice_s -> . except_choice_s | except_choice
    (464) except_choice -> . name
    (465) except_choice -> . OTHERS
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    OTHERS          shift and go to state 703
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 704
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    except_choice_s                shift and go to state 866
    except_choice                  shift and go to state 702
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 804

    (272) if_stmt -> IF cond_clause_s else_opt END IF . ;

    ;               shift and go to state 867


state 805

    (506) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END . RECORD ;

    RECORD          shift and go to state 868


state 806

    (510) comp_loc_s -> comp_loc_s mark . AT expression RANGE range ;
    (159) mark -> mark . TICK attribute_id
    (160) mark -> mark . . simple_name

    AT              shift and go to state 869
    TICK            shift and go to state 312
    .               shift and go to state 311


state 807

    (508) align_opt -> AT MOD expression . ;
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ;               shift and go to state 870
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 808

    (367) task_body -> TASK BODY simple_name IS decl_part block_body END . id_opt ;
    (295) id_opt -> .
    (296) id_opt -> . designator
    (318) designator -> . compound_name
    (319) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 295 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 463
    id_opt                         shift and go to state 871
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 809

    (399) rep_spec_s -> rep_spec_s rep_spec pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    FOR             reduce using rule 399 (rep_spec_s -> rep_spec_s rep_spec pragma_s .)
    END             reduce using rule 399 (rep_spec_s -> rep_spec_s rep_spec pragma_s .)
    PRIVATE         reduce using rule 399 (rep_spec_s -> rep_spec_s rep_spec pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 810

    (366) task_private_opt -> PRIVATE entry_decl_s . rep_spec_s
    (391) entry_decl_s -> entry_decl_s . entry_decl pragma_s
    (398) rep_spec_s -> .
    (399) rep_spec_s -> . rep_spec_s rep_spec pragma_s
    (392) entry_decl -> . ENTRY IDENTIFIER formal_part_opt ;
    (393) entry_decl -> . ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ;

    FOR             reduce using rule 398 (rep_spec_s -> .)
    END             reduce using rule 398 (rep_spec_s -> .)
    ENTRY           shift and go to state 539

    rep_spec_s                     shift and go to state 872
    entry_decl                     shift and go to state 592

state 811

    (364) task_def -> IS entry_decl_s rep_spec_s task_private_opt END . id_opt
    (295) id_opt -> .
    (296) id_opt -> . designator
    (318) designator -> . compound_name
    (319) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 295 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 463
    id_opt                         shift and go to state 873
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 812

    (113) discrim_spec -> def_id_s : access_opt mark . init_opt
    (159) mark -> mark . TICK attribute_id
    (160) mark -> mark . . simple_name
    (33) init_opt -> .
    (34) init_opt -> . ASSIGNMENT expression

    TICK            shift and go to state 312
    .               shift and go to state 311
    )               reduce using rule 33 (init_opt -> .)
    ;               reduce using rule 33 (init_opt -> .)
    ASSIGNMENT      shift and go to state 630

    init_opt                       shift and go to state 874

state 813

    (59) derived_type -> ABSTRACT NEW subtype_ind . WITH PRIVATE
    (60) derived_type -> ABSTRACT NEW subtype_ind . WITH record_def

    WITH            shift and go to state 875


state 814

    (57) derived_type -> NEW subtype_ind WITH . PRIVATE
    (58) derived_type -> NEW subtype_ind WITH . record_def
    (96) record_def -> . RECORD pragma_s comp_list END RECORD
    (97) record_def -> . NuLL RECORD

    PRIVATE         shift and go to state 876
    RECORD          shift and go to state 826
    NuLL            shift and go to state 827

    record_def                     shift and go to state 877

state 815

    (63) enumeration_type -> ( enum_id_s ) .

    ;               reduce using rule 63 (enumeration_type -> ( enum_id_s ) .)


state 816

    (65) enum_id_s -> enum_id_s , . enum_id
    (66) enum_id -> . IDENTIFIER
    (67) enum_id -> . CHAR

    IDENTIFIER      shift and go to state 726
    CHAR            shift and go to state 725

    enum_id                        shift and go to state 878

state 817

    (72) range_spec_opt -> range_spec .

    ;               reduce using rule 72 (range_spec_opt -> range_spec .)


state 818

    (75) float_type -> DIGITS expression range_spec_opt .

    ;               reduce using rule 75 (float_type -> DIGITS expression range_spec_opt .)


state 819

    (77) fixed_type -> DELTA expression DIGITS . expression range_spec_opt
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 879

state 820

    (76) fixed_type -> DELTA expression range_spec .

    ;               reduce using rule 76 (fixed_type -> DELTA expression range_spec .)


state 821

    (129) access_type -> ACCESS CONSTANT subtype_ind .

    ;               reduce using rule 129 (access_type -> ACCESS CONSTANT subtype_ind .)


state 822

    (132) access_type -> ACCESS prot_opt FUNCTION . formal_part_opt RETURN mark
    (320) formal_part_opt -> .
    (321) formal_part_opt -> . formal_part
    (322) formal_part -> . ( param_s )

    RETURN          reduce using rule 320 (formal_part_opt -> .)
    (               shift and go to state 189

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 880

state 823

    (131) access_type -> ACCESS prot_opt PROCEDURE . formal_part_opt
    (320) formal_part_opt -> .
    (321) formal_part_opt -> . formal_part
    (322) formal_part -> . ( param_s )

    ;               reduce using rule 320 (formal_part_opt -> .)
    (               shift and go to state 189

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 881

state 824

    (130) access_type -> ACCESS ALL subtype_ind .

    ;               reduce using rule 130 (access_type -> ACCESS ALL subtype_ind .)


state 825

    (345) private_type -> tagged_opt limited_opt PRIVATE .

    ;               reduce using rule 345 (private_type -> tagged_opt limited_opt PRIVATE .)


state 826

    (96) record_def -> RECORD . pragma_s comp_list END RECORD
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    NuLL            reduce using rule 8 (pragma_s -> .)
    PRAGMA          reduce using rule 8 (pragma_s -> .)
    CASE            reduce using rule 8 (pragma_s -> .)
    error           reduce using rule 8 (pragma_s -> .)
    IDENTIFIER      reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 882

state 827

    (97) record_def -> NuLL . RECORD

    RECORD          shift and go to state 883


state 828

    (95) record_type -> tagged_opt limited_opt record_def .

    ;               reduce using rule 95 (record_type -> tagged_opt limited_opt record_def .)


state 829

    (55) decimal_digits_constraint -> DIGITS expression range_constr_opt .

    ;               reduce using rule 55 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)
    RENAMES         reduce using rule 55 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)
    ASSIGNMENT      reduce using rule 55 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)
    WITH            reduce using rule 55 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)


state 830

    (88) iter_index_constraint -> ( iter_discrete_range_s ) .

    OF              reduce using rule 88 (iter_index_constraint -> ( iter_discrete_range_s ) .)


state 831

    (90) iter_discrete_range_s -> iter_discrete_range_s , . discrete_range
    (91) discrete_range -> . name range_constr_opt
    (92) discrete_range -> . range
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    simple_expression              shift and go to state 358
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    discrete_range                 shift and go to state 884
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 678
    operator_symbol                shift and go to state 149
    range                          shift and go to state 679

state 832

    (80) unconstr_array_type -> ARRAY ( index_s ) . OF component_subtype_def

    OF              shift and go to state 885


state 833

    (86) index_s -> index_s , . index
    (87) index -> . name RANGE LESSMORE
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    index                          shift and go to state 886
    name                           shift and go to state 887
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 834

    (87) index -> name RANGE . LESSMORE
    (61) range_constraint -> RANGE . range
    (62) range -> . simple_expression DOTDOT simple_expression
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    LESSMORE        shift and go to state 888
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    simple_expression              shift and go to state 358
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    range                          shift and go to state 520

state 835

    (84) aliased_opt -> ALIASED .

    IDENTIFIER      reduce using rule 84 (aliased_opt -> ALIASED .)
    STRING          reduce using rule 84 (aliased_opt -> ALIASED .)


state 836

    (82) component_subtype_def -> aliased_opt . subtype_ind
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    name                           shift and go to state 482
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 149
    subtype_ind                    shift and go to state 889
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 837

    (81) constr_array_type -> ARRAY iter_index_constraint OF component_subtype_def .

    ;               reduce using rule 81 (constr_array_type -> ARRAY iter_index_constraint OF component_subtype_def .)
    ASSIGNMENT      reduce using rule 81 (constr_array_type -> ARRAY iter_index_constraint OF component_subtype_def .)


state 838

    (342) pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt . ;

    ;               shift and go to state 890


state 839

    (476) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default . ;

    ;               shift and go to state 891


state 840

    (477) generic_formal -> WITH PACKAGE simple_name IS NEW name ( . LESSMORE ) ;
    (168) indexed_comp -> name ( . value_s )
    (169) value_s -> . value
    (170) value_s -> . value_s , value
    (171) value -> . expression
    (172) value -> . comp_assoc
    (173) value -> . discrete_with_range
    (174) value -> . error
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (197) comp_assoc -> . choice_s ARROW expression
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    LESSMORE        shift and go to state 892
    error           shift and go to state 233
    OTHERS          shift and go to state 223
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    value_s                        shift and go to state 380
    simple_expression              shift and go to state 381
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    choice_s                       shift and go to state 225
    comp_assoc                     shift and go to state 382
    factor                         shift and go to state 137
    choice                         shift and go to state 227
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 146
    name                           shift and go to state 230
    operator_symbol                shift and go to state 149
    value                          shift and go to state 383
    range                          shift and go to state 232
    expression                     shift and go to state 384

state 841

    (478) generic_formal -> WITH PACKAGE simple_name IS NEW name ; .

    PACKAGE         reduce using rule 478 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    PROCEDURE       reduce using rule 478 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    FUNCTION        reduce using rule 478 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    TYPE            reduce using rule 478 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    WITH            reduce using rule 478 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    error           reduce using rule 478 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    USE             reduce using rule 478 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    IDENTIFIER      reduce using rule 478 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)


state 842

    (498) generic_derived_type -> ABSTRACT NEW subtype_ind . WITH PRIVATE

    WITH            shift and go to state 893


state 843

    (497) generic_derived_type -> NEW subtype_ind WITH . PRIVATE

    PRIVATE         shift and go to state 894


state 844

    (486) generic_type_def -> ( LESSMORE ) .

    ;               reduce using rule 486 (generic_type_def -> ( LESSMORE ) .)


state 845

    (490) generic_type_def -> DELTA LESSMORE DIGITS . LESSMORE

    LESSMORE        shift and go to state 895


state 846

    (384) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .

    PRAGMA          reduce using rule 384 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    PRIVATE         reduce using rule 384 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    WITH            reduce using rule 384 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    PACKAGE         reduce using rule 384 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    SEPARATE        reduce using rule 384 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    PROCEDURE       reduce using rule 384 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    FUNCTION        reduce using rule 384 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    GENERIC         reduce using rule 384 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    $end            reduce using rule 384 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    TASK            reduce using rule 384 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    PROTECTED       reduce using rule 384 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    error           reduce using rule 384 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    USE             reduce using rule 384 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    TYPE            reduce using rule 384 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    SUBTYPE         reduce using rule 384 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    FOR             reduce using rule 384 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    IDENTIFIER      reduce using rule 384 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    BEGIN           reduce using rule 384 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    END             reduce using rule 384 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)


state 847

    (395) entry_body -> ENTRY IDENTIFIER ( . iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part
    (322) formal_part -> ( . param_s )
    (291) iter_part -> . FOR IDENTIFIER IN
    (323) param_s -> . param
    (324) param_s -> . param_s ; param
    (325) param -> . def_id_s : mode mark init_opt
    (326) param -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    FOR             shift and go to state 417
    error           shift and go to state 109
    IDENTIFIER      shift and go to state 76

    def_id                         shift and go to state 89
    param_s                        shift and go to state 341
    iter_part                      shift and go to state 896
    param                          shift and go to state 340
    def_id_s                       shift and go to state 105

state 848

    (394) entry_body -> ENTRY IDENTIFIER formal_part_opt . WHEN condition entry_body_part

    WHEN            shift and go to state 897


state 849

    (108) comp_decl -> def_id_s : . component_subtype_def init_opt ;
    (82) component_subtype_def -> . aliased_opt subtype_ind
    (83) aliased_opt -> .
    (84) aliased_opt -> . ALIASED

    IDENTIFIER      reduce using rule 83 (aliased_opt -> .)
    STRING          reduce using rule 83 (aliased_opt -> .)
    ALIASED         shift and go to state 835

    aliased_opt                    shift and go to state 836
    component_subtype_def          shift and go to state 898

state 850

    (109) comp_decl -> error ; .

    error           reduce using rule 109 (comp_decl -> error ; .)
    CASE            reduce using rule 109 (comp_decl -> error ; .)
    PRAGMA          reduce using rule 109 (comp_decl -> error ; .)
    IDENTIFIER      reduce using rule 109 (comp_decl -> error ; .)
    END             reduce using rule 109 (comp_decl -> error ; .)
    WHEN            reduce using rule 109 (comp_decl -> error ; .)
    ENTRY           reduce using rule 109 (comp_decl -> error ; .)
    PROCEDURE       reduce using rule 109 (comp_decl -> error ; .)
    FUNCTION        reduce using rule 109 (comp_decl -> error ; .)
    FOR             reduce using rule 109 (comp_decl -> error ; .)


state 851

    (393) entry_decl -> ENTRY IDENTIFIER ( discrete_range . ) formal_part_opt ;

    )               shift and go to state 899


state 852

    (161) simple_name -> IDENTIFIER .
    (26) def_id -> IDENTIFIER .

    (               reduce using rule 161 (simple_name -> IDENTIFIER .)
    .               reduce using rule 161 (simple_name -> IDENTIFIER .)
    TICK            reduce using rule 161 (simple_name -> IDENTIFIER .)
    RANGE           reduce using rule 161 (simple_name -> IDENTIFIER .)
    )               reduce using rule 161 (simple_name -> IDENTIFIER .)
    STARSTAR        reduce using rule 161 (simple_name -> IDENTIFIER .)
    *               reduce using rule 161 (simple_name -> IDENTIFIER .)
    /               reduce using rule 161 (simple_name -> IDENTIFIER .)
    MOD             reduce using rule 161 (simple_name -> IDENTIFIER .)
    REM             reduce using rule 161 (simple_name -> IDENTIFIER .)
    DOTDOT          reduce using rule 161 (simple_name -> IDENTIFIER .)
    +               reduce using rule 161 (simple_name -> IDENTIFIER .)
    -               reduce using rule 161 (simple_name -> IDENTIFIER .)
    &               reduce using rule 161 (simple_name -> IDENTIFIER .)
    :               reduce using rule 26 (def_id -> IDENTIFIER .)
    ,               reduce using rule 26 (def_id -> IDENTIFIER .)


state 853

    (392) entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .

    error           reduce using rule 392 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    ENTRY           reduce using rule 392 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    PROCEDURE       reduce using rule 392 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    FUNCTION        reduce using rule 392 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    PRAGMA          reduce using rule 392 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    FOR             reduce using rule 392 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    IDENTIFIER      reduce using rule 392 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    END             reduce using rule 392 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    PRIVATE         reduce using rule 392 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)


state 854

    (297) block -> label_opt block_decl block_body END id_opt ; .

    LESSLESS        reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    error           reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    PRAGMA          reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    NuLL            reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    EXIT            reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    RETURN          reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    GOTO            reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    DELAY           reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    ABORT           reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    RAISE           reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    REQUEUE         reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    IF              reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    CASE            reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    IDENTIFIER      reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    ACCEPT          reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    SELECT          reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    STRING          reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    WHILE           reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    DECLARE         reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    FOR             reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    LOOP            reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    BEGIN           reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    END             reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    WHEN            reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    EXCEPTION       reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    THEN            reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    OR              reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    ELSE            reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)
    ELSIF           reduce using rule 297 (block -> label_opt block_decl block_body END id_opt ; .)


state 855

    (294) basic_loop -> LOOP statement_s END LOOP .

    STRING          reduce using rule 294 (basic_loop -> LOOP statement_s END LOOP .)
    IDENTIFIER      reduce using rule 294 (basic_loop -> LOOP statement_s END LOOP .)
    ;               reduce using rule 294 (basic_loop -> LOOP statement_s END LOOP .)


state 856

    (424) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END . SELECT ;

    SELECT          shift and go to state 900


state 857

    (423) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt . END SELECT ;

    END             shift and go to state 901


state 858

    (422) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END . SELECT ;

    SELECT          shift and go to state 902


state 859

    (418) select_alt -> delay_stmt stmts_opt .

    OR              reduce using rule 418 (select_alt -> delay_stmt stmts_opt .)
    ELSE            reduce using rule 418 (select_alt -> delay_stmt stmts_opt .)
    END             reduce using rule 418 (select_alt -> delay_stmt stmts_opt .)


state 860

    (412) select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT . ;

    ;               shift and go to state 903


state 861

    (280) case_stmt -> case_hdr pragma_s alternative_s END CASE ; .

    LESSLESS        reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    error           reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    PRAGMA          reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    NuLL            reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    EXIT            reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    RETURN          reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    GOTO            reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    DELAY           reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    ABORT           reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    RAISE           reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    REQUEUE         reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    IF              reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    CASE            reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    IDENTIFIER      reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    ACCEPT          reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    SELECT          reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    STRING          reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    WHILE           reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    DECLARE         reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    FOR             reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    LOOP            reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    BEGIN           reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    END             reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    EXCEPTION       reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    OR              reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    ELSE            reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    THEN            reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    ELSIF           reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    WHEN            reduce using rule 280 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)


state 862

    (284) alternative -> WHEN choice_s ARROW . statement_s
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 904
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 863

    (402) accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .

    LESSLESS        reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    error           reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    PRAGMA          reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    NuLL            reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    EXIT            reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    RETURN          reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    GOTO            reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    DELAY           reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    ABORT           reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    RAISE           reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    REQUEUE         reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    IF              reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    CASE            reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    IDENTIFIER      reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    ACCEPT          reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    SELECT          reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    STRING          reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    WHILE           reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    DECLARE         reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    FOR             reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    LOOP            reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    BEGIN           reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    THEN            reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    OR              reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    ELSE            reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    END             reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    EXCEPTION       reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    WHEN            reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    ELSIF           reduce using rule 402 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)


state 864

    (460) exception_handler -> WHEN except_choice_s ARROW statement_s .
    (245) statement_s -> statement_s . statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    WHEN            reduce using rule 460 (exception_handler -> WHEN except_choice_s ARROW statement_s .)
    END             reduce using rule 460 (exception_handler -> WHEN except_choice_s ARROW statement_s .)
    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 456
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 865

    (463) except_choice_s -> except_choice_s | except_choice .

    ARROW           reduce using rule 463 (except_choice_s -> except_choice_s | except_choice .)
    |               reduce using rule 463 (except_choice_s -> except_choice_s | except_choice .)


state 866

    (461) exception_handler -> WHEN IDENTIFIER : except_choice_s . ARROW statement_s
    (463) except_choice_s -> except_choice_s . | except_choice

    ARROW           shift and go to state 905
    |               shift and go to state 802


state 867

    (272) if_stmt -> IF cond_clause_s else_opt END IF ; .

    END             reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    LESSLESS        reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    error           reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    PRAGMA          reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    NuLL            reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    EXIT            reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    RETURN          reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    GOTO            reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    DELAY           reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    ABORT           reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    RAISE           reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    REQUEUE         reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    IF              reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    CASE            reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    IDENTIFIER      reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    ACCEPT          reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    SELECT          reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    STRING          reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    WHILE           reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    DECLARE         reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    FOR             reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    LOOP            reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    BEGIN           reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    EXCEPTION       reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    WHEN            reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    THEN            reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    OR              reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    ELSE            reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    ELSIF           reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)


state 868

    (506) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD . ;

    ;               shift and go to state 906


state 869

    (510) comp_loc_s -> comp_loc_s mark AT . expression RANGE range ;
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 907

state 870

    (508) align_opt -> AT MOD expression ; .

    END             reduce using rule 508 (align_opt -> AT MOD expression ; .)
    IDENTIFIER      reduce using rule 508 (align_opt -> AT MOD expression ; .)


state 871

    (367) task_body -> TASK BODY simple_name IS decl_part block_body END id_opt . ;

    ;               shift and go to state 908


state 872

    (366) task_private_opt -> PRIVATE entry_decl_s rep_spec_s .
    (399) rep_spec_s -> rep_spec_s . rep_spec pragma_s
    (502) rep_spec -> . attrib_def
    (503) rep_spec -> . record_type_spec
    (504) rep_spec -> . address_spec
    (505) attrib_def -> . FOR mark USE expression ;
    (506) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (511) address_spec -> . FOR mark USE AT expression ;

    END             reduce using rule 366 (task_private_opt -> PRIVATE entry_decl_s rep_spec_s .)
    FOR             shift and go to state 63

    record_type_spec               shift and go to state 68
    rep_spec                       shift and go to state 713
    attrib_def                     shift and go to state 70
    address_spec                   shift and go to state 52

state 873

    (364) task_def -> IS entry_decl_s rep_spec_s task_private_opt END id_opt .

    ;               reduce using rule 364 (task_def -> IS entry_decl_s rep_spec_s task_private_opt END id_opt .)


state 874

    (113) discrim_spec -> def_id_s : access_opt mark init_opt .

    )               reduce using rule 113 (discrim_spec -> def_id_s : access_opt mark init_opt .)
    ;               reduce using rule 113 (discrim_spec -> def_id_s : access_opt mark init_opt .)


state 875

    (59) derived_type -> ABSTRACT NEW subtype_ind WITH . PRIVATE
    (60) derived_type -> ABSTRACT NEW subtype_ind WITH . record_def
    (96) record_def -> . RECORD pragma_s comp_list END RECORD
    (97) record_def -> . NuLL RECORD

    PRIVATE         shift and go to state 909
    RECORD          shift and go to state 826
    NuLL            shift and go to state 827

    record_def                     shift and go to state 910

state 876

    (57) derived_type -> NEW subtype_ind WITH PRIVATE .

    ;               reduce using rule 57 (derived_type -> NEW subtype_ind WITH PRIVATE .)


state 877

    (58) derived_type -> NEW subtype_ind WITH record_def .

    ;               reduce using rule 58 (derived_type -> NEW subtype_ind WITH record_def .)


state 878

    (65) enum_id_s -> enum_id_s , enum_id .

    )               reduce using rule 65 (enum_id_s -> enum_id_s , enum_id .)
    ,               reduce using rule 65 (enum_id_s -> enum_id_s , enum_id .)


state 879

    (77) fixed_type -> DELTA expression DIGITS expression . range_spec_opt
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (71) range_spec_opt -> .
    (72) range_spec_opt -> . range_spec
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE
    (70) range_spec -> . range_constraint
    (61) range_constraint -> . RANGE range

    ;               reduce using rule 71 (range_spec_opt -> .)
    AND             shift and go to state 247
    OR              shift and go to state 250
    RANGE           shift and go to state 371

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249
    range_constraint               shift and go to state 599
    range_spec                     shift and go to state 817
    range_spec_opt                 shift and go to state 911

state 880

    (132) access_type -> ACCESS prot_opt FUNCTION formal_part_opt . RETURN mark

    RETURN          shift and go to state 912


state 881

    (131) access_type -> ACCESS prot_opt PROCEDURE formal_part_opt .

    ;               reduce using rule 131 (access_type -> ACCESS prot_opt PROCEDURE formal_part_opt .)


state 882

    (96) record_def -> RECORD pragma_s . comp_list END RECORD
    (9) pragma_s -> pragma_s . pragma
    (101) comp_list -> . comp_decl_s variant_part_opt
    (102) comp_list -> . variant_part pragma_s
    (103) comp_list -> . NuLL ; pragma_s
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (104) comp_decl_s -> . comp_decl
    (105) comp_decl_s -> . comp_decl_s pragma_s comp_decl
    (117) variant_part -> . CASE simple_name IS pragma_s variant_s END CASE ;
    (108) comp_decl -> . def_id_s : component_subtype_def init_opt ;
    (109) comp_decl -> . error ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    NuLL            shift and go to state 918
    PRAGMA          shift and go to state 4
    CASE            shift and go to state 914
    error           shift and go to state 780
    IDENTIFIER      shift and go to state 76

    def_id_s                       shift and go to state 776
    comp_list                      shift and go to state 915
    comp_decl                      shift and go to state 916
    def_id                         shift and go to state 89
    variant_part                   shift and go to state 917
    pragma                         shift and go to state 14
    comp_decl_s                    shift and go to state 913

state 883

    (97) record_def -> NuLL RECORD .

    ;               reduce using rule 97 (record_def -> NuLL RECORD .)


state 884

    (90) iter_discrete_range_s -> iter_discrete_range_s , discrete_range .

    )               reduce using rule 90 (iter_discrete_range_s -> iter_discrete_range_s , discrete_range .)
    ,               reduce using rule 90 (iter_discrete_range_s -> iter_discrete_range_s , discrete_range .)


state 885

    (80) unconstr_array_type -> ARRAY ( index_s ) OF . component_subtype_def
    (82) component_subtype_def -> . aliased_opt subtype_ind
    (83) aliased_opt -> .
    (84) aliased_opt -> . ALIASED

    IDENTIFIER      reduce using rule 83 (aliased_opt -> .)
    STRING          reduce using rule 83 (aliased_opt -> .)
    ALIASED         shift and go to state 835

    aliased_opt                    shift and go to state 836
    component_subtype_def          shift and go to state 919

state 886

    (86) index_s -> index_s , index .

    )               reduce using rule 86 (index_s -> index_s , index .)
    ,               reduce using rule 86 (index_s -> index_s , index .)


state 887

    (87) index -> name . RANGE LESSMORE
    (168) indexed_comp -> name . ( value_s )
    (175) selected_comp -> name . . simple_name
    (176) selected_comp -> name . . used_char
    (177) selected_comp -> name . . operator_symbol
    (178) selected_comp -> name . . ALL
    (179) attribute -> name . TICK attribute_id

    RANGE           shift and go to state 920
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 888

    (87) index -> name RANGE LESSMORE .

    )               reduce using rule 87 (index -> name RANGE LESSMORE .)
    ,               reduce using rule 87 (index -> name RANGE LESSMORE .)


state 889

    (82) component_subtype_def -> aliased_opt subtype_ind .

    ASSIGNMENT      reduce using rule 82 (component_subtype_def -> aliased_opt subtype_ind .)
    ;               reduce using rule 82 (component_subtype_def -> aliased_opt subtype_ind .)


state 890

    (342) pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .

    PACKAGE         reduce using rule 342 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    TASK            reduce using rule 342 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    PROTECTED       reduce using rule 342 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    error           reduce using rule 342 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    USE             reduce using rule 342 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    PRAGMA          reduce using rule 342 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    TYPE            reduce using rule 342 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    SUBTYPE         reduce using rule 342 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    FOR             reduce using rule 342 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    PROCEDURE       reduce using rule 342 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    FUNCTION        reduce using rule 342 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    GENERIC         reduce using rule 342 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    IDENTIFIER      reduce using rule 342 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    BEGIN           reduce using rule 342 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    END             reduce using rule 342 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    PRIVATE         reduce using rule 342 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    WITH            reduce using rule 342 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    SEPARATE        reduce using rule 342 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    $end            reduce using rule 342 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)


state 891

    (476) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .

    PACKAGE         reduce using rule 476 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    PROCEDURE       reduce using rule 476 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    FUNCTION        reduce using rule 476 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    TYPE            reduce using rule 476 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    WITH            reduce using rule 476 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    error           reduce using rule 476 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    USE             reduce using rule 476 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    IDENTIFIER      reduce using rule 476 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)


state 892

    (477) generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE . ) ;

    )               shift and go to state 921


state 893

    (498) generic_derived_type -> ABSTRACT NEW subtype_ind WITH . PRIVATE

    PRIVATE         shift and go to state 922


state 894

    (497) generic_derived_type -> NEW subtype_ind WITH PRIVATE .

    ;               reduce using rule 497 (generic_derived_type -> NEW subtype_ind WITH PRIVATE .)


state 895

    (490) generic_type_def -> DELTA LESSMORE DIGITS LESSMORE .

    ;               reduce using rule 490 (generic_type_def -> DELTA LESSMORE DIGITS LESSMORE .)


state 896

    (395) entry_body -> ENTRY IDENTIFIER ( iter_part . discrete_range ) formal_part_opt WHEN condition entry_body_part
    (91) discrete_range -> . name range_constr_opt
    (92) discrete_range -> . range
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    simple_expression              shift and go to state 358
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    allocator                      shift and go to state 130
    factor                         shift and go to state 137
    parenthesized_primary          shift and go to state 141
    discrete_range                 shift and go to state 923
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 678
    operator_symbol                shift and go to state 149
    range                          shift and go to state 679
    qualified                      shift and go to state 140

state 897

    (394) entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN . condition entry_body_part
    (277) condition -> . expression
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    allocator                      shift and go to state 130
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    condition                      shift and go to state 924
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    expression                     shift and go to state 462

state 898

    (108) comp_decl -> def_id_s : component_subtype_def . init_opt ;
    (33) init_opt -> .
    (34) init_opt -> . ASSIGNMENT expression

    ;               reduce using rule 33 (init_opt -> .)
    ASSIGNMENT      shift and go to state 630

    init_opt                       shift and go to state 925

state 899

    (393) entry_decl -> ENTRY IDENTIFIER ( discrete_range ) . formal_part_opt ;
    (320) formal_part_opt -> .
    (321) formal_part_opt -> . formal_part
    (322) formal_part -> . ( param_s )

    ;               reduce using rule 320 (formal_part_opt -> .)
    (               shift and go to state 189

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 926

state 900

    (424) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT . ;

    ;               shift and go to state 927


state 901

    (423) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END . SELECT ;

    SELECT          shift and go to state 928


state 902

    (422) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT . ;

    ;               shift and go to state 929


state 903

    (412) select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .

    LESSLESS        reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    error           reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    PRAGMA          reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    NuLL            reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    EXIT            reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    RETURN          reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    GOTO            reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    DELAY           reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    ABORT           reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    RAISE           reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    REQUEUE         reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    IF              reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    CASE            reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    IDENTIFIER      reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    ACCEPT          reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    SELECT          reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    STRING          reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    WHILE           reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    DECLARE         reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    FOR             reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    LOOP            reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    BEGIN           reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    OR              reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    ELSE            reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    THEN            reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    END             reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    EXCEPTION       reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    ELSIF           reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    WHEN            reduce using rule 412 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)


state 904

    (284) alternative -> WHEN choice_s ARROW statement_s .
    (245) statement_s -> statement_s . statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    END             reduce using rule 284 (alternative -> WHEN choice_s ARROW statement_s .)
    WHEN            reduce using rule 284 (alternative -> WHEN choice_s ARROW statement_s .)
    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 456
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 905

    (461) exception_handler -> WHEN IDENTIFIER : except_choice_s ARROW . statement_s
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 930
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 906

    (506) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .

    PRIVATE         reduce using rule 506 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    ENTRY           reduce using rule 506 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    PROCEDURE       reduce using rule 506 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    FUNCTION        reduce using rule 506 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    PRAGMA          reduce using rule 506 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    FOR             reduce using rule 506 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    END             reduce using rule 506 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    PACKAGE         reduce using rule 506 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    TASK            reduce using rule 506 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    PROTECTED       reduce using rule 506 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    error           reduce using rule 506 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    USE             reduce using rule 506 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    TYPE            reduce using rule 506 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    SUBTYPE         reduce using rule 506 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    GENERIC         reduce using rule 506 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    IDENTIFIER      reduce using rule 506 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    BEGIN           reduce using rule 506 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)


state 907

    (510) comp_loc_s -> comp_loc_s mark AT expression . RANGE range ;
    (199) expression -> expression . logical relation
    (200) expression -> expression . short_circuit relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    RANGE           shift and go to state 931
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 908

    (367) task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .

    PACKAGE         reduce using rule 367 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    TASK            reduce using rule 367 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    PROTECTED       reduce using rule 367 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    error           reduce using rule 367 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    USE             reduce using rule 367 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    PRAGMA          reduce using rule 367 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    TYPE            reduce using rule 367 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    SUBTYPE         reduce using rule 367 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    FOR             reduce using rule 367 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    PROCEDURE       reduce using rule 367 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    FUNCTION        reduce using rule 367 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    GENERIC         reduce using rule 367 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    IDENTIFIER      reduce using rule 367 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    BEGIN           reduce using rule 367 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    END             reduce using rule 367 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    PRIVATE         reduce using rule 367 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    WITH            reduce using rule 367 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    SEPARATE        reduce using rule 367 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    $end            reduce using rule 367 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)


state 909

    (59) derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .

    ;               reduce using rule 59 (derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .)


state 910

    (60) derived_type -> ABSTRACT NEW subtype_ind WITH record_def .

    ;               reduce using rule 60 (derived_type -> ABSTRACT NEW subtype_ind WITH record_def .)


state 911

    (77) fixed_type -> DELTA expression DIGITS expression range_spec_opt .

    ;               reduce using rule 77 (fixed_type -> DELTA expression DIGITS expression range_spec_opt .)


state 912

    (132) access_type -> ACCESS prot_opt FUNCTION formal_part_opt RETURN . mark
    (158) mark -> . simple_name
    (159) mark -> . mark TICK attribute_id
    (160) mark -> . mark . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 165
    mark                           shift and go to state 932

state 913

    (101) comp_list -> comp_decl_s . variant_part_opt
    (105) comp_decl_s -> comp_decl_s . pragma_s comp_decl
    (106) variant_part_opt -> . pragma_s
    (107) variant_part_opt -> . pragma_s variant_part pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    error           reduce using rule 8 (pragma_s -> .)
    CASE            reduce using rule 8 (pragma_s -> .)
    PRAGMA          reduce using rule 8 (pragma_s -> .)
    IDENTIFIER      reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 933
    variant_part_opt               shift and go to state 934

state 914

    (117) variant_part -> CASE . simple_name IS pragma_s variant_s END CASE ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 935

state 915

    (96) record_def -> RECORD pragma_s comp_list . END RECORD

    END             shift and go to state 936


state 916

    (104) comp_decl_s -> comp_decl .

    error           reduce using rule 104 (comp_decl_s -> comp_decl .)
    CASE            reduce using rule 104 (comp_decl_s -> comp_decl .)
    PRAGMA          reduce using rule 104 (comp_decl_s -> comp_decl .)
    IDENTIFIER      reduce using rule 104 (comp_decl_s -> comp_decl .)
    END             reduce using rule 104 (comp_decl_s -> comp_decl .)
    WHEN            reduce using rule 104 (comp_decl_s -> comp_decl .)


state 917

    (102) comp_list -> variant_part . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 937

state 918

    (103) comp_list -> NuLL . ; pragma_s

    ;               shift and go to state 938


state 919

    (80) unconstr_array_type -> ARRAY ( index_s ) OF component_subtype_def .

    ;               reduce using rule 80 (unconstr_array_type -> ARRAY ( index_s ) OF component_subtype_def .)
    ASSIGNMENT      reduce using rule 80 (unconstr_array_type -> ARRAY ( index_s ) OF component_subtype_def .)


state 920

    (87) index -> name RANGE . LESSMORE

    LESSMORE        shift and go to state 888


state 921

    (477) generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) . ;

    ;               shift and go to state 939


state 922

    (498) generic_derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .

    ;               reduce using rule 498 (generic_derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .)


state 923

    (395) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range . ) formal_part_opt WHEN condition entry_body_part

    )               shift and go to state 940


state 924

    (394) entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition . entry_body_part
    (396) entry_body_part -> . ;
    (397) entry_body_part -> . IS decl_part block_body END id_opt ;

    ;               shift and go to state 943
    IS              shift and go to state 942

    entry_body_part                shift and go to state 941

state 925

    (108) comp_decl -> def_id_s : component_subtype_def init_opt . ;

    ;               shift and go to state 944


state 926

    (393) entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt . ;

    ;               shift and go to state 945


state 927

    (424) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .

    LESSLESS        reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    error           reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    PRAGMA          reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    NuLL            reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    EXIT            reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    RETURN          reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    GOTO            reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    DELAY           reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    ABORT           reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    RAISE           reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    REQUEUE         reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    IF              reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    CASE            reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    IDENTIFIER      reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    ACCEPT          reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    SELECT          reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    STRING          reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    WHILE           reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    DECLARE         reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    FOR             reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    LOOP            reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    BEGIN           reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    OR              reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    ELSE            reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    END             reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    WHEN            reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    EXCEPTION       reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    ELSIF           reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    THEN            reduce using rule 424 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)


state 928

    (423) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT . ;

    ;               shift and go to state 946


state 929

    (422) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .

    LESSLESS        reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    error           reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    PRAGMA          reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    NuLL            reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    EXIT            reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    RETURN          reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    GOTO            reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    DELAY           reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    ABORT           reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    RAISE           reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    REQUEUE         reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    IF              reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    CASE            reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    IDENTIFIER      reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    ACCEPT          reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    SELECT          reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    STRING          reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    WHILE           reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    DECLARE         reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    FOR             reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    LOOP            reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    BEGIN           reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    THEN            reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    OR              reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    ELSE            reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    END             reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    EXCEPTION       reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    ELSIF           reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    WHEN            reduce using rule 422 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)


state 930

    (461) exception_handler -> WHEN IDENTIFIER : except_choice_s ARROW statement_s .
    (245) statement_s -> statement_s . statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (304) exit_stmt -> . EXIT name_opt when_opt ;
    (309) return_stmt -> . RETURN ;
    (310) return_stmt -> . RETURN expression ;
    (311) goto_stmt -> . GOTO name ;
    (334) procedure_call -> . name ;
    (406) delay_stmt -> . DELAY expression ;
    (407) delay_stmt -> . DELAY UNTIL expression ;
    (427) abort_stmt -> . ABORT name_s ;
    (466) raise_stmt -> . RAISE name_opt ;
    (512) code_stmt -> . qualified ;
    (467) requeue_stmt -> . REQUEUE name ;
    (468) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (280) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (285) loop_stmt -> . label_opt iteration basic_loop id_opt ;
    (297) block -> . label_opt block_decl block_body END id_opt ;
    (401) accept_stmt -> . accept_hdr ;
    (402) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (408) select_stmt -> . select_wait
    (409) select_stmt -> . async_select
    (410) select_stmt -> . timed_entry_call
    (411) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (281) case_hdr -> . CASE expression IS
    (286) label_opt -> .
    (287) label_opt -> . IDENTIFIER :
    (403) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (412) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (422) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (423) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (424) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    WHEN            reduce using rule 461 (exception_handler -> WHEN IDENTIFIER : except_choice_s ARROW statement_s .)
    END             reduce using rule 461 (exception_handler -> WHEN IDENTIFIER : except_choice_s ARROW statement_s .)
    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 286 (label_opt -> .)
    DECLARE         reduce using rule 286 (label_opt -> .)
    FOR             reduce using rule 286 (label_opt -> .)
    LOOP            reduce using rule 286 (label_opt -> .)
    BEGIN           reduce using rule 286 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 138

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 149
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 456
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 931

    (510) comp_loc_s -> comp_loc_s mark AT expression RANGE . range ;
    (62) range -> . simple_expression DOTDOT simple_expression
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    simple_expression              shift and go to state 358
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    range                          shift and go to state 947

state 932

    (132) access_type -> ACCESS prot_opt FUNCTION formal_part_opt RETURN mark .
    (159) mark -> mark . TICK attribute_id
    (160) mark -> mark . . simple_name

    ;               reduce using rule 132 (access_type -> ACCESS prot_opt FUNCTION formal_part_opt RETURN mark .)
    TICK            shift and go to state 312
    .               shift and go to state 311


state 933

    (105) comp_decl_s -> comp_decl_s pragma_s . comp_decl
    (106) variant_part_opt -> pragma_s .
    (107) variant_part_opt -> pragma_s . variant_part pragma_s
    (9) pragma_s -> pragma_s . pragma
    (108) comp_decl -> . def_id_s : component_subtype_def init_opt ;
    (109) comp_decl -> . error ;
    (117) variant_part -> . CASE simple_name IS pragma_s variant_s END CASE ;
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    END             reduce using rule 106 (variant_part_opt -> pragma_s .)
    WHEN            reduce using rule 106 (variant_part_opt -> pragma_s .)
    error           shift and go to state 780
    CASE            shift and go to state 914
    PRAGMA          shift and go to state 4
    IDENTIFIER      shift and go to state 76

    comp_decl                      shift and go to state 948
    def_id                         shift and go to state 89
    def_id_s                       shift and go to state 776
    pragma                         shift and go to state 14
    variant_part                   shift and go to state 949

state 934

    (101) comp_list -> comp_decl_s variant_part_opt .

    END             reduce using rule 101 (comp_list -> comp_decl_s variant_part_opt .)
    WHEN            reduce using rule 101 (comp_list -> comp_decl_s variant_part_opt .)


state 935

    (117) variant_part -> CASE simple_name . IS pragma_s variant_s END CASE ;

    IS              shift and go to state 950


state 936

    (96) record_def -> RECORD pragma_s comp_list END . RECORD

    RECORD          shift and go to state 951


state 937

    (102) comp_list -> variant_part pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 102 (comp_list -> variant_part pragma_s .)
    WHEN            reduce using rule 102 (comp_list -> variant_part pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 938

    (103) comp_list -> NuLL ; . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 952

state 939

    (477) generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .

    PACKAGE         reduce using rule 477 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)
    PROCEDURE       reduce using rule 477 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)
    FUNCTION        reduce using rule 477 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)
    TYPE            reduce using rule 477 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)
    WITH            reduce using rule 477 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)
    error           reduce using rule 477 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)
    USE             reduce using rule 477 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)
    IDENTIFIER      reduce using rule 477 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)


state 940

    (395) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) . formal_part_opt WHEN condition entry_body_part
    (320) formal_part_opt -> .
    (321) formal_part_opt -> . formal_part
    (322) formal_part -> . ( param_s )

    WHEN            reduce using rule 320 (formal_part_opt -> .)
    (               shift and go to state 189

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 953

state 941

    (394) entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .

    PRAGMA          reduce using rule 394 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)
    END             reduce using rule 394 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)
    ENTRY           reduce using rule 394 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)
    PROCEDURE       reduce using rule 394 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)
    FUNCTION        reduce using rule 394 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)


state 942

    (397) entry_body_part -> IS . decl_part block_body END id_opt ;
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (333) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (342) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (367) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (384) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (348) use_clause -> . USE name_s ;
    (349) use_clause -> . USE TYPE name_s ;
    (502) rep_spec -> . attrib_def
    (503) rep_spec -> . record_type_spec
    (504) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (332) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (312) subprog_decl -> . subprog_spec ;
    (313) subprog_decl -> . generic_subp_inst ;
    (314) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (335) pkg_decl -> . pkg_spec ;
    (336) pkg_decl -> . generic_pkg_inst ;
    (360) task_decl -> . task_spec ;
    (368) prot_decl -> . prot_spec ;
    (457) exception_decl -> . def_id_s : EXCEPTION ;
    (352) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (353) rename_decl -> . def_id_s : EXCEPTION renames ;
    (354) rename_decl -> . rename_unit
    (469) generic_decl -> . generic_formal_part subprog_spec ;
    (470) generic_decl -> . generic_formal_part pkg_spec ;
    (453) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (454) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (455) body_stub -> . subprog_spec IS SEPARATE ;
    (456) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (505) attrib_def -> . FOR mark USE expression ;
    (506) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (511) address_spec -> . FOR mark USE AT expression ;
    (315) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (316) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (317) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (499) generic_subp_inst -> . subprog_spec IS generic_inst
    (337) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (500) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (361) task_spec -> . TASK simple_name task_def
    (362) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (369) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (370) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (355) rename_unit -> . PACKAGE compound_name renames ;
    (356) rename_unit -> . subprog_spec renames ;
    (357) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (358) rename_unit -> . generic_formal_part subprog_spec renames ;
    (471) generic_formal_part -> . GENERIC
    (472) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 954
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 943

    (396) entry_body_part -> ; .

    PRAGMA          reduce using rule 396 (entry_body_part -> ; .)
    END             reduce using rule 396 (entry_body_part -> ; .)
    ENTRY           reduce using rule 396 (entry_body_part -> ; .)
    PROCEDURE       reduce using rule 396 (entry_body_part -> ; .)
    FUNCTION        reduce using rule 396 (entry_body_part -> ; .)


state 944

    (108) comp_decl -> def_id_s : component_subtype_def init_opt ; .

    error           reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    CASE            reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    PRAGMA          reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    IDENTIFIER      reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    END             reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    WHEN            reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    ENTRY           reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    PROCEDURE       reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    FUNCTION        reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    FOR             reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)


state 945

    (393) entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .

    error           reduce using rule 393 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    ENTRY           reduce using rule 393 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    PROCEDURE       reduce using rule 393 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    FUNCTION        reduce using rule 393 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    PRAGMA          reduce using rule 393 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    FOR             reduce using rule 393 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    IDENTIFIER      reduce using rule 393 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    END             reduce using rule 393 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    PRIVATE         reduce using rule 393 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)


state 946

    (423) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .

    EXCEPTION       reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    LESSLESS        reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    error           reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    PRAGMA          reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    NuLL            reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    EXIT            reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    RETURN          reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    GOTO            reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    DELAY           reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    ABORT           reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    RAISE           reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    REQUEUE         reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    IF              reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    CASE            reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    IDENTIFIER      reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    ACCEPT          reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    SELECT          reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    STRING          reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    WHILE           reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    DECLARE         reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    FOR             reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    LOOP            reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    BEGIN           reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    END             reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    OR              reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    ELSE            reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    THEN            reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    WHEN            reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    ELSIF           reduce using rule 423 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)


state 947

    (510) comp_loc_s -> comp_loc_s mark AT expression RANGE range . ;

    ;               shift and go to state 955


state 948

    (105) comp_decl_s -> comp_decl_s pragma_s comp_decl .

    error           reduce using rule 105 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
    CASE            reduce using rule 105 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
    PRAGMA          reduce using rule 105 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
    IDENTIFIER      reduce using rule 105 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
    END             reduce using rule 105 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
    WHEN            reduce using rule 105 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)


state 949

    (107) variant_part_opt -> pragma_s variant_part . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 956

state 950

    (117) variant_part -> CASE simple_name IS . pragma_s variant_s END CASE ;
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 957

state 951

    (96) record_def -> RECORD pragma_s comp_list END RECORD .

    ;               reduce using rule 96 (record_def -> RECORD pragma_s comp_list END RECORD .)


state 952

    (103) comp_list -> NuLL ; pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 103 (comp_list -> NuLL ; pragma_s .)
    WHEN            reduce using rule 103 (comp_list -> NuLL ; pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 953

    (395) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt . WHEN condition entry_body_part

    WHEN            shift and go to state 958


state 954

    (397) entry_body_part -> IS decl_part . block_body END id_opt ;
    (300) block_body -> . BEGIN handled_stmt_s

    BEGIN           shift and go to state 162

    block_body                     shift and go to state 959

state 955

    (510) comp_loc_s -> comp_loc_s mark AT expression RANGE range ; .

    END             reduce using rule 510 (comp_loc_s -> comp_loc_s mark AT expression RANGE range ; .)
    IDENTIFIER      reduce using rule 510 (comp_loc_s -> comp_loc_s mark AT expression RANGE range ; .)


state 956

    (107) variant_part_opt -> pragma_s variant_part pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 107 (variant_part_opt -> pragma_s variant_part pragma_s .)
    WHEN            reduce using rule 107 (variant_part_opt -> pragma_s variant_part pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 957

    (117) variant_part -> CASE simple_name IS pragma_s . variant_s END CASE ;
    (9) pragma_s -> pragma_s . pragma
    (118) variant_s -> . variant
    (119) variant_s -> . variant_s variant
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (120) variant -> . WHEN choice_s ARROW pragma_s comp_list

    PRAGMA          shift and go to state 4
    WHEN            shift and go to state 961

    variant_s                      shift and go to state 960
    variant                        shift and go to state 962
    pragma                         shift and go to state 14

state 958

    (395) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN . condition entry_body_part
    (277) condition -> . expression
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    allocator                      shift and go to state 130
    factor                         shift and go to state 137
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    condition                      shift and go to state 963
    term                           shift and go to state 146
    name                           shift and go to state 147
    operator_symbol                shift and go to state 149
    qualified                      shift and go to state 140
    expression                     shift and go to state 462

state 959

    (397) entry_body_part -> IS decl_part block_body . END id_opt ;

    END             shift and go to state 964


state 960

    (117) variant_part -> CASE simple_name IS pragma_s variant_s . END CASE ;
    (119) variant_s -> variant_s . variant
    (120) variant -> . WHEN choice_s ARROW pragma_s comp_list

    END             shift and go to state 965
    WHEN            shift and go to state 961

    variant                        shift and go to state 966

state 961

    (120) variant -> WHEN . choice_s ARROW pragma_s comp_list
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (198) expression -> . relation
    (199) expression -> . expression logical relation
    (200) expression -> . expression short_circuit relation
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (175) selected_comp -> . name . simple_name
    (176) selected_comp -> . name . used_char
    (177) selected_comp -> . name . operator_symbol
    (178) selected_comp -> . name . ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (184) literal -> . INTEGER
    (185) literal -> . BASE_INTEGER
    (186) literal -> . FLOAT
    (187) literal -> . BASE_FLOAT
    (188) literal -> . used_char
    (189) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (190) aggregate -> . ( comp_assoc )
    (191) aggregate -> . ( value_s_2 )
    (192) aggregate -> . ( expression WITH value_s )
    (193) aggregate -> . ( expression WITH NuLL RECORD )
    (194) aggregate -> . ( NuLL RECORD )

    OTHERS          shift and go to state 223
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 138
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 142
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 148
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 145

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 144
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 381
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    choice_s                       shift and go to state 967
    factor                         shift and go to state 137
    choice                         shift and go to state 227
    qualified                      shift and go to state 140
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 143
    discrete_with_range            shift and go to state 516
    term                           shift and go to state 146
    name                           shift and go to state 230
    operator_symbol                shift and go to state 149
    range                          shift and go to state 232
    expression                     shift and go to state 517

state 962

    (118) variant_s -> variant .

    END             reduce using rule 118 (variant_s -> variant .)
    WHEN            reduce using rule 118 (variant_s -> variant .)


state 963

    (395) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition . entry_body_part
    (396) entry_body_part -> . ;
    (397) entry_body_part -> . IS decl_part block_body END id_opt ;

    ;               shift and go to state 943
    IS              shift and go to state 942

    entry_body_part                shift and go to state 968

state 964

    (397) entry_body_part -> IS decl_part block_body END . id_opt ;
    (295) id_opt -> .
    (296) id_opt -> . designator
    (318) designator -> . compound_name
    (319) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 295 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 463
    id_opt                         shift and go to state 969
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 965

    (117) variant_part -> CASE simple_name IS pragma_s variant_s END . CASE ;

    CASE            shift and go to state 970


state 966

    (119) variant_s -> variant_s variant .

    END             reduce using rule 119 (variant_s -> variant_s variant .)
    WHEN            reduce using rule 119 (variant_s -> variant_s variant .)


state 967

    (120) variant -> WHEN choice_s . ARROW pragma_s comp_list
    (122) choice_s -> choice_s . | choice

    ARROW           shift and go to state 971
    |               shift and go to state 365


state 968

    (395) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .

    PRAGMA          reduce using rule 395 (entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)
    END             reduce using rule 395 (entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)
    ENTRY           reduce using rule 395 (entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)
    PROCEDURE       reduce using rule 395 (entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)
    FUNCTION        reduce using rule 395 (entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)


state 969

    (397) entry_body_part -> IS decl_part block_body END id_opt . ;

    ;               shift and go to state 972


state 970

    (117) variant_part -> CASE simple_name IS pragma_s variant_s END CASE . ;

    ;               shift and go to state 973


state 971

    (120) variant -> WHEN choice_s ARROW . pragma_s comp_list
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    NuLL            reduce using rule 8 (pragma_s -> .)
    PRAGMA          reduce using rule 8 (pragma_s -> .)
    CASE            reduce using rule 8 (pragma_s -> .)
    error           reduce using rule 8 (pragma_s -> .)
    IDENTIFIER      reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 974

state 972

    (397) entry_body_part -> IS decl_part block_body END id_opt ; .

    PRAGMA          reduce using rule 397 (entry_body_part -> IS decl_part block_body END id_opt ; .)
    END             reduce using rule 397 (entry_body_part -> IS decl_part block_body END id_opt ; .)
    ENTRY           reduce using rule 397 (entry_body_part -> IS decl_part block_body END id_opt ; .)
    PROCEDURE       reduce using rule 397 (entry_body_part -> IS decl_part block_body END id_opt ; .)
    FUNCTION        reduce using rule 397 (entry_body_part -> IS decl_part block_body END id_opt ; .)


state 973

    (117) variant_part -> CASE simple_name IS pragma_s variant_s END CASE ; .

    PRAGMA          reduce using rule 117 (variant_part -> CASE simple_name IS pragma_s variant_s END CASE ; .)
    END             reduce using rule 117 (variant_part -> CASE simple_name IS pragma_s variant_s END CASE ; .)
    WHEN            reduce using rule 117 (variant_part -> CASE simple_name IS pragma_s variant_s END CASE ; .)


state 974

    (120) variant -> WHEN choice_s ARROW pragma_s . comp_list
    (9) pragma_s -> pragma_s . pragma
    (101) comp_list -> . comp_decl_s variant_part_opt
    (102) comp_list -> . variant_part pragma_s
    (103) comp_list -> . NuLL ; pragma_s
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (104) comp_decl_s -> . comp_decl
    (105) comp_decl_s -> . comp_decl_s pragma_s comp_decl
    (117) variant_part -> . CASE simple_name IS pragma_s variant_s END CASE ;
    (108) comp_decl -> . def_id_s : component_subtype_def init_opt ;
    (109) comp_decl -> . error ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    NuLL            shift and go to state 918
    PRAGMA          shift and go to state 4
    CASE            shift and go to state 914
    error           shift and go to state 780
    IDENTIFIER      shift and go to state 76

    def_id_s                       shift and go to state 776
    comp_list                      shift and go to state 975
    comp_decl                      shift and go to state 916
    def_id                         shift and go to state 89
    variant_part                   shift and go to state 917
    pragma                         shift and go to state 14
    comp_decl_s                    shift and go to state 913

state 975

    (120) variant -> WHEN choice_s ARROW pragma_s comp_list .

    END             reduce using rule 120 (variant -> WHEN choice_s ARROW pragma_s comp_list .)
    WHEN            reduce using rule 120 (variant -> WHEN choice_s ARROW pragma_s comp_list .)

