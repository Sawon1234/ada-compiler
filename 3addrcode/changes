expression 
place -> expr_value

variables
place -> value


Did not understand the use of class and base
range 
range_low = lower_limit
range_high = upper_limit
index_type -> index_bound_type

lower_limit and upper_limit are lists for arrays

standard error format:
print "[Expression Computations] Error at line " + p.lineno + " : unary operator used on a wrong subtype"
p_error(p)

get_temp : 
I have only used two arguments there
Why Stack??

simple_name :
why when its not in the symbol_table ?
 
emit
unary+ -> un+
unary- -> un-

factor1 :
value logic



def p_subprog_spec_is_push(p):
    '''subprog_spec_is_push : subprog_spec IS
    '''
    p[0] = deepcopy(p[1])

    p[0]["nextlist"] = []

    if(symbol_table.get_current_table().prev_table != None):  #going out/back/ used while calling
        p[0]["nextlist"] = [three_addr_code.get_next_instr_no()]
        #three_addr_code.emit("goto" , None , None , None )

    symbol_table.begin_scope()
    symbol_table.declare_Procedure(p[1]["lexeme"] , p[1]["var_List"])
    three_addr_code.emit("proc_label" , p[1]["lexeme"] , symbol_table.get_width() , None )

    


def p_subprog_body(p):
    '''subprog_body : subprog_spec IS decl_part block_body END id_opt ';'
    '''
    p[0] = deepcopy(p[1])

    p[0]["nextlist"] = []

    if(symbol_table.get_current_table().prev_table != None):  #going out/back/ used while calling
        p[0]["nextlist"] = [three_addr_code.get_next_instr_no()]
        #three_addr_code.emit("goto" , None , None , None )

    symbol_table.begin_scope()
    symbol_table.declare_Procedure(p[1]["lexeme"] , p[1]["var_List"])
    three_addr_code.emit("proc_label" , p[1]["lexeme"] , symbol_table.get_width() , None )


    if(p[5] != None):
        if(p[1]["lexeme"] != p[5]["lexeme"]):
            print "[Procedure Declaration] Error : labels at the end of procedure block do not match"
            p_error(p)

    p[0] = deepcopy(p[3])

    outvars = ""
    for item in symbol_table.get_Hash_Table():
        if(symbol_table.get_Attribute_Value(item , "paramtype") == "out"):
            outvars += " " + symbol_table.get_Attribute_Value(item ,"lexeme")
    #In the symbol table of the procedure

    three_addr_code.emit("end_proc_label" , p[1]["lexeme"] ,None , None )

    if (outvars != ""):
        three_addr_code.emit("return" , outvars , None , None )
    else:
        three_addr_code.emit("return" , None , None , None)

    symbol_table.end_scope()

    if(p[0] != None):
        backpatch(p[0]["nextlist"] , three_addr_code.get_next_instr_no() - 1)
    else:
        print "None statement propagating"
    

        