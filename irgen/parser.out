Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    XOR
    ABS

Grammar

Rule 0     S' -> start_symbol
Rule 1     start_symbol -> compilation
Rule 2     pragma -> PRAGMA IDENTIFIER ;
Rule 3     pragma -> PRAGMA simple_name ( pragma_arg_s ) ;
Rule 4     pragma_arg_s -> pragma_arg
Rule 5     pragma_arg_s -> pragma_arg_s , pragma_arg
Rule 6     pragma_arg -> expression
Rule 7     pragma_arg -> simple_name ARROW expression
Rule 8     pragma_s -> <empty>
Rule 9     pragma_s -> pragma_s pragma
Rule 10    decl -> object_decl
Rule 11    decl -> number_decl
Rule 12    decl -> type_decl
Rule 13    decl -> subtype_decl
Rule 14    decl -> subprog_decl
Rule 15    decl -> pkg_decl
Rule 16    decl -> task_decl
Rule 17    decl -> prot_decl
Rule 18    decl -> exception_decl
Rule 19    decl -> rename_decl
Rule 20    decl -> generic_decl
Rule 21    decl -> body_stub
Rule 22    decl -> error ;
Rule 23    object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ;
Rule 24    def_id_s -> def_id
Rule 25    def_id_s -> def_id_s , def_id
Rule 26    def_id -> IDENTIFIER
Rule 27    object_qualifier_opt -> <empty>
Rule 28    object_qualifier_opt -> ALIASED
Rule 29    object_qualifier_opt -> ALIASED CONSTANT
Rule 30    object_qualifier_opt -> CONSTANT
Rule 31    object_subtype_def -> subtype_ind
Rule 32    object_subtype_def -> array_type
Rule 33    init_opt -> <empty>
Rule 34    init_opt -> ASSIGNMENT expression
Rule 35    number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ;
Rule 36    type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ;
Rule 37    discrim_part_opt -> <empty>
Rule 38    discrim_part_opt -> discrim_part
Rule 39    discrim_part_opt -> ( LESSMORE )
Rule 40    type_completion -> <empty>
Rule 41    type_completion -> IS type_def
Rule 42    type_def -> enumeration_type
Rule 43    type_def -> integer_type
Rule 44    type_def -> real_type
Rule 45    type_def -> array_type
Rule 46    type_def -> record_type
Rule 47    type_def -> access_type
Rule 48    type_def -> derived_type
Rule 49    type_def -> private_type
Rule 50    subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ;
Rule 51    subtype_ind -> name constraint
Rule 52    subtype_ind -> name
Rule 53    constraint -> range_constraint
Rule 54    constraint -> decimal_digits_constraint
Rule 55    decimal_digits_constraint -> DIGITS expression range_constr_opt
Rule 56    derived_type -> NEW subtype_ind
Rule 57    derived_type -> NEW subtype_ind WITH PRIVATE
Rule 58    derived_type -> NEW subtype_ind WITH record_def
Rule 59    derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE
Rule 60    derived_type -> ABSTRACT NEW subtype_ind WITH record_def
Rule 61    range_constraint -> RANGE range
Rule 62    range -> simple_expression DOTDOT simple_expression
Rule 63    range -> name
Rule 64    enumeration_type -> ( enum_id_s )
Rule 65    enum_id_s -> enum_id
Rule 66    enum_id_s -> enum_id_s , enum_id
Rule 67    enum_id -> IDENTIFIER
Rule 68    enum_id -> CHAR
Rule 69    integer_type -> range_spec
Rule 70    range_spec -> range_constraint
Rule 71    range_spec_opt -> <empty>
Rule 72    range_spec_opt -> range_spec
Rule 73    real_type -> float_type
Rule 74    real_type -> fixed_type
Rule 75    float_type -> DIGITS expression range_spec_opt
Rule 76    fixed_type -> DELTA expression range_spec
Rule 77    fixed_type -> DELTA expression DIGITS expression range_spec_opt
Rule 78    array_type -> unconstr_array_type
Rule 79    array_type -> constr_array_type
Rule 80    unconstr_array_type -> ARRAY ( index_s ) OF component_subtype_def
Rule 81    constr_array_type -> ARRAY iter_index_constraint OF subtype_ind
Rule 82    component_subtype_def -> aliased_opt subtype_ind
Rule 83    aliased_opt -> <empty>
Rule 84    aliased_opt -> ALIASED
Rule 85    index_s -> index
Rule 86    index_s -> index_s , index
Rule 87    index -> name RANGE LESSMORE
Rule 88    iter_index_constraint -> ( iter_discrete_range_s )
Rule 89    iter_discrete_range_s -> discrete_range
Rule 90    iter_discrete_range_s -> iter_discrete_range_s , discrete_range
Rule 91    discrete_range -> name range_constr_opt
Rule 92    discrete_range -> range
Rule 93    range_constr_opt -> <empty>
Rule 94    range_constr_opt -> range_constraint
Rule 95    record_type -> tagged_opt limited_opt record_def
Rule 96    record_def -> RECORD pragma_s comp_list END RECORD
Rule 97    record_def -> NuLL RECORD
Rule 98    tagged_opt -> <empty>
Rule 99    tagged_opt -> TAGGED
Rule 100   tagged_opt -> ABSTRACT TAGGED
Rule 101   comp_list -> comp_decl_s variant_part_opt
Rule 102   comp_list -> variant_part pragma_s
Rule 103   comp_list -> NuLL ; pragma_s
Rule 104   comp_decl_s -> comp_decl
Rule 105   comp_decl_s -> comp_decl_s pragma_s comp_decl
Rule 106   variant_part_opt -> pragma_s
Rule 107   variant_part_opt -> pragma_s variant_part pragma_s
Rule 108   comp_decl -> def_id_s : component_subtype_def init_opt ;
Rule 109   comp_decl -> error ;
Rule 110   discrim_part -> ( discrim_spec_s )
Rule 111   discrim_spec_s -> discrim_spec
Rule 112   discrim_spec_s -> discrim_spec_s ; discrim_spec
Rule 113   discrim_spec -> def_id_s : access_opt mark init_opt
Rule 114   discrim_spec -> error
Rule 115   access_opt -> <empty>
Rule 116   access_opt -> ACCESS
Rule 117   variant_part -> CASE simple_name IS pragma_s variant_s END CASE ;
Rule 118   variant_s -> variant
Rule 119   variant_s -> variant_s variant
Rule 120   variant -> WHEN choice_s ARROW pragma_s comp_list
Rule 121   choice_s -> choice
Rule 122   choice_s -> choice_s | choice
Rule 123   choice -> expression
Rule 124   choice -> discrete_with_range
Rule 125   choice -> OTHERS
Rule 126   discrete_with_range -> name range_constraint
Rule 127   discrete_with_range -> range
Rule 128   access_type -> ACCESS subtype_ind
Rule 129   access_type -> ACCESS CONSTANT subtype_ind
Rule 130   access_type -> ACCESS ALL subtype_ind
Rule 131   access_type -> ACCESS prot_opt PROCEDURE formal_part_opt
Rule 132   access_type -> ACCESS prot_opt FUNCTION formal_part_opt RETURN mark
Rule 133   prot_opt -> <empty>
Rule 134   prot_opt -> PROTECTED
Rule 135   decl_part -> <empty>
Rule 136   decl_part -> decl_item_or_body_s1
Rule 137   decl_item_s -> <empty>
Rule 138   decl_item_s -> decl_item_s1
Rule 139   decl_item_s1 -> decl_item
Rule 140   decl_item_s1 -> decl_item_s1 decl_item
Rule 141   decl_item -> decl
Rule 142   decl_item -> use_clause
Rule 143   decl_item -> rep_spec
Rule 144   decl_item -> pragma
Rule 145   decl_item_or_body_s1 -> decl_item_or_body
Rule 146   decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body
Rule 147   decl_item_or_body -> body
Rule 148   decl_item_or_body -> decl_item
Rule 149   body -> subprog_body
Rule 150   body -> pkg_body
Rule 151   body -> task_body
Rule 152   body -> prot_body
Rule 153   name -> simple_name
Rule 154   name -> indexed_comp
Rule 155   name -> selected_comp
Rule 156   name -> attribute
Rule 157   name -> operator_symbol
Rule 158   mark -> simple_name
Rule 159   mark -> mark TICK attribute_id
Rule 160   mark -> mark . simple_name
Rule 161   simple_name -> IDENTIFIER
Rule 162   compound_name -> simple_name
Rule 163   compound_name -> compound_name . simple_name
Rule 164   c_name_list -> compound_name
Rule 165   c_name_list -> c_name_list , compound_name
Rule 166   used_char -> CHAR
Rule 167   operator_symbol -> STRING
Rule 168   indexed_comp -> name ( value_s )
Rule 169   value_s -> value
Rule 170   value_s -> value_s , value
Rule 171   value -> expression
Rule 172   value -> comp_assoc
Rule 173   value -> error
Rule 174   selected_comp -> name . simple_name
Rule 175   selected_comp -> name . used_char
Rule 176   selected_comp -> name . operator_symbol
Rule 177   selected_comp -> name . ALL
Rule 178   attribute -> name TICK attribute_id
Rule 179   attribute_id -> IDENTIFIER
Rule 180   attribute_id -> DIGITS
Rule 181   attribute_id -> DELTA
Rule 182   attribute_id -> ACCESS
Rule 183   literal -> INTEGER
Rule 184   literal -> BASE_INTEGER
Rule 185   literal -> FLOAT
Rule 186   literal -> BASE_FLOAT
Rule 187   literal -> used_char
Rule 188   literal -> NuLL
Rule 189   aggregate -> ( comp_assoc )
Rule 190   aggregate -> ( value_s_2 )
Rule 191   aggregate -> ( expression WITH value_s )
Rule 192   aggregate -> ( expression WITH NuLL RECORD )
Rule 193   aggregate -> ( NuLL RECORD )
Rule 194   value_s_2 -> value , value
Rule 195   value_s_2 -> value_s_2 , value
Rule 196   comp_assoc -> choice_s ARROW expression
Rule 197   m -> <empty>
Rule 198   expression -> relation
Rule 199   expression -> expression logical m relation
Rule 200   expression -> expression short_circuit m relation
Rule 201   logical -> AND
Rule 202   logical -> OR
Rule 203   short_circuit -> AND THEN
Rule 204   short_circuit -> OR ELSE
Rule 205   relation -> simple_expression
Rule 206   relation -> simple_expression relational simple_expression
Rule 207   relation -> simple_expression membership range
Rule 208   relation -> simple_expression membership name
Rule 209   relational -> =
Rule 210   relational -> NOTEQUAL
Rule 211   relational -> <
Rule 212   relational -> LESSEQ
Rule 213   relational -> >
Rule 214   relational -> GREATEREQ
Rule 215   membership -> IN
Rule 216   membership -> NOT IN
Rule 217   simple_expression -> unary term
Rule 218   simple_expression -> term
Rule 219   simple_expression -> simple_expression adding term
Rule 220   unary -> +
Rule 221   unary -> -
Rule 222   adding -> +
Rule 223   adding -> -
Rule 224   adding -> &
Rule 225   term -> factor
Rule 226   term -> term multiplying factor
Rule 227   multiplying -> *
Rule 228   multiplying -> /
Rule 229   multiplying -> MOD
Rule 230   multiplying -> REM
Rule 231   factor -> primary
Rule 232   factor -> NOT primary
Rule 233   factor -> primary STARSTAR primary
Rule 234   primary -> literal
Rule 235   primary -> name
Rule 236   primary -> allocator
Rule 237   primary -> qualified
Rule 238   primary -> parenthesized_primary
Rule 239   parenthesized_primary -> aggregate
Rule 240   parenthesized_primary -> ( expression )
Rule 241   qualified -> name TICK parenthesized_primary
Rule 242   allocator -> NEW name
Rule 243   allocator -> NEW qualified
Rule 244   statement_s -> statement
Rule 245   statement_s -> statement_s m statement
Rule 246   statement -> unlabeled
Rule 247   statement -> label statement
Rule 248   unlabeled -> simple_stmt
Rule 249   unlabeled -> compound_stmt
Rule 250   unlabeled -> pragma
Rule 251   simple_stmt -> null_stmt
Rule 252   simple_stmt -> assign_stmt
Rule 253   simple_stmt -> exit_stmt
Rule 254   simple_stmt -> return_stmt
Rule 255   simple_stmt -> goto_stmt
Rule 256   simple_stmt -> procedure_call
Rule 257   simple_stmt -> delay_stmt
Rule 258   simple_stmt -> abort_stmt
Rule 259   simple_stmt -> raise_stmt
Rule 260   simple_stmt -> code_stmt
Rule 261   simple_stmt -> requeue_stmt
Rule 262   simple_stmt -> error ;
Rule 263   compound_stmt -> if_stmt
Rule 264   compound_stmt -> case_stmt
Rule 265   compound_stmt -> loop_stmt
Rule 266   compound_stmt -> block
Rule 267   compound_stmt -> accept_stmt
Rule 268   compound_stmt -> select_stmt
Rule 269   label -> LESSLESS IDENTIFIER MOREMORE
Rule 270   null_stmt -> NuLL ;
Rule 271   assign_stmt -> name ASSIGNMENT expression ;
Rule 272   if_stmt -> IF cond_clause_s else_opt END IF ;
Rule 273   cond_clause_s -> cond_clause
Rule 274   cond_clause_s -> cond_clause ELSIF m cond_clause_s
Rule 275   n -> <empty>
Rule 276   cond_clause -> cond_part m statement_s n
Rule 277   cond_part -> condition THEN
Rule 278   condition -> expression
Rule 279   else_opt -> <empty>
Rule 280   else_opt -> ELSE m statement_s
Rule 281   case_stmt -> case_hdr pragma_s alternative_s END CASE ;
Rule 282   case_hdr -> CASE expression IS
Rule 283   alternative_s -> <empty>
Rule 284   alternative_s -> alternative_s alternative
Rule 285   alternative -> WHEN choice_s ARROW statement_s
Rule 286   loop_stmt -> label_opt iteration m basic_loop id_opt ;
Rule 287   label_opt -> <empty>
Rule 288   label_opt -> IDENTIFIER :
Rule 289   iteration -> <empty>
Rule 290   iteration -> WHILE m condition
Rule 291   iteration -> iter_part reverse_opt discrete_range
Rule 292   iter_part -> FOR IDENTIFIER IN
Rule 293   reverse_opt -> <empty>
Rule 294   reverse_opt -> REVERSE
Rule 295   basic_loop -> LOOP statement_s END LOOP
Rule 296   id_opt -> <empty>
Rule 297   id_opt -> designator
Rule 298   block -> label_opt block_decl block_body END id_opt ;
Rule 299   block_decl -> <empty>
Rule 300   block_decl -> DECLARE decl_part
Rule 301   block_body -> BEGIN handled_stmt_s
Rule 302   handled_stmt_s -> statement_s except_handler_part_opt
Rule 303   except_handler_part_opt -> <empty>
Rule 304   except_handler_part_opt -> except_handler_part
Rule 305   exit_stmt -> EXIT name_opt when_opt ;
Rule 306   name_opt -> <empty>
Rule 307   name_opt -> name
Rule 308   when_opt -> <empty>
Rule 309   when_opt -> WHEN condition
Rule 310   return_stmt -> RETURN ;
Rule 311   return_stmt -> RETURN expression ;
Rule 312   goto_stmt -> GOTO name ;
Rule 313   subprog_decl -> subprog_spec ;
Rule 314   subprog_decl -> generic_subp_inst ;
Rule 315   subprog_decl -> subprog_spec_is_push ABSTRACT ;
Rule 316   subprog_spec -> PROCEDURE compound_name formal_part_opt
Rule 317   subprog_spec -> FUNCTION designator formal_part_opt RETURN name
Rule 318   subprog_spec -> FUNCTION designator
Rule 319   designator -> compound_name
Rule 320   designator -> STRING
Rule 321   formal_part_opt -> <empty>
Rule 322   formal_part_opt -> formal_part
Rule 323   formal_part -> ( param_s )
Rule 324   param_s -> param
Rule 325   param_s -> param_s ; param
Rule 326   param -> def_id_s : mode mark init_opt
Rule 327   param -> error
Rule 328   mode -> <empty>
Rule 329   mode -> IN
Rule 330   mode -> OUT
Rule 331   mode -> IN OUT
Rule 332   mode -> ACCESS
Rule 333   subprog_spec_is_push -> subprog_spec IS
Rule 334   subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ;
Rule 335   procedure_call -> name ;
Rule 336   pkg_decl -> pkg_spec ;
Rule 337   pkg_decl -> generic_pkg_inst ;
Rule 338   pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END c_id_opt
Rule 339   private_part -> <empty>
Rule 340   private_part -> PRIVATE decl_item_s
Rule 341   c_id_opt -> <empty>
Rule 342   c_id_opt -> compound_name
Rule 343   pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
Rule 344   body_opt -> <empty>
Rule 345   body_opt -> block_body
Rule 346   private_type -> tagged_opt limited_opt PRIVATE
Rule 347   limited_opt -> <empty>
Rule 348   limited_opt -> LIMITED
Rule 349   use_clause -> USE name_s ;
Rule 350   use_clause -> USE TYPE name_s ;
Rule 351   name_s -> name
Rule 352   name_s -> name_s , name
Rule 353   rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ;
Rule 354   rename_decl -> def_id_s : EXCEPTION renames ;
Rule 355   rename_decl -> rename_unit
Rule 356   rename_unit -> PACKAGE compound_name renames ;
Rule 357   rename_unit -> subprog_spec renames ;
Rule 358   rename_unit -> generic_formal_part PACKAGE compound_name renames ;
Rule 359   rename_unit -> generic_formal_part subprog_spec renames ;
Rule 360   renames -> RENAMES name
Rule 361   task_decl -> task_spec ;
Rule 362   task_spec -> TASK simple_name task_def
Rule 363   task_spec -> TASK TYPE simple_name discrim_part_opt task_def
Rule 364   task_def -> <empty>
Rule 365   task_def -> IS entry_decl_s rep_spec_s task_private_opt END id_opt
Rule 366   task_private_opt -> <empty>
Rule 367   task_private_opt -> PRIVATE entry_decl_s rep_spec_s
Rule 368   task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ;
Rule 369   prot_decl -> prot_spec ;
Rule 370   prot_spec -> PROTECTED IDENTIFIER prot_def
Rule 371   prot_spec -> PROTECTED TYPE simple_name discrim_part_opt prot_def
Rule 372   prot_def -> IS prot_op_decl_s prot_private_opt END id_opt
Rule 373   prot_private_opt -> <empty>
Rule 374   prot_private_opt -> PRIVATE prot_elem_decl_s
Rule 375   prot_op_decl_s -> <empty>
Rule 376   prot_op_decl_s -> prot_op_decl_s prot_op_decl
Rule 377   prot_op_decl -> entry_decl
Rule 378   prot_op_decl -> subprog_spec ;
Rule 379   prot_op_decl -> rep_spec
Rule 380   prot_op_decl -> pragma
Rule 381   prot_elem_decl_s -> <empty>
Rule 382   prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl
Rule 383   prot_elem_decl -> prot_op_decl
Rule 384   prot_elem_decl -> comp_decl
Rule 385   prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
Rule 386   prot_op_body_s -> pragma_s
Rule 387   prot_op_body_s -> prot_op_body_s prot_op_body pragma_s
Rule 388   prot_op_body -> entry_body
Rule 389   prot_op_body -> subprog_body
Rule 390   prot_op_body -> subprog_spec ;
Rule 391   entry_decl_s -> pragma_s
Rule 392   entry_decl_s -> entry_decl_s entry_decl pragma_s
Rule 393   entry_decl -> ENTRY IDENTIFIER formal_part_opt ;
Rule 394   entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ;
Rule 395   entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part
Rule 396   entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part
Rule 397   entry_body_part -> ;
Rule 398   entry_body_part -> IS decl_part block_body END id_opt ;
Rule 399   rep_spec_s -> <empty>
Rule 400   rep_spec_s -> rep_spec_s rep_spec pragma_s
Rule 401   entry_call -> procedure_call
Rule 402   accept_stmt -> accept_hdr ;
Rule 403   accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ;
Rule 404   accept_hdr -> ACCEPT entry_name formal_part_opt
Rule 405   entry_name -> simple_name
Rule 406   entry_name -> entry_name ( expression )
Rule 407   delay_stmt -> DELAY expression ;
Rule 408   delay_stmt -> DELAY UNTIL expression ;
Rule 409   select_stmt -> select_wait
Rule 410   select_stmt -> async_select
Rule 411   select_stmt -> timed_entry_call
Rule 412   select_stmt -> cond_entry_call
Rule 413   select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ;
Rule 414   guarded_select_alt -> select_alt
Rule 415   guarded_select_alt -> WHEN condition ARROW select_alt
Rule 416   or_select -> <empty>
Rule 417   or_select -> or_select OR guarded_select_alt
Rule 418   select_alt -> accept_stmt stmts_opt
Rule 419   select_alt -> delay_stmt stmts_opt
Rule 420   select_alt -> TERMINATE ;
Rule 421   delay_or_entry_alt -> delay_stmt stmts_opt
Rule 422   delay_or_entry_alt -> entry_call stmts_opt
Rule 423   async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
Rule 424   timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
Rule 425   cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
Rule 426   stmts_opt -> <empty>
Rule 427   stmts_opt -> statement_s
Rule 428   abort_stmt -> ABORT name_s ;
Rule 429   compilation -> <empty>
Rule 430   compilation -> compilation comp_unit
Rule 431   compilation -> pragma pragma_s
Rule 432   comp_unit -> context_spec private_opt unit pragma_s
Rule 433   comp_unit -> private_opt unit pragma_s
Rule 434   private_opt -> <empty>
Rule 435   private_opt -> PRIVATE
Rule 436   context_spec -> with_clause use_clause_opt
Rule 437   context_spec -> context_spec with_clause use_clause_opt
Rule 438   context_spec -> context_spec pragma
Rule 439   with_clause -> WITH c_name_list ;
Rule 440   use_clause_opt -> <empty>
Rule 441   use_clause_opt -> use_clause_opt use_clause
Rule 442   unit -> pkg_decl
Rule 443   unit -> pkg_body
Rule 444   unit -> subprog_decl
Rule 445   unit -> subprog_body
Rule 446   unit -> subunit
Rule 447   unit -> generic_decl
Rule 448   unit -> rename_unit
Rule 449   subunit -> SEPARATE ( compound_name ) subunit_body
Rule 450   subunit_body -> subprog_body
Rule 451   subunit_body -> pkg_body
Rule 452   subunit_body -> task_body
Rule 453   subunit_body -> prot_body
Rule 454   body_stub -> TASK BODY simple_name IS SEPARATE ;
Rule 455   body_stub -> PACKAGE BODY compound_name IS SEPARATE ;
Rule 456   body_stub -> subprog_spec IS SEPARATE ;
Rule 457   body_stub -> PROTECTED BODY simple_name IS SEPARATE ;
Rule 458   exception_decl -> def_id_s : EXCEPTION ;
Rule 459   except_handler_part -> EXCEPTION exception_handler
Rule 460   except_handler_part -> except_handler_part exception_handler
Rule 461   exception_handler -> WHEN except_choice_s ARROW statement_s
Rule 462   exception_handler -> WHEN IDENTIFIER : except_choice_s ARROW statement_s
Rule 463   except_choice_s -> except_choice
Rule 464   except_choice_s -> except_choice_s | except_choice
Rule 465   except_choice -> name
Rule 466   except_choice -> OTHERS
Rule 467   raise_stmt -> RAISE name_opt ;
Rule 468   requeue_stmt -> REQUEUE name ;
Rule 469   requeue_stmt -> REQUEUE name WITH ABORT ;
Rule 470   generic_decl -> generic_formal_part subprog_spec ;
Rule 471   generic_decl -> generic_formal_part pkg_spec ;
Rule 472   generic_formal_part -> GENERIC
Rule 473   generic_formal_part -> generic_formal_part generic_formal
Rule 474   generic_formal -> param ;
Rule 475   generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ;
Rule 476   generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ;
Rule 477   generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ;
Rule 478   generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ;
Rule 479   generic_formal -> WITH PACKAGE simple_name IS NEW name ;
Rule 480   generic_formal -> use_clause
Rule 481   generic_discrim_part_opt -> <empty>
Rule 482   generic_discrim_part_opt -> discrim_part
Rule 483   generic_discrim_part_opt -> ( LESSMORE )
Rule 484   subp_default -> <empty>
Rule 485   subp_default -> IS name
Rule 486   subp_default -> IS LESSMORE
Rule 487   generic_type_def -> ( LESSMORE )
Rule 488   generic_type_def -> RANGE LESSMORE
Rule 489   generic_type_def -> MOD LESSMORE
Rule 490   generic_type_def -> DELTA LESSMORE
Rule 491   generic_type_def -> DELTA LESSMORE DIGITS LESSMORE
Rule 492   generic_type_def -> DIGITS LESSMORE
Rule 493   generic_type_def -> array_type
Rule 494   generic_type_def -> access_type
Rule 495   generic_type_def -> private_type
Rule 496   generic_type_def -> generic_derived_type
Rule 497   generic_derived_type -> NEW subtype_ind
Rule 498   generic_derived_type -> NEW subtype_ind WITH PRIVATE
Rule 499   generic_derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE
Rule 500   generic_subp_inst -> subprog_spec IS generic_inst
Rule 501   generic_pkg_inst -> PACKAGE compound_name IS generic_inst
Rule 502   generic_inst -> NEW name
Rule 503   rep_spec -> attrib_def
Rule 504   rep_spec -> record_type_spec
Rule 505   rep_spec -> address_spec
Rule 506   attrib_def -> FOR mark USE expression ;
Rule 507   record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
Rule 508   align_opt -> <empty>
Rule 509   align_opt -> AT MOD expression ;
Rule 510   comp_loc_s -> <empty>
Rule 511   comp_loc_s -> comp_loc_s mark AT expression RANGE range ;
Rule 512   address_spec -> FOR mark USE AT expression ;
Rule 513   code_stmt -> qualified ;

Terminals, with rules where they appear

&                    : 224
(                    : 3 39 64 80 88 110 168 189 190 191 192 193 240 323 394 396 406 449 478 483 487
)                    : 3 39 64 80 88 110 168 189 190 191 192 193 240 323 394 396 406 449 478 483 487
*                    : 227
+                    : 220 222
,                    : 5 25 66 86 90 165 170 194 195 352
-                    : 221 223
.                    : 160 163 174 175 176 177
/                    : 228
:                    : 23 35 108 113 288 326 353 354 458 462
;                    : 2 3 22 23 35 36 50 103 108 109 112 117 262 270 271 272 281 286 298 305 310 311 312 313 314 315 325 334 335 336 337 343 349 350 353 354 356 357 358 359 361 368 369 378 385 390 393 394 397 398 402 403 407 408 413 420 423 424 425 428 439 454 455 456 457 458 467 468 469 470 471 474 475 476 477 478 479 506 507 509 511 512 513
<                    : 211
=                    : 209
>                    : 213
ABORT                : 423 428 469
ABS                  : 
ABSTRACT             : 59 60 100 315 499
ACCEPT               : 404
ACCESS               : 116 128 129 130 131 132 182 332
ALIASED              : 28 29 84
ALL                  : 130 177
AND                  : 201 203
ARRAY                : 80 81
ARROW                : 7 120 196 285 415 461 462
ASSIGNMENT           : 34 35 271
AT                   : 509 511 512
BASE_FLOAT           : 186
BASE_INTEGER         : 184
BEGIN                : 301
BODY                 : 343 368 385 454 455 457
CASE                 : 117 117 281 282
CHAR                 : 68 166
CONSTANT             : 29 30 35 129
DECLARE              : 300
DELAY                : 407 408
DELTA                : 76 77 181 490 491
DIGITS               : 55 75 77 180 491 492
DO                   : 403
DOTDOT               : 62
ELSE                 : 204 280 425
ELSIF                : 274
END                  : 96 117 272 281 295 298 334 338 343 365 368 372 385 398 403 413 423 424 425 507
ENTRY                : 393 394 395 396
EXCEPTION            : 354 458 459
EXIT                 : 305
FLOAT                : 185
FOR                  : 292 506 507 512
FUNCTION             : 132 317 318 477
GENERIC              : 472
GOTO                 : 312
GREATEREQ            : 214
IDENTIFIER           : 2 26 36 50 67 161 179 269 288 292 370 393 394 395 396 462
IF                   : 272 272
IN                   : 215 216 292 329 331
INTEGER              : 183
IS                   : 41 50 117 282 333 338 343 365 368 372 385 398 454 455 456 457 475 478 479 485 486 500 501
LESSEQ               : 212
LESSLESS             : 269
LESSMORE             : 39 87 478 483 486 487 488 489 490 491 491 492
LIMITED              : 348
LOOP                 : 295 295
MOD                  : 229 489 509
MOREMORE             : 269
NEW                  : 56 57 58 59 60 242 243 478 479 497 498 499 502
NOT                  : 216 232
NOTEQUAL             : 210
NuLL                 : 97 103 188 192 193 270
OF                   : 80 81
OR                   : 202 204 417 424
OTHERS               : 125 466
OUT                  : 330 331
PACKAGE              : 338 343 356 358 455 478 479 501
PRAGMA               : 2 3
PRIVATE              : 57 59 340 346 367 374 435 498 499
PROCEDURE            : 131 316 476
PROTECTED            : 134 370 371 385 457
RAISE                : 467
RANGE                : 61 87 488 511
RECORD               : 96 96 97 192 193 507 507
REM                  : 230
RENAMES              : 360
REQUEUE              : 468 469
RETURN               : 132 310 311 317 477
REVERSE              : 294
SELECT               : 413 413 423 423 424 424 425 425
SEPARATE             : 449 454 455 456 457
STARSTAR             : 233
STRING               : 167 320
SUBTYPE              : 50
TAGGED               : 99 100
TASK                 : 362 363 368 454
TERMINATE            : 420
THEN                 : 203 277 423
TICK                 : 159 178 241
TYPE                 : 36 350 363 371 475
UNTIL                : 408
USE                  : 349 350 506 507 512
WHEN                 : 120 285 309 395 396 415 461 462
WHILE                : 290
WITH                 : 57 58 59 60 191 192 439 469 476 477 478 479 498 499
XOR                  : 
error                : 22 109 114 173 262 327
|                    : 122 464

Nonterminals, with rules where they appear

abort_stmt           : 258
accept_hdr           : 402 403
accept_stmt          : 267 418
access_opt           : 113
access_type          : 47 494
adding               : 219
address_spec         : 505
aggregate            : 239
aliased_opt          : 82
align_opt            : 507
allocator            : 236
alternative          : 284
alternative_s        : 281 284
array_type           : 32 45 493
assign_stmt          : 252
async_select         : 410
attrib_def           : 503
attribute            : 156
attribute_id         : 159 178
basic_loop           : 286
block                : 266
block_body           : 298 334 345 368 398
block_decl           : 298
body                 : 147
body_opt             : 343
body_stub            : 21
c_id_opt             : 338 343
c_name_list          : 165 439
case_hdr             : 281
case_stmt            : 264
choice               : 121 122
choice_s             : 120 122 196 285
code_stmt            : 260
comp_assoc           : 172 189
comp_decl            : 104 105 384
comp_decl_s          : 101 105
comp_list            : 96 120
comp_loc_s           : 507 511
comp_unit            : 430
compilation          : 1 430
component_subtype_def : 80 108
compound_name        : 163 164 165 316 319 338 342 343 356 358 449 455 501
compound_stmt        : 249
cond_clause          : 273 274
cond_clause_s        : 272 274
cond_entry_call      : 412
cond_part            : 276
condition            : 277 290 309 395 396 415
constr_array_type    : 79
constraint           : 51
context_spec         : 432 437 438
decimal_digits_constraint : 54
decl                 : 141
decl_item            : 139 140 148
decl_item_or_body    : 145 146
decl_item_or_body_s1 : 136 146
decl_item_s          : 338 340
decl_item_s1         : 138 140
decl_part            : 300 334 343 368 398
def_id               : 24 25
def_id_s             : 23 25 35 108 113 326 353 354 458
delay_or_entry_alt   : 423
delay_stmt           : 257 419 421 424
derived_type         : 48
designator           : 297 317 318 477
discrete_range       : 89 90 291 394 396
discrete_with_range  : 124
discrim_part         : 38 482
discrim_part_opt     : 36 363 371
discrim_spec         : 111 112
discrim_spec_s       : 110 112
else_opt             : 272 413
entry_body           : 388
entry_body_part      : 395 396
entry_call           : 422 424 425
entry_decl           : 377 392
entry_decl_s         : 365 367 392
entry_name           : 404 406
enum_id              : 65 66
enum_id_s            : 64 66
enumeration_type     : 42
except_choice        : 463 464
except_choice_s      : 461 462 464
except_handler_part  : 304 460
except_handler_part_opt : 302
exception_decl       : 18
exception_handler    : 459 460
exit_stmt            : 253
expression           : 6 7 34 35 55 75 76 77 77 123 171 191 192 196 199 200 240 271 278 282 311 406 407 408 506 509 511 512
factor               : 225 226
fixed_type           : 74
float_type           : 73
formal_part          : 322
formal_part_opt      : 131 132 316 317 393 394 395 396 404 476 477
generic_decl         : 20 447
generic_derived_type : 496
generic_discrim_part_opt : 475
generic_formal       : 473
generic_formal_part  : 358 359 470 471 473
generic_inst         : 500 501
generic_pkg_inst     : 337
generic_subp_inst    : 314
generic_type_def     : 475
goto_stmt            : 255
guarded_select_alt   : 413 417
handled_stmt_s       : 301 403
id_opt               : 286 298 334 365 368 372 385 398 403
if_stmt              : 263
index                : 85 86
index_s              : 80 86
indexed_comp         : 154
init_opt             : 23 108 113 326
integer_type         : 43
iter_discrete_range_s : 88 90
iter_index_constraint : 81
iter_part            : 291 396
iteration            : 286
label                : 247
label_opt            : 286 298
limited_opt          : 95 346
literal              : 234
logical              : 199
loop_stmt            : 265
m                    : 199 200 245 274 276 280 286 290
mark                 : 113 132 159 160 326 506 507 511 512
membership           : 207 208
mode                 : 326
multiplying          : 226
n                    : 276
name                 : 51 52 63 87 91 126 168 174 175 176 177 178 208 235 241 242 271 307 312 317 335 351 352 360 465 468 469 477 478 479 485 502
name_opt             : 305 467
name_s               : 349 350 352 428
null_stmt            : 251
number_decl          : 11
object_decl          : 10
object_qualifier_opt : 23 353
object_subtype_def   : 23
operator_symbol      : 157 176
or_select            : 413 417
param                : 324 325 474
param_s              : 323 325
parenthesized_primary : 238 241
pkg_body             : 150 443 451
pkg_decl             : 15 442
pkg_spec             : 336 471
pragma               : 9 144 250 380 431 438
pragma_arg           : 4 5
pragma_arg_s         : 3 5
pragma_s             : 9 96 102 103 105 106 107 107 117 120 281 386 387 391 392 400 431 432 433
primary              : 231 232 233 233
private_opt          : 432 433
private_part         : 338
private_type         : 49 495
procedure_call       : 256 401
prot_body            : 152 453
prot_decl            : 17
prot_def             : 370 371
prot_elem_decl       : 382
prot_elem_decl_s     : 374 382
prot_op_body         : 387
prot_op_body_s       : 385 387
prot_op_decl         : 376 383
prot_op_decl_s       : 372 376
prot_opt             : 131 132
prot_private_opt     : 372
prot_spec            : 369
qualified            : 237 243 513
raise_stmt           : 259
range                : 61 92 127 207 511
range_constr_opt     : 55 91
range_constraint     : 53 70 94 126
range_spec           : 69 72 76
range_spec_opt       : 75 77
real_type            : 44
record_def           : 58 60 95
record_type          : 46
record_type_spec     : 504
relation             : 198 199 200
relational           : 206
rename_decl          : 19
rename_unit          : 355 448
renames              : 353 354 356 357 358 359
rep_spec             : 143 379 400
rep_spec_s           : 365 367 400
requeue_stmt         : 261
return_stmt          : 254
reverse_opt          : 291
select_alt           : 414 415
select_stmt          : 268
select_wait          : 409
selected_comp        : 155
short_circuit        : 200
simple_expression    : 62 62 205 206 206 207 208 219
simple_name          : 3 7 117 153 158 160 162 163 174 362 363 368 371 385 405 454 457 475 476 478 479
simple_stmt          : 248
start_symbol         : 0
statement            : 244 245 247
statement_s          : 245 276 280 285 295 302 423 425 427 461 462
stmts_opt            : 418 419 421 422 424 424 425
subp_default         : 476 477
subprog_body         : 149 389 445 450
subprog_decl         : 14 444
subprog_spec         : 313 333 357 359 378 390 456 470 500
subprog_spec_is_push : 315 334
subtype_decl         : 13
subtype_ind          : 31 50 56 57 58 59 60 81 82 128 129 130 353 497 498 499
subunit              : 446
subunit_body         : 449
tagged_opt           : 95 346
task_body            : 151 452
task_decl            : 16
task_def             : 362 363
task_private_opt     : 365
task_spec            : 361
term                 : 217 218 219 226
timed_entry_call     : 411
type_completion      : 36
type_decl            : 12
type_def             : 41
unary                : 217
unconstr_array_type  : 78
unit                 : 432 433
unlabeled            : 246
use_clause           : 142 441 480
use_clause_opt       : 436 437 441
used_char            : 175 187
value                : 169 170 194 194 195
value_s              : 168 170 191
value_s_2            : 190 195
variant              : 118 119
variant_part         : 102 107
variant_part_opt     : 101
variant_s            : 117 119
when_opt             : 305
with_clause          : 436 437

Parsing method: LALR

state 0

    (0) S' -> . start_symbol
    (1) start_symbol -> . compilation
    (429) compilation -> .
    (430) compilation -> . compilation comp_unit
    (431) compilation -> . pragma pragma_s
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    PRIVATE         reduce using rule 429 (compilation -> .)
    WITH            reduce using rule 429 (compilation -> .)
    PACKAGE         reduce using rule 429 (compilation -> .)
    SEPARATE        reduce using rule 429 (compilation -> .)
    PROCEDURE       reduce using rule 429 (compilation -> .)
    FUNCTION        reduce using rule 429 (compilation -> .)
    GENERIC         reduce using rule 429 (compilation -> .)
    $end            reduce using rule 429 (compilation -> .)
    PRAGMA          shift and go to state 4

    start_symbol                   shift and go to state 1
    compilation                    shift and go to state 3
    pragma                         shift and go to state 2

state 1

    (0) S' -> start_symbol .



state 2

    (431) compilation -> pragma . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    WITH            reduce using rule 8 (pragma_s -> .)
    PACKAGE         reduce using rule 8 (pragma_s -> .)
    SEPARATE        reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)
    GENERIC         reduce using rule 8 (pragma_s -> .)
    $end            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 5

state 3

    (1) start_symbol -> compilation .
    (430) compilation -> compilation . comp_unit
    (432) comp_unit -> . context_spec private_opt unit pragma_s
    (433) comp_unit -> . private_opt unit pragma_s
    (436) context_spec -> . with_clause use_clause_opt
    (437) context_spec -> . context_spec with_clause use_clause_opt
    (438) context_spec -> . context_spec pragma
    (434) private_opt -> .
    (435) private_opt -> . PRIVATE
    (439) with_clause -> . WITH c_name_list ;

    $end            reduce using rule 1 (start_symbol -> compilation .)
    PACKAGE         reduce using rule 434 (private_opt -> .)
    SEPARATE        reduce using rule 434 (private_opt -> .)
    PROCEDURE       reduce using rule 434 (private_opt -> .)
    FUNCTION        reduce using rule 434 (private_opt -> .)
    GENERIC         reduce using rule 434 (private_opt -> .)
    PRIVATE         shift and go to state 7
    WITH            shift and go to state 11

    context_spec                   shift and go to state 6
    with_clause                    shift and go to state 8
    private_opt                    shift and go to state 9
    comp_unit                      shift and go to state 10

state 4

    (2) pragma -> PRAGMA . IDENTIFIER ;
    (3) pragma -> PRAGMA . simple_name ( pragma_arg_s ) ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 12

    simple_name                    shift and go to state 13

state 5

    (431) compilation -> pragma pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    PRIVATE         reduce using rule 431 (compilation -> pragma pragma_s .)
    WITH            reduce using rule 431 (compilation -> pragma pragma_s .)
    PACKAGE         reduce using rule 431 (compilation -> pragma pragma_s .)
    SEPARATE        reduce using rule 431 (compilation -> pragma pragma_s .)
    PROCEDURE       reduce using rule 431 (compilation -> pragma pragma_s .)
    FUNCTION        reduce using rule 431 (compilation -> pragma pragma_s .)
    GENERIC         reduce using rule 431 (compilation -> pragma pragma_s .)
    $end            reduce using rule 431 (compilation -> pragma pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 6

    (432) comp_unit -> context_spec . private_opt unit pragma_s
    (437) context_spec -> context_spec . with_clause use_clause_opt
    (438) context_spec -> context_spec . pragma
    (434) private_opt -> .
    (435) private_opt -> . PRIVATE
    (439) with_clause -> . WITH c_name_list ;
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    PACKAGE         reduce using rule 434 (private_opt -> .)
    SEPARATE        reduce using rule 434 (private_opt -> .)
    PROCEDURE       reduce using rule 434 (private_opt -> .)
    FUNCTION        reduce using rule 434 (private_opt -> .)
    GENERIC         reduce using rule 434 (private_opt -> .)
    PRIVATE         shift and go to state 7
    WITH            shift and go to state 11
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 15
    with_clause                    shift and go to state 16
    private_opt                    shift and go to state 17

state 7

    (435) private_opt -> PRIVATE .

    PACKAGE         reduce using rule 435 (private_opt -> PRIVATE .)
    SEPARATE        reduce using rule 435 (private_opt -> PRIVATE .)
    PROCEDURE       reduce using rule 435 (private_opt -> PRIVATE .)
    FUNCTION        reduce using rule 435 (private_opt -> PRIVATE .)
    GENERIC         reduce using rule 435 (private_opt -> PRIVATE .)


state 8

    (436) context_spec -> with_clause . use_clause_opt
    (440) use_clause_opt -> .
    (441) use_clause_opt -> . use_clause_opt use_clause

    USE             reduce using rule 440 (use_clause_opt -> .)
    PRIVATE         reduce using rule 440 (use_clause_opt -> .)
    WITH            reduce using rule 440 (use_clause_opt -> .)
    PRAGMA          reduce using rule 440 (use_clause_opt -> .)
    PACKAGE         reduce using rule 440 (use_clause_opt -> .)
    SEPARATE        reduce using rule 440 (use_clause_opt -> .)
    PROCEDURE       reduce using rule 440 (use_clause_opt -> .)
    FUNCTION        reduce using rule 440 (use_clause_opt -> .)
    GENERIC         reduce using rule 440 (use_clause_opt -> .)

    use_clause_opt                 shift and go to state 18

state 9

    (433) comp_unit -> private_opt . unit pragma_s
    (442) unit -> . pkg_decl
    (443) unit -> . pkg_body
    (444) unit -> . subprog_decl
    (445) unit -> . subprog_body
    (446) unit -> . subunit
    (447) unit -> . generic_decl
    (448) unit -> . rename_unit
    (336) pkg_decl -> . pkg_spec ;
    (337) pkg_decl -> . generic_pkg_inst ;
    (343) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (313) subprog_decl -> . subprog_spec ;
    (314) subprog_decl -> . generic_subp_inst ;
    (315) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (334) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (449) subunit -> . SEPARATE ( compound_name ) subunit_body
    (470) generic_decl -> . generic_formal_part subprog_spec ;
    (471) generic_decl -> . generic_formal_part pkg_spec ;
    (356) rename_unit -> . PACKAGE compound_name renames ;
    (357) rename_unit -> . subprog_spec renames ;
    (358) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (359) rename_unit -> . generic_formal_part subprog_spec renames ;
    (338) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (316) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (317) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (318) subprog_spec -> . FUNCTION designator
    (500) generic_subp_inst -> . subprog_spec IS generic_inst
    (333) subprog_spec_is_push -> . subprog_spec IS
    (472) generic_formal_part -> . GENERIC
    (473) generic_formal_part -> . generic_formal_part generic_formal

    PACKAGE         shift and go to state 28
    SEPARATE        shift and go to state 20
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21

    subprog_body                   shift and go to state 19
    pkg_body                       shift and go to state 22
    unit                           shift and go to state 23
    subprog_spec_is_push           shift and go to state 24
    generic_decl                   shift and go to state 25
    subprog_spec                   shift and go to state 26
    subunit                        shift and go to state 27
    generic_subp_inst              shift and go to state 29
    rename_unit                    shift and go to state 30
    pkg_decl                       shift and go to state 32
    generic_formal_part            shift and go to state 33
    generic_pkg_inst               shift and go to state 34
    subprog_decl                   shift and go to state 35
    pkg_spec                       shift and go to state 37

state 10

    (430) compilation -> compilation comp_unit .

    PRIVATE         reduce using rule 430 (compilation -> compilation comp_unit .)
    WITH            reduce using rule 430 (compilation -> compilation comp_unit .)
    PACKAGE         reduce using rule 430 (compilation -> compilation comp_unit .)
    SEPARATE        reduce using rule 430 (compilation -> compilation comp_unit .)
    PROCEDURE       reduce using rule 430 (compilation -> compilation comp_unit .)
    FUNCTION        reduce using rule 430 (compilation -> compilation comp_unit .)
    GENERIC         reduce using rule 430 (compilation -> compilation comp_unit .)
    $end            reduce using rule 430 (compilation -> compilation comp_unit .)


state 11

    (439) with_clause -> WITH . c_name_list ;
    (164) c_name_list -> . compound_name
    (165) c_name_list -> . c_name_list , compound_name
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    c_name_list                    shift and go to state 38
    compound_name                  shift and go to state 40
    simple_name                    shift and go to state 41

state 12

    (2) pragma -> PRAGMA IDENTIFIER . ;
    (161) simple_name -> IDENTIFIER .

    ;               shift and go to state 42
    (               reduce using rule 161 (simple_name -> IDENTIFIER .)


state 13

    (3) pragma -> PRAGMA simple_name . ( pragma_arg_s ) ;

    (               shift and go to state 43


state 14

    (9) pragma_s -> pragma_s pragma .

    NuLL            reduce using rule 9 (pragma_s -> pragma_s pragma .)
    PRAGMA          reduce using rule 9 (pragma_s -> pragma_s pragma .)
    CASE            reduce using rule 9 (pragma_s -> pragma_s pragma .)
    error           reduce using rule 9 (pragma_s -> pragma_s pragma .)
    IDENTIFIER      reduce using rule 9 (pragma_s -> pragma_s pragma .)
    END             reduce using rule 9 (pragma_s -> pragma_s pragma .)
    WHEN            reduce using rule 9 (pragma_s -> pragma_s pragma .)
    ENTRY           reduce using rule 9 (pragma_s -> pragma_s pragma .)
    FOR             reduce using rule 9 (pragma_s -> pragma_s pragma .)
    PRIVATE         reduce using rule 9 (pragma_s -> pragma_s pragma .)
    WITH            reduce using rule 9 (pragma_s -> pragma_s pragma .)
    PACKAGE         reduce using rule 9 (pragma_s -> pragma_s pragma .)
    SEPARATE        reduce using rule 9 (pragma_s -> pragma_s pragma .)
    PROCEDURE       reduce using rule 9 (pragma_s -> pragma_s pragma .)
    FUNCTION        reduce using rule 9 (pragma_s -> pragma_s pragma .)
    GENERIC         reduce using rule 9 (pragma_s -> pragma_s pragma .)
    $end            reduce using rule 9 (pragma_s -> pragma_s pragma .)


state 15

    (438) context_spec -> context_spec pragma .

    PRIVATE         reduce using rule 438 (context_spec -> context_spec pragma .)
    WITH            reduce using rule 438 (context_spec -> context_spec pragma .)
    PRAGMA          reduce using rule 438 (context_spec -> context_spec pragma .)
    PACKAGE         reduce using rule 438 (context_spec -> context_spec pragma .)
    SEPARATE        reduce using rule 438 (context_spec -> context_spec pragma .)
    PROCEDURE       reduce using rule 438 (context_spec -> context_spec pragma .)
    FUNCTION        reduce using rule 438 (context_spec -> context_spec pragma .)
    GENERIC         reduce using rule 438 (context_spec -> context_spec pragma .)


state 16

    (437) context_spec -> context_spec with_clause . use_clause_opt
    (440) use_clause_opt -> .
    (441) use_clause_opt -> . use_clause_opt use_clause

    USE             reduce using rule 440 (use_clause_opt -> .)
    PRIVATE         reduce using rule 440 (use_clause_opt -> .)
    WITH            reduce using rule 440 (use_clause_opt -> .)
    PRAGMA          reduce using rule 440 (use_clause_opt -> .)
    PACKAGE         reduce using rule 440 (use_clause_opt -> .)
    SEPARATE        reduce using rule 440 (use_clause_opt -> .)
    PROCEDURE       reduce using rule 440 (use_clause_opt -> .)
    FUNCTION        reduce using rule 440 (use_clause_opt -> .)
    GENERIC         reduce using rule 440 (use_clause_opt -> .)

    use_clause_opt                 shift and go to state 44

state 17

    (432) comp_unit -> context_spec private_opt . unit pragma_s
    (442) unit -> . pkg_decl
    (443) unit -> . pkg_body
    (444) unit -> . subprog_decl
    (445) unit -> . subprog_body
    (446) unit -> . subunit
    (447) unit -> . generic_decl
    (448) unit -> . rename_unit
    (336) pkg_decl -> . pkg_spec ;
    (337) pkg_decl -> . generic_pkg_inst ;
    (343) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (313) subprog_decl -> . subprog_spec ;
    (314) subprog_decl -> . generic_subp_inst ;
    (315) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (334) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (449) subunit -> . SEPARATE ( compound_name ) subunit_body
    (470) generic_decl -> . generic_formal_part subprog_spec ;
    (471) generic_decl -> . generic_formal_part pkg_spec ;
    (356) rename_unit -> . PACKAGE compound_name renames ;
    (357) rename_unit -> . subprog_spec renames ;
    (358) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (359) rename_unit -> . generic_formal_part subprog_spec renames ;
    (338) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (316) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (317) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (318) subprog_spec -> . FUNCTION designator
    (500) generic_subp_inst -> . subprog_spec IS generic_inst
    (333) subprog_spec_is_push -> . subprog_spec IS
    (472) generic_formal_part -> . GENERIC
    (473) generic_formal_part -> . generic_formal_part generic_formal

    PACKAGE         shift and go to state 28
    SEPARATE        shift and go to state 20
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21

    subprog_body                   shift and go to state 19
    subprog_decl                   shift and go to state 35
    unit                           shift and go to state 45
    subprog_spec_is_push           shift and go to state 24
    generic_decl                   shift and go to state 25
    subprog_spec                   shift and go to state 26
    subunit                        shift and go to state 27
    generic_subp_inst              shift and go to state 29
    rename_unit                    shift and go to state 30
    pkg_decl                       shift and go to state 32
    generic_formal_part            shift and go to state 33
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 22
    pkg_spec                       shift and go to state 37

state 18

    (436) context_spec -> with_clause use_clause_opt .
    (441) use_clause_opt -> use_clause_opt . use_clause
    (349) use_clause -> . USE name_s ;
    (350) use_clause -> . USE TYPE name_s ;

    PRIVATE         reduce using rule 436 (context_spec -> with_clause use_clause_opt .)
    WITH            reduce using rule 436 (context_spec -> with_clause use_clause_opt .)
    PRAGMA          reduce using rule 436 (context_spec -> with_clause use_clause_opt .)
    PACKAGE         reduce using rule 436 (context_spec -> with_clause use_clause_opt .)
    SEPARATE        reduce using rule 436 (context_spec -> with_clause use_clause_opt .)
    PROCEDURE       reduce using rule 436 (context_spec -> with_clause use_clause_opt .)
    FUNCTION        reduce using rule 436 (context_spec -> with_clause use_clause_opt .)
    GENERIC         reduce using rule 436 (context_spec -> with_clause use_clause_opt .)
    USE             shift and go to state 46

    use_clause                     shift and go to state 47

state 19

    (445) unit -> subprog_body .

    PRAGMA          reduce using rule 445 (unit -> subprog_body .)
    PRIVATE         reduce using rule 445 (unit -> subprog_body .)
    WITH            reduce using rule 445 (unit -> subprog_body .)
    PACKAGE         reduce using rule 445 (unit -> subprog_body .)
    SEPARATE        reduce using rule 445 (unit -> subprog_body .)
    PROCEDURE       reduce using rule 445 (unit -> subprog_body .)
    FUNCTION        reduce using rule 445 (unit -> subprog_body .)
    GENERIC         reduce using rule 445 (unit -> subprog_body .)
    $end            reduce using rule 445 (unit -> subprog_body .)


state 20

    (449) subunit -> SEPARATE . ( compound_name ) subunit_body

    (               shift and go to state 48


state 21

    (472) generic_formal_part -> GENERIC .

    PACKAGE         reduce using rule 472 (generic_formal_part -> GENERIC .)
    PROCEDURE       reduce using rule 472 (generic_formal_part -> GENERIC .)
    FUNCTION        reduce using rule 472 (generic_formal_part -> GENERIC .)
    TYPE            reduce using rule 472 (generic_formal_part -> GENERIC .)
    WITH            reduce using rule 472 (generic_formal_part -> GENERIC .)
    error           reduce using rule 472 (generic_formal_part -> GENERIC .)
    USE             reduce using rule 472 (generic_formal_part -> GENERIC .)
    IDENTIFIER      reduce using rule 472 (generic_formal_part -> GENERIC .)


state 22

    (443) unit -> pkg_body .

    PRAGMA          reduce using rule 443 (unit -> pkg_body .)
    PRIVATE         reduce using rule 443 (unit -> pkg_body .)
    WITH            reduce using rule 443 (unit -> pkg_body .)
    PACKAGE         reduce using rule 443 (unit -> pkg_body .)
    SEPARATE        reduce using rule 443 (unit -> pkg_body .)
    PROCEDURE       reduce using rule 443 (unit -> pkg_body .)
    FUNCTION        reduce using rule 443 (unit -> pkg_body .)
    GENERIC         reduce using rule 443 (unit -> pkg_body .)
    $end            reduce using rule 443 (unit -> pkg_body .)


state 23

    (433) comp_unit -> private_opt unit . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    WITH            reduce using rule 8 (pragma_s -> .)
    PACKAGE         reduce using rule 8 (pragma_s -> .)
    SEPARATE        reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)
    GENERIC         reduce using rule 8 (pragma_s -> .)
    $end            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 49

state 24

    (315) subprog_decl -> subprog_spec_is_push . ABSTRACT ;
    (334) subprog_body -> subprog_spec_is_push . decl_part block_body END id_opt ;
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (334) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (343) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (368) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (385) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (349) use_clause -> . USE name_s ;
    (350) use_clause -> . USE TYPE name_s ;
    (503) rep_spec -> . attrib_def
    (504) rep_spec -> . record_type_spec
    (505) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (333) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (313) subprog_decl -> . subprog_spec ;
    (314) subprog_decl -> . generic_subp_inst ;
    (315) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (336) pkg_decl -> . pkg_spec ;
    (337) pkg_decl -> . generic_pkg_inst ;
    (361) task_decl -> . task_spec ;
    (369) prot_decl -> . prot_spec ;
    (458) exception_decl -> . def_id_s : EXCEPTION ;
    (353) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (354) rename_decl -> . def_id_s : EXCEPTION renames ;
    (355) rename_decl -> . rename_unit
    (470) generic_decl -> . generic_formal_part subprog_spec ;
    (471) generic_decl -> . generic_formal_part pkg_spec ;
    (454) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (455) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (456) body_stub -> . subprog_spec IS SEPARATE ;
    (457) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (506) attrib_def -> . FOR mark USE expression ;
    (507) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (512) address_spec -> . FOR mark USE AT expression ;
    (316) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (317) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (318) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (500) generic_subp_inst -> . subprog_spec IS generic_inst
    (338) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (362) task_spec -> . TASK simple_name task_def
    (363) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (370) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (371) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (356) rename_unit -> . PACKAGE compound_name renames ;
    (357) rename_unit -> . subprog_spec renames ;
    (358) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (359) rename_unit -> . generic_formal_part subprog_spec renames ;
    (472) generic_formal_part -> . GENERIC
    (473) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    ABSTRACT        shift and go to state 81
    BEGIN           reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 54
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 25

    (447) unit -> generic_decl .

    PRAGMA          reduce using rule 447 (unit -> generic_decl .)
    PRIVATE         reduce using rule 447 (unit -> generic_decl .)
    WITH            reduce using rule 447 (unit -> generic_decl .)
    PACKAGE         reduce using rule 447 (unit -> generic_decl .)
    SEPARATE        reduce using rule 447 (unit -> generic_decl .)
    PROCEDURE       reduce using rule 447 (unit -> generic_decl .)
    FUNCTION        reduce using rule 447 (unit -> generic_decl .)
    GENERIC         reduce using rule 447 (unit -> generic_decl .)
    $end            reduce using rule 447 (unit -> generic_decl .)


state 26

    (313) subprog_decl -> subprog_spec . ;
    (357) rename_unit -> subprog_spec . renames ;
    (500) generic_subp_inst -> subprog_spec . IS generic_inst
    (333) subprog_spec_is_push -> subprog_spec . IS
    (360) renames -> . RENAMES name

    ;               shift and go to state 97
    IS              shift and go to state 96
    RENAMES         shift and go to state 95

    renames                        shift and go to state 94

state 27

    (446) unit -> subunit .

    PRAGMA          reduce using rule 446 (unit -> subunit .)
    PRIVATE         reduce using rule 446 (unit -> subunit .)
    WITH            reduce using rule 446 (unit -> subunit .)
    PACKAGE         reduce using rule 446 (unit -> subunit .)
    SEPARATE        reduce using rule 446 (unit -> subunit .)
    PROCEDURE       reduce using rule 446 (unit -> subunit .)
    FUNCTION        reduce using rule 446 (unit -> subunit .)
    GENERIC         reduce using rule 446 (unit -> subunit .)
    $end            reduce using rule 446 (unit -> subunit .)


state 28

    (343) pkg_body -> PACKAGE . BODY compound_name IS decl_part body_opt END c_id_opt ;
    (356) rename_unit -> PACKAGE . compound_name renames ;
    (338) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> PACKAGE . compound_name IS generic_inst
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    BODY            shift and go to state 98
    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 41
    compound_name                  shift and go to state 99

state 29

    (314) subprog_decl -> generic_subp_inst . ;

    ;               shift and go to state 100


state 30

    (448) unit -> rename_unit .

    PRAGMA          reduce using rule 448 (unit -> rename_unit .)
    PRIVATE         reduce using rule 448 (unit -> rename_unit .)
    WITH            reduce using rule 448 (unit -> rename_unit .)
    PACKAGE         reduce using rule 448 (unit -> rename_unit .)
    SEPARATE        reduce using rule 448 (unit -> rename_unit .)
    PROCEDURE       reduce using rule 448 (unit -> rename_unit .)
    FUNCTION        reduce using rule 448 (unit -> rename_unit .)
    GENERIC         reduce using rule 448 (unit -> rename_unit .)
    $end            reduce using rule 448 (unit -> rename_unit .)


state 31

    (316) subprog_spec -> PROCEDURE . compound_name formal_part_opt
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 101
    simple_name                    shift and go to state 41

state 32

    (442) unit -> pkg_decl .

    PRAGMA          reduce using rule 442 (unit -> pkg_decl .)
    PRIVATE         reduce using rule 442 (unit -> pkg_decl .)
    WITH            reduce using rule 442 (unit -> pkg_decl .)
    PACKAGE         reduce using rule 442 (unit -> pkg_decl .)
    SEPARATE        reduce using rule 442 (unit -> pkg_decl .)
    PROCEDURE       reduce using rule 442 (unit -> pkg_decl .)
    FUNCTION        reduce using rule 442 (unit -> pkg_decl .)
    GENERIC         reduce using rule 442 (unit -> pkg_decl .)
    $end            reduce using rule 442 (unit -> pkg_decl .)


state 33

    (470) generic_decl -> generic_formal_part . subprog_spec ;
    (471) generic_decl -> generic_formal_part . pkg_spec ;
    (358) rename_unit -> generic_formal_part . PACKAGE compound_name renames ;
    (359) rename_unit -> generic_formal_part . subprog_spec renames ;
    (473) generic_formal_part -> generic_formal_part . generic_formal
    (316) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (317) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (318) subprog_spec -> . FUNCTION designator
    (338) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (474) generic_formal -> . param ;
    (475) generic_formal -> . TYPE simple_name generic_discrim_part_opt IS generic_type_def ;
    (476) generic_formal -> . WITH PROCEDURE simple_name formal_part_opt subp_default ;
    (477) generic_formal -> . WITH FUNCTION designator formal_part_opt RETURN name subp_default ;
    (478) generic_formal -> . WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ;
    (479) generic_formal -> . WITH PACKAGE simple_name IS NEW name ;
    (480) generic_formal -> . use_clause
    (326) param -> . def_id_s : mode mark init_opt
    (327) param -> . error
    (349) use_clause -> . USE name_s ;
    (350) use_clause -> . USE TYPE name_s ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    PACKAGE         shift and go to state 106
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    TYPE            shift and go to state 111
    WITH            shift and go to state 102
    error           shift and go to state 109
    USE             shift and go to state 46
    IDENTIFIER      shift and go to state 76

    param                          shift and go to state 103
    subprog_spec                   shift and go to state 104
    def_id_s                       shift and go to state 105
    def_id                         shift and go to state 89
    generic_formal                 shift and go to state 107
    use_clause                     shift and go to state 108
    pkg_spec                       shift and go to state 110

state 34

    (337) pkg_decl -> generic_pkg_inst . ;

    ;               shift and go to state 112


state 35

    (444) unit -> subprog_decl .

    PRAGMA          reduce using rule 444 (unit -> subprog_decl .)
    PRIVATE         reduce using rule 444 (unit -> subprog_decl .)
    WITH            reduce using rule 444 (unit -> subprog_decl .)
    PACKAGE         reduce using rule 444 (unit -> subprog_decl .)
    SEPARATE        reduce using rule 444 (unit -> subprog_decl .)
    PROCEDURE       reduce using rule 444 (unit -> subprog_decl .)
    FUNCTION        reduce using rule 444 (unit -> subprog_decl .)
    GENERIC         reduce using rule 444 (unit -> subprog_decl .)
    $end            reduce using rule 444 (unit -> subprog_decl .)


state 36

    (317) subprog_spec -> FUNCTION . designator formal_part_opt RETURN name
    (318) subprog_spec -> FUNCTION . designator
    (319) designator -> . compound_name
    (320) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 114
    designator                     shift and go to state 113
    simple_name                    shift and go to state 41

state 37

    (336) pkg_decl -> pkg_spec . ;

    ;               shift and go to state 116


state 38

    (439) with_clause -> WITH c_name_list . ;
    (165) c_name_list -> c_name_list . , compound_name

    ;               shift and go to state 117
    ,               shift and go to state 118


state 39

    (161) simple_name -> IDENTIFIER .

    USE             reduce using rule 161 (simple_name -> IDENTIFIER .)
    TICK            reduce using rule 161 (simple_name -> IDENTIFIER .)
    .               reduce using rule 161 (simple_name -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 161 (simple_name -> IDENTIFIER .)
    ;               reduce using rule 161 (simple_name -> IDENTIFIER .)
    )               reduce using rule 161 (simple_name -> IDENTIFIER .)
    AT              reduce using rule 161 (simple_name -> IDENTIFIER .)
    (               reduce using rule 161 (simple_name -> IDENTIFIER .)
    RANGE           reduce using rule 161 (simple_name -> IDENTIFIER .)
    ,               reduce using rule 161 (simple_name -> IDENTIFIER .)
    STARSTAR        reduce using rule 161 (simple_name -> IDENTIFIER .)
    *               reduce using rule 161 (simple_name -> IDENTIFIER .)
    /               reduce using rule 161 (simple_name -> IDENTIFIER .)
    MOD             reduce using rule 161 (simple_name -> IDENTIFIER .)
    REM             reduce using rule 161 (simple_name -> IDENTIFIER .)
    DOTDOT          reduce using rule 161 (simple_name -> IDENTIFIER .)
    +               reduce using rule 161 (simple_name -> IDENTIFIER .)
    -               reduce using rule 161 (simple_name -> IDENTIFIER .)
    &               reduce using rule 161 (simple_name -> IDENTIFIER .)
    =               reduce using rule 161 (simple_name -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 161 (simple_name -> IDENTIFIER .)
    <               reduce using rule 161 (simple_name -> IDENTIFIER .)
    LESSEQ          reduce using rule 161 (simple_name -> IDENTIFIER .)
    >               reduce using rule 161 (simple_name -> IDENTIFIER .)
    GREATEREQ       reduce using rule 161 (simple_name -> IDENTIFIER .)
    IN              reduce using rule 161 (simple_name -> IDENTIFIER .)
    NOT             reduce using rule 161 (simple_name -> IDENTIFIER .)
    IS              reduce using rule 161 (simple_name -> IDENTIFIER .)
    AND             reduce using rule 161 (simple_name -> IDENTIFIER .)
    OR              reduce using rule 161 (simple_name -> IDENTIFIER .)
    WITH            reduce using rule 161 (simple_name -> IDENTIFIER .)
    ARROW           reduce using rule 161 (simple_name -> IDENTIFIER .)
    |               reduce using rule 161 (simple_name -> IDENTIFIER .)
    THEN            reduce using rule 161 (simple_name -> IDENTIFIER .)
    LOOP            reduce using rule 161 (simple_name -> IDENTIFIER .)
    DIGITS          reduce using rule 161 (simple_name -> IDENTIFIER .)
    RENAMES         reduce using rule 161 (simple_name -> IDENTIFIER .)
    WHEN            reduce using rule 161 (simple_name -> IDENTIFIER .)
    RETURN          reduce using rule 161 (simple_name -> IDENTIFIER .)
    DO              reduce using rule 161 (simple_name -> IDENTIFIER .)


state 40

    (164) c_name_list -> compound_name .
    (163) compound_name -> compound_name . . simple_name

    ;               reduce using rule 164 (c_name_list -> compound_name .)
    ,               reduce using rule 164 (c_name_list -> compound_name .)
    .               shift and go to state 119


state 41

    (162) compound_name -> simple_name .

    .               reduce using rule 162 (compound_name -> simple_name .)
    (               reduce using rule 162 (compound_name -> simple_name .)
    RETURN          reduce using rule 162 (compound_name -> simple_name .)
    ;               reduce using rule 162 (compound_name -> simple_name .)
    ,               reduce using rule 162 (compound_name -> simple_name .)
    IS              reduce using rule 162 (compound_name -> simple_name .)
    RENAMES         reduce using rule 162 (compound_name -> simple_name .)
    )               reduce using rule 162 (compound_name -> simple_name .)


state 42

    (2) pragma -> PRAGMA IDENTIFIER ; .

    PRAGMA          reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    PRIVATE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    WITH            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    PACKAGE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    SEPARATE        reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    PROCEDURE       reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    FUNCTION        reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    GENERIC         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    $end            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    LESSLESS        reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    error           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    NuLL            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    EXIT            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    RETURN          reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    GOTO            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    DELAY           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    ABORT           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    RAISE           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    REQUEUE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    IF              reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    CASE            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    IDENTIFIER      reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    ACCEPT          reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    SELECT          reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    STRING          reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    WHILE           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    DECLARE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    FOR             reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    LOOP            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    BEGIN           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    WHEN            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    END             reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    ENTRY           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    TASK            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    PROTECTED       reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    USE             reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    TYPE            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    SUBTYPE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    ELSIF           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    ELSE            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    EXCEPTION       reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    OR              reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)
    THEN            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER ; .)


state 43

    (3) pragma -> PRAGMA simple_name ( . pragma_arg_s ) ;
    (4) pragma_arg_s -> . pragma_arg
    (5) pragma_arg_s -> . pragma_arg_s , pragma_arg
    (6) pragma_arg -> . expression
    (7) pragma_arg -> . simple_name ARROW expression
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (161) simple_name -> . IDENTIFIER
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 39
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    pragma_arg                     shift and go to state 123
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 131
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    pragma_arg_s                   shift and go to state 140
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    used_char                      shift and go to state 145
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 152

state 44

    (437) context_spec -> context_spec with_clause use_clause_opt .
    (441) use_clause_opt -> use_clause_opt . use_clause
    (349) use_clause -> . USE name_s ;
    (350) use_clause -> . USE TYPE name_s ;

    PRIVATE         reduce using rule 437 (context_spec -> context_spec with_clause use_clause_opt .)
    WITH            reduce using rule 437 (context_spec -> context_spec with_clause use_clause_opt .)
    PRAGMA          reduce using rule 437 (context_spec -> context_spec with_clause use_clause_opt .)
    PACKAGE         reduce using rule 437 (context_spec -> context_spec with_clause use_clause_opt .)
    SEPARATE        reduce using rule 437 (context_spec -> context_spec with_clause use_clause_opt .)
    PROCEDURE       reduce using rule 437 (context_spec -> context_spec with_clause use_clause_opt .)
    FUNCTION        reduce using rule 437 (context_spec -> context_spec with_clause use_clause_opt .)
    GENERIC         reduce using rule 437 (context_spec -> context_spec with_clause use_clause_opt .)
    USE             shift and go to state 46

    use_clause                     shift and go to state 47

state 45

    (432) comp_unit -> context_spec private_opt unit . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    WITH            reduce using rule 8 (pragma_s -> .)
    PACKAGE         reduce using rule 8 (pragma_s -> .)
    SEPARATE        reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)
    GENERIC         reduce using rule 8 (pragma_s -> .)
    $end            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 153

state 46

    (349) use_clause -> USE . name_s ;
    (350) use_clause -> USE . TYPE name_s ;
    (351) name_s -> . name
    (352) name_s -> . name_s , name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    TYPE            shift and go to state 156
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name_s                         shift and go to state 154
    name                           shift and go to state 155
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 47

    (441) use_clause_opt -> use_clause_opt use_clause .

    USE             reduce using rule 441 (use_clause_opt -> use_clause_opt use_clause .)
    PRIVATE         reduce using rule 441 (use_clause_opt -> use_clause_opt use_clause .)
    WITH            reduce using rule 441 (use_clause_opt -> use_clause_opt use_clause .)
    PRAGMA          reduce using rule 441 (use_clause_opt -> use_clause_opt use_clause .)
    PACKAGE         reduce using rule 441 (use_clause_opt -> use_clause_opt use_clause .)
    SEPARATE        reduce using rule 441 (use_clause_opt -> use_clause_opt use_clause .)
    PROCEDURE       reduce using rule 441 (use_clause_opt -> use_clause_opt use_clause .)
    FUNCTION        reduce using rule 441 (use_clause_opt -> use_clause_opt use_clause .)
    GENERIC         reduce using rule 441 (use_clause_opt -> use_clause_opt use_clause .)


state 48

    (449) subunit -> SEPARATE ( . compound_name ) subunit_body
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 158
    simple_name                    shift and go to state 41

state 49

    (433) comp_unit -> private_opt unit pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    PRIVATE         reduce using rule 433 (comp_unit -> private_opt unit pragma_s .)
    WITH            reduce using rule 433 (comp_unit -> private_opt unit pragma_s .)
    PACKAGE         reduce using rule 433 (comp_unit -> private_opt unit pragma_s .)
    SEPARATE        reduce using rule 433 (comp_unit -> private_opt unit pragma_s .)
    PROCEDURE       reduce using rule 433 (comp_unit -> private_opt unit pragma_s .)
    FUNCTION        reduce using rule 433 (comp_unit -> private_opt unit pragma_s .)
    GENERIC         reduce using rule 433 (comp_unit -> private_opt unit pragma_s .)
    $end            reduce using rule 433 (comp_unit -> private_opt unit pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 50

    (141) decl_item -> decl .

    PACKAGE         reduce using rule 141 (decl_item -> decl .)
    TASK            reduce using rule 141 (decl_item -> decl .)
    PROTECTED       reduce using rule 141 (decl_item -> decl .)
    error           reduce using rule 141 (decl_item -> decl .)
    USE             reduce using rule 141 (decl_item -> decl .)
    PRAGMA          reduce using rule 141 (decl_item -> decl .)
    TYPE            reduce using rule 141 (decl_item -> decl .)
    SUBTYPE         reduce using rule 141 (decl_item -> decl .)
    FOR             reduce using rule 141 (decl_item -> decl .)
    PROCEDURE       reduce using rule 141 (decl_item -> decl .)
    FUNCTION        reduce using rule 141 (decl_item -> decl .)
    GENERIC         reduce using rule 141 (decl_item -> decl .)
    IDENTIFIER      reduce using rule 141 (decl_item -> decl .)
    BEGIN           reduce using rule 141 (decl_item -> decl .)
    END             reduce using rule 141 (decl_item -> decl .)
    PRIVATE         reduce using rule 141 (decl_item -> decl .)


state 51

    (385) prot_body -> PROTECTED . BODY simple_name IS prot_op_body_s END id_opt ;
    (457) body_stub -> PROTECTED . BODY simple_name IS SEPARATE ;
    (370) prot_spec -> PROTECTED . IDENTIFIER prot_def
    (371) prot_spec -> PROTECTED . TYPE simple_name discrim_part_opt prot_def

    BODY            shift and go to state 159
    IDENTIFIER      shift and go to state 160
    TYPE            shift and go to state 161


state 52

    (505) rep_spec -> address_spec .

    PACKAGE         reduce using rule 505 (rep_spec -> address_spec .)
    TASK            reduce using rule 505 (rep_spec -> address_spec .)
    PROTECTED       reduce using rule 505 (rep_spec -> address_spec .)
    error           reduce using rule 505 (rep_spec -> address_spec .)
    USE             reduce using rule 505 (rep_spec -> address_spec .)
    PRAGMA          reduce using rule 505 (rep_spec -> address_spec .)
    TYPE            reduce using rule 505 (rep_spec -> address_spec .)
    SUBTYPE         reduce using rule 505 (rep_spec -> address_spec .)
    FOR             reduce using rule 505 (rep_spec -> address_spec .)
    PROCEDURE       reduce using rule 505 (rep_spec -> address_spec .)
    FUNCTION        reduce using rule 505 (rep_spec -> address_spec .)
    GENERIC         reduce using rule 505 (rep_spec -> address_spec .)
    IDENTIFIER      reduce using rule 505 (rep_spec -> address_spec .)
    BEGIN           reduce using rule 505 (rep_spec -> address_spec .)
    END             reduce using rule 505 (rep_spec -> address_spec .)
    PRIVATE         reduce using rule 505 (rep_spec -> address_spec .)
    ENTRY           reduce using rule 505 (rep_spec -> address_spec .)


state 53

    (148) decl_item_or_body -> decl_item .

    PACKAGE         reduce using rule 148 (decl_item_or_body -> decl_item .)
    TASK            reduce using rule 148 (decl_item_or_body -> decl_item .)
    PROTECTED       reduce using rule 148 (decl_item_or_body -> decl_item .)
    error           reduce using rule 148 (decl_item_or_body -> decl_item .)
    USE             reduce using rule 148 (decl_item_or_body -> decl_item .)
    PRAGMA          reduce using rule 148 (decl_item_or_body -> decl_item .)
    TYPE            reduce using rule 148 (decl_item_or_body -> decl_item .)
    SUBTYPE         reduce using rule 148 (decl_item_or_body -> decl_item .)
    FOR             reduce using rule 148 (decl_item_or_body -> decl_item .)
    PROCEDURE       reduce using rule 148 (decl_item_or_body -> decl_item .)
    FUNCTION        reduce using rule 148 (decl_item_or_body -> decl_item .)
    GENERIC         reduce using rule 148 (decl_item_or_body -> decl_item .)
    IDENTIFIER      reduce using rule 148 (decl_item_or_body -> decl_item .)
    BEGIN           reduce using rule 148 (decl_item_or_body -> decl_item .)
    END             reduce using rule 148 (decl_item_or_body -> decl_item .)


state 54

    (334) subprog_body -> subprog_spec_is_push decl_part . block_body END id_opt ;
    (301) block_body -> . BEGIN handled_stmt_s

    BEGIN           shift and go to state 162

    block_body                     shift and go to state 163

state 55

    (17) decl -> prot_decl .

    PACKAGE         reduce using rule 17 (decl -> prot_decl .)
    TASK            reduce using rule 17 (decl -> prot_decl .)
    PROTECTED       reduce using rule 17 (decl -> prot_decl .)
    error           reduce using rule 17 (decl -> prot_decl .)
    USE             reduce using rule 17 (decl -> prot_decl .)
    PRAGMA          reduce using rule 17 (decl -> prot_decl .)
    TYPE            reduce using rule 17 (decl -> prot_decl .)
    SUBTYPE         reduce using rule 17 (decl -> prot_decl .)
    FOR             reduce using rule 17 (decl -> prot_decl .)
    PROCEDURE       reduce using rule 17 (decl -> prot_decl .)
    FUNCTION        reduce using rule 17 (decl -> prot_decl .)
    GENERIC         reduce using rule 17 (decl -> prot_decl .)
    IDENTIFIER      reduce using rule 17 (decl -> prot_decl .)
    BEGIN           reduce using rule 17 (decl -> prot_decl .)
    PRIVATE         reduce using rule 17 (decl -> prot_decl .)
    END             reduce using rule 17 (decl -> prot_decl .)


state 56

    (12) decl -> type_decl .

    PACKAGE         reduce using rule 12 (decl -> type_decl .)
    TASK            reduce using rule 12 (decl -> type_decl .)
    PROTECTED       reduce using rule 12 (decl -> type_decl .)
    error           reduce using rule 12 (decl -> type_decl .)
    USE             reduce using rule 12 (decl -> type_decl .)
    PRAGMA          reduce using rule 12 (decl -> type_decl .)
    TYPE            reduce using rule 12 (decl -> type_decl .)
    SUBTYPE         reduce using rule 12 (decl -> type_decl .)
    FOR             reduce using rule 12 (decl -> type_decl .)
    PROCEDURE       reduce using rule 12 (decl -> type_decl .)
    FUNCTION        reduce using rule 12 (decl -> type_decl .)
    GENERIC         reduce using rule 12 (decl -> type_decl .)
    IDENTIFIER      reduce using rule 12 (decl -> type_decl .)
    BEGIN           reduce using rule 12 (decl -> type_decl .)
    PRIVATE         reduce using rule 12 (decl -> type_decl .)
    END             reduce using rule 12 (decl -> type_decl .)


state 57

    (15) decl -> pkg_decl .

    PACKAGE         reduce using rule 15 (decl -> pkg_decl .)
    TASK            reduce using rule 15 (decl -> pkg_decl .)
    PROTECTED       reduce using rule 15 (decl -> pkg_decl .)
    error           reduce using rule 15 (decl -> pkg_decl .)
    USE             reduce using rule 15 (decl -> pkg_decl .)
    PRAGMA          reduce using rule 15 (decl -> pkg_decl .)
    TYPE            reduce using rule 15 (decl -> pkg_decl .)
    SUBTYPE         reduce using rule 15 (decl -> pkg_decl .)
    FOR             reduce using rule 15 (decl -> pkg_decl .)
    PROCEDURE       reduce using rule 15 (decl -> pkg_decl .)
    FUNCTION        reduce using rule 15 (decl -> pkg_decl .)
    GENERIC         reduce using rule 15 (decl -> pkg_decl .)
    IDENTIFIER      reduce using rule 15 (decl -> pkg_decl .)
    BEGIN           reduce using rule 15 (decl -> pkg_decl .)
    PRIVATE         reduce using rule 15 (decl -> pkg_decl .)
    END             reduce using rule 15 (decl -> pkg_decl .)


state 58

    (14) decl -> subprog_decl .

    PACKAGE         reduce using rule 14 (decl -> subprog_decl .)
    TASK            reduce using rule 14 (decl -> subprog_decl .)
    PROTECTED       reduce using rule 14 (decl -> subprog_decl .)
    error           reduce using rule 14 (decl -> subprog_decl .)
    USE             reduce using rule 14 (decl -> subprog_decl .)
    PRAGMA          reduce using rule 14 (decl -> subprog_decl .)
    TYPE            reduce using rule 14 (decl -> subprog_decl .)
    SUBTYPE         reduce using rule 14 (decl -> subprog_decl .)
    FOR             reduce using rule 14 (decl -> subprog_decl .)
    PROCEDURE       reduce using rule 14 (decl -> subprog_decl .)
    FUNCTION        reduce using rule 14 (decl -> subprog_decl .)
    GENERIC         reduce using rule 14 (decl -> subprog_decl .)
    IDENTIFIER      reduce using rule 14 (decl -> subprog_decl .)
    BEGIN           reduce using rule 14 (decl -> subprog_decl .)
    PRIVATE         reduce using rule 14 (decl -> subprog_decl .)
    END             reduce using rule 14 (decl -> subprog_decl .)


state 59

    (149) body -> subprog_body .

    PACKAGE         reduce using rule 149 (body -> subprog_body .)
    TASK            reduce using rule 149 (body -> subprog_body .)
    PROTECTED       reduce using rule 149 (body -> subprog_body .)
    error           reduce using rule 149 (body -> subprog_body .)
    USE             reduce using rule 149 (body -> subprog_body .)
    PRAGMA          reduce using rule 149 (body -> subprog_body .)
    TYPE            reduce using rule 149 (body -> subprog_body .)
    SUBTYPE         reduce using rule 149 (body -> subprog_body .)
    FOR             reduce using rule 149 (body -> subprog_body .)
    PROCEDURE       reduce using rule 149 (body -> subprog_body .)
    FUNCTION        reduce using rule 149 (body -> subprog_body .)
    GENERIC         reduce using rule 149 (body -> subprog_body .)
    IDENTIFIER      reduce using rule 149 (body -> subprog_body .)
    BEGIN           reduce using rule 149 (body -> subprog_body .)
    END             reduce using rule 149 (body -> subprog_body .)


state 60

    (16) decl -> task_decl .

    PACKAGE         reduce using rule 16 (decl -> task_decl .)
    TASK            reduce using rule 16 (decl -> task_decl .)
    PROTECTED       reduce using rule 16 (decl -> task_decl .)
    error           reduce using rule 16 (decl -> task_decl .)
    USE             reduce using rule 16 (decl -> task_decl .)
    PRAGMA          reduce using rule 16 (decl -> task_decl .)
    TYPE            reduce using rule 16 (decl -> task_decl .)
    SUBTYPE         reduce using rule 16 (decl -> task_decl .)
    FOR             reduce using rule 16 (decl -> task_decl .)
    PROCEDURE       reduce using rule 16 (decl -> task_decl .)
    FUNCTION        reduce using rule 16 (decl -> task_decl .)
    GENERIC         reduce using rule 16 (decl -> task_decl .)
    IDENTIFIER      reduce using rule 16 (decl -> task_decl .)
    BEGIN           reduce using rule 16 (decl -> task_decl .)
    PRIVATE         reduce using rule 16 (decl -> task_decl .)
    END             reduce using rule 16 (decl -> task_decl .)


state 61

    (13) decl -> subtype_decl .

    PACKAGE         reduce using rule 13 (decl -> subtype_decl .)
    TASK            reduce using rule 13 (decl -> subtype_decl .)
    PROTECTED       reduce using rule 13 (decl -> subtype_decl .)
    error           reduce using rule 13 (decl -> subtype_decl .)
    USE             reduce using rule 13 (decl -> subtype_decl .)
    PRAGMA          reduce using rule 13 (decl -> subtype_decl .)
    TYPE            reduce using rule 13 (decl -> subtype_decl .)
    SUBTYPE         reduce using rule 13 (decl -> subtype_decl .)
    FOR             reduce using rule 13 (decl -> subtype_decl .)
    PROCEDURE       reduce using rule 13 (decl -> subtype_decl .)
    FUNCTION        reduce using rule 13 (decl -> subtype_decl .)
    GENERIC         reduce using rule 13 (decl -> subtype_decl .)
    IDENTIFIER      reduce using rule 13 (decl -> subtype_decl .)
    BEGIN           reduce using rule 13 (decl -> subtype_decl .)
    PRIVATE         reduce using rule 13 (decl -> subtype_decl .)
    END             reduce using rule 13 (decl -> subtype_decl .)


state 62

    (147) decl_item_or_body -> body .

    PACKAGE         reduce using rule 147 (decl_item_or_body -> body .)
    TASK            reduce using rule 147 (decl_item_or_body -> body .)
    PROTECTED       reduce using rule 147 (decl_item_or_body -> body .)
    error           reduce using rule 147 (decl_item_or_body -> body .)
    USE             reduce using rule 147 (decl_item_or_body -> body .)
    PRAGMA          reduce using rule 147 (decl_item_or_body -> body .)
    TYPE            reduce using rule 147 (decl_item_or_body -> body .)
    SUBTYPE         reduce using rule 147 (decl_item_or_body -> body .)
    FOR             reduce using rule 147 (decl_item_or_body -> body .)
    PROCEDURE       reduce using rule 147 (decl_item_or_body -> body .)
    FUNCTION        reduce using rule 147 (decl_item_or_body -> body .)
    GENERIC         reduce using rule 147 (decl_item_or_body -> body .)
    IDENTIFIER      reduce using rule 147 (decl_item_or_body -> body .)
    BEGIN           reduce using rule 147 (decl_item_or_body -> body .)
    END             reduce using rule 147 (decl_item_or_body -> body .)


state 63

    (506) attrib_def -> FOR . mark USE expression ;
    (507) record_type_spec -> FOR . mark USE RECORD align_opt comp_loc_s END RECORD ;
    (512) address_spec -> FOR . mark USE AT expression ;
    (158) mark -> . simple_name
    (159) mark -> . mark TICK attribute_id
    (160) mark -> . mark . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    mark                           shift and go to state 164
    simple_name                    shift and go to state 165

state 64

    (10) decl -> object_decl .

    PACKAGE         reduce using rule 10 (decl -> object_decl .)
    TASK            reduce using rule 10 (decl -> object_decl .)
    PROTECTED       reduce using rule 10 (decl -> object_decl .)
    error           reduce using rule 10 (decl -> object_decl .)
    USE             reduce using rule 10 (decl -> object_decl .)
    PRAGMA          reduce using rule 10 (decl -> object_decl .)
    TYPE            reduce using rule 10 (decl -> object_decl .)
    SUBTYPE         reduce using rule 10 (decl -> object_decl .)
    FOR             reduce using rule 10 (decl -> object_decl .)
    PROCEDURE       reduce using rule 10 (decl -> object_decl .)
    FUNCTION        reduce using rule 10 (decl -> object_decl .)
    GENERIC         reduce using rule 10 (decl -> object_decl .)
    IDENTIFIER      reduce using rule 10 (decl -> object_decl .)
    BEGIN           reduce using rule 10 (decl -> object_decl .)
    PRIVATE         reduce using rule 10 (decl -> object_decl .)
    END             reduce using rule 10 (decl -> object_decl .)


state 65

    (361) task_decl -> task_spec . ;

    ;               shift and go to state 166


state 66

    (142) decl_item -> use_clause .

    PACKAGE         reduce using rule 142 (decl_item -> use_clause .)
    TASK            reduce using rule 142 (decl_item -> use_clause .)
    PROTECTED       reduce using rule 142 (decl_item -> use_clause .)
    error           reduce using rule 142 (decl_item -> use_clause .)
    USE             reduce using rule 142 (decl_item -> use_clause .)
    PRAGMA          reduce using rule 142 (decl_item -> use_clause .)
    TYPE            reduce using rule 142 (decl_item -> use_clause .)
    SUBTYPE         reduce using rule 142 (decl_item -> use_clause .)
    FOR             reduce using rule 142 (decl_item -> use_clause .)
    PROCEDURE       reduce using rule 142 (decl_item -> use_clause .)
    FUNCTION        reduce using rule 142 (decl_item -> use_clause .)
    GENERIC         reduce using rule 142 (decl_item -> use_clause .)
    IDENTIFIER      reduce using rule 142 (decl_item -> use_clause .)
    BEGIN           reduce using rule 142 (decl_item -> use_clause .)
    END             reduce using rule 142 (decl_item -> use_clause .)
    PRIVATE         reduce using rule 142 (decl_item -> use_clause .)


state 67

    (368) task_body -> TASK . BODY simple_name IS decl_part block_body END id_opt ;
    (454) body_stub -> TASK . BODY simple_name IS SEPARATE ;
    (362) task_spec -> TASK . simple_name task_def
    (363) task_spec -> TASK . TYPE simple_name discrim_part_opt task_def
    (161) simple_name -> . IDENTIFIER

    BODY            shift and go to state 167
    TYPE            shift and go to state 168
    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 169

state 68

    (504) rep_spec -> record_type_spec .

    PACKAGE         reduce using rule 504 (rep_spec -> record_type_spec .)
    TASK            reduce using rule 504 (rep_spec -> record_type_spec .)
    PROTECTED       reduce using rule 504 (rep_spec -> record_type_spec .)
    error           reduce using rule 504 (rep_spec -> record_type_spec .)
    USE             reduce using rule 504 (rep_spec -> record_type_spec .)
    PRAGMA          reduce using rule 504 (rep_spec -> record_type_spec .)
    TYPE            reduce using rule 504 (rep_spec -> record_type_spec .)
    SUBTYPE         reduce using rule 504 (rep_spec -> record_type_spec .)
    FOR             reduce using rule 504 (rep_spec -> record_type_spec .)
    PROCEDURE       reduce using rule 504 (rep_spec -> record_type_spec .)
    FUNCTION        reduce using rule 504 (rep_spec -> record_type_spec .)
    GENERIC         reduce using rule 504 (rep_spec -> record_type_spec .)
    IDENTIFIER      reduce using rule 504 (rep_spec -> record_type_spec .)
    BEGIN           reduce using rule 504 (rep_spec -> record_type_spec .)
    END             reduce using rule 504 (rep_spec -> record_type_spec .)
    PRIVATE         reduce using rule 504 (rep_spec -> record_type_spec .)
    ENTRY           reduce using rule 504 (rep_spec -> record_type_spec .)


state 69

    (20) decl -> generic_decl .

    PACKAGE         reduce using rule 20 (decl -> generic_decl .)
    TASK            reduce using rule 20 (decl -> generic_decl .)
    PROTECTED       reduce using rule 20 (decl -> generic_decl .)
    error           reduce using rule 20 (decl -> generic_decl .)
    USE             reduce using rule 20 (decl -> generic_decl .)
    PRAGMA          reduce using rule 20 (decl -> generic_decl .)
    TYPE            reduce using rule 20 (decl -> generic_decl .)
    SUBTYPE         reduce using rule 20 (decl -> generic_decl .)
    FOR             reduce using rule 20 (decl -> generic_decl .)
    PROCEDURE       reduce using rule 20 (decl -> generic_decl .)
    FUNCTION        reduce using rule 20 (decl -> generic_decl .)
    GENERIC         reduce using rule 20 (decl -> generic_decl .)
    IDENTIFIER      reduce using rule 20 (decl -> generic_decl .)
    BEGIN           reduce using rule 20 (decl -> generic_decl .)
    PRIVATE         reduce using rule 20 (decl -> generic_decl .)
    END             reduce using rule 20 (decl -> generic_decl .)


state 70

    (503) rep_spec -> attrib_def .

    PACKAGE         reduce using rule 503 (rep_spec -> attrib_def .)
    TASK            reduce using rule 503 (rep_spec -> attrib_def .)
    PROTECTED       reduce using rule 503 (rep_spec -> attrib_def .)
    error           reduce using rule 503 (rep_spec -> attrib_def .)
    USE             reduce using rule 503 (rep_spec -> attrib_def .)
    PRAGMA          reduce using rule 503 (rep_spec -> attrib_def .)
    TYPE            reduce using rule 503 (rep_spec -> attrib_def .)
    SUBTYPE         reduce using rule 503 (rep_spec -> attrib_def .)
    FOR             reduce using rule 503 (rep_spec -> attrib_def .)
    PROCEDURE       reduce using rule 503 (rep_spec -> attrib_def .)
    FUNCTION        reduce using rule 503 (rep_spec -> attrib_def .)
    GENERIC         reduce using rule 503 (rep_spec -> attrib_def .)
    IDENTIFIER      reduce using rule 503 (rep_spec -> attrib_def .)
    BEGIN           reduce using rule 503 (rep_spec -> attrib_def .)
    END             reduce using rule 503 (rep_spec -> attrib_def .)
    PRIVATE         reduce using rule 503 (rep_spec -> attrib_def .)
    ENTRY           reduce using rule 503 (rep_spec -> attrib_def .)


state 71

    (136) decl_part -> decl_item_or_body_s1 .
    (146) decl_item_or_body_s1 -> decl_item_or_body_s1 . decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (334) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (343) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (368) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (385) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (349) use_clause -> . USE name_s ;
    (350) use_clause -> . USE TYPE name_s ;
    (503) rep_spec -> . attrib_def
    (504) rep_spec -> . record_type_spec
    (505) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (333) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (313) subprog_decl -> . subprog_spec ;
    (314) subprog_decl -> . generic_subp_inst ;
    (315) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (336) pkg_decl -> . pkg_spec ;
    (337) pkg_decl -> . generic_pkg_inst ;
    (361) task_decl -> . task_spec ;
    (369) prot_decl -> . prot_spec ;
    (458) exception_decl -> . def_id_s : EXCEPTION ;
    (353) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (354) rename_decl -> . def_id_s : EXCEPTION renames ;
    (355) rename_decl -> . rename_unit
    (470) generic_decl -> . generic_formal_part subprog_spec ;
    (471) generic_decl -> . generic_formal_part pkg_spec ;
    (454) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (455) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (456) body_stub -> . subprog_spec IS SEPARATE ;
    (457) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (506) attrib_def -> . FOR mark USE expression ;
    (507) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (512) address_spec -> . FOR mark USE AT expression ;
    (316) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (317) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (318) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (500) generic_subp_inst -> . subprog_spec IS generic_inst
    (338) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (362) task_spec -> . TASK simple_name task_def
    (363) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (370) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (371) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (356) rename_unit -> . PACKAGE compound_name renames ;
    (357) rename_unit -> . subprog_spec renames ;
    (358) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (359) rename_unit -> . generic_formal_part subprog_spec renames ;
    (472) generic_formal_part -> . GENERIC
    (473) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 136 (decl_part -> decl_item_or_body_s1 .)
    END             reduce using rule 136 (decl_part -> decl_item_or_body_s1 .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 170
    number_decl                    shift and go to state 93

state 72

    (343) pkg_body -> PACKAGE . BODY compound_name IS decl_part body_opt END c_id_opt ;
    (455) body_stub -> PACKAGE . BODY compound_name IS SEPARATE ;
    (338) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> PACKAGE . compound_name IS generic_inst
    (356) rename_unit -> PACKAGE . compound_name renames ;
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    BODY            shift and go to state 171
    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 41
    compound_name                  shift and go to state 172

state 73

    (21) decl -> body_stub .

    PACKAGE         reduce using rule 21 (decl -> body_stub .)
    TASK            reduce using rule 21 (decl -> body_stub .)
    PROTECTED       reduce using rule 21 (decl -> body_stub .)
    error           reduce using rule 21 (decl -> body_stub .)
    USE             reduce using rule 21 (decl -> body_stub .)
    PRAGMA          reduce using rule 21 (decl -> body_stub .)
    TYPE            reduce using rule 21 (decl -> body_stub .)
    SUBTYPE         reduce using rule 21 (decl -> body_stub .)
    FOR             reduce using rule 21 (decl -> body_stub .)
    PROCEDURE       reduce using rule 21 (decl -> body_stub .)
    FUNCTION        reduce using rule 21 (decl -> body_stub .)
    GENERIC         reduce using rule 21 (decl -> body_stub .)
    IDENTIFIER      reduce using rule 21 (decl -> body_stub .)
    BEGIN           reduce using rule 21 (decl -> body_stub .)
    PRIVATE         reduce using rule 21 (decl -> body_stub .)
    END             reduce using rule 21 (decl -> body_stub .)


state 74

    (144) decl_item -> pragma .

    PACKAGE         reduce using rule 144 (decl_item -> pragma .)
    TASK            reduce using rule 144 (decl_item -> pragma .)
    PROTECTED       reduce using rule 144 (decl_item -> pragma .)
    error           reduce using rule 144 (decl_item -> pragma .)
    USE             reduce using rule 144 (decl_item -> pragma .)
    PRAGMA          reduce using rule 144 (decl_item -> pragma .)
    TYPE            reduce using rule 144 (decl_item -> pragma .)
    SUBTYPE         reduce using rule 144 (decl_item -> pragma .)
    FOR             reduce using rule 144 (decl_item -> pragma .)
    PROCEDURE       reduce using rule 144 (decl_item -> pragma .)
    FUNCTION        reduce using rule 144 (decl_item -> pragma .)
    GENERIC         reduce using rule 144 (decl_item -> pragma .)
    IDENTIFIER      reduce using rule 144 (decl_item -> pragma .)
    BEGIN           reduce using rule 144 (decl_item -> pragma .)
    END             reduce using rule 144 (decl_item -> pragma .)
    PRIVATE         reduce using rule 144 (decl_item -> pragma .)


state 75

    (369) prot_decl -> prot_spec . ;

    ;               shift and go to state 173


state 76

    (26) def_id -> IDENTIFIER .

    :               reduce using rule 26 (def_id -> IDENTIFIER .)
    ,               reduce using rule 26 (def_id -> IDENTIFIER .)


state 77

    (150) body -> pkg_body .

    PACKAGE         reduce using rule 150 (body -> pkg_body .)
    TASK            reduce using rule 150 (body -> pkg_body .)
    PROTECTED       reduce using rule 150 (body -> pkg_body .)
    error           reduce using rule 150 (body -> pkg_body .)
    USE             reduce using rule 150 (body -> pkg_body .)
    PRAGMA          reduce using rule 150 (body -> pkg_body .)
    TYPE            reduce using rule 150 (body -> pkg_body .)
    SUBTYPE         reduce using rule 150 (body -> pkg_body .)
    FOR             reduce using rule 150 (body -> pkg_body .)
    PROCEDURE       reduce using rule 150 (body -> pkg_body .)
    FUNCTION        reduce using rule 150 (body -> pkg_body .)
    GENERIC         reduce using rule 150 (body -> pkg_body .)
    IDENTIFIER      reduce using rule 150 (body -> pkg_body .)
    BEGIN           reduce using rule 150 (body -> pkg_body .)
    END             reduce using rule 150 (body -> pkg_body .)


state 78

    (22) decl -> error . ;

    ;               shift and go to state 174


state 79

    (145) decl_item_or_body_s1 -> decl_item_or_body .

    PACKAGE         reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    TASK            reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    PROTECTED       reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    error           reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    USE             reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    PRAGMA          reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    TYPE            reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    SUBTYPE         reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    FOR             reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    PROCEDURE       reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    FUNCTION        reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    GENERIC         reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    IDENTIFIER      reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    BEGIN           reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    END             reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)


state 80

    (36) type_decl -> TYPE . IDENTIFIER discrim_part_opt type_completion ;

    IDENTIFIER      shift and go to state 175


state 81

    (315) subprog_decl -> subprog_spec_is_push ABSTRACT . ;

    ;               shift and go to state 176


state 82

    (143) decl_item -> rep_spec .

    PACKAGE         reduce using rule 143 (decl_item -> rep_spec .)
    TASK            reduce using rule 143 (decl_item -> rep_spec .)
    PROTECTED       reduce using rule 143 (decl_item -> rep_spec .)
    error           reduce using rule 143 (decl_item -> rep_spec .)
    USE             reduce using rule 143 (decl_item -> rep_spec .)
    PRAGMA          reduce using rule 143 (decl_item -> rep_spec .)
    TYPE            reduce using rule 143 (decl_item -> rep_spec .)
    SUBTYPE         reduce using rule 143 (decl_item -> rep_spec .)
    FOR             reduce using rule 143 (decl_item -> rep_spec .)
    PROCEDURE       reduce using rule 143 (decl_item -> rep_spec .)
    FUNCTION        reduce using rule 143 (decl_item -> rep_spec .)
    GENERIC         reduce using rule 143 (decl_item -> rep_spec .)
    IDENTIFIER      reduce using rule 143 (decl_item -> rep_spec .)
    BEGIN           reduce using rule 143 (decl_item -> rep_spec .)
    END             reduce using rule 143 (decl_item -> rep_spec .)
    PRIVATE         reduce using rule 143 (decl_item -> rep_spec .)


state 83

    (151) body -> task_body .

    PACKAGE         reduce using rule 151 (body -> task_body .)
    TASK            reduce using rule 151 (body -> task_body .)
    PROTECTED       reduce using rule 151 (body -> task_body .)
    error           reduce using rule 151 (body -> task_body .)
    USE             reduce using rule 151 (body -> task_body .)
    PRAGMA          reduce using rule 151 (body -> task_body .)
    TYPE            reduce using rule 151 (body -> task_body .)
    SUBTYPE         reduce using rule 151 (body -> task_body .)
    FOR             reduce using rule 151 (body -> task_body .)
    PROCEDURE       reduce using rule 151 (body -> task_body .)
    FUNCTION        reduce using rule 151 (body -> task_body .)
    GENERIC         reduce using rule 151 (body -> task_body .)
    IDENTIFIER      reduce using rule 151 (body -> task_body .)
    BEGIN           reduce using rule 151 (body -> task_body .)
    END             reduce using rule 151 (body -> task_body .)


state 84

    (50) subtype_decl -> SUBTYPE . IDENTIFIER IS subtype_ind ;

    IDENTIFIER      shift and go to state 177


state 85

    (18) decl -> exception_decl .

    PACKAGE         reduce using rule 18 (decl -> exception_decl .)
    TASK            reduce using rule 18 (decl -> exception_decl .)
    PROTECTED       reduce using rule 18 (decl -> exception_decl .)
    error           reduce using rule 18 (decl -> exception_decl .)
    USE             reduce using rule 18 (decl -> exception_decl .)
    PRAGMA          reduce using rule 18 (decl -> exception_decl .)
    TYPE            reduce using rule 18 (decl -> exception_decl .)
    SUBTYPE         reduce using rule 18 (decl -> exception_decl .)
    FOR             reduce using rule 18 (decl -> exception_decl .)
    PROCEDURE       reduce using rule 18 (decl -> exception_decl .)
    FUNCTION        reduce using rule 18 (decl -> exception_decl .)
    GENERIC         reduce using rule 18 (decl -> exception_decl .)
    IDENTIFIER      reduce using rule 18 (decl -> exception_decl .)
    BEGIN           reduce using rule 18 (decl -> exception_decl .)
    PRIVATE         reduce using rule 18 (decl -> exception_decl .)
    END             reduce using rule 18 (decl -> exception_decl .)


state 86

    (334) subprog_body -> subprog_spec_is_push . decl_part block_body END id_opt ;
    (315) subprog_decl -> subprog_spec_is_push . ABSTRACT ;
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (334) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (343) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (368) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (385) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (349) use_clause -> . USE name_s ;
    (350) use_clause -> . USE TYPE name_s ;
    (503) rep_spec -> . attrib_def
    (504) rep_spec -> . record_type_spec
    (505) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (333) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (313) subprog_decl -> . subprog_spec ;
    (314) subprog_decl -> . generic_subp_inst ;
    (315) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (336) pkg_decl -> . pkg_spec ;
    (337) pkg_decl -> . generic_pkg_inst ;
    (361) task_decl -> . task_spec ;
    (369) prot_decl -> . prot_spec ;
    (458) exception_decl -> . def_id_s : EXCEPTION ;
    (353) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (354) rename_decl -> . def_id_s : EXCEPTION renames ;
    (355) rename_decl -> . rename_unit
    (470) generic_decl -> . generic_formal_part subprog_spec ;
    (471) generic_decl -> . generic_formal_part pkg_spec ;
    (454) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (455) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (456) body_stub -> . subprog_spec IS SEPARATE ;
    (457) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (506) attrib_def -> . FOR mark USE expression ;
    (507) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (512) address_spec -> . FOR mark USE AT expression ;
    (316) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (317) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (318) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (500) generic_subp_inst -> . subprog_spec IS generic_inst
    (338) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (362) task_spec -> . TASK simple_name task_def
    (363) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (370) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (371) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (356) rename_unit -> . PACKAGE compound_name renames ;
    (357) rename_unit -> . subprog_spec renames ;
    (358) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (359) rename_unit -> . generic_formal_part subprog_spec renames ;
    (472) generic_formal_part -> . GENERIC
    (473) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    ABSTRACT        shift and go to state 81
    BEGIN           reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 54
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 87

    (333) subprog_spec_is_push -> subprog_spec . IS
    (313) subprog_decl -> subprog_spec . ;
    (456) body_stub -> subprog_spec . IS SEPARATE ;
    (500) generic_subp_inst -> subprog_spec . IS generic_inst
    (357) rename_unit -> subprog_spec . renames ;
    (360) renames -> . RENAMES name

    IS              shift and go to state 178
    ;               shift and go to state 97
    RENAMES         shift and go to state 95

    renames                        shift and go to state 94

state 88

    (23) object_decl -> def_id_s . : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> def_id_s . : CONSTANT ASSIGNMENT expression ;
    (458) exception_decl -> def_id_s . : EXCEPTION ;
    (353) rename_decl -> def_id_s . : object_qualifier_opt subtype_ind renames ;
    (354) rename_decl -> def_id_s . : EXCEPTION renames ;
    (25) def_id_s -> def_id_s . , def_id

    :               shift and go to state 180
    ,               shift and go to state 179


state 89

    (24) def_id_s -> def_id .

    :               reduce using rule 24 (def_id_s -> def_id .)
    ,               reduce using rule 24 (def_id_s -> def_id .)


state 90

    (19) decl -> rename_decl .

    PACKAGE         reduce using rule 19 (decl -> rename_decl .)
    TASK            reduce using rule 19 (decl -> rename_decl .)
    PROTECTED       reduce using rule 19 (decl -> rename_decl .)
    error           reduce using rule 19 (decl -> rename_decl .)
    USE             reduce using rule 19 (decl -> rename_decl .)
    PRAGMA          reduce using rule 19 (decl -> rename_decl .)
    TYPE            reduce using rule 19 (decl -> rename_decl .)
    SUBTYPE         reduce using rule 19 (decl -> rename_decl .)
    FOR             reduce using rule 19 (decl -> rename_decl .)
    PROCEDURE       reduce using rule 19 (decl -> rename_decl .)
    FUNCTION        reduce using rule 19 (decl -> rename_decl .)
    GENERIC         reduce using rule 19 (decl -> rename_decl .)
    IDENTIFIER      reduce using rule 19 (decl -> rename_decl .)
    BEGIN           reduce using rule 19 (decl -> rename_decl .)
    PRIVATE         reduce using rule 19 (decl -> rename_decl .)
    END             reduce using rule 19 (decl -> rename_decl .)


state 91

    (355) rename_decl -> rename_unit .

    PACKAGE         reduce using rule 355 (rename_decl -> rename_unit .)
    TASK            reduce using rule 355 (rename_decl -> rename_unit .)
    PROTECTED       reduce using rule 355 (rename_decl -> rename_unit .)
    error           reduce using rule 355 (rename_decl -> rename_unit .)
    USE             reduce using rule 355 (rename_decl -> rename_unit .)
    PRAGMA          reduce using rule 355 (rename_decl -> rename_unit .)
    TYPE            reduce using rule 355 (rename_decl -> rename_unit .)
    SUBTYPE         reduce using rule 355 (rename_decl -> rename_unit .)
    FOR             reduce using rule 355 (rename_decl -> rename_unit .)
    PROCEDURE       reduce using rule 355 (rename_decl -> rename_unit .)
    FUNCTION        reduce using rule 355 (rename_decl -> rename_unit .)
    GENERIC         reduce using rule 355 (rename_decl -> rename_unit .)
    IDENTIFIER      reduce using rule 355 (rename_decl -> rename_unit .)
    BEGIN           reduce using rule 355 (rename_decl -> rename_unit .)
    END             reduce using rule 355 (rename_decl -> rename_unit .)
    PRIVATE         reduce using rule 355 (rename_decl -> rename_unit .)


state 92

    (152) body -> prot_body .

    PACKAGE         reduce using rule 152 (body -> prot_body .)
    TASK            reduce using rule 152 (body -> prot_body .)
    PROTECTED       reduce using rule 152 (body -> prot_body .)
    error           reduce using rule 152 (body -> prot_body .)
    USE             reduce using rule 152 (body -> prot_body .)
    PRAGMA          reduce using rule 152 (body -> prot_body .)
    TYPE            reduce using rule 152 (body -> prot_body .)
    SUBTYPE         reduce using rule 152 (body -> prot_body .)
    FOR             reduce using rule 152 (body -> prot_body .)
    PROCEDURE       reduce using rule 152 (body -> prot_body .)
    FUNCTION        reduce using rule 152 (body -> prot_body .)
    GENERIC         reduce using rule 152 (body -> prot_body .)
    IDENTIFIER      reduce using rule 152 (body -> prot_body .)
    BEGIN           reduce using rule 152 (body -> prot_body .)
    END             reduce using rule 152 (body -> prot_body .)


state 93

    (11) decl -> number_decl .

    PACKAGE         reduce using rule 11 (decl -> number_decl .)
    TASK            reduce using rule 11 (decl -> number_decl .)
    PROTECTED       reduce using rule 11 (decl -> number_decl .)
    error           reduce using rule 11 (decl -> number_decl .)
    USE             reduce using rule 11 (decl -> number_decl .)
    PRAGMA          reduce using rule 11 (decl -> number_decl .)
    TYPE            reduce using rule 11 (decl -> number_decl .)
    SUBTYPE         reduce using rule 11 (decl -> number_decl .)
    FOR             reduce using rule 11 (decl -> number_decl .)
    PROCEDURE       reduce using rule 11 (decl -> number_decl .)
    FUNCTION        reduce using rule 11 (decl -> number_decl .)
    GENERIC         reduce using rule 11 (decl -> number_decl .)
    IDENTIFIER      reduce using rule 11 (decl -> number_decl .)
    BEGIN           reduce using rule 11 (decl -> number_decl .)
    PRIVATE         reduce using rule 11 (decl -> number_decl .)
    END             reduce using rule 11 (decl -> number_decl .)


state 94

    (357) rename_unit -> subprog_spec renames . ;

    ;               shift and go to state 181


state 95

    (360) renames -> RENAMES . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 182
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 96

    (500) generic_subp_inst -> subprog_spec IS . generic_inst
    (333) subprog_spec_is_push -> subprog_spec IS .
    (502) generic_inst -> . NEW name

    ABSTRACT        reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    PACKAGE         reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    TASK            reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    PROTECTED       reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    error           reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    USE             reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    PRAGMA          reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    TYPE            reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    SUBTYPE         reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    FOR             reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    PROCEDURE       reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    FUNCTION        reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    GENERIC         reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    IDENTIFIER      reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    BEGIN           reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    NEW             shift and go to state 183

    generic_inst                   shift and go to state 184

state 97

    (313) subprog_decl -> subprog_spec ; .

    PACKAGE         reduce using rule 313 (subprog_decl -> subprog_spec ; .)
    TASK            reduce using rule 313 (subprog_decl -> subprog_spec ; .)
    PROTECTED       reduce using rule 313 (subprog_decl -> subprog_spec ; .)
    error           reduce using rule 313 (subprog_decl -> subprog_spec ; .)
    USE             reduce using rule 313 (subprog_decl -> subprog_spec ; .)
    PRAGMA          reduce using rule 313 (subprog_decl -> subprog_spec ; .)
    TYPE            reduce using rule 313 (subprog_decl -> subprog_spec ; .)
    SUBTYPE         reduce using rule 313 (subprog_decl -> subprog_spec ; .)
    FOR             reduce using rule 313 (subprog_decl -> subprog_spec ; .)
    PROCEDURE       reduce using rule 313 (subprog_decl -> subprog_spec ; .)
    FUNCTION        reduce using rule 313 (subprog_decl -> subprog_spec ; .)
    GENERIC         reduce using rule 313 (subprog_decl -> subprog_spec ; .)
    IDENTIFIER      reduce using rule 313 (subprog_decl -> subprog_spec ; .)
    BEGIN           reduce using rule 313 (subprog_decl -> subprog_spec ; .)
    PRIVATE         reduce using rule 313 (subprog_decl -> subprog_spec ; .)
    WITH            reduce using rule 313 (subprog_decl -> subprog_spec ; .)
    SEPARATE        reduce using rule 313 (subprog_decl -> subprog_spec ; .)
    $end            reduce using rule 313 (subprog_decl -> subprog_spec ; .)
    END             reduce using rule 313 (subprog_decl -> subprog_spec ; .)


state 98

    (343) pkg_body -> PACKAGE BODY . compound_name IS decl_part body_opt END c_id_opt ;
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 185
    simple_name                    shift and go to state 41

state 99

    (356) rename_unit -> PACKAGE compound_name . renames ;
    (338) pkg_spec -> PACKAGE compound_name . IS decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> PACKAGE compound_name . IS generic_inst
    (163) compound_name -> compound_name . . simple_name
    (360) renames -> . RENAMES name

    IS              shift and go to state 187
    .               shift and go to state 119
    RENAMES         shift and go to state 95

    renames                        shift and go to state 186

state 100

    (314) subprog_decl -> generic_subp_inst ; .

    PACKAGE         reduce using rule 314 (subprog_decl -> generic_subp_inst ; .)
    TASK            reduce using rule 314 (subprog_decl -> generic_subp_inst ; .)
    PROTECTED       reduce using rule 314 (subprog_decl -> generic_subp_inst ; .)
    error           reduce using rule 314 (subprog_decl -> generic_subp_inst ; .)
    USE             reduce using rule 314 (subprog_decl -> generic_subp_inst ; .)
    PRAGMA          reduce using rule 314 (subprog_decl -> generic_subp_inst ; .)
    TYPE            reduce using rule 314 (subprog_decl -> generic_subp_inst ; .)
    SUBTYPE         reduce using rule 314 (subprog_decl -> generic_subp_inst ; .)
    FOR             reduce using rule 314 (subprog_decl -> generic_subp_inst ; .)
    PROCEDURE       reduce using rule 314 (subprog_decl -> generic_subp_inst ; .)
    FUNCTION        reduce using rule 314 (subprog_decl -> generic_subp_inst ; .)
    GENERIC         reduce using rule 314 (subprog_decl -> generic_subp_inst ; .)
    IDENTIFIER      reduce using rule 314 (subprog_decl -> generic_subp_inst ; .)
    BEGIN           reduce using rule 314 (subprog_decl -> generic_subp_inst ; .)
    PRIVATE         reduce using rule 314 (subprog_decl -> generic_subp_inst ; .)
    WITH            reduce using rule 314 (subprog_decl -> generic_subp_inst ; .)
    SEPARATE        reduce using rule 314 (subprog_decl -> generic_subp_inst ; .)
    $end            reduce using rule 314 (subprog_decl -> generic_subp_inst ; .)
    END             reduce using rule 314 (subprog_decl -> generic_subp_inst ; .)


state 101

    (316) subprog_spec -> PROCEDURE compound_name . formal_part_opt
    (163) compound_name -> compound_name . . simple_name
    (321) formal_part_opt -> .
    (322) formal_part_opt -> . formal_part
    (323) formal_part -> . ( param_s )

    .               shift and go to state 119
    ;               reduce using rule 321 (formal_part_opt -> .)
    IS              reduce using rule 321 (formal_part_opt -> .)
    RENAMES         reduce using rule 321 (formal_part_opt -> .)
    (               shift and go to state 189

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 190

state 102

    (476) generic_formal -> WITH . PROCEDURE simple_name formal_part_opt subp_default ;
    (477) generic_formal -> WITH . FUNCTION designator formal_part_opt RETURN name subp_default ;
    (478) generic_formal -> WITH . PACKAGE simple_name IS NEW name ( LESSMORE ) ;
    (479) generic_formal -> WITH . PACKAGE simple_name IS NEW name ;

    PROCEDURE       shift and go to state 193
    FUNCTION        shift and go to state 191
    PACKAGE         shift and go to state 192


state 103

    (474) generic_formal -> param . ;

    ;               shift and go to state 194


state 104

    (470) generic_decl -> generic_formal_part subprog_spec . ;
    (359) rename_unit -> generic_formal_part subprog_spec . renames ;
    (360) renames -> . RENAMES name

    ;               shift and go to state 196
    RENAMES         shift and go to state 95

    renames                        shift and go to state 195

state 105

    (326) param -> def_id_s . : mode mark init_opt
    (25) def_id_s -> def_id_s . , def_id

    :               shift and go to state 197
    ,               shift and go to state 179


state 106

    (358) rename_unit -> generic_formal_part PACKAGE . compound_name renames ;
    (338) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 41
    compound_name                  shift and go to state 198

state 107

    (473) generic_formal_part -> generic_formal_part generic_formal .

    PACKAGE         reduce using rule 473 (generic_formal_part -> generic_formal_part generic_formal .)
    PROCEDURE       reduce using rule 473 (generic_formal_part -> generic_formal_part generic_formal .)
    FUNCTION        reduce using rule 473 (generic_formal_part -> generic_formal_part generic_formal .)
    TYPE            reduce using rule 473 (generic_formal_part -> generic_formal_part generic_formal .)
    WITH            reduce using rule 473 (generic_formal_part -> generic_formal_part generic_formal .)
    error           reduce using rule 473 (generic_formal_part -> generic_formal_part generic_formal .)
    USE             reduce using rule 473 (generic_formal_part -> generic_formal_part generic_formal .)
    IDENTIFIER      reduce using rule 473 (generic_formal_part -> generic_formal_part generic_formal .)


state 108

    (480) generic_formal -> use_clause .

    PACKAGE         reduce using rule 480 (generic_formal -> use_clause .)
    PROCEDURE       reduce using rule 480 (generic_formal -> use_clause .)
    FUNCTION        reduce using rule 480 (generic_formal -> use_clause .)
    TYPE            reduce using rule 480 (generic_formal -> use_clause .)
    WITH            reduce using rule 480 (generic_formal -> use_clause .)
    error           reduce using rule 480 (generic_formal -> use_clause .)
    USE             reduce using rule 480 (generic_formal -> use_clause .)
    IDENTIFIER      reduce using rule 480 (generic_formal -> use_clause .)


state 109

    (327) param -> error .

    )               reduce using rule 327 (param -> error .)
    ;               reduce using rule 327 (param -> error .)


state 110

    (471) generic_decl -> generic_formal_part pkg_spec . ;

    ;               shift and go to state 199


state 111

    (475) generic_formal -> TYPE . simple_name generic_discrim_part_opt IS generic_type_def ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 200

state 112

    (337) pkg_decl -> generic_pkg_inst ; .

    error           reduce using rule 337 (pkg_decl -> generic_pkg_inst ; .)
    USE             reduce using rule 337 (pkg_decl -> generic_pkg_inst ; .)
    PRAGMA          reduce using rule 337 (pkg_decl -> generic_pkg_inst ; .)
    TYPE            reduce using rule 337 (pkg_decl -> generic_pkg_inst ; .)
    SUBTYPE         reduce using rule 337 (pkg_decl -> generic_pkg_inst ; .)
    TASK            reduce using rule 337 (pkg_decl -> generic_pkg_inst ; .)
    PACKAGE         reduce using rule 337 (pkg_decl -> generic_pkg_inst ; .)
    PROTECTED       reduce using rule 337 (pkg_decl -> generic_pkg_inst ; .)
    FOR             reduce using rule 337 (pkg_decl -> generic_pkg_inst ; .)
    PROCEDURE       reduce using rule 337 (pkg_decl -> generic_pkg_inst ; .)
    FUNCTION        reduce using rule 337 (pkg_decl -> generic_pkg_inst ; .)
    GENERIC         reduce using rule 337 (pkg_decl -> generic_pkg_inst ; .)
    IDENTIFIER      reduce using rule 337 (pkg_decl -> generic_pkg_inst ; .)
    PRIVATE         reduce using rule 337 (pkg_decl -> generic_pkg_inst ; .)
    END             reduce using rule 337 (pkg_decl -> generic_pkg_inst ; .)
    BEGIN           reduce using rule 337 (pkg_decl -> generic_pkg_inst ; .)
    WITH            reduce using rule 337 (pkg_decl -> generic_pkg_inst ; .)
    SEPARATE        reduce using rule 337 (pkg_decl -> generic_pkg_inst ; .)
    $end            reduce using rule 337 (pkg_decl -> generic_pkg_inst ; .)


state 113

    (317) subprog_spec -> FUNCTION designator . formal_part_opt RETURN name
    (318) subprog_spec -> FUNCTION designator .
    (321) formal_part_opt -> .
    (322) formal_part_opt -> . formal_part
    (323) formal_part -> . ( param_s )

    ;               reduce using rule 318 (subprog_spec -> FUNCTION designator .)
    IS              reduce using rule 318 (subprog_spec -> FUNCTION designator .)
    RENAMES         reduce using rule 318 (subprog_spec -> FUNCTION designator .)
    RETURN          reduce using rule 321 (formal_part_opt -> .)
    (               shift and go to state 189

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 201

state 114

    (319) designator -> compound_name .
    (163) compound_name -> compound_name . . simple_name

    (               reduce using rule 319 (designator -> compound_name .)
    RETURN          reduce using rule 319 (designator -> compound_name .)
    ;               reduce using rule 319 (designator -> compound_name .)
    IS              reduce using rule 319 (designator -> compound_name .)
    RENAMES         reduce using rule 319 (designator -> compound_name .)
    .               shift and go to state 119


state 115

    (320) designator -> STRING .

    (               reduce using rule 320 (designator -> STRING .)
    RETURN          reduce using rule 320 (designator -> STRING .)
    ;               reduce using rule 320 (designator -> STRING .)
    IS              reduce using rule 320 (designator -> STRING .)
    RENAMES         reduce using rule 320 (designator -> STRING .)


state 116

    (336) pkg_decl -> pkg_spec ; .

    error           reduce using rule 336 (pkg_decl -> pkg_spec ; .)
    USE             reduce using rule 336 (pkg_decl -> pkg_spec ; .)
    PRAGMA          reduce using rule 336 (pkg_decl -> pkg_spec ; .)
    TYPE            reduce using rule 336 (pkg_decl -> pkg_spec ; .)
    SUBTYPE         reduce using rule 336 (pkg_decl -> pkg_spec ; .)
    TASK            reduce using rule 336 (pkg_decl -> pkg_spec ; .)
    PACKAGE         reduce using rule 336 (pkg_decl -> pkg_spec ; .)
    PROTECTED       reduce using rule 336 (pkg_decl -> pkg_spec ; .)
    FOR             reduce using rule 336 (pkg_decl -> pkg_spec ; .)
    PROCEDURE       reduce using rule 336 (pkg_decl -> pkg_spec ; .)
    FUNCTION        reduce using rule 336 (pkg_decl -> pkg_spec ; .)
    GENERIC         reduce using rule 336 (pkg_decl -> pkg_spec ; .)
    IDENTIFIER      reduce using rule 336 (pkg_decl -> pkg_spec ; .)
    PRIVATE         reduce using rule 336 (pkg_decl -> pkg_spec ; .)
    END             reduce using rule 336 (pkg_decl -> pkg_spec ; .)
    BEGIN           reduce using rule 336 (pkg_decl -> pkg_spec ; .)
    WITH            reduce using rule 336 (pkg_decl -> pkg_spec ; .)
    SEPARATE        reduce using rule 336 (pkg_decl -> pkg_spec ; .)
    $end            reduce using rule 336 (pkg_decl -> pkg_spec ; .)


state 117

    (439) with_clause -> WITH c_name_list ; .

    USE             reduce using rule 439 (with_clause -> WITH c_name_list ; .)
    PRIVATE         reduce using rule 439 (with_clause -> WITH c_name_list ; .)
    WITH            reduce using rule 439 (with_clause -> WITH c_name_list ; .)
    PRAGMA          reduce using rule 439 (with_clause -> WITH c_name_list ; .)
    PACKAGE         reduce using rule 439 (with_clause -> WITH c_name_list ; .)
    SEPARATE        reduce using rule 439 (with_clause -> WITH c_name_list ; .)
    PROCEDURE       reduce using rule 439 (with_clause -> WITH c_name_list ; .)
    FUNCTION        reduce using rule 439 (with_clause -> WITH c_name_list ; .)
    GENERIC         reduce using rule 439 (with_clause -> WITH c_name_list ; .)


state 118

    (165) c_name_list -> c_name_list , . compound_name
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 202
    simple_name                    shift and go to state 41

state 119

    (163) compound_name -> compound_name . . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 203

state 120

    (155) name -> selected_comp .

    TICK            reduce using rule 155 (name -> selected_comp .)
    (               reduce using rule 155 (name -> selected_comp .)
    .               reduce using rule 155 (name -> selected_comp .)
    STARSTAR        reduce using rule 155 (name -> selected_comp .)
    *               reduce using rule 155 (name -> selected_comp .)
    /               reduce using rule 155 (name -> selected_comp .)
    MOD             reduce using rule 155 (name -> selected_comp .)
    REM             reduce using rule 155 (name -> selected_comp .)
    =               reduce using rule 155 (name -> selected_comp .)
    NOTEQUAL        reduce using rule 155 (name -> selected_comp .)
    <               reduce using rule 155 (name -> selected_comp .)
    LESSEQ          reduce using rule 155 (name -> selected_comp .)
    >               reduce using rule 155 (name -> selected_comp .)
    GREATEREQ       reduce using rule 155 (name -> selected_comp .)
    IN              reduce using rule 155 (name -> selected_comp .)
    NOT             reduce using rule 155 (name -> selected_comp .)
    +               reduce using rule 155 (name -> selected_comp .)
    -               reduce using rule 155 (name -> selected_comp .)
    &               reduce using rule 155 (name -> selected_comp .)
    IS              reduce using rule 155 (name -> selected_comp .)
    AND             reduce using rule 155 (name -> selected_comp .)
    OR              reduce using rule 155 (name -> selected_comp .)
    RANGE           reduce using rule 155 (name -> selected_comp .)
    DIGITS          reduce using rule 155 (name -> selected_comp .)
    ;               reduce using rule 155 (name -> selected_comp .)
    )               reduce using rule 155 (name -> selected_comp .)
    ,               reduce using rule 155 (name -> selected_comp .)
    WITH            reduce using rule 155 (name -> selected_comp .)
    ARROW           reduce using rule 155 (name -> selected_comp .)
    |               reduce using rule 155 (name -> selected_comp .)
    THEN            reduce using rule 155 (name -> selected_comp .)
    LOOP            reduce using rule 155 (name -> selected_comp .)
    RENAMES         reduce using rule 155 (name -> selected_comp .)
    ASSIGNMENT      reduce using rule 155 (name -> selected_comp .)
    DOTDOT          reduce using rule 155 (name -> selected_comp .)
    WHEN            reduce using rule 155 (name -> selected_comp .)


state 121

    (156) name -> attribute .

    TICK            reduce using rule 156 (name -> attribute .)
    (               reduce using rule 156 (name -> attribute .)
    .               reduce using rule 156 (name -> attribute .)
    STARSTAR        reduce using rule 156 (name -> attribute .)
    *               reduce using rule 156 (name -> attribute .)
    /               reduce using rule 156 (name -> attribute .)
    MOD             reduce using rule 156 (name -> attribute .)
    REM             reduce using rule 156 (name -> attribute .)
    =               reduce using rule 156 (name -> attribute .)
    NOTEQUAL        reduce using rule 156 (name -> attribute .)
    <               reduce using rule 156 (name -> attribute .)
    LESSEQ          reduce using rule 156 (name -> attribute .)
    >               reduce using rule 156 (name -> attribute .)
    GREATEREQ       reduce using rule 156 (name -> attribute .)
    IN              reduce using rule 156 (name -> attribute .)
    NOT             reduce using rule 156 (name -> attribute .)
    +               reduce using rule 156 (name -> attribute .)
    -               reduce using rule 156 (name -> attribute .)
    &               reduce using rule 156 (name -> attribute .)
    IS              reduce using rule 156 (name -> attribute .)
    AND             reduce using rule 156 (name -> attribute .)
    OR              reduce using rule 156 (name -> attribute .)
    RANGE           reduce using rule 156 (name -> attribute .)
    DIGITS          reduce using rule 156 (name -> attribute .)
    ;               reduce using rule 156 (name -> attribute .)
    )               reduce using rule 156 (name -> attribute .)
    ,               reduce using rule 156 (name -> attribute .)
    WITH            reduce using rule 156 (name -> attribute .)
    ARROW           reduce using rule 156 (name -> attribute .)
    |               reduce using rule 156 (name -> attribute .)
    THEN            reduce using rule 156 (name -> attribute .)
    LOOP            reduce using rule 156 (name -> attribute .)
    RENAMES         reduce using rule 156 (name -> attribute .)
    ASSIGNMENT      reduce using rule 156 (name -> attribute .)
    DOTDOT          reduce using rule 156 (name -> attribute .)
    WHEN            reduce using rule 156 (name -> attribute .)


state 122

    (231) factor -> primary .
    (233) factor -> primary . STARSTAR primary

    *               reduce using rule 231 (factor -> primary .)
    /               reduce using rule 231 (factor -> primary .)
    MOD             reduce using rule 231 (factor -> primary .)
    REM             reduce using rule 231 (factor -> primary .)
    =               reduce using rule 231 (factor -> primary .)
    NOTEQUAL        reduce using rule 231 (factor -> primary .)
    <               reduce using rule 231 (factor -> primary .)
    LESSEQ          reduce using rule 231 (factor -> primary .)
    >               reduce using rule 231 (factor -> primary .)
    GREATEREQ       reduce using rule 231 (factor -> primary .)
    IN              reduce using rule 231 (factor -> primary .)
    NOT             reduce using rule 231 (factor -> primary .)
    +               reduce using rule 231 (factor -> primary .)
    -               reduce using rule 231 (factor -> primary .)
    &               reduce using rule 231 (factor -> primary .)
    AND             reduce using rule 231 (factor -> primary .)
    OR              reduce using rule 231 (factor -> primary .)
    )               reduce using rule 231 (factor -> primary .)
    ,               reduce using rule 231 (factor -> primary .)
    DOTDOT          reduce using rule 231 (factor -> primary .)
    ;               reduce using rule 231 (factor -> primary .)
    ARROW           reduce using rule 231 (factor -> primary .)
    |               reduce using rule 231 (factor -> primary .)
    RANGE           reduce using rule 231 (factor -> primary .)
    DIGITS          reduce using rule 231 (factor -> primary .)
    WITH            reduce using rule 231 (factor -> primary .)
    IS              reduce using rule 231 (factor -> primary .)
    THEN            reduce using rule 231 (factor -> primary .)
    LOOP            reduce using rule 231 (factor -> primary .)
    RENAMES         reduce using rule 231 (factor -> primary .)
    ASSIGNMENT      reduce using rule 231 (factor -> primary .)
    STARSTAR        shift and go to state 204


state 123

    (4) pragma_arg_s -> pragma_arg .

    )               reduce using rule 4 (pragma_arg_s -> pragma_arg .)
    ,               reduce using rule 4 (pragma_arg_s -> pragma_arg .)


state 124

    (217) simple_expression -> unary . term
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 205
    name                           shift and go to state 148
    operator_symbol                shift and go to state 138

state 125

    (198) expression -> relation .

    AND             reduce using rule 198 (expression -> relation .)
    OR              reduce using rule 198 (expression -> relation .)
    LOOP            reduce using rule 198 (expression -> relation .)
    )               reduce using rule 198 (expression -> relation .)
    ,               reduce using rule 198 (expression -> relation .)
    ARROW           reduce using rule 198 (expression -> relation .)
    |               reduce using rule 198 (expression -> relation .)
    ;               reduce using rule 198 (expression -> relation .)
    IS              reduce using rule 198 (expression -> relation .)
    RANGE           reduce using rule 198 (expression -> relation .)
    RENAMES         reduce using rule 198 (expression -> relation .)
    ASSIGNMENT      reduce using rule 198 (expression -> relation .)
    WITH            reduce using rule 198 (expression -> relation .)
    THEN            reduce using rule 198 (expression -> relation .)
    DIGITS          reduce using rule 198 (expression -> relation .)


state 126

    (186) literal -> BASE_FLOAT .

    STARSTAR        reduce using rule 186 (literal -> BASE_FLOAT .)
    *               reduce using rule 186 (literal -> BASE_FLOAT .)
    /               reduce using rule 186 (literal -> BASE_FLOAT .)
    MOD             reduce using rule 186 (literal -> BASE_FLOAT .)
    REM             reduce using rule 186 (literal -> BASE_FLOAT .)
    =               reduce using rule 186 (literal -> BASE_FLOAT .)
    NOTEQUAL        reduce using rule 186 (literal -> BASE_FLOAT .)
    <               reduce using rule 186 (literal -> BASE_FLOAT .)
    LESSEQ          reduce using rule 186 (literal -> BASE_FLOAT .)
    >               reduce using rule 186 (literal -> BASE_FLOAT .)
    GREATEREQ       reduce using rule 186 (literal -> BASE_FLOAT .)
    IN              reduce using rule 186 (literal -> BASE_FLOAT .)
    NOT             reduce using rule 186 (literal -> BASE_FLOAT .)
    +               reduce using rule 186 (literal -> BASE_FLOAT .)
    -               reduce using rule 186 (literal -> BASE_FLOAT .)
    &               reduce using rule 186 (literal -> BASE_FLOAT .)
    AND             reduce using rule 186 (literal -> BASE_FLOAT .)
    OR              reduce using rule 186 (literal -> BASE_FLOAT .)
    ;               reduce using rule 186 (literal -> BASE_FLOAT .)
    )               reduce using rule 186 (literal -> BASE_FLOAT .)
    DOTDOT          reduce using rule 186 (literal -> BASE_FLOAT .)
    ,               reduce using rule 186 (literal -> BASE_FLOAT .)
    IS              reduce using rule 186 (literal -> BASE_FLOAT .)
    WITH            reduce using rule 186 (literal -> BASE_FLOAT .)
    ARROW           reduce using rule 186 (literal -> BASE_FLOAT .)
    |               reduce using rule 186 (literal -> BASE_FLOAT .)
    THEN            reduce using rule 186 (literal -> BASE_FLOAT .)
    LOOP            reduce using rule 186 (literal -> BASE_FLOAT .)
    RANGE           reduce using rule 186 (literal -> BASE_FLOAT .)
    DIGITS          reduce using rule 186 (literal -> BASE_FLOAT .)
    RENAMES         reduce using rule 186 (literal -> BASE_FLOAT .)
    ASSIGNMENT      reduce using rule 186 (literal -> BASE_FLOAT .)


state 127

    (242) allocator -> NEW . name
    (243) allocator -> NEW . qualified
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 206
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 207
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 128

    (205) relation -> simple_expression .
    (206) relation -> simple_expression . relational simple_expression
    (207) relation -> simple_expression . membership range
    (208) relation -> simple_expression . membership name
    (219) simple_expression -> simple_expression . adding term
    (209) relational -> . =
    (210) relational -> . NOTEQUAL
    (211) relational -> . <
    (212) relational -> . LESSEQ
    (213) relational -> . >
    (214) relational -> . GREATEREQ
    (215) membership -> . IN
    (216) membership -> . NOT IN
    (222) adding -> . +
    (223) adding -> . -
    (224) adding -> . &

    AND             reduce using rule 205 (relation -> simple_expression .)
    OR              reduce using rule 205 (relation -> simple_expression .)
    )               reduce using rule 205 (relation -> simple_expression .)
    ,               reduce using rule 205 (relation -> simple_expression .)
    RANGE           reduce using rule 205 (relation -> simple_expression .)
    ;               reduce using rule 205 (relation -> simple_expression .)
    THEN            reduce using rule 205 (relation -> simple_expression .)
    LOOP            reduce using rule 205 (relation -> simple_expression .)
    WITH            reduce using rule 205 (relation -> simple_expression .)
    ARROW           reduce using rule 205 (relation -> simple_expression .)
    |               reduce using rule 205 (relation -> simple_expression .)
    IS              reduce using rule 205 (relation -> simple_expression .)
    DIGITS          reduce using rule 205 (relation -> simple_expression .)
    RENAMES         reduce using rule 205 (relation -> simple_expression .)
    ASSIGNMENT      reduce using rule 205 (relation -> simple_expression .)
    =               shift and go to state 219
    NOTEQUAL        shift and go to state 209
    <               shift and go to state 220
    LESSEQ          shift and go to state 215
    >               shift and go to state 221
    GREATEREQ       shift and go to state 214
    IN              shift and go to state 216
    NOT             shift and go to state 217
    +               shift and go to state 210
    -               shift and go to state 212
    &               shift and go to state 211

    adding                         shift and go to state 208
    membership                     shift and go to state 213
    relational                     shift and go to state 218

state 129

    (154) name -> indexed_comp .

    TICK            reduce using rule 154 (name -> indexed_comp .)
    (               reduce using rule 154 (name -> indexed_comp .)
    .               reduce using rule 154 (name -> indexed_comp .)
    STARSTAR        reduce using rule 154 (name -> indexed_comp .)
    *               reduce using rule 154 (name -> indexed_comp .)
    /               reduce using rule 154 (name -> indexed_comp .)
    MOD             reduce using rule 154 (name -> indexed_comp .)
    REM             reduce using rule 154 (name -> indexed_comp .)
    =               reduce using rule 154 (name -> indexed_comp .)
    NOTEQUAL        reduce using rule 154 (name -> indexed_comp .)
    <               reduce using rule 154 (name -> indexed_comp .)
    LESSEQ          reduce using rule 154 (name -> indexed_comp .)
    >               reduce using rule 154 (name -> indexed_comp .)
    GREATEREQ       reduce using rule 154 (name -> indexed_comp .)
    IN              reduce using rule 154 (name -> indexed_comp .)
    NOT             reduce using rule 154 (name -> indexed_comp .)
    +               reduce using rule 154 (name -> indexed_comp .)
    -               reduce using rule 154 (name -> indexed_comp .)
    &               reduce using rule 154 (name -> indexed_comp .)
    IS              reduce using rule 154 (name -> indexed_comp .)
    AND             reduce using rule 154 (name -> indexed_comp .)
    OR              reduce using rule 154 (name -> indexed_comp .)
    RANGE           reduce using rule 154 (name -> indexed_comp .)
    DIGITS          reduce using rule 154 (name -> indexed_comp .)
    ;               reduce using rule 154 (name -> indexed_comp .)
    )               reduce using rule 154 (name -> indexed_comp .)
    ,               reduce using rule 154 (name -> indexed_comp .)
    WITH            reduce using rule 154 (name -> indexed_comp .)
    ARROW           reduce using rule 154 (name -> indexed_comp .)
    |               reduce using rule 154 (name -> indexed_comp .)
    THEN            reduce using rule 154 (name -> indexed_comp .)
    LOOP            reduce using rule 154 (name -> indexed_comp .)
    RENAMES         reduce using rule 154 (name -> indexed_comp .)
    ASSIGNMENT      reduce using rule 154 (name -> indexed_comp .)
    DOTDOT          reduce using rule 154 (name -> indexed_comp .)
    WHEN            reduce using rule 154 (name -> indexed_comp .)


state 130

    (236) primary -> allocator .

    STARSTAR        reduce using rule 236 (primary -> allocator .)
    *               reduce using rule 236 (primary -> allocator .)
    /               reduce using rule 236 (primary -> allocator .)
    MOD             reduce using rule 236 (primary -> allocator .)
    REM             reduce using rule 236 (primary -> allocator .)
    =               reduce using rule 236 (primary -> allocator .)
    NOTEQUAL        reduce using rule 236 (primary -> allocator .)
    <               reduce using rule 236 (primary -> allocator .)
    LESSEQ          reduce using rule 236 (primary -> allocator .)
    >               reduce using rule 236 (primary -> allocator .)
    GREATEREQ       reduce using rule 236 (primary -> allocator .)
    IN              reduce using rule 236 (primary -> allocator .)
    NOT             reduce using rule 236 (primary -> allocator .)
    +               reduce using rule 236 (primary -> allocator .)
    -               reduce using rule 236 (primary -> allocator .)
    &               reduce using rule 236 (primary -> allocator .)
    AND             reduce using rule 236 (primary -> allocator .)
    OR              reduce using rule 236 (primary -> allocator .)
    ;               reduce using rule 236 (primary -> allocator .)
    IS              reduce using rule 236 (primary -> allocator .)
    )               reduce using rule 236 (primary -> allocator .)
    ,               reduce using rule 236 (primary -> allocator .)
    DOTDOT          reduce using rule 236 (primary -> allocator .)
    ARROW           reduce using rule 236 (primary -> allocator .)
    |               reduce using rule 236 (primary -> allocator .)
    THEN            reduce using rule 236 (primary -> allocator .)
    WITH            reduce using rule 236 (primary -> allocator .)
    LOOP            reduce using rule 236 (primary -> allocator .)
    RANGE           reduce using rule 236 (primary -> allocator .)
    DIGITS          reduce using rule 236 (primary -> allocator .)
    RENAMES         reduce using rule 236 (primary -> allocator .)
    ASSIGNMENT      reduce using rule 236 (primary -> allocator .)


state 131

    (7) pragma_arg -> simple_name . ARROW expression
    (153) name -> simple_name .

    ARROW           shift and go to state 222
    TICK            reduce using rule 153 (name -> simple_name .)
    (               reduce using rule 153 (name -> simple_name .)
    .               reduce using rule 153 (name -> simple_name .)
    STARSTAR        reduce using rule 153 (name -> simple_name .)
    *               reduce using rule 153 (name -> simple_name .)
    /               reduce using rule 153 (name -> simple_name .)
    MOD             reduce using rule 153 (name -> simple_name .)
    REM             reduce using rule 153 (name -> simple_name .)
    =               reduce using rule 153 (name -> simple_name .)
    NOTEQUAL        reduce using rule 153 (name -> simple_name .)
    <               reduce using rule 153 (name -> simple_name .)
    LESSEQ          reduce using rule 153 (name -> simple_name .)
    >               reduce using rule 153 (name -> simple_name .)
    GREATEREQ       reduce using rule 153 (name -> simple_name .)
    IN              reduce using rule 153 (name -> simple_name .)
    NOT             reduce using rule 153 (name -> simple_name .)
    +               reduce using rule 153 (name -> simple_name .)
    -               reduce using rule 153 (name -> simple_name .)
    &               reduce using rule 153 (name -> simple_name .)
    AND             reduce using rule 153 (name -> simple_name .)
    OR              reduce using rule 153 (name -> simple_name .)
    )               reduce using rule 153 (name -> simple_name .)
    ,               reduce using rule 153 (name -> simple_name .)


state 132

    (240) parenthesized_primary -> ( . expression )
    (189) aggregate -> ( . comp_assoc )
    (190) aggregate -> ( . value_s_2 )
    (191) aggregate -> ( . expression WITH value_s )
    (192) aggregate -> ( . expression WITH NuLL RECORD )
    (193) aggregate -> ( . NuLL RECORD )
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (196) comp_assoc -> . choice_s ARROW expression
    (194) value_s_2 -> . value , value
    (195) value_s_2 -> . value_s_2 , value
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (171) value -> . expression
    (172) value -> . comp_assoc
    (173) value -> . error
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    NuLL            shift and go to state 234
    error           shift and go to state 233
    OTHERS          shift and go to state 223
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 224
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    comp_assoc                     shift and go to state 226
    choice_s                       shift and go to state 225
    choice                         shift and go to state 227
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    value_s_2                      shift and go to state 228
    aggregate                      shift and go to state 144
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 147
    name                           shift and go to state 230
    value                          shift and go to state 231
    range                          shift and go to state 232
    expression                     shift and go to state 235

state 133

    (220) unary -> + .

    NOT             reduce using rule 220 (unary -> + .)
    INTEGER         reduce using rule 220 (unary -> + .)
    BASE_INTEGER    reduce using rule 220 (unary -> + .)
    FLOAT           reduce using rule 220 (unary -> + .)
    BASE_FLOAT      reduce using rule 220 (unary -> + .)
    NuLL            reduce using rule 220 (unary -> + .)
    NEW             reduce using rule 220 (unary -> + .)
    (               reduce using rule 220 (unary -> + .)
    CHAR            reduce using rule 220 (unary -> + .)
    IDENTIFIER      reduce using rule 220 (unary -> + .)
    STRING          reduce using rule 220 (unary -> + .)


state 134

    (221) unary -> - .

    NOT             reduce using rule 221 (unary -> - .)
    INTEGER         reduce using rule 221 (unary -> - .)
    BASE_INTEGER    reduce using rule 221 (unary -> - .)
    FLOAT           reduce using rule 221 (unary -> - .)
    BASE_FLOAT      reduce using rule 221 (unary -> - .)
    NuLL            reduce using rule 221 (unary -> - .)
    NEW             reduce using rule 221 (unary -> - .)
    (               reduce using rule 221 (unary -> - .)
    CHAR            reduce using rule 221 (unary -> - .)
    IDENTIFIER      reduce using rule 221 (unary -> - .)
    STRING          reduce using rule 221 (unary -> - .)


state 135

    (234) primary -> literal .

    STARSTAR        reduce using rule 234 (primary -> literal .)
    *               reduce using rule 234 (primary -> literal .)
    /               reduce using rule 234 (primary -> literal .)
    MOD             reduce using rule 234 (primary -> literal .)
    REM             reduce using rule 234 (primary -> literal .)
    =               reduce using rule 234 (primary -> literal .)
    NOTEQUAL        reduce using rule 234 (primary -> literal .)
    <               reduce using rule 234 (primary -> literal .)
    LESSEQ          reduce using rule 234 (primary -> literal .)
    >               reduce using rule 234 (primary -> literal .)
    GREATEREQ       reduce using rule 234 (primary -> literal .)
    IN              reduce using rule 234 (primary -> literal .)
    NOT             reduce using rule 234 (primary -> literal .)
    +               reduce using rule 234 (primary -> literal .)
    -               reduce using rule 234 (primary -> literal .)
    &               reduce using rule 234 (primary -> literal .)
    AND             reduce using rule 234 (primary -> literal .)
    OR              reduce using rule 234 (primary -> literal .)
    ;               reduce using rule 234 (primary -> literal .)
    IS              reduce using rule 234 (primary -> literal .)
    )               reduce using rule 234 (primary -> literal .)
    ,               reduce using rule 234 (primary -> literal .)
    DOTDOT          reduce using rule 234 (primary -> literal .)
    ARROW           reduce using rule 234 (primary -> literal .)
    |               reduce using rule 234 (primary -> literal .)
    THEN            reduce using rule 234 (primary -> literal .)
    WITH            reduce using rule 234 (primary -> literal .)
    LOOP            reduce using rule 234 (primary -> literal .)
    RANGE           reduce using rule 234 (primary -> literal .)
    DIGITS          reduce using rule 234 (primary -> literal .)
    RENAMES         reduce using rule 234 (primary -> literal .)
    ASSIGNMENT      reduce using rule 234 (primary -> literal .)


state 136

    (184) literal -> BASE_INTEGER .

    STARSTAR        reduce using rule 184 (literal -> BASE_INTEGER .)
    *               reduce using rule 184 (literal -> BASE_INTEGER .)
    /               reduce using rule 184 (literal -> BASE_INTEGER .)
    MOD             reduce using rule 184 (literal -> BASE_INTEGER .)
    REM             reduce using rule 184 (literal -> BASE_INTEGER .)
    =               reduce using rule 184 (literal -> BASE_INTEGER .)
    NOTEQUAL        reduce using rule 184 (literal -> BASE_INTEGER .)
    <               reduce using rule 184 (literal -> BASE_INTEGER .)
    LESSEQ          reduce using rule 184 (literal -> BASE_INTEGER .)
    >               reduce using rule 184 (literal -> BASE_INTEGER .)
    GREATEREQ       reduce using rule 184 (literal -> BASE_INTEGER .)
    IN              reduce using rule 184 (literal -> BASE_INTEGER .)
    NOT             reduce using rule 184 (literal -> BASE_INTEGER .)
    +               reduce using rule 184 (literal -> BASE_INTEGER .)
    -               reduce using rule 184 (literal -> BASE_INTEGER .)
    &               reduce using rule 184 (literal -> BASE_INTEGER .)
    AND             reduce using rule 184 (literal -> BASE_INTEGER .)
    OR              reduce using rule 184 (literal -> BASE_INTEGER .)
    ;               reduce using rule 184 (literal -> BASE_INTEGER .)
    )               reduce using rule 184 (literal -> BASE_INTEGER .)
    DOTDOT          reduce using rule 184 (literal -> BASE_INTEGER .)
    ,               reduce using rule 184 (literal -> BASE_INTEGER .)
    IS              reduce using rule 184 (literal -> BASE_INTEGER .)
    WITH            reduce using rule 184 (literal -> BASE_INTEGER .)
    ARROW           reduce using rule 184 (literal -> BASE_INTEGER .)
    |               reduce using rule 184 (literal -> BASE_INTEGER .)
    THEN            reduce using rule 184 (literal -> BASE_INTEGER .)
    LOOP            reduce using rule 184 (literal -> BASE_INTEGER .)
    RANGE           reduce using rule 184 (literal -> BASE_INTEGER .)
    DIGITS          reduce using rule 184 (literal -> BASE_INTEGER .)
    RENAMES         reduce using rule 184 (literal -> BASE_INTEGER .)
    ASSIGNMENT      reduce using rule 184 (literal -> BASE_INTEGER .)


state 137

    (225) term -> factor .

    *               reduce using rule 225 (term -> factor .)
    /               reduce using rule 225 (term -> factor .)
    MOD             reduce using rule 225 (term -> factor .)
    REM             reduce using rule 225 (term -> factor .)
    =               reduce using rule 225 (term -> factor .)
    NOTEQUAL        reduce using rule 225 (term -> factor .)
    <               reduce using rule 225 (term -> factor .)
    LESSEQ          reduce using rule 225 (term -> factor .)
    >               reduce using rule 225 (term -> factor .)
    GREATEREQ       reduce using rule 225 (term -> factor .)
    IN              reduce using rule 225 (term -> factor .)
    NOT             reduce using rule 225 (term -> factor .)
    +               reduce using rule 225 (term -> factor .)
    -               reduce using rule 225 (term -> factor .)
    &               reduce using rule 225 (term -> factor .)
    IS              reduce using rule 225 (term -> factor .)
    AND             reduce using rule 225 (term -> factor .)
    OR              reduce using rule 225 (term -> factor .)
    )               reduce using rule 225 (term -> factor .)
    ,               reduce using rule 225 (term -> factor .)
    DOTDOT          reduce using rule 225 (term -> factor .)
    WITH            reduce using rule 225 (term -> factor .)
    ARROW           reduce using rule 225 (term -> factor .)
    |               reduce using rule 225 (term -> factor .)
    ;               reduce using rule 225 (term -> factor .)
    THEN            reduce using rule 225 (term -> factor .)
    LOOP            reduce using rule 225 (term -> factor .)
    RANGE           reduce using rule 225 (term -> factor .)
    DIGITS          reduce using rule 225 (term -> factor .)
    RENAMES         reduce using rule 225 (term -> factor .)
    ASSIGNMENT      reduce using rule 225 (term -> factor .)


state 138

    (157) name -> operator_symbol .

    TICK            reduce using rule 157 (name -> operator_symbol .)
    (               reduce using rule 157 (name -> operator_symbol .)
    .               reduce using rule 157 (name -> operator_symbol .)
    STARSTAR        reduce using rule 157 (name -> operator_symbol .)
    *               reduce using rule 157 (name -> operator_symbol .)
    /               reduce using rule 157 (name -> operator_symbol .)
    MOD             reduce using rule 157 (name -> operator_symbol .)
    REM             reduce using rule 157 (name -> operator_symbol .)
    =               reduce using rule 157 (name -> operator_symbol .)
    NOTEQUAL        reduce using rule 157 (name -> operator_symbol .)
    <               reduce using rule 157 (name -> operator_symbol .)
    LESSEQ          reduce using rule 157 (name -> operator_symbol .)
    >               reduce using rule 157 (name -> operator_symbol .)
    GREATEREQ       reduce using rule 157 (name -> operator_symbol .)
    IN              reduce using rule 157 (name -> operator_symbol .)
    NOT             reduce using rule 157 (name -> operator_symbol .)
    +               reduce using rule 157 (name -> operator_symbol .)
    -               reduce using rule 157 (name -> operator_symbol .)
    &               reduce using rule 157 (name -> operator_symbol .)
    IS              reduce using rule 157 (name -> operator_symbol .)
    AND             reduce using rule 157 (name -> operator_symbol .)
    OR              reduce using rule 157 (name -> operator_symbol .)
    RANGE           reduce using rule 157 (name -> operator_symbol .)
    DIGITS          reduce using rule 157 (name -> operator_symbol .)
    ;               reduce using rule 157 (name -> operator_symbol .)
    )               reduce using rule 157 (name -> operator_symbol .)
    ,               reduce using rule 157 (name -> operator_symbol .)
    WITH            reduce using rule 157 (name -> operator_symbol .)
    ARROW           reduce using rule 157 (name -> operator_symbol .)
    |               reduce using rule 157 (name -> operator_symbol .)
    THEN            reduce using rule 157 (name -> operator_symbol .)
    LOOP            reduce using rule 157 (name -> operator_symbol .)
    RENAMES         reduce using rule 157 (name -> operator_symbol .)
    ASSIGNMENT      reduce using rule 157 (name -> operator_symbol .)
    DOTDOT          reduce using rule 157 (name -> operator_symbol .)
    WHEN            reduce using rule 157 (name -> operator_symbol .)


state 139

    (167) operator_symbol -> STRING .

    (               reduce using rule 167 (operator_symbol -> STRING .)
    .               reduce using rule 167 (operator_symbol -> STRING .)
    TICK            reduce using rule 167 (operator_symbol -> STRING .)
    RANGE           reduce using rule 167 (operator_symbol -> STRING .)
    ARROW           reduce using rule 167 (operator_symbol -> STRING .)
    |               reduce using rule 167 (operator_symbol -> STRING .)
    STARSTAR        reduce using rule 167 (operator_symbol -> STRING .)
    *               reduce using rule 167 (operator_symbol -> STRING .)
    /               reduce using rule 167 (operator_symbol -> STRING .)
    MOD             reduce using rule 167 (operator_symbol -> STRING .)
    REM             reduce using rule 167 (operator_symbol -> STRING .)
    DOTDOT          reduce using rule 167 (operator_symbol -> STRING .)
    =               reduce using rule 167 (operator_symbol -> STRING .)
    NOTEQUAL        reduce using rule 167 (operator_symbol -> STRING .)
    <               reduce using rule 167 (operator_symbol -> STRING .)
    LESSEQ          reduce using rule 167 (operator_symbol -> STRING .)
    >               reduce using rule 167 (operator_symbol -> STRING .)
    GREATEREQ       reduce using rule 167 (operator_symbol -> STRING .)
    IN              reduce using rule 167 (operator_symbol -> STRING .)
    NOT             reduce using rule 167 (operator_symbol -> STRING .)
    +               reduce using rule 167 (operator_symbol -> STRING .)
    -               reduce using rule 167 (operator_symbol -> STRING .)
    &               reduce using rule 167 (operator_symbol -> STRING .)
    AND             reduce using rule 167 (operator_symbol -> STRING .)
    OR              reduce using rule 167 (operator_symbol -> STRING .)
    )               reduce using rule 167 (operator_symbol -> STRING .)
    ,               reduce using rule 167 (operator_symbol -> STRING .)
    ASSIGNMENT      reduce using rule 167 (operator_symbol -> STRING .)
    ;               reduce using rule 167 (operator_symbol -> STRING .)
    DIGITS          reduce using rule 167 (operator_symbol -> STRING .)
    THEN            reduce using rule 167 (operator_symbol -> STRING .)
    WITH            reduce using rule 167 (operator_symbol -> STRING .)
    IS              reduce using rule 167 (operator_symbol -> STRING .)
    LOOP            reduce using rule 167 (operator_symbol -> STRING .)
    RENAMES         reduce using rule 167 (operator_symbol -> STRING .)
    WHEN            reduce using rule 167 (operator_symbol -> STRING .)


state 140

    (3) pragma -> PRAGMA simple_name ( pragma_arg_s . ) ;
    (5) pragma_arg_s -> pragma_arg_s . , pragma_arg

    )               shift and go to state 236
    ,               shift and go to state 237


state 141

    (237) primary -> qualified .

    STARSTAR        reduce using rule 237 (primary -> qualified .)
    *               reduce using rule 237 (primary -> qualified .)
    /               reduce using rule 237 (primary -> qualified .)
    MOD             reduce using rule 237 (primary -> qualified .)
    REM             reduce using rule 237 (primary -> qualified .)
    =               reduce using rule 237 (primary -> qualified .)
    NOTEQUAL        reduce using rule 237 (primary -> qualified .)
    <               reduce using rule 237 (primary -> qualified .)
    LESSEQ          reduce using rule 237 (primary -> qualified .)
    >               reduce using rule 237 (primary -> qualified .)
    GREATEREQ       reduce using rule 237 (primary -> qualified .)
    IN              reduce using rule 237 (primary -> qualified .)
    NOT             reduce using rule 237 (primary -> qualified .)
    +               reduce using rule 237 (primary -> qualified .)
    -               reduce using rule 237 (primary -> qualified .)
    &               reduce using rule 237 (primary -> qualified .)
    AND             reduce using rule 237 (primary -> qualified .)
    OR              reduce using rule 237 (primary -> qualified .)
    ;               reduce using rule 237 (primary -> qualified .)
    IS              reduce using rule 237 (primary -> qualified .)
    )               reduce using rule 237 (primary -> qualified .)
    ,               reduce using rule 237 (primary -> qualified .)
    DOTDOT          reduce using rule 237 (primary -> qualified .)
    ARROW           reduce using rule 237 (primary -> qualified .)
    |               reduce using rule 237 (primary -> qualified .)
    THEN            reduce using rule 237 (primary -> qualified .)
    WITH            reduce using rule 237 (primary -> qualified .)
    LOOP            reduce using rule 237 (primary -> qualified .)
    RANGE           reduce using rule 237 (primary -> qualified .)
    DIGITS          reduce using rule 237 (primary -> qualified .)
    RENAMES         reduce using rule 237 (primary -> qualified .)
    ASSIGNMENT      reduce using rule 237 (primary -> qualified .)


state 142

    (238) primary -> parenthesized_primary .

    STARSTAR        reduce using rule 238 (primary -> parenthesized_primary .)
    *               reduce using rule 238 (primary -> parenthesized_primary .)
    /               reduce using rule 238 (primary -> parenthesized_primary .)
    MOD             reduce using rule 238 (primary -> parenthesized_primary .)
    REM             reduce using rule 238 (primary -> parenthesized_primary .)
    =               reduce using rule 238 (primary -> parenthesized_primary .)
    NOTEQUAL        reduce using rule 238 (primary -> parenthesized_primary .)
    <               reduce using rule 238 (primary -> parenthesized_primary .)
    LESSEQ          reduce using rule 238 (primary -> parenthesized_primary .)
    >               reduce using rule 238 (primary -> parenthesized_primary .)
    GREATEREQ       reduce using rule 238 (primary -> parenthesized_primary .)
    IN              reduce using rule 238 (primary -> parenthesized_primary .)
    NOT             reduce using rule 238 (primary -> parenthesized_primary .)
    +               reduce using rule 238 (primary -> parenthesized_primary .)
    -               reduce using rule 238 (primary -> parenthesized_primary .)
    &               reduce using rule 238 (primary -> parenthesized_primary .)
    AND             reduce using rule 238 (primary -> parenthesized_primary .)
    OR              reduce using rule 238 (primary -> parenthesized_primary .)
    ;               reduce using rule 238 (primary -> parenthesized_primary .)
    IS              reduce using rule 238 (primary -> parenthesized_primary .)
    )               reduce using rule 238 (primary -> parenthesized_primary .)
    ,               reduce using rule 238 (primary -> parenthesized_primary .)
    DOTDOT          reduce using rule 238 (primary -> parenthesized_primary .)
    ARROW           reduce using rule 238 (primary -> parenthesized_primary .)
    |               reduce using rule 238 (primary -> parenthesized_primary .)
    THEN            reduce using rule 238 (primary -> parenthesized_primary .)
    WITH            reduce using rule 238 (primary -> parenthesized_primary .)
    LOOP            reduce using rule 238 (primary -> parenthesized_primary .)
    RANGE           reduce using rule 238 (primary -> parenthesized_primary .)
    DIGITS          reduce using rule 238 (primary -> parenthesized_primary .)
    RENAMES         reduce using rule 238 (primary -> parenthesized_primary .)
    ASSIGNMENT      reduce using rule 238 (primary -> parenthesized_primary .)


state 143

    (183) literal -> INTEGER .

    STARSTAR        reduce using rule 183 (literal -> INTEGER .)
    *               reduce using rule 183 (literal -> INTEGER .)
    /               reduce using rule 183 (literal -> INTEGER .)
    MOD             reduce using rule 183 (literal -> INTEGER .)
    REM             reduce using rule 183 (literal -> INTEGER .)
    =               reduce using rule 183 (literal -> INTEGER .)
    NOTEQUAL        reduce using rule 183 (literal -> INTEGER .)
    <               reduce using rule 183 (literal -> INTEGER .)
    LESSEQ          reduce using rule 183 (literal -> INTEGER .)
    >               reduce using rule 183 (literal -> INTEGER .)
    GREATEREQ       reduce using rule 183 (literal -> INTEGER .)
    IN              reduce using rule 183 (literal -> INTEGER .)
    NOT             reduce using rule 183 (literal -> INTEGER .)
    +               reduce using rule 183 (literal -> INTEGER .)
    -               reduce using rule 183 (literal -> INTEGER .)
    &               reduce using rule 183 (literal -> INTEGER .)
    AND             reduce using rule 183 (literal -> INTEGER .)
    OR              reduce using rule 183 (literal -> INTEGER .)
    ;               reduce using rule 183 (literal -> INTEGER .)
    )               reduce using rule 183 (literal -> INTEGER .)
    DOTDOT          reduce using rule 183 (literal -> INTEGER .)
    ,               reduce using rule 183 (literal -> INTEGER .)
    IS              reduce using rule 183 (literal -> INTEGER .)
    WITH            reduce using rule 183 (literal -> INTEGER .)
    ARROW           reduce using rule 183 (literal -> INTEGER .)
    |               reduce using rule 183 (literal -> INTEGER .)
    THEN            reduce using rule 183 (literal -> INTEGER .)
    LOOP            reduce using rule 183 (literal -> INTEGER .)
    RANGE           reduce using rule 183 (literal -> INTEGER .)
    DIGITS          reduce using rule 183 (literal -> INTEGER .)
    RENAMES         reduce using rule 183 (literal -> INTEGER .)
    ASSIGNMENT      reduce using rule 183 (literal -> INTEGER .)


state 144

    (239) parenthesized_primary -> aggregate .

    STARSTAR        reduce using rule 239 (parenthesized_primary -> aggregate .)
    *               reduce using rule 239 (parenthesized_primary -> aggregate .)
    /               reduce using rule 239 (parenthesized_primary -> aggregate .)
    MOD             reduce using rule 239 (parenthesized_primary -> aggregate .)
    REM             reduce using rule 239 (parenthesized_primary -> aggregate .)
    DOTDOT          reduce using rule 239 (parenthesized_primary -> aggregate .)
    =               reduce using rule 239 (parenthesized_primary -> aggregate .)
    NOTEQUAL        reduce using rule 239 (parenthesized_primary -> aggregate .)
    <               reduce using rule 239 (parenthesized_primary -> aggregate .)
    LESSEQ          reduce using rule 239 (parenthesized_primary -> aggregate .)
    >               reduce using rule 239 (parenthesized_primary -> aggregate .)
    GREATEREQ       reduce using rule 239 (parenthesized_primary -> aggregate .)
    IN              reduce using rule 239 (parenthesized_primary -> aggregate .)
    NOT             reduce using rule 239 (parenthesized_primary -> aggregate .)
    +               reduce using rule 239 (parenthesized_primary -> aggregate .)
    -               reduce using rule 239 (parenthesized_primary -> aggregate .)
    &               reduce using rule 239 (parenthesized_primary -> aggregate .)
    )               reduce using rule 239 (parenthesized_primary -> aggregate .)
    WITH            reduce using rule 239 (parenthesized_primary -> aggregate .)
    AND             reduce using rule 239 (parenthesized_primary -> aggregate .)
    OR              reduce using rule 239 (parenthesized_primary -> aggregate .)
    ,               reduce using rule 239 (parenthesized_primary -> aggregate .)
    ARROW           reduce using rule 239 (parenthesized_primary -> aggregate .)
    |               reduce using rule 239 (parenthesized_primary -> aggregate .)
    ;               reduce using rule 239 (parenthesized_primary -> aggregate .)
    IS              reduce using rule 239 (parenthesized_primary -> aggregate .)
    THEN            reduce using rule 239 (parenthesized_primary -> aggregate .)
    LOOP            reduce using rule 239 (parenthesized_primary -> aggregate .)
    RANGE           reduce using rule 239 (parenthesized_primary -> aggregate .)
    DIGITS          reduce using rule 239 (parenthesized_primary -> aggregate .)
    RENAMES         reduce using rule 239 (parenthesized_primary -> aggregate .)
    ASSIGNMENT      reduce using rule 239 (parenthesized_primary -> aggregate .)


state 145

    (187) literal -> used_char .

    STARSTAR        reduce using rule 187 (literal -> used_char .)
    *               reduce using rule 187 (literal -> used_char .)
    /               reduce using rule 187 (literal -> used_char .)
    MOD             reduce using rule 187 (literal -> used_char .)
    REM             reduce using rule 187 (literal -> used_char .)
    =               reduce using rule 187 (literal -> used_char .)
    NOTEQUAL        reduce using rule 187 (literal -> used_char .)
    <               reduce using rule 187 (literal -> used_char .)
    LESSEQ          reduce using rule 187 (literal -> used_char .)
    >               reduce using rule 187 (literal -> used_char .)
    GREATEREQ       reduce using rule 187 (literal -> used_char .)
    IN              reduce using rule 187 (literal -> used_char .)
    NOT             reduce using rule 187 (literal -> used_char .)
    +               reduce using rule 187 (literal -> used_char .)
    -               reduce using rule 187 (literal -> used_char .)
    &               reduce using rule 187 (literal -> used_char .)
    AND             reduce using rule 187 (literal -> used_char .)
    OR              reduce using rule 187 (literal -> used_char .)
    ;               reduce using rule 187 (literal -> used_char .)
    )               reduce using rule 187 (literal -> used_char .)
    DOTDOT          reduce using rule 187 (literal -> used_char .)
    ,               reduce using rule 187 (literal -> used_char .)
    IS              reduce using rule 187 (literal -> used_char .)
    WITH            reduce using rule 187 (literal -> used_char .)
    ARROW           reduce using rule 187 (literal -> used_char .)
    |               reduce using rule 187 (literal -> used_char .)
    THEN            reduce using rule 187 (literal -> used_char .)
    LOOP            reduce using rule 187 (literal -> used_char .)
    RANGE           reduce using rule 187 (literal -> used_char .)
    DIGITS          reduce using rule 187 (literal -> used_char .)
    RENAMES         reduce using rule 187 (literal -> used_char .)
    ASSIGNMENT      reduce using rule 187 (literal -> used_char .)


state 146

    (166) used_char -> CHAR .

    STARSTAR        reduce using rule 166 (used_char -> CHAR .)
    *               reduce using rule 166 (used_char -> CHAR .)
    /               reduce using rule 166 (used_char -> CHAR .)
    MOD             reduce using rule 166 (used_char -> CHAR .)
    REM             reduce using rule 166 (used_char -> CHAR .)
    =               reduce using rule 166 (used_char -> CHAR .)
    NOTEQUAL        reduce using rule 166 (used_char -> CHAR .)
    <               reduce using rule 166 (used_char -> CHAR .)
    LESSEQ          reduce using rule 166 (used_char -> CHAR .)
    >               reduce using rule 166 (used_char -> CHAR .)
    GREATEREQ       reduce using rule 166 (used_char -> CHAR .)
    IN              reduce using rule 166 (used_char -> CHAR .)
    NOT             reduce using rule 166 (used_char -> CHAR .)
    +               reduce using rule 166 (used_char -> CHAR .)
    -               reduce using rule 166 (used_char -> CHAR .)
    &               reduce using rule 166 (used_char -> CHAR .)
    AND             reduce using rule 166 (used_char -> CHAR .)
    OR              reduce using rule 166 (used_char -> CHAR .)
    THEN            reduce using rule 166 (used_char -> CHAR .)
    DOTDOT          reduce using rule 166 (used_char -> CHAR .)
    ;               reduce using rule 166 (used_char -> CHAR .)
    )               reduce using rule 166 (used_char -> CHAR .)
    ,               reduce using rule 166 (used_char -> CHAR .)
    RANGE           reduce using rule 166 (used_char -> CHAR .)
    WITH            reduce using rule 166 (used_char -> CHAR .)
    ARROW           reduce using rule 166 (used_char -> CHAR .)
    |               reduce using rule 166 (used_char -> CHAR .)
    IS              reduce using rule 166 (used_char -> CHAR .)
    LOOP            reduce using rule 166 (used_char -> CHAR .)
    DIGITS          reduce using rule 166 (used_char -> CHAR .)
    RENAMES         reduce using rule 166 (used_char -> CHAR .)
    ASSIGNMENT      reduce using rule 166 (used_char -> CHAR .)
    TICK            reduce using rule 166 (used_char -> CHAR .)
    (               reduce using rule 166 (used_char -> CHAR .)
    .               reduce using rule 166 (used_char -> CHAR .)
    WHEN            reduce using rule 166 (used_char -> CHAR .)


state 147

    (218) simple_expression -> term .
    (226) term -> term . multiplying factor
    (227) multiplying -> . *
    (228) multiplying -> . /
    (229) multiplying -> . MOD
    (230) multiplying -> . REM

    +               reduce using rule 218 (simple_expression -> term .)
    -               reduce using rule 218 (simple_expression -> term .)
    &               reduce using rule 218 (simple_expression -> term .)
    ARROW           reduce using rule 218 (simple_expression -> term .)
    |               reduce using rule 218 (simple_expression -> term .)
    AND             reduce using rule 218 (simple_expression -> term .)
    OR              reduce using rule 218 (simple_expression -> term .)
    )               reduce using rule 218 (simple_expression -> term .)
    ,               reduce using rule 218 (simple_expression -> term .)
    WITH            reduce using rule 218 (simple_expression -> term .)
    ;               reduce using rule 218 (simple_expression -> term .)
    IS              reduce using rule 218 (simple_expression -> term .)
    THEN            reduce using rule 218 (simple_expression -> term .)
    LOOP            reduce using rule 218 (simple_expression -> term .)
    RANGE           reduce using rule 218 (simple_expression -> term .)
    DIGITS          reduce using rule 218 (simple_expression -> term .)
    RENAMES         reduce using rule 218 (simple_expression -> term .)
    ASSIGNMENT      reduce using rule 218 (simple_expression -> term .)
    =               reduce using rule 218 (simple_expression -> term .)
    NOTEQUAL        reduce using rule 218 (simple_expression -> term .)
    <               reduce using rule 218 (simple_expression -> term .)
    LESSEQ          reduce using rule 218 (simple_expression -> term .)
    >               reduce using rule 218 (simple_expression -> term .)
    GREATEREQ       reduce using rule 218 (simple_expression -> term .)
    IN              reduce using rule 218 (simple_expression -> term .)
    NOT             reduce using rule 218 (simple_expression -> term .)
    DOTDOT          reduce using rule 218 (simple_expression -> term .)
    *               shift and go to state 240
    /               shift and go to state 241
    MOD             shift and go to state 242
    REM             shift and go to state 238

    multiplying                    shift and go to state 239

state 148

    (235) primary -> name .
    (241) qualified -> name . TICK parenthesized_primary
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id

    STARSTAR        reduce using rule 235 (primary -> name .)
    *               reduce using rule 235 (primary -> name .)
    /               reduce using rule 235 (primary -> name .)
    MOD             reduce using rule 235 (primary -> name .)
    REM             reduce using rule 235 (primary -> name .)
    =               reduce using rule 235 (primary -> name .)
    NOTEQUAL        reduce using rule 235 (primary -> name .)
    <               reduce using rule 235 (primary -> name .)
    LESSEQ          reduce using rule 235 (primary -> name .)
    >               reduce using rule 235 (primary -> name .)
    GREATEREQ       reduce using rule 235 (primary -> name .)
    IN              reduce using rule 235 (primary -> name .)
    NOT             reduce using rule 235 (primary -> name .)
    +               reduce using rule 235 (primary -> name .)
    -               reduce using rule 235 (primary -> name .)
    &               reduce using rule 235 (primary -> name .)
    AND             reduce using rule 235 (primary -> name .)
    OR              reduce using rule 235 (primary -> name .)
    ;               reduce using rule 235 (primary -> name .)
    IS              reduce using rule 235 (primary -> name .)
    )               reduce using rule 235 (primary -> name .)
    ,               reduce using rule 235 (primary -> name .)
    THEN            reduce using rule 235 (primary -> name .)
    DOTDOT          reduce using rule 235 (primary -> name .)
    WITH            reduce using rule 235 (primary -> name .)
    ARROW           reduce using rule 235 (primary -> name .)
    |               reduce using rule 235 (primary -> name .)
    LOOP            reduce using rule 235 (primary -> name .)
    RANGE           reduce using rule 235 (primary -> name .)
    DIGITS          reduce using rule 235 (primary -> name .)
    RENAMES         reduce using rule 235 (primary -> name .)
    ASSIGNMENT      reduce using rule 235 (primary -> name .)
    TICK            shift and go to state 245
    (               shift and go to state 243
    .               shift and go to state 244


state 149

    (185) literal -> FLOAT .

    STARSTAR        reduce using rule 185 (literal -> FLOAT .)
    *               reduce using rule 185 (literal -> FLOAT .)
    /               reduce using rule 185 (literal -> FLOAT .)
    MOD             reduce using rule 185 (literal -> FLOAT .)
    REM             reduce using rule 185 (literal -> FLOAT .)
    =               reduce using rule 185 (literal -> FLOAT .)
    NOTEQUAL        reduce using rule 185 (literal -> FLOAT .)
    <               reduce using rule 185 (literal -> FLOAT .)
    LESSEQ          reduce using rule 185 (literal -> FLOAT .)
    >               reduce using rule 185 (literal -> FLOAT .)
    GREATEREQ       reduce using rule 185 (literal -> FLOAT .)
    IN              reduce using rule 185 (literal -> FLOAT .)
    NOT             reduce using rule 185 (literal -> FLOAT .)
    +               reduce using rule 185 (literal -> FLOAT .)
    -               reduce using rule 185 (literal -> FLOAT .)
    &               reduce using rule 185 (literal -> FLOAT .)
    AND             reduce using rule 185 (literal -> FLOAT .)
    OR              reduce using rule 185 (literal -> FLOAT .)
    ;               reduce using rule 185 (literal -> FLOAT .)
    )               reduce using rule 185 (literal -> FLOAT .)
    DOTDOT          reduce using rule 185 (literal -> FLOAT .)
    ,               reduce using rule 185 (literal -> FLOAT .)
    IS              reduce using rule 185 (literal -> FLOAT .)
    WITH            reduce using rule 185 (literal -> FLOAT .)
    ARROW           reduce using rule 185 (literal -> FLOAT .)
    |               reduce using rule 185 (literal -> FLOAT .)
    THEN            reduce using rule 185 (literal -> FLOAT .)
    LOOP            reduce using rule 185 (literal -> FLOAT .)
    RANGE           reduce using rule 185 (literal -> FLOAT .)
    DIGITS          reduce using rule 185 (literal -> FLOAT .)
    RENAMES         reduce using rule 185 (literal -> FLOAT .)
    ASSIGNMENT      reduce using rule 185 (literal -> FLOAT .)


state 150

    (232) factor -> NOT . primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 148
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    primary                        shift and go to state 246
    used_char                      shift and go to state 145
    literal                        shift and go to state 135
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157

state 151

    (188) literal -> NuLL .

    STARSTAR        reduce using rule 188 (literal -> NuLL .)
    *               reduce using rule 188 (literal -> NuLL .)
    /               reduce using rule 188 (literal -> NuLL .)
    MOD             reduce using rule 188 (literal -> NuLL .)
    REM             reduce using rule 188 (literal -> NuLL .)
    =               reduce using rule 188 (literal -> NuLL .)
    NOTEQUAL        reduce using rule 188 (literal -> NuLL .)
    <               reduce using rule 188 (literal -> NuLL .)
    LESSEQ          reduce using rule 188 (literal -> NuLL .)
    >               reduce using rule 188 (literal -> NuLL .)
    GREATEREQ       reduce using rule 188 (literal -> NuLL .)
    IN              reduce using rule 188 (literal -> NuLL .)
    NOT             reduce using rule 188 (literal -> NuLL .)
    +               reduce using rule 188 (literal -> NuLL .)
    -               reduce using rule 188 (literal -> NuLL .)
    &               reduce using rule 188 (literal -> NuLL .)
    AND             reduce using rule 188 (literal -> NuLL .)
    OR              reduce using rule 188 (literal -> NuLL .)
    ;               reduce using rule 188 (literal -> NuLL .)
    )               reduce using rule 188 (literal -> NuLL .)
    DOTDOT          reduce using rule 188 (literal -> NuLL .)
    ,               reduce using rule 188 (literal -> NuLL .)
    IS              reduce using rule 188 (literal -> NuLL .)
    WITH            reduce using rule 188 (literal -> NuLL .)
    ARROW           reduce using rule 188 (literal -> NuLL .)
    |               reduce using rule 188 (literal -> NuLL .)
    THEN            reduce using rule 188 (literal -> NuLL .)
    LOOP            reduce using rule 188 (literal -> NuLL .)
    RANGE           reduce using rule 188 (literal -> NuLL .)
    DIGITS          reduce using rule 188 (literal -> NuLL .)
    RENAMES         reduce using rule 188 (literal -> NuLL .)
    ASSIGNMENT      reduce using rule 188 (literal -> NuLL .)


state 152

    (6) pragma_arg -> expression .
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    )               reduce using rule 6 (pragma_arg -> expression .)
    ,               reduce using rule 6 (pragma_arg -> expression .)
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 153

    (432) comp_unit -> context_spec private_opt unit pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    PRIVATE         reduce using rule 432 (comp_unit -> context_spec private_opt unit pragma_s .)
    WITH            reduce using rule 432 (comp_unit -> context_spec private_opt unit pragma_s .)
    PACKAGE         reduce using rule 432 (comp_unit -> context_spec private_opt unit pragma_s .)
    SEPARATE        reduce using rule 432 (comp_unit -> context_spec private_opt unit pragma_s .)
    PROCEDURE       reduce using rule 432 (comp_unit -> context_spec private_opt unit pragma_s .)
    FUNCTION        reduce using rule 432 (comp_unit -> context_spec private_opt unit pragma_s .)
    GENERIC         reduce using rule 432 (comp_unit -> context_spec private_opt unit pragma_s .)
    $end            reduce using rule 432 (comp_unit -> context_spec private_opt unit pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 154

    (349) use_clause -> USE name_s . ;
    (352) name_s -> name_s . , name

    ;               shift and go to state 251
    ,               shift and go to state 252


state 155

    (351) name_s -> name .
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id

    ;               reduce using rule 351 (name_s -> name .)
    ,               reduce using rule 351 (name_s -> name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 156

    (350) use_clause -> USE TYPE . name_s ;
    (351) name_s -> . name
    (352) name_s -> . name_s , name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name_s                         shift and go to state 254
    name                           shift and go to state 155
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 157

    (153) name -> simple_name .

    TICK            reduce using rule 153 (name -> simple_name .)
    (               reduce using rule 153 (name -> simple_name .)
    .               reduce using rule 153 (name -> simple_name .)
    STARSTAR        reduce using rule 153 (name -> simple_name .)
    *               reduce using rule 153 (name -> simple_name .)
    /               reduce using rule 153 (name -> simple_name .)
    MOD             reduce using rule 153 (name -> simple_name .)
    REM             reduce using rule 153 (name -> simple_name .)
    =               reduce using rule 153 (name -> simple_name .)
    NOTEQUAL        reduce using rule 153 (name -> simple_name .)
    <               reduce using rule 153 (name -> simple_name .)
    LESSEQ          reduce using rule 153 (name -> simple_name .)
    >               reduce using rule 153 (name -> simple_name .)
    GREATEREQ       reduce using rule 153 (name -> simple_name .)
    IN              reduce using rule 153 (name -> simple_name .)
    NOT             reduce using rule 153 (name -> simple_name .)
    +               reduce using rule 153 (name -> simple_name .)
    -               reduce using rule 153 (name -> simple_name .)
    &               reduce using rule 153 (name -> simple_name .)
    IS              reduce using rule 153 (name -> simple_name .)
    AND             reduce using rule 153 (name -> simple_name .)
    OR              reduce using rule 153 (name -> simple_name .)
    RANGE           reduce using rule 153 (name -> simple_name .)
    DIGITS          reduce using rule 153 (name -> simple_name .)
    ;               reduce using rule 153 (name -> simple_name .)
    )               reduce using rule 153 (name -> simple_name .)
    ,               reduce using rule 153 (name -> simple_name .)
    WITH            reduce using rule 153 (name -> simple_name .)
    ARROW           reduce using rule 153 (name -> simple_name .)
    |               reduce using rule 153 (name -> simple_name .)
    THEN            reduce using rule 153 (name -> simple_name .)
    LOOP            reduce using rule 153 (name -> simple_name .)
    RENAMES         reduce using rule 153 (name -> simple_name .)
    ASSIGNMENT      reduce using rule 153 (name -> simple_name .)
    DOTDOT          reduce using rule 153 (name -> simple_name .)
    WHEN            reduce using rule 153 (name -> simple_name .)


state 158

    (449) subunit -> SEPARATE ( compound_name . ) subunit_body
    (163) compound_name -> compound_name . . simple_name

    )               shift and go to state 255
    .               shift and go to state 119


state 159

    (385) prot_body -> PROTECTED BODY . simple_name IS prot_op_body_s END id_opt ;
    (457) body_stub -> PROTECTED BODY . simple_name IS SEPARATE ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 256

state 160

    (370) prot_spec -> PROTECTED IDENTIFIER . prot_def
    (372) prot_def -> . IS prot_op_decl_s prot_private_opt END id_opt

    IS              shift and go to state 257

    prot_def                       shift and go to state 258

state 161

    (371) prot_spec -> PROTECTED TYPE . simple_name discrim_part_opt prot_def
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 259

state 162

    (301) block_body -> BEGIN . handled_stmt_s
    (302) handled_stmt_s -> . statement_s except_handler_part_opt
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s m statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (305) exit_stmt -> . EXIT name_opt when_opt ;
    (310) return_stmt -> . RETURN ;
    (311) return_stmt -> . RETURN expression ;
    (312) goto_stmt -> . GOTO name ;
    (335) procedure_call -> . name ;
    (407) delay_stmt -> . DELAY expression ;
    (408) delay_stmt -> . DELAY UNTIL expression ;
    (428) abort_stmt -> . ABORT name_s ;
    (467) raise_stmt -> . RAISE name_opt ;
    (513) code_stmt -> . qualified ;
    (468) requeue_stmt -> . REQUEUE name ;
    (469) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (281) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (286) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (298) block -> . label_opt block_decl block_body END id_opt ;
    (402) accept_stmt -> . accept_hdr ;
    (403) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (409) select_stmt -> . select_wait
    (410) select_stmt -> . async_select
    (411) select_stmt -> . timed_entry_call
    (412) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (282) case_hdr -> . CASE expression IS
    (287) label_opt -> .
    (288) label_opt -> . IDENTIFIER :
    (404) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (413) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (423) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (424) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (425) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 287 (label_opt -> .)
    DECLARE         reduce using rule 287 (label_opt -> .)
    FOR             reduce using rule 287 (label_opt -> .)
    LOOP            reduce using rule 287 (label_opt -> .)
    BEGIN           reduce using rule 287 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 139

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    label                          shift and go to state 279
    statement_s                    shift and go to state 300
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    handled_stmt_s                 shift and go to state 286
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 138
    assign_stmt                    shift and go to state 308
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    attribute                      shift and go to state 121
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 163

    (334) subprog_body -> subprog_spec_is_push decl_part block_body . END id_opt ;

    END             shift and go to state 309


state 164

    (506) attrib_def -> FOR mark . USE expression ;
    (507) record_type_spec -> FOR mark . USE RECORD align_opt comp_loc_s END RECORD ;
    (512) address_spec -> FOR mark . USE AT expression ;
    (159) mark -> mark . TICK attribute_id
    (160) mark -> mark . . simple_name

    USE             shift and go to state 310
    TICK            shift and go to state 312
    .               shift and go to state 311


state 165

    (158) mark -> simple_name .

    TICK            reduce using rule 158 (mark -> simple_name .)
    .               reduce using rule 158 (mark -> simple_name .)
    ;               reduce using rule 158 (mark -> simple_name .)
    USE             reduce using rule 158 (mark -> simple_name .)
    AT              reduce using rule 158 (mark -> simple_name .)
    ASSIGNMENT      reduce using rule 158 (mark -> simple_name .)
    )               reduce using rule 158 (mark -> simple_name .)


state 166

    (361) task_decl -> task_spec ; .

    PACKAGE         reduce using rule 361 (task_decl -> task_spec ; .)
    TASK            reduce using rule 361 (task_decl -> task_spec ; .)
    PROTECTED       reduce using rule 361 (task_decl -> task_spec ; .)
    error           reduce using rule 361 (task_decl -> task_spec ; .)
    USE             reduce using rule 361 (task_decl -> task_spec ; .)
    PRAGMA          reduce using rule 361 (task_decl -> task_spec ; .)
    TYPE            reduce using rule 361 (task_decl -> task_spec ; .)
    SUBTYPE         reduce using rule 361 (task_decl -> task_spec ; .)
    FOR             reduce using rule 361 (task_decl -> task_spec ; .)
    PROCEDURE       reduce using rule 361 (task_decl -> task_spec ; .)
    FUNCTION        reduce using rule 361 (task_decl -> task_spec ; .)
    GENERIC         reduce using rule 361 (task_decl -> task_spec ; .)
    IDENTIFIER      reduce using rule 361 (task_decl -> task_spec ; .)
    BEGIN           reduce using rule 361 (task_decl -> task_spec ; .)
    END             reduce using rule 361 (task_decl -> task_spec ; .)
    PRIVATE         reduce using rule 361 (task_decl -> task_spec ; .)


state 167

    (368) task_body -> TASK BODY . simple_name IS decl_part block_body END id_opt ;
    (454) body_stub -> TASK BODY . simple_name IS SEPARATE ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 313

state 168

    (363) task_spec -> TASK TYPE . simple_name discrim_part_opt task_def
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 314

state 169

    (362) task_spec -> TASK simple_name . task_def
    (364) task_def -> .
    (365) task_def -> . IS entry_decl_s rep_spec_s task_private_opt END id_opt

    ;               reduce using rule 364 (task_def -> .)
    IS              shift and go to state 315

    task_def                       shift and go to state 316

state 170

    (146) decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .

    PACKAGE         reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    TASK            reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    PROTECTED       reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    error           reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    USE             reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    PRAGMA          reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    TYPE            reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    SUBTYPE         reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    FOR             reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    PROCEDURE       reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    FUNCTION        reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    GENERIC         reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    IDENTIFIER      reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    BEGIN           reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    END             reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)


state 171

    (343) pkg_body -> PACKAGE BODY . compound_name IS decl_part body_opt END c_id_opt ;
    (455) body_stub -> PACKAGE BODY . compound_name IS SEPARATE ;
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 317
    simple_name                    shift and go to state 41

state 172

    (338) pkg_spec -> PACKAGE compound_name . IS decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> PACKAGE compound_name . IS generic_inst
    (356) rename_unit -> PACKAGE compound_name . renames ;
    (163) compound_name -> compound_name . . simple_name
    (360) renames -> . RENAMES name

    IS              shift and go to state 187
    .               shift and go to state 119
    RENAMES         shift and go to state 95

    renames                        shift and go to state 186

state 173

    (369) prot_decl -> prot_spec ; .

    error           reduce using rule 369 (prot_decl -> prot_spec ; .)
    USE             reduce using rule 369 (prot_decl -> prot_spec ; .)
    PRAGMA          reduce using rule 369 (prot_decl -> prot_spec ; .)
    TYPE            reduce using rule 369 (prot_decl -> prot_spec ; .)
    SUBTYPE         reduce using rule 369 (prot_decl -> prot_spec ; .)
    TASK            reduce using rule 369 (prot_decl -> prot_spec ; .)
    PACKAGE         reduce using rule 369 (prot_decl -> prot_spec ; .)
    PROTECTED       reduce using rule 369 (prot_decl -> prot_spec ; .)
    FOR             reduce using rule 369 (prot_decl -> prot_spec ; .)
    PROCEDURE       reduce using rule 369 (prot_decl -> prot_spec ; .)
    FUNCTION        reduce using rule 369 (prot_decl -> prot_spec ; .)
    GENERIC         reduce using rule 369 (prot_decl -> prot_spec ; .)
    IDENTIFIER      reduce using rule 369 (prot_decl -> prot_spec ; .)
    PRIVATE         reduce using rule 369 (prot_decl -> prot_spec ; .)
    END             reduce using rule 369 (prot_decl -> prot_spec ; .)
    BEGIN           reduce using rule 369 (prot_decl -> prot_spec ; .)


state 174

    (22) decl -> error ; .

    PACKAGE         reduce using rule 22 (decl -> error ; .)
    TASK            reduce using rule 22 (decl -> error ; .)
    PROTECTED       reduce using rule 22 (decl -> error ; .)
    error           reduce using rule 22 (decl -> error ; .)
    USE             reduce using rule 22 (decl -> error ; .)
    PRAGMA          reduce using rule 22 (decl -> error ; .)
    TYPE            reduce using rule 22 (decl -> error ; .)
    SUBTYPE         reduce using rule 22 (decl -> error ; .)
    FOR             reduce using rule 22 (decl -> error ; .)
    PROCEDURE       reduce using rule 22 (decl -> error ; .)
    FUNCTION        reduce using rule 22 (decl -> error ; .)
    GENERIC         reduce using rule 22 (decl -> error ; .)
    IDENTIFIER      reduce using rule 22 (decl -> error ; .)
    BEGIN           reduce using rule 22 (decl -> error ; .)
    PRIVATE         reduce using rule 22 (decl -> error ; .)
    END             reduce using rule 22 (decl -> error ; .)


state 175

    (36) type_decl -> TYPE IDENTIFIER . discrim_part_opt type_completion ;
    (37) discrim_part_opt -> .
    (38) discrim_part_opt -> . discrim_part
    (39) discrim_part_opt -> . ( LESSMORE )
    (110) discrim_part -> . ( discrim_spec_s )

    IS              reduce using rule 37 (discrim_part_opt -> .)
    ;               reduce using rule 37 (discrim_part_opt -> .)
    (               shift and go to state 318

    discrim_part_opt               shift and go to state 319
    discrim_part                   shift and go to state 320

state 176

    (315) subprog_decl -> subprog_spec_is_push ABSTRACT ; .

    PACKAGE         reduce using rule 315 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    TASK            reduce using rule 315 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    PROTECTED       reduce using rule 315 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    error           reduce using rule 315 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    USE             reduce using rule 315 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    PRAGMA          reduce using rule 315 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    TYPE            reduce using rule 315 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    SUBTYPE         reduce using rule 315 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    FOR             reduce using rule 315 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    PROCEDURE       reduce using rule 315 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    FUNCTION        reduce using rule 315 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    GENERIC         reduce using rule 315 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    IDENTIFIER      reduce using rule 315 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    BEGIN           reduce using rule 315 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    PRIVATE         reduce using rule 315 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    WITH            reduce using rule 315 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    SEPARATE        reduce using rule 315 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    $end            reduce using rule 315 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)
    END             reduce using rule 315 (subprog_decl -> subprog_spec_is_push ABSTRACT ; .)


state 177

    (50) subtype_decl -> SUBTYPE IDENTIFIER . IS subtype_ind ;

    IS              shift and go to state 321


state 178

    (333) subprog_spec_is_push -> subprog_spec IS .
    (456) body_stub -> subprog_spec IS . SEPARATE ;
    (500) generic_subp_inst -> subprog_spec IS . generic_inst
    (502) generic_inst -> . NEW name

    ABSTRACT        reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    PACKAGE         reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    TASK            reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    PROTECTED       reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    error           reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    USE             reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    PRAGMA          reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    TYPE            reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    SUBTYPE         reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    FOR             reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    PROCEDURE       reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    FUNCTION        reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    GENERIC         reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    IDENTIFIER      reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    BEGIN           reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    SEPARATE        shift and go to state 322
    NEW             shift and go to state 183

    generic_inst                   shift and go to state 184

state 179

    (25) def_id_s -> def_id_s , . def_id
    (26) def_id -> . IDENTIFIER

    IDENTIFIER      shift and go to state 76

    def_id                         shift and go to state 323

state 180

    (23) object_decl -> def_id_s : . object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> def_id_s : . CONSTANT ASSIGNMENT expression ;
    (458) exception_decl -> def_id_s : . EXCEPTION ;
    (353) rename_decl -> def_id_s : . object_qualifier_opt subtype_ind renames ;
    (354) rename_decl -> def_id_s : . EXCEPTION renames ;
    (27) object_qualifier_opt -> .
    (28) object_qualifier_opt -> . ALIASED
    (29) object_qualifier_opt -> . ALIASED CONSTANT
    (30) object_qualifier_opt -> . CONSTANT

    CONSTANT        shift and go to state 325
    EXCEPTION       shift and go to state 324
    ARRAY           reduce using rule 27 (object_qualifier_opt -> .)
    IDENTIFIER      reduce using rule 27 (object_qualifier_opt -> .)
    STRING          reduce using rule 27 (object_qualifier_opt -> .)
    ALIASED         shift and go to state 326

    object_qualifier_opt           shift and go to state 327

state 181

    (357) rename_unit -> subprog_spec renames ; .

    PACKAGE         reduce using rule 357 (rename_unit -> subprog_spec renames ; .)
    TASK            reduce using rule 357 (rename_unit -> subprog_spec renames ; .)
    PROTECTED       reduce using rule 357 (rename_unit -> subprog_spec renames ; .)
    error           reduce using rule 357 (rename_unit -> subprog_spec renames ; .)
    USE             reduce using rule 357 (rename_unit -> subprog_spec renames ; .)
    PRAGMA          reduce using rule 357 (rename_unit -> subprog_spec renames ; .)
    TYPE            reduce using rule 357 (rename_unit -> subprog_spec renames ; .)
    SUBTYPE         reduce using rule 357 (rename_unit -> subprog_spec renames ; .)
    FOR             reduce using rule 357 (rename_unit -> subprog_spec renames ; .)
    PROCEDURE       reduce using rule 357 (rename_unit -> subprog_spec renames ; .)
    FUNCTION        reduce using rule 357 (rename_unit -> subprog_spec renames ; .)
    GENERIC         reduce using rule 357 (rename_unit -> subprog_spec renames ; .)
    IDENTIFIER      reduce using rule 357 (rename_unit -> subprog_spec renames ; .)
    BEGIN           reduce using rule 357 (rename_unit -> subprog_spec renames ; .)
    END             reduce using rule 357 (rename_unit -> subprog_spec renames ; .)
    PRIVATE         reduce using rule 357 (rename_unit -> subprog_spec renames ; .)
    WITH            reduce using rule 357 (rename_unit -> subprog_spec renames ; .)
    SEPARATE        reduce using rule 357 (rename_unit -> subprog_spec renames ; .)
    $end            reduce using rule 357 (rename_unit -> subprog_spec renames ; .)


state 182

    (360) renames -> RENAMES name .
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id

    ;               reduce using rule 360 (renames -> RENAMES name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 183

    (502) generic_inst -> NEW . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 328
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 184

    (500) generic_subp_inst -> subprog_spec IS generic_inst .

    ;               reduce using rule 500 (generic_subp_inst -> subprog_spec IS generic_inst .)


state 185

    (343) pkg_body -> PACKAGE BODY compound_name . IS decl_part body_opt END c_id_opt ;
    (163) compound_name -> compound_name . . simple_name

    IS              shift and go to state 329
    .               shift and go to state 119


state 186

    (356) rename_unit -> PACKAGE compound_name renames . ;

    ;               shift and go to state 330


state 187

    (338) pkg_spec -> PACKAGE compound_name IS . decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> PACKAGE compound_name IS . generic_inst
    (137) decl_item_s -> .
    (138) decl_item_s -> . decl_item_s1
    (502) generic_inst -> . NEW name
    (139) decl_item_s1 -> . decl_item
    (140) decl_item_s1 -> . decl_item_s1 decl_item
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (349) use_clause -> . USE name_s ;
    (350) use_clause -> . USE TYPE name_s ;
    (503) rep_spec -> . attrib_def
    (504) rep_spec -> . record_type_spec
    (505) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (313) subprog_decl -> . subprog_spec ;
    (314) subprog_decl -> . generic_subp_inst ;
    (315) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (336) pkg_decl -> . pkg_spec ;
    (337) pkg_decl -> . generic_pkg_inst ;
    (361) task_decl -> . task_spec ;
    (369) prot_decl -> . prot_spec ;
    (458) exception_decl -> . def_id_s : EXCEPTION ;
    (353) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (354) rename_decl -> . def_id_s : EXCEPTION renames ;
    (355) rename_decl -> . rename_unit
    (470) generic_decl -> . generic_formal_part subprog_spec ;
    (471) generic_decl -> . generic_formal_part pkg_spec ;
    (454) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (455) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (456) body_stub -> . subprog_spec IS SEPARATE ;
    (457) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (506) attrib_def -> . FOR mark USE expression ;
    (507) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (512) address_spec -> . FOR mark USE AT expression ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (316) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (317) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (318) subprog_spec -> . FUNCTION designator
    (500) generic_subp_inst -> . subprog_spec IS generic_inst
    (333) subprog_spec_is_push -> . subprog_spec IS
    (338) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (362) task_spec -> . TASK simple_name task_def
    (363) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (370) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (371) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (356) rename_unit -> . PACKAGE compound_name renames ;
    (357) rename_unit -> . subprog_spec renames ;
    (358) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (359) rename_unit -> . generic_formal_part subprog_spec renames ;
    (472) generic_formal_part -> . GENERIC
    (473) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    PRIVATE         reduce using rule 137 (decl_item_s -> .)
    END             reduce using rule 137 (decl_item_s -> .)
    NEW             shift and go to state 183
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    TASK            shift and go to state 336
    PACKAGE         shift and go to state 337
    PROTECTED       shift and go to state 333
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    task_decl                      shift and go to state 60
    subtype_decl                   shift and go to state 61
    generic_inst                   shift and go to state 331
    rep_spec                       shift and go to state 82
    decl_item_s1                   shift and go to state 332
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    decl_item                      shift and go to state 334
    subprog_spec_is_push           shift and go to state 338
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 339
    def_id_s                       shift and go to state 88
    task_spec                      shift and go to state 65
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    generic_subp_inst              shift and go to state 29
    def_id                         shift and go to state 89
    rename_decl                    shift and go to state 90
    type_decl                      shift and go to state 56
    rename_unit                    shift and go to state 91
    generic_formal_part            shift and go to state 33
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    subprog_decl                   shift and go to state 58
    decl_item_s                    shift and go to state 335
    pragma                         shift and go to state 74
    pkg_spec                       shift and go to state 37
    number_decl                    shift and go to state 93

state 188

    (322) formal_part_opt -> formal_part .

    RETURN          reduce using rule 322 (formal_part_opt -> formal_part .)
    ;               reduce using rule 322 (formal_part_opt -> formal_part .)
    WHEN            reduce using rule 322 (formal_part_opt -> formal_part .)
    DO              reduce using rule 322 (formal_part_opt -> formal_part .)
    IS              reduce using rule 322 (formal_part_opt -> formal_part .)
    RENAMES         reduce using rule 322 (formal_part_opt -> formal_part .)


state 189

    (323) formal_part -> ( . param_s )
    (324) param_s -> . param
    (325) param_s -> . param_s ; param
    (326) param -> . def_id_s : mode mark init_opt
    (327) param -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    error           shift and go to state 109
    IDENTIFIER      shift and go to state 76

    param_s                        shift and go to state 341
    param                          shift and go to state 340
    def_id                         shift and go to state 89
    def_id_s                       shift and go to state 105

state 190

    (316) subprog_spec -> PROCEDURE compound_name formal_part_opt .

    ;               reduce using rule 316 (subprog_spec -> PROCEDURE compound_name formal_part_opt .)
    IS              reduce using rule 316 (subprog_spec -> PROCEDURE compound_name formal_part_opt .)
    RENAMES         reduce using rule 316 (subprog_spec -> PROCEDURE compound_name formal_part_opt .)


state 191

    (477) generic_formal -> WITH FUNCTION . designator formal_part_opt RETURN name subp_default ;
    (319) designator -> . compound_name
    (320) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 342
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 192

    (478) generic_formal -> WITH PACKAGE . simple_name IS NEW name ( LESSMORE ) ;
    (479) generic_formal -> WITH PACKAGE . simple_name IS NEW name ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 343

state 193

    (476) generic_formal -> WITH PROCEDURE . simple_name formal_part_opt subp_default ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 344

state 194

    (474) generic_formal -> param ; .

    PACKAGE         reduce using rule 474 (generic_formal -> param ; .)
    PROCEDURE       reduce using rule 474 (generic_formal -> param ; .)
    FUNCTION        reduce using rule 474 (generic_formal -> param ; .)
    TYPE            reduce using rule 474 (generic_formal -> param ; .)
    WITH            reduce using rule 474 (generic_formal -> param ; .)
    error           reduce using rule 474 (generic_formal -> param ; .)
    USE             reduce using rule 474 (generic_formal -> param ; .)
    IDENTIFIER      reduce using rule 474 (generic_formal -> param ; .)


state 195

    (359) rename_unit -> generic_formal_part subprog_spec renames . ;

    ;               shift and go to state 345


state 196

    (470) generic_decl -> generic_formal_part subprog_spec ; .

    PACKAGE         reduce using rule 470 (generic_decl -> generic_formal_part subprog_spec ; .)
    TASK            reduce using rule 470 (generic_decl -> generic_formal_part subprog_spec ; .)
    PROTECTED       reduce using rule 470 (generic_decl -> generic_formal_part subprog_spec ; .)
    error           reduce using rule 470 (generic_decl -> generic_formal_part subprog_spec ; .)
    USE             reduce using rule 470 (generic_decl -> generic_formal_part subprog_spec ; .)
    PRAGMA          reduce using rule 470 (generic_decl -> generic_formal_part subprog_spec ; .)
    TYPE            reduce using rule 470 (generic_decl -> generic_formal_part subprog_spec ; .)
    SUBTYPE         reduce using rule 470 (generic_decl -> generic_formal_part subprog_spec ; .)
    FOR             reduce using rule 470 (generic_decl -> generic_formal_part subprog_spec ; .)
    PROCEDURE       reduce using rule 470 (generic_decl -> generic_formal_part subprog_spec ; .)
    FUNCTION        reduce using rule 470 (generic_decl -> generic_formal_part subprog_spec ; .)
    GENERIC         reduce using rule 470 (generic_decl -> generic_formal_part subprog_spec ; .)
    IDENTIFIER      reduce using rule 470 (generic_decl -> generic_formal_part subprog_spec ; .)
    BEGIN           reduce using rule 470 (generic_decl -> generic_formal_part subprog_spec ; .)
    PRIVATE         reduce using rule 470 (generic_decl -> generic_formal_part subprog_spec ; .)
    END             reduce using rule 470 (generic_decl -> generic_formal_part subprog_spec ; .)
    WITH            reduce using rule 470 (generic_decl -> generic_formal_part subprog_spec ; .)
    SEPARATE        reduce using rule 470 (generic_decl -> generic_formal_part subprog_spec ; .)
    $end            reduce using rule 470 (generic_decl -> generic_formal_part subprog_spec ; .)


state 197

    (326) param -> def_id_s : . mode mark init_opt
    (328) mode -> .
    (329) mode -> . IN
    (330) mode -> . OUT
    (331) mode -> . IN OUT
    (332) mode -> . ACCESS

    IDENTIFIER      reduce using rule 328 (mode -> .)
    IN              shift and go to state 348
    OUT             shift and go to state 347
    ACCESS          shift and go to state 346

    mode                           shift and go to state 349

state 198

    (358) rename_unit -> generic_formal_part PACKAGE compound_name . renames ;
    (338) pkg_spec -> PACKAGE compound_name . IS decl_item_s private_part END c_id_opt
    (163) compound_name -> compound_name . . simple_name
    (360) renames -> . RENAMES name

    IS              shift and go to state 351
    .               shift and go to state 119
    RENAMES         shift and go to state 95

    renames                        shift and go to state 350

state 199

    (471) generic_decl -> generic_formal_part pkg_spec ; .

    PACKAGE         reduce using rule 471 (generic_decl -> generic_formal_part pkg_spec ; .)
    TASK            reduce using rule 471 (generic_decl -> generic_formal_part pkg_spec ; .)
    PROTECTED       reduce using rule 471 (generic_decl -> generic_formal_part pkg_spec ; .)
    error           reduce using rule 471 (generic_decl -> generic_formal_part pkg_spec ; .)
    USE             reduce using rule 471 (generic_decl -> generic_formal_part pkg_spec ; .)
    PRAGMA          reduce using rule 471 (generic_decl -> generic_formal_part pkg_spec ; .)
    TYPE            reduce using rule 471 (generic_decl -> generic_formal_part pkg_spec ; .)
    SUBTYPE         reduce using rule 471 (generic_decl -> generic_formal_part pkg_spec ; .)
    FOR             reduce using rule 471 (generic_decl -> generic_formal_part pkg_spec ; .)
    PROCEDURE       reduce using rule 471 (generic_decl -> generic_formal_part pkg_spec ; .)
    FUNCTION        reduce using rule 471 (generic_decl -> generic_formal_part pkg_spec ; .)
    GENERIC         reduce using rule 471 (generic_decl -> generic_formal_part pkg_spec ; .)
    IDENTIFIER      reduce using rule 471 (generic_decl -> generic_formal_part pkg_spec ; .)
    BEGIN           reduce using rule 471 (generic_decl -> generic_formal_part pkg_spec ; .)
    PRIVATE         reduce using rule 471 (generic_decl -> generic_formal_part pkg_spec ; .)
    END             reduce using rule 471 (generic_decl -> generic_formal_part pkg_spec ; .)
    WITH            reduce using rule 471 (generic_decl -> generic_formal_part pkg_spec ; .)
    SEPARATE        reduce using rule 471 (generic_decl -> generic_formal_part pkg_spec ; .)
    $end            reduce using rule 471 (generic_decl -> generic_formal_part pkg_spec ; .)


state 200

    (475) generic_formal -> TYPE simple_name . generic_discrim_part_opt IS generic_type_def ;
    (481) generic_discrim_part_opt -> .
    (482) generic_discrim_part_opt -> . discrim_part
    (483) generic_discrim_part_opt -> . ( LESSMORE )
    (110) discrim_part -> . ( discrim_spec_s )

    IS              reduce using rule 481 (generic_discrim_part_opt -> .)
    (               shift and go to state 353

    generic_discrim_part_opt       shift and go to state 352
    discrim_part                   shift and go to state 354

state 201

    (317) subprog_spec -> FUNCTION designator formal_part_opt . RETURN name

    RETURN          shift and go to state 355


state 202

    (165) c_name_list -> c_name_list , compound_name .
    (163) compound_name -> compound_name . . simple_name

    ;               reduce using rule 165 (c_name_list -> c_name_list , compound_name .)
    ,               reduce using rule 165 (c_name_list -> c_name_list , compound_name .)
    .               shift and go to state 119


state 203

    (163) compound_name -> compound_name . simple_name .

    .               reduce using rule 163 (compound_name -> compound_name . simple_name .)
    (               reduce using rule 163 (compound_name -> compound_name . simple_name .)
    RETURN          reduce using rule 163 (compound_name -> compound_name . simple_name .)
    ;               reduce using rule 163 (compound_name -> compound_name . simple_name .)
    ,               reduce using rule 163 (compound_name -> compound_name . simple_name .)
    IS              reduce using rule 163 (compound_name -> compound_name . simple_name .)
    RENAMES         reduce using rule 163 (compound_name -> compound_name . simple_name .)
    )               reduce using rule 163 (compound_name -> compound_name . simple_name .)


state 204

    (233) factor -> primary STARSTAR . primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 148
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    primary                        shift and go to state 356
    used_char                      shift and go to state 145
    literal                        shift and go to state 135
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157

state 205

    (217) simple_expression -> unary term .
    (226) term -> term . multiplying factor
    (227) multiplying -> . *
    (228) multiplying -> . /
    (229) multiplying -> . MOD
    (230) multiplying -> . REM

    +               reduce using rule 217 (simple_expression -> unary term .)
    -               reduce using rule 217 (simple_expression -> unary term .)
    &               reduce using rule 217 (simple_expression -> unary term .)
    ARROW           reduce using rule 217 (simple_expression -> unary term .)
    |               reduce using rule 217 (simple_expression -> unary term .)
    AND             reduce using rule 217 (simple_expression -> unary term .)
    OR              reduce using rule 217 (simple_expression -> unary term .)
    )               reduce using rule 217 (simple_expression -> unary term .)
    ,               reduce using rule 217 (simple_expression -> unary term .)
    WITH            reduce using rule 217 (simple_expression -> unary term .)
    ;               reduce using rule 217 (simple_expression -> unary term .)
    IS              reduce using rule 217 (simple_expression -> unary term .)
    THEN            reduce using rule 217 (simple_expression -> unary term .)
    LOOP            reduce using rule 217 (simple_expression -> unary term .)
    RANGE           reduce using rule 217 (simple_expression -> unary term .)
    DIGITS          reduce using rule 217 (simple_expression -> unary term .)
    RENAMES         reduce using rule 217 (simple_expression -> unary term .)
    ASSIGNMENT      reduce using rule 217 (simple_expression -> unary term .)
    =               reduce using rule 217 (simple_expression -> unary term .)
    NOTEQUAL        reduce using rule 217 (simple_expression -> unary term .)
    <               reduce using rule 217 (simple_expression -> unary term .)
    LESSEQ          reduce using rule 217 (simple_expression -> unary term .)
    >               reduce using rule 217 (simple_expression -> unary term .)
    GREATEREQ       reduce using rule 217 (simple_expression -> unary term .)
    IN              reduce using rule 217 (simple_expression -> unary term .)
    NOT             reduce using rule 217 (simple_expression -> unary term .)
    DOTDOT          reduce using rule 217 (simple_expression -> unary term .)
    *               shift and go to state 240
    /               shift and go to state 241
    MOD             shift and go to state 242
    REM             shift and go to state 238

    multiplying                    shift and go to state 239

state 206

    (242) allocator -> NEW name .
    (241) qualified -> name . TICK parenthesized_primary
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id

    STARSTAR        reduce using rule 242 (allocator -> NEW name .)
    *               reduce using rule 242 (allocator -> NEW name .)
    /               reduce using rule 242 (allocator -> NEW name .)
    MOD             reduce using rule 242 (allocator -> NEW name .)
    REM             reduce using rule 242 (allocator -> NEW name .)
    DOTDOT          reduce using rule 242 (allocator -> NEW name .)
    +               reduce using rule 242 (allocator -> NEW name .)
    -               reduce using rule 242 (allocator -> NEW name .)
    &               reduce using rule 242 (allocator -> NEW name .)
    =               reduce using rule 242 (allocator -> NEW name .)
    NOTEQUAL        reduce using rule 242 (allocator -> NEW name .)
    <               reduce using rule 242 (allocator -> NEW name .)
    LESSEQ          reduce using rule 242 (allocator -> NEW name .)
    >               reduce using rule 242 (allocator -> NEW name .)
    GREATEREQ       reduce using rule 242 (allocator -> NEW name .)
    IN              reduce using rule 242 (allocator -> NEW name .)
    NOT             reduce using rule 242 (allocator -> NEW name .)
    AND             reduce using rule 242 (allocator -> NEW name .)
    OR              reduce using rule 242 (allocator -> NEW name .)
    )               reduce using rule 242 (allocator -> NEW name .)
    ,               reduce using rule 242 (allocator -> NEW name .)
    WITH            reduce using rule 242 (allocator -> NEW name .)
    ARROW           reduce using rule 242 (allocator -> NEW name .)
    |               reduce using rule 242 (allocator -> NEW name .)
    ;               reduce using rule 242 (allocator -> NEW name .)
    IS              reduce using rule 242 (allocator -> NEW name .)
    THEN            reduce using rule 242 (allocator -> NEW name .)
    LOOP            reduce using rule 242 (allocator -> NEW name .)
    RANGE           reduce using rule 242 (allocator -> NEW name .)
    DIGITS          reduce using rule 242 (allocator -> NEW name .)
    RENAMES         reduce using rule 242 (allocator -> NEW name .)
    ASSIGNMENT      reduce using rule 242 (allocator -> NEW name .)
    TICK            shift and go to state 245
    (               shift and go to state 243
    .               shift and go to state 244


state 207

    (243) allocator -> NEW qualified .

    STARSTAR        reduce using rule 243 (allocator -> NEW qualified .)
    *               reduce using rule 243 (allocator -> NEW qualified .)
    /               reduce using rule 243 (allocator -> NEW qualified .)
    MOD             reduce using rule 243 (allocator -> NEW qualified .)
    REM             reduce using rule 243 (allocator -> NEW qualified .)
    DOTDOT          reduce using rule 243 (allocator -> NEW qualified .)
    +               reduce using rule 243 (allocator -> NEW qualified .)
    -               reduce using rule 243 (allocator -> NEW qualified .)
    &               reduce using rule 243 (allocator -> NEW qualified .)
    =               reduce using rule 243 (allocator -> NEW qualified .)
    NOTEQUAL        reduce using rule 243 (allocator -> NEW qualified .)
    <               reduce using rule 243 (allocator -> NEW qualified .)
    LESSEQ          reduce using rule 243 (allocator -> NEW qualified .)
    >               reduce using rule 243 (allocator -> NEW qualified .)
    GREATEREQ       reduce using rule 243 (allocator -> NEW qualified .)
    IN              reduce using rule 243 (allocator -> NEW qualified .)
    NOT             reduce using rule 243 (allocator -> NEW qualified .)
    AND             reduce using rule 243 (allocator -> NEW qualified .)
    OR              reduce using rule 243 (allocator -> NEW qualified .)
    )               reduce using rule 243 (allocator -> NEW qualified .)
    ,               reduce using rule 243 (allocator -> NEW qualified .)
    WITH            reduce using rule 243 (allocator -> NEW qualified .)
    ARROW           reduce using rule 243 (allocator -> NEW qualified .)
    |               reduce using rule 243 (allocator -> NEW qualified .)
    ;               reduce using rule 243 (allocator -> NEW qualified .)
    IS              reduce using rule 243 (allocator -> NEW qualified .)
    THEN            reduce using rule 243 (allocator -> NEW qualified .)
    LOOP            reduce using rule 243 (allocator -> NEW qualified .)
    RANGE           reduce using rule 243 (allocator -> NEW qualified .)
    DIGITS          reduce using rule 243 (allocator -> NEW qualified .)
    RENAMES         reduce using rule 243 (allocator -> NEW qualified .)
    ASSIGNMENT      reduce using rule 243 (allocator -> NEW qualified .)


state 208

    (219) simple_expression -> simple_expression adding . term
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 357
    name                           shift and go to state 148
    operator_symbol                shift and go to state 138

state 209

    (210) relational -> NOTEQUAL .

    +               reduce using rule 210 (relational -> NOTEQUAL .)
    -               reduce using rule 210 (relational -> NOTEQUAL .)
    NOT             reduce using rule 210 (relational -> NOTEQUAL .)
    INTEGER         reduce using rule 210 (relational -> NOTEQUAL .)
    BASE_INTEGER    reduce using rule 210 (relational -> NOTEQUAL .)
    FLOAT           reduce using rule 210 (relational -> NOTEQUAL .)
    BASE_FLOAT      reduce using rule 210 (relational -> NOTEQUAL .)
    NuLL            reduce using rule 210 (relational -> NOTEQUAL .)
    NEW             reduce using rule 210 (relational -> NOTEQUAL .)
    (               reduce using rule 210 (relational -> NOTEQUAL .)
    CHAR            reduce using rule 210 (relational -> NOTEQUAL .)
    IDENTIFIER      reduce using rule 210 (relational -> NOTEQUAL .)
    STRING          reduce using rule 210 (relational -> NOTEQUAL .)


state 210

    (222) adding -> + .

    NOT             reduce using rule 222 (adding -> + .)
    INTEGER         reduce using rule 222 (adding -> + .)
    BASE_INTEGER    reduce using rule 222 (adding -> + .)
    FLOAT           reduce using rule 222 (adding -> + .)
    BASE_FLOAT      reduce using rule 222 (adding -> + .)
    NuLL            reduce using rule 222 (adding -> + .)
    NEW             reduce using rule 222 (adding -> + .)
    (               reduce using rule 222 (adding -> + .)
    CHAR            reduce using rule 222 (adding -> + .)
    IDENTIFIER      reduce using rule 222 (adding -> + .)
    STRING          reduce using rule 222 (adding -> + .)


state 211

    (224) adding -> & .

    NOT             reduce using rule 224 (adding -> & .)
    INTEGER         reduce using rule 224 (adding -> & .)
    BASE_INTEGER    reduce using rule 224 (adding -> & .)
    FLOAT           reduce using rule 224 (adding -> & .)
    BASE_FLOAT      reduce using rule 224 (adding -> & .)
    NuLL            reduce using rule 224 (adding -> & .)
    NEW             reduce using rule 224 (adding -> & .)
    (               reduce using rule 224 (adding -> & .)
    CHAR            reduce using rule 224 (adding -> & .)
    IDENTIFIER      reduce using rule 224 (adding -> & .)
    STRING          reduce using rule 224 (adding -> & .)


state 212

    (223) adding -> - .

    NOT             reduce using rule 223 (adding -> - .)
    INTEGER         reduce using rule 223 (adding -> - .)
    BASE_INTEGER    reduce using rule 223 (adding -> - .)
    FLOAT           reduce using rule 223 (adding -> - .)
    BASE_FLOAT      reduce using rule 223 (adding -> - .)
    NuLL            reduce using rule 223 (adding -> - .)
    NEW             reduce using rule 223 (adding -> - .)
    (               reduce using rule 223 (adding -> - .)
    CHAR            reduce using rule 223 (adding -> - .)
    IDENTIFIER      reduce using rule 223 (adding -> - .)
    STRING          reduce using rule 223 (adding -> - .)


state 213

    (207) relation -> simple_expression membership . range
    (208) relation -> simple_expression membership . name
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    simple_expression              shift and go to state 358
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 359
    operator_symbol                shift and go to state 138
    range                          shift and go to state 360

state 214

    (214) relational -> GREATEREQ .

    +               reduce using rule 214 (relational -> GREATEREQ .)
    -               reduce using rule 214 (relational -> GREATEREQ .)
    NOT             reduce using rule 214 (relational -> GREATEREQ .)
    INTEGER         reduce using rule 214 (relational -> GREATEREQ .)
    BASE_INTEGER    reduce using rule 214 (relational -> GREATEREQ .)
    FLOAT           reduce using rule 214 (relational -> GREATEREQ .)
    BASE_FLOAT      reduce using rule 214 (relational -> GREATEREQ .)
    NuLL            reduce using rule 214 (relational -> GREATEREQ .)
    NEW             reduce using rule 214 (relational -> GREATEREQ .)
    (               reduce using rule 214 (relational -> GREATEREQ .)
    CHAR            reduce using rule 214 (relational -> GREATEREQ .)
    IDENTIFIER      reduce using rule 214 (relational -> GREATEREQ .)
    STRING          reduce using rule 214 (relational -> GREATEREQ .)


state 215

    (212) relational -> LESSEQ .

    +               reduce using rule 212 (relational -> LESSEQ .)
    -               reduce using rule 212 (relational -> LESSEQ .)
    NOT             reduce using rule 212 (relational -> LESSEQ .)
    INTEGER         reduce using rule 212 (relational -> LESSEQ .)
    BASE_INTEGER    reduce using rule 212 (relational -> LESSEQ .)
    FLOAT           reduce using rule 212 (relational -> LESSEQ .)
    BASE_FLOAT      reduce using rule 212 (relational -> LESSEQ .)
    NuLL            reduce using rule 212 (relational -> LESSEQ .)
    NEW             reduce using rule 212 (relational -> LESSEQ .)
    (               reduce using rule 212 (relational -> LESSEQ .)
    CHAR            reduce using rule 212 (relational -> LESSEQ .)
    IDENTIFIER      reduce using rule 212 (relational -> LESSEQ .)
    STRING          reduce using rule 212 (relational -> LESSEQ .)


state 216

    (215) membership -> IN .

    IDENTIFIER      reduce using rule 215 (membership -> IN .)
    STRING          reduce using rule 215 (membership -> IN .)
    +               reduce using rule 215 (membership -> IN .)
    -               reduce using rule 215 (membership -> IN .)
    NOT             reduce using rule 215 (membership -> IN .)
    INTEGER         reduce using rule 215 (membership -> IN .)
    BASE_INTEGER    reduce using rule 215 (membership -> IN .)
    FLOAT           reduce using rule 215 (membership -> IN .)
    BASE_FLOAT      reduce using rule 215 (membership -> IN .)
    NuLL            reduce using rule 215 (membership -> IN .)
    NEW             reduce using rule 215 (membership -> IN .)
    (               reduce using rule 215 (membership -> IN .)
    CHAR            reduce using rule 215 (membership -> IN .)


state 217

    (216) membership -> NOT . IN

    IN              shift and go to state 361


state 218

    (206) relation -> simple_expression relational . simple_expression
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    simple_expression              shift and go to state 362
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148
    operator_symbol                shift and go to state 138

state 219

    (209) relational -> = .

    +               reduce using rule 209 (relational -> = .)
    -               reduce using rule 209 (relational -> = .)
    NOT             reduce using rule 209 (relational -> = .)
    INTEGER         reduce using rule 209 (relational -> = .)
    BASE_INTEGER    reduce using rule 209 (relational -> = .)
    FLOAT           reduce using rule 209 (relational -> = .)
    BASE_FLOAT      reduce using rule 209 (relational -> = .)
    NuLL            reduce using rule 209 (relational -> = .)
    NEW             reduce using rule 209 (relational -> = .)
    (               reduce using rule 209 (relational -> = .)
    CHAR            reduce using rule 209 (relational -> = .)
    IDENTIFIER      reduce using rule 209 (relational -> = .)
    STRING          reduce using rule 209 (relational -> = .)


state 220

    (211) relational -> < .

    +               reduce using rule 211 (relational -> < .)
    -               reduce using rule 211 (relational -> < .)
    NOT             reduce using rule 211 (relational -> < .)
    INTEGER         reduce using rule 211 (relational -> < .)
    BASE_INTEGER    reduce using rule 211 (relational -> < .)
    FLOAT           reduce using rule 211 (relational -> < .)
    BASE_FLOAT      reduce using rule 211 (relational -> < .)
    NuLL            reduce using rule 211 (relational -> < .)
    NEW             reduce using rule 211 (relational -> < .)
    (               reduce using rule 211 (relational -> < .)
    CHAR            reduce using rule 211 (relational -> < .)
    IDENTIFIER      reduce using rule 211 (relational -> < .)
    STRING          reduce using rule 211 (relational -> < .)


state 221

    (213) relational -> > .

    +               reduce using rule 213 (relational -> > .)
    -               reduce using rule 213 (relational -> > .)
    NOT             reduce using rule 213 (relational -> > .)
    INTEGER         reduce using rule 213 (relational -> > .)
    BASE_INTEGER    reduce using rule 213 (relational -> > .)
    FLOAT           reduce using rule 213 (relational -> > .)
    BASE_FLOAT      reduce using rule 213 (relational -> > .)
    NuLL            reduce using rule 213 (relational -> > .)
    NEW             reduce using rule 213 (relational -> > .)
    (               reduce using rule 213 (relational -> > .)
    CHAR            reduce using rule 213 (relational -> > .)
    IDENTIFIER      reduce using rule 213 (relational -> > .)
    STRING          reduce using rule 213 (relational -> > .)


state 222

    (7) pragma_arg -> simple_name ARROW . expression
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 363

state 223

    (125) choice -> OTHERS .

    ARROW           reduce using rule 125 (choice -> OTHERS .)
    |               reduce using rule 125 (choice -> OTHERS .)


state 224

    (205) relation -> simple_expression .
    (206) relation -> simple_expression . relational simple_expression
    (207) relation -> simple_expression . membership range
    (208) relation -> simple_expression . membership name
    (219) simple_expression -> simple_expression . adding term
    (62) range -> simple_expression . DOTDOT simple_expression
    (209) relational -> . =
    (210) relational -> . NOTEQUAL
    (211) relational -> . <
    (212) relational -> . LESSEQ
    (213) relational -> . >
    (214) relational -> . GREATEREQ
    (215) membership -> . IN
    (216) membership -> . NOT IN
    (222) adding -> . +
    (223) adding -> . -
    (224) adding -> . &

    AND             reduce using rule 205 (relation -> simple_expression .)
    OR              reduce using rule 205 (relation -> simple_expression .)
    )               reduce using rule 205 (relation -> simple_expression .)
    ,               reduce using rule 205 (relation -> simple_expression .)
    ARROW           reduce using rule 205 (relation -> simple_expression .)
    |               reduce using rule 205 (relation -> simple_expression .)
    WITH            reduce using rule 205 (relation -> simple_expression .)
    DOTDOT          shift and go to state 364
    =               shift and go to state 219
    NOTEQUAL        shift and go to state 209
    <               shift and go to state 220
    LESSEQ          shift and go to state 215
    >               shift and go to state 221
    GREATEREQ       shift and go to state 214
    IN              shift and go to state 216
    NOT             shift and go to state 217
    +               shift and go to state 210
    -               shift and go to state 212
    &               shift and go to state 211

    adding                         shift and go to state 208
    membership                     shift and go to state 213
    relational                     shift and go to state 218

state 225

    (196) comp_assoc -> choice_s . ARROW expression
    (122) choice_s -> choice_s . | choice

    ARROW           shift and go to state 366
    |               shift and go to state 365


state 226

    (189) aggregate -> ( comp_assoc . )
    (172) value -> comp_assoc .

    )               shift and go to state 367
    ,               reduce using rule 172 (value -> comp_assoc .)


state 227

    (121) choice_s -> choice .

    ARROW           reduce using rule 121 (choice_s -> choice .)
    |               reduce using rule 121 (choice_s -> choice .)


state 228

    (190) aggregate -> ( value_s_2 . )
    (195) value_s_2 -> value_s_2 . , value

    )               shift and go to state 368
    ,               shift and go to state 369


state 229

    (124) choice -> discrete_with_range .

    ARROW           reduce using rule 124 (choice -> discrete_with_range .)
    |               reduce using rule 124 (choice -> discrete_with_range .)


state 230

    (126) discrete_with_range -> name . range_constraint
    (63) range -> name .
    (235) primary -> name .
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id
    (241) qualified -> name . TICK parenthesized_primary
    (61) range_constraint -> . RANGE range

  ! reduce/reduce conflict for ARROW resolved using rule 63 (range -> name .)
  ! reduce/reduce conflict for | resolved using rule 63 (range -> name .)
    ARROW           reduce using rule 63 (range -> name .)
    |               reduce using rule 63 (range -> name .)
    STARSTAR        reduce using rule 235 (primary -> name .)
    *               reduce using rule 235 (primary -> name .)
    /               reduce using rule 235 (primary -> name .)
    MOD             reduce using rule 235 (primary -> name .)
    REM             reduce using rule 235 (primary -> name .)
    DOTDOT          reduce using rule 235 (primary -> name .)
    =               reduce using rule 235 (primary -> name .)
    NOTEQUAL        reduce using rule 235 (primary -> name .)
    <               reduce using rule 235 (primary -> name .)
    LESSEQ          reduce using rule 235 (primary -> name .)
    >               reduce using rule 235 (primary -> name .)
    GREATEREQ       reduce using rule 235 (primary -> name .)
    IN              reduce using rule 235 (primary -> name .)
    NOT             reduce using rule 235 (primary -> name .)
    +               reduce using rule 235 (primary -> name .)
    -               reduce using rule 235 (primary -> name .)
    &               reduce using rule 235 (primary -> name .)
    AND             reduce using rule 235 (primary -> name .)
    OR              reduce using rule 235 (primary -> name .)
    )               reduce using rule 235 (primary -> name .)
    ,               reduce using rule 235 (primary -> name .)
    WITH            reduce using rule 235 (primary -> name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 370
    RANGE           shift and go to state 371

  ! ARROW           [ reduce using rule 235 (primary -> name .) ]
  ! |               [ reduce using rule 235 (primary -> name .) ]

    range_constraint               shift and go to state 372

state 231

    (194) value_s_2 -> value . , value

    ,               shift and go to state 373


state 232

    (127) discrete_with_range -> range .

    ARROW           reduce using rule 127 (discrete_with_range -> range .)
    |               reduce using rule 127 (discrete_with_range -> range .)


state 233

    (173) value -> error .

    )               reduce using rule 173 (value -> error .)
    ,               reduce using rule 173 (value -> error .)


state 234

    (193) aggregate -> ( NuLL . RECORD )
    (188) literal -> NuLL .

    RECORD          shift and go to state 374
    STARSTAR        reduce using rule 188 (literal -> NuLL .)
    *               reduce using rule 188 (literal -> NuLL .)
    /               reduce using rule 188 (literal -> NuLL .)
    MOD             reduce using rule 188 (literal -> NuLL .)
    REM             reduce using rule 188 (literal -> NuLL .)
    DOTDOT          reduce using rule 188 (literal -> NuLL .)
    =               reduce using rule 188 (literal -> NuLL .)
    NOTEQUAL        reduce using rule 188 (literal -> NuLL .)
    <               reduce using rule 188 (literal -> NuLL .)
    LESSEQ          reduce using rule 188 (literal -> NuLL .)
    >               reduce using rule 188 (literal -> NuLL .)
    GREATEREQ       reduce using rule 188 (literal -> NuLL .)
    IN              reduce using rule 188 (literal -> NuLL .)
    NOT             reduce using rule 188 (literal -> NuLL .)
    +               reduce using rule 188 (literal -> NuLL .)
    -               reduce using rule 188 (literal -> NuLL .)
    &               reduce using rule 188 (literal -> NuLL .)
    )               reduce using rule 188 (literal -> NuLL .)
    WITH            reduce using rule 188 (literal -> NuLL .)
    AND             reduce using rule 188 (literal -> NuLL .)
    OR              reduce using rule 188 (literal -> NuLL .)
    ,               reduce using rule 188 (literal -> NuLL .)
    ARROW           reduce using rule 188 (literal -> NuLL .)
    |               reduce using rule 188 (literal -> NuLL .)


state 235

    (240) parenthesized_primary -> ( expression . )
    (191) aggregate -> ( expression . WITH value_s )
    (192) aggregate -> ( expression . WITH NuLL RECORD )
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (171) value -> expression .
    (123) choice -> expression .
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    )               shift and go to state 375
    WITH            shift and go to state 376
    ,               reduce using rule 171 (value -> expression .)
    ARROW           reduce using rule 123 (choice -> expression .)
    |               reduce using rule 123 (choice -> expression .)
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 236

    (3) pragma -> PRAGMA simple_name ( pragma_arg_s ) . ;

    ;               shift and go to state 377


state 237

    (5) pragma_arg_s -> pragma_arg_s , . pragma_arg
    (6) pragma_arg -> . expression
    (7) pragma_arg -> . simple_name ARROW expression
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (161) simple_name -> . IDENTIFIER
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 39
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    pragma_arg                     shift and go to state 378
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 131
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    used_char                      shift and go to state 145
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 152

state 238

    (230) multiplying -> REM .

    NOT             reduce using rule 230 (multiplying -> REM .)
    INTEGER         reduce using rule 230 (multiplying -> REM .)
    BASE_INTEGER    reduce using rule 230 (multiplying -> REM .)
    FLOAT           reduce using rule 230 (multiplying -> REM .)
    BASE_FLOAT      reduce using rule 230 (multiplying -> REM .)
    NuLL            reduce using rule 230 (multiplying -> REM .)
    NEW             reduce using rule 230 (multiplying -> REM .)
    (               reduce using rule 230 (multiplying -> REM .)
    CHAR            reduce using rule 230 (multiplying -> REM .)
    IDENTIFIER      reduce using rule 230 (multiplying -> REM .)
    STRING          reduce using rule 230 (multiplying -> REM .)


state 239

    (226) term -> term multiplying . factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 148
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    literal                        shift and go to state 135
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    factor                         shift and go to state 379
    aggregate                      shift and go to state 144
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157

state 240

    (227) multiplying -> * .

    NOT             reduce using rule 227 (multiplying -> * .)
    INTEGER         reduce using rule 227 (multiplying -> * .)
    BASE_INTEGER    reduce using rule 227 (multiplying -> * .)
    FLOAT           reduce using rule 227 (multiplying -> * .)
    BASE_FLOAT      reduce using rule 227 (multiplying -> * .)
    NuLL            reduce using rule 227 (multiplying -> * .)
    NEW             reduce using rule 227 (multiplying -> * .)
    (               reduce using rule 227 (multiplying -> * .)
    CHAR            reduce using rule 227 (multiplying -> * .)
    IDENTIFIER      reduce using rule 227 (multiplying -> * .)
    STRING          reduce using rule 227 (multiplying -> * .)


state 241

    (228) multiplying -> / .

    NOT             reduce using rule 228 (multiplying -> / .)
    INTEGER         reduce using rule 228 (multiplying -> / .)
    BASE_INTEGER    reduce using rule 228 (multiplying -> / .)
    FLOAT           reduce using rule 228 (multiplying -> / .)
    BASE_FLOAT      reduce using rule 228 (multiplying -> / .)
    NuLL            reduce using rule 228 (multiplying -> / .)
    NEW             reduce using rule 228 (multiplying -> / .)
    (               reduce using rule 228 (multiplying -> / .)
    CHAR            reduce using rule 228 (multiplying -> / .)
    IDENTIFIER      reduce using rule 228 (multiplying -> / .)
    STRING          reduce using rule 228 (multiplying -> / .)


state 242

    (229) multiplying -> MOD .

    NOT             reduce using rule 229 (multiplying -> MOD .)
    INTEGER         reduce using rule 229 (multiplying -> MOD .)
    BASE_INTEGER    reduce using rule 229 (multiplying -> MOD .)
    FLOAT           reduce using rule 229 (multiplying -> MOD .)
    BASE_FLOAT      reduce using rule 229 (multiplying -> MOD .)
    NuLL            reduce using rule 229 (multiplying -> MOD .)
    NEW             reduce using rule 229 (multiplying -> MOD .)
    (               reduce using rule 229 (multiplying -> MOD .)
    CHAR            reduce using rule 229 (multiplying -> MOD .)
    IDENTIFIER      reduce using rule 229 (multiplying -> MOD .)
    STRING          reduce using rule 229 (multiplying -> MOD .)


state 243

    (168) indexed_comp -> name ( . value_s )
    (169) value_s -> . value
    (170) value_s -> . value_s , value
    (171) value -> . expression
    (172) value -> . comp_assoc
    (173) value -> . error
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (196) comp_assoc -> . choice_s ARROW expression
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 233
    OTHERS          shift and go to state 223
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    value_s                        shift and go to state 380
    simple_expression              shift and go to state 224
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    comp_assoc                     shift and go to state 381
    choice_s                       shift and go to state 225
    choice                         shift and go to state 227
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 147
    name                           shift and go to state 230
    value                          shift and go to state 382
    range                          shift and go to state 232
    expression                     shift and go to state 383

state 244

    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (161) simple_name -> . IDENTIFIER
    (166) used_char -> . CHAR
    (167) operator_symbol -> . STRING

    ALL             shift and go to state 384
    IDENTIFIER      shift and go to state 39
    CHAR            shift and go to state 146
    STRING          shift and go to state 139

    used_char                      shift and go to state 386
    operator_symbol                shift and go to state 385
    simple_name                    shift and go to state 387

state 245

    (241) qualified -> name TICK . parenthesized_primary
    (178) attribute -> name TICK . attribute_id
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (179) attribute_id -> . IDENTIFIER
    (180) attribute_id -> . DIGITS
    (181) attribute_id -> . DELTA
    (182) attribute_id -> . ACCESS
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    (               shift and go to state 132
    IDENTIFIER      shift and go to state 389
    DIGITS          shift and go to state 388
    DELTA           shift and go to state 392
    ACCESS          shift and go to state 390

    attribute_id                   shift and go to state 391
    aggregate                      shift and go to state 144
    parenthesized_primary          shift and go to state 393

state 246

    (232) factor -> NOT primary .

    *               reduce using rule 232 (factor -> NOT primary .)
    /               reduce using rule 232 (factor -> NOT primary .)
    MOD             reduce using rule 232 (factor -> NOT primary .)
    REM             reduce using rule 232 (factor -> NOT primary .)
    =               reduce using rule 232 (factor -> NOT primary .)
    NOTEQUAL        reduce using rule 232 (factor -> NOT primary .)
    <               reduce using rule 232 (factor -> NOT primary .)
    LESSEQ          reduce using rule 232 (factor -> NOT primary .)
    >               reduce using rule 232 (factor -> NOT primary .)
    GREATEREQ       reduce using rule 232 (factor -> NOT primary .)
    IN              reduce using rule 232 (factor -> NOT primary .)
    NOT             reduce using rule 232 (factor -> NOT primary .)
    +               reduce using rule 232 (factor -> NOT primary .)
    -               reduce using rule 232 (factor -> NOT primary .)
    &               reduce using rule 232 (factor -> NOT primary .)
    AND             reduce using rule 232 (factor -> NOT primary .)
    OR              reduce using rule 232 (factor -> NOT primary .)
    )               reduce using rule 232 (factor -> NOT primary .)
    ,               reduce using rule 232 (factor -> NOT primary .)
    DOTDOT          reduce using rule 232 (factor -> NOT primary .)
    ;               reduce using rule 232 (factor -> NOT primary .)
    ARROW           reduce using rule 232 (factor -> NOT primary .)
    |               reduce using rule 232 (factor -> NOT primary .)
    RANGE           reduce using rule 232 (factor -> NOT primary .)
    DIGITS          reduce using rule 232 (factor -> NOT primary .)
    WITH            reduce using rule 232 (factor -> NOT primary .)
    IS              reduce using rule 232 (factor -> NOT primary .)
    THEN            reduce using rule 232 (factor -> NOT primary .)
    LOOP            reduce using rule 232 (factor -> NOT primary .)
    RENAMES         reduce using rule 232 (factor -> NOT primary .)
    ASSIGNMENT      reduce using rule 232 (factor -> NOT primary .)


state 247

    (201) logical -> AND .
    (203) short_circuit -> AND . THEN

    +               reduce using rule 201 (logical -> AND .)
    -               reduce using rule 201 (logical -> AND .)
    NOT             reduce using rule 201 (logical -> AND .)
    INTEGER         reduce using rule 201 (logical -> AND .)
    BASE_INTEGER    reduce using rule 201 (logical -> AND .)
    FLOAT           reduce using rule 201 (logical -> AND .)
    BASE_FLOAT      reduce using rule 201 (logical -> AND .)
    NuLL            reduce using rule 201 (logical -> AND .)
    NEW             reduce using rule 201 (logical -> AND .)
    (               reduce using rule 201 (logical -> AND .)
    CHAR            reduce using rule 201 (logical -> AND .)
    IDENTIFIER      reduce using rule 201 (logical -> AND .)
    STRING          reduce using rule 201 (logical -> AND .)
    THEN            shift and go to state 394


state 248

    (199) expression -> expression logical . m relation
    (197) m -> .

    +               reduce using rule 197 (m -> .)
    -               reduce using rule 197 (m -> .)
    NOT             reduce using rule 197 (m -> .)
    INTEGER         reduce using rule 197 (m -> .)
    BASE_INTEGER    reduce using rule 197 (m -> .)
    FLOAT           reduce using rule 197 (m -> .)
    BASE_FLOAT      reduce using rule 197 (m -> .)
    NuLL            reduce using rule 197 (m -> .)
    NEW             reduce using rule 197 (m -> .)
    (               reduce using rule 197 (m -> .)
    CHAR            reduce using rule 197 (m -> .)
    IDENTIFIER      reduce using rule 197 (m -> .)
    STRING          reduce using rule 197 (m -> .)

    m                              shift and go to state 395

state 249

    (200) expression -> expression short_circuit . m relation
    (197) m -> .

    +               reduce using rule 197 (m -> .)
    -               reduce using rule 197 (m -> .)
    NOT             reduce using rule 197 (m -> .)
    INTEGER         reduce using rule 197 (m -> .)
    BASE_INTEGER    reduce using rule 197 (m -> .)
    FLOAT           reduce using rule 197 (m -> .)
    BASE_FLOAT      reduce using rule 197 (m -> .)
    NuLL            reduce using rule 197 (m -> .)
    NEW             reduce using rule 197 (m -> .)
    (               reduce using rule 197 (m -> .)
    CHAR            reduce using rule 197 (m -> .)
    IDENTIFIER      reduce using rule 197 (m -> .)
    STRING          reduce using rule 197 (m -> .)

    m                              shift and go to state 396

state 250

    (202) logical -> OR .
    (204) short_circuit -> OR . ELSE

    +               reduce using rule 202 (logical -> OR .)
    -               reduce using rule 202 (logical -> OR .)
    NOT             reduce using rule 202 (logical -> OR .)
    INTEGER         reduce using rule 202 (logical -> OR .)
    BASE_INTEGER    reduce using rule 202 (logical -> OR .)
    FLOAT           reduce using rule 202 (logical -> OR .)
    BASE_FLOAT      reduce using rule 202 (logical -> OR .)
    NuLL            reduce using rule 202 (logical -> OR .)
    NEW             reduce using rule 202 (logical -> OR .)
    (               reduce using rule 202 (logical -> OR .)
    CHAR            reduce using rule 202 (logical -> OR .)
    IDENTIFIER      reduce using rule 202 (logical -> OR .)
    STRING          reduce using rule 202 (logical -> OR .)
    ELSE            shift and go to state 397


state 251

    (349) use_clause -> USE name_s ; .

    PACKAGE         reduce using rule 349 (use_clause -> USE name_s ; .)
    TASK            reduce using rule 349 (use_clause -> USE name_s ; .)
    PROTECTED       reduce using rule 349 (use_clause -> USE name_s ; .)
    error           reduce using rule 349 (use_clause -> USE name_s ; .)
    USE             reduce using rule 349 (use_clause -> USE name_s ; .)
    PRAGMA          reduce using rule 349 (use_clause -> USE name_s ; .)
    TYPE            reduce using rule 349 (use_clause -> USE name_s ; .)
    SUBTYPE         reduce using rule 349 (use_clause -> USE name_s ; .)
    FOR             reduce using rule 349 (use_clause -> USE name_s ; .)
    PROCEDURE       reduce using rule 349 (use_clause -> USE name_s ; .)
    FUNCTION        reduce using rule 349 (use_clause -> USE name_s ; .)
    GENERIC         reduce using rule 349 (use_clause -> USE name_s ; .)
    IDENTIFIER      reduce using rule 349 (use_clause -> USE name_s ; .)
    BEGIN           reduce using rule 349 (use_clause -> USE name_s ; .)
    PRIVATE         reduce using rule 349 (use_clause -> USE name_s ; .)
    WITH            reduce using rule 349 (use_clause -> USE name_s ; .)
    SEPARATE        reduce using rule 349 (use_clause -> USE name_s ; .)
    END             reduce using rule 349 (use_clause -> USE name_s ; .)


state 252

    (352) name_s -> name_s , . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 398
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 253

    (178) attribute -> name TICK . attribute_id
    (179) attribute_id -> . IDENTIFIER
    (180) attribute_id -> . DIGITS
    (181) attribute_id -> . DELTA
    (182) attribute_id -> . ACCESS

    IDENTIFIER      shift and go to state 389
    DIGITS          shift and go to state 388
    DELTA           shift and go to state 392
    ACCESS          shift and go to state 390

    attribute_id                   shift and go to state 391

state 254

    (350) use_clause -> USE TYPE name_s . ;
    (352) name_s -> name_s . , name

    ;               shift and go to state 399
    ,               shift and go to state 252


state 255

    (449) subunit -> SEPARATE ( compound_name ) . subunit_body
    (450) subunit_body -> . subprog_body
    (451) subunit_body -> . pkg_body
    (452) subunit_body -> . task_body
    (453) subunit_body -> . prot_body
    (334) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (343) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (368) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (385) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (333) subprog_spec_is_push -> . subprog_spec IS
    (316) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (317) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (318) subprog_spec -> . FUNCTION designator

    PACKAGE         shift and go to state 407
    TASK            shift and go to state 404
    PROTECTED       shift and go to state 402
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36

    subprog_body                   shift and go to state 400
    subprog_spec_is_push           shift and go to state 405
    prot_body                      shift and go to state 408
    pkg_body                       shift and go to state 409
    task_body                      shift and go to state 401
    subprog_spec                   shift and go to state 406
    subunit_body                   shift and go to state 403

state 256

    (385) prot_body -> PROTECTED BODY simple_name . IS prot_op_body_s END id_opt ;
    (457) body_stub -> PROTECTED BODY simple_name . IS SEPARATE ;

    IS              shift and go to state 410


state 257

    (372) prot_def -> IS . prot_op_decl_s prot_private_opt END id_opt
    (375) prot_op_decl_s -> .
    (376) prot_op_decl_s -> . prot_op_decl_s prot_op_decl

    PRIVATE         reduce using rule 375 (prot_op_decl_s -> .)
    ENTRY           reduce using rule 375 (prot_op_decl_s -> .)
    PROCEDURE       reduce using rule 375 (prot_op_decl_s -> .)
    FUNCTION        reduce using rule 375 (prot_op_decl_s -> .)
    PRAGMA          reduce using rule 375 (prot_op_decl_s -> .)
    FOR             reduce using rule 375 (prot_op_decl_s -> .)
    END             reduce using rule 375 (prot_op_decl_s -> .)

    prot_op_decl_s                 shift and go to state 411

state 258

    (370) prot_spec -> PROTECTED IDENTIFIER prot_def .

    ;               reduce using rule 370 (prot_spec -> PROTECTED IDENTIFIER prot_def .)


state 259

    (371) prot_spec -> PROTECTED TYPE simple_name . discrim_part_opt prot_def
    (37) discrim_part_opt -> .
    (38) discrim_part_opt -> . discrim_part
    (39) discrim_part_opt -> . ( LESSMORE )
    (110) discrim_part -> . ( discrim_spec_s )

    IS              reduce using rule 37 (discrim_part_opt -> .)
    (               shift and go to state 318

    discrim_part_opt               shift and go to state 412
    discrim_part                   shift and go to state 320

state 260

    (407) delay_stmt -> DELAY . expression ;
    (408) delay_stmt -> DELAY . UNTIL expression ;
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    UNTIL           shift and go to state 413
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 414

state 261

    (410) select_stmt -> async_select .

    LESSLESS        reduce using rule 410 (select_stmt -> async_select .)
    error           reduce using rule 410 (select_stmt -> async_select .)
    PRAGMA          reduce using rule 410 (select_stmt -> async_select .)
    NuLL            reduce using rule 410 (select_stmt -> async_select .)
    EXIT            reduce using rule 410 (select_stmt -> async_select .)
    RETURN          reduce using rule 410 (select_stmt -> async_select .)
    GOTO            reduce using rule 410 (select_stmt -> async_select .)
    DELAY           reduce using rule 410 (select_stmt -> async_select .)
    ABORT           reduce using rule 410 (select_stmt -> async_select .)
    RAISE           reduce using rule 410 (select_stmt -> async_select .)
    REQUEUE         reduce using rule 410 (select_stmt -> async_select .)
    IF              reduce using rule 410 (select_stmt -> async_select .)
    CASE            reduce using rule 410 (select_stmt -> async_select .)
    IDENTIFIER      reduce using rule 410 (select_stmt -> async_select .)
    ACCEPT          reduce using rule 410 (select_stmt -> async_select .)
    SELECT          reduce using rule 410 (select_stmt -> async_select .)
    STRING          reduce using rule 410 (select_stmt -> async_select .)
    WHILE           reduce using rule 410 (select_stmt -> async_select .)
    DECLARE         reduce using rule 410 (select_stmt -> async_select .)
    FOR             reduce using rule 410 (select_stmt -> async_select .)
    LOOP            reduce using rule 410 (select_stmt -> async_select .)
    BEGIN           reduce using rule 410 (select_stmt -> async_select .)
    END             reduce using rule 410 (select_stmt -> async_select .)
    EXCEPTION       reduce using rule 410 (select_stmt -> async_select .)
    OR              reduce using rule 410 (select_stmt -> async_select .)
    ELSE            reduce using rule 410 (select_stmt -> async_select .)
    THEN            reduce using rule 410 (select_stmt -> async_select .)
    ELSIF           reduce using rule 410 (select_stmt -> async_select .)
    WHEN            reduce using rule 410 (select_stmt -> async_select .)


state 262

    (268) compound_stmt -> select_stmt .

    LESSLESS        reduce using rule 268 (compound_stmt -> select_stmt .)
    error           reduce using rule 268 (compound_stmt -> select_stmt .)
    PRAGMA          reduce using rule 268 (compound_stmt -> select_stmt .)
    NuLL            reduce using rule 268 (compound_stmt -> select_stmt .)
    EXIT            reduce using rule 268 (compound_stmt -> select_stmt .)
    RETURN          reduce using rule 268 (compound_stmt -> select_stmt .)
    GOTO            reduce using rule 268 (compound_stmt -> select_stmt .)
    DELAY           reduce using rule 268 (compound_stmt -> select_stmt .)
    ABORT           reduce using rule 268 (compound_stmt -> select_stmt .)
    RAISE           reduce using rule 268 (compound_stmt -> select_stmt .)
    REQUEUE         reduce using rule 268 (compound_stmt -> select_stmt .)
    IF              reduce using rule 268 (compound_stmt -> select_stmt .)
    CASE            reduce using rule 268 (compound_stmt -> select_stmt .)
    IDENTIFIER      reduce using rule 268 (compound_stmt -> select_stmt .)
    ACCEPT          reduce using rule 268 (compound_stmt -> select_stmt .)
    SELECT          reduce using rule 268 (compound_stmt -> select_stmt .)
    STRING          reduce using rule 268 (compound_stmt -> select_stmt .)
    WHILE           reduce using rule 268 (compound_stmt -> select_stmt .)
    DECLARE         reduce using rule 268 (compound_stmt -> select_stmt .)
    FOR             reduce using rule 268 (compound_stmt -> select_stmt .)
    LOOP            reduce using rule 268 (compound_stmt -> select_stmt .)
    BEGIN           reduce using rule 268 (compound_stmt -> select_stmt .)
    END             reduce using rule 268 (compound_stmt -> select_stmt .)
    WHEN            reduce using rule 268 (compound_stmt -> select_stmt .)
    ELSIF           reduce using rule 268 (compound_stmt -> select_stmt .)
    ELSE            reduce using rule 268 (compound_stmt -> select_stmt .)
    OR              reduce using rule 268 (compound_stmt -> select_stmt .)
    EXCEPTION       reduce using rule 268 (compound_stmt -> select_stmt .)
    THEN            reduce using rule 268 (compound_stmt -> select_stmt .)


state 263

    (286) loop_stmt -> label_opt . iteration m basic_loop id_opt ;
    (298) block -> label_opt . block_decl block_body END id_opt ;
    (289) iteration -> .
    (290) iteration -> . WHILE m condition
    (291) iteration -> . iter_part reverse_opt discrete_range
    (299) block_decl -> .
    (300) block_decl -> . DECLARE decl_part
    (292) iter_part -> . FOR IDENTIFIER IN

    LOOP            reduce using rule 289 (iteration -> .)
    WHILE           shift and go to state 419
    BEGIN           reduce using rule 299 (block_decl -> .)
    DECLARE         shift and go to state 420
    FOR             shift and go to state 416

    iter_part                      shift and go to state 415
    iteration                      shift and go to state 417
    block_decl                     shift and go to state 418

state 264

    (312) goto_stmt -> GOTO . name ;
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 421
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 265

    (248) unlabeled -> simple_stmt .

    EXCEPTION       reduce using rule 248 (unlabeled -> simple_stmt .)
    LESSLESS        reduce using rule 248 (unlabeled -> simple_stmt .)
    error           reduce using rule 248 (unlabeled -> simple_stmt .)
    PRAGMA          reduce using rule 248 (unlabeled -> simple_stmt .)
    NuLL            reduce using rule 248 (unlabeled -> simple_stmt .)
    EXIT            reduce using rule 248 (unlabeled -> simple_stmt .)
    RETURN          reduce using rule 248 (unlabeled -> simple_stmt .)
    GOTO            reduce using rule 248 (unlabeled -> simple_stmt .)
    DELAY           reduce using rule 248 (unlabeled -> simple_stmt .)
    ABORT           reduce using rule 248 (unlabeled -> simple_stmt .)
    RAISE           reduce using rule 248 (unlabeled -> simple_stmt .)
    REQUEUE         reduce using rule 248 (unlabeled -> simple_stmt .)
    IF              reduce using rule 248 (unlabeled -> simple_stmt .)
    CASE            reduce using rule 248 (unlabeled -> simple_stmt .)
    IDENTIFIER      reduce using rule 248 (unlabeled -> simple_stmt .)
    ACCEPT          reduce using rule 248 (unlabeled -> simple_stmt .)
    SELECT          reduce using rule 248 (unlabeled -> simple_stmt .)
    STRING          reduce using rule 248 (unlabeled -> simple_stmt .)
    WHILE           reduce using rule 248 (unlabeled -> simple_stmt .)
    DECLARE         reduce using rule 248 (unlabeled -> simple_stmt .)
    FOR             reduce using rule 248 (unlabeled -> simple_stmt .)
    LOOP            reduce using rule 248 (unlabeled -> simple_stmt .)
    BEGIN           reduce using rule 248 (unlabeled -> simple_stmt .)
    END             reduce using rule 248 (unlabeled -> simple_stmt .)
    OR              reduce using rule 248 (unlabeled -> simple_stmt .)
    ELSE            reduce using rule 248 (unlabeled -> simple_stmt .)
    THEN            reduce using rule 248 (unlabeled -> simple_stmt .)
    ELSIF           reduce using rule 248 (unlabeled -> simple_stmt .)
    WHEN            reduce using rule 248 (unlabeled -> simple_stmt .)


state 266

    (265) compound_stmt -> loop_stmt .

    LESSLESS        reduce using rule 265 (compound_stmt -> loop_stmt .)
    error           reduce using rule 265 (compound_stmt -> loop_stmt .)
    PRAGMA          reduce using rule 265 (compound_stmt -> loop_stmt .)
    NuLL            reduce using rule 265 (compound_stmt -> loop_stmt .)
    EXIT            reduce using rule 265 (compound_stmt -> loop_stmt .)
    RETURN          reduce using rule 265 (compound_stmt -> loop_stmt .)
    GOTO            reduce using rule 265 (compound_stmt -> loop_stmt .)
    DELAY           reduce using rule 265 (compound_stmt -> loop_stmt .)
    ABORT           reduce using rule 265 (compound_stmt -> loop_stmt .)
    RAISE           reduce using rule 265 (compound_stmt -> loop_stmt .)
    REQUEUE         reduce using rule 265 (compound_stmt -> loop_stmt .)
    IF              reduce using rule 265 (compound_stmt -> loop_stmt .)
    CASE            reduce using rule 265 (compound_stmt -> loop_stmt .)
    IDENTIFIER      reduce using rule 265 (compound_stmt -> loop_stmt .)
    ACCEPT          reduce using rule 265 (compound_stmt -> loop_stmt .)
    SELECT          reduce using rule 265 (compound_stmt -> loop_stmt .)
    STRING          reduce using rule 265 (compound_stmt -> loop_stmt .)
    WHILE           reduce using rule 265 (compound_stmt -> loop_stmt .)
    DECLARE         reduce using rule 265 (compound_stmt -> loop_stmt .)
    FOR             reduce using rule 265 (compound_stmt -> loop_stmt .)
    LOOP            reduce using rule 265 (compound_stmt -> loop_stmt .)
    BEGIN           reduce using rule 265 (compound_stmt -> loop_stmt .)
    END             reduce using rule 265 (compound_stmt -> loop_stmt .)
    WHEN            reduce using rule 265 (compound_stmt -> loop_stmt .)
    ELSIF           reduce using rule 265 (compound_stmt -> loop_stmt .)
    ELSE            reduce using rule 265 (compound_stmt -> loop_stmt .)
    OR              reduce using rule 265 (compound_stmt -> loop_stmt .)
    EXCEPTION       reduce using rule 265 (compound_stmt -> loop_stmt .)
    THEN            reduce using rule 265 (compound_stmt -> loop_stmt .)


state 267

    (513) code_stmt -> qualified . ;

    ;               shift and go to state 422


state 268

    (263) compound_stmt -> if_stmt .

    LESSLESS        reduce using rule 263 (compound_stmt -> if_stmt .)
    error           reduce using rule 263 (compound_stmt -> if_stmt .)
    PRAGMA          reduce using rule 263 (compound_stmt -> if_stmt .)
    NuLL            reduce using rule 263 (compound_stmt -> if_stmt .)
    EXIT            reduce using rule 263 (compound_stmt -> if_stmt .)
    RETURN          reduce using rule 263 (compound_stmt -> if_stmt .)
    GOTO            reduce using rule 263 (compound_stmt -> if_stmt .)
    DELAY           reduce using rule 263 (compound_stmt -> if_stmt .)
    ABORT           reduce using rule 263 (compound_stmt -> if_stmt .)
    RAISE           reduce using rule 263 (compound_stmt -> if_stmt .)
    REQUEUE         reduce using rule 263 (compound_stmt -> if_stmt .)
    IF              reduce using rule 263 (compound_stmt -> if_stmt .)
    CASE            reduce using rule 263 (compound_stmt -> if_stmt .)
    IDENTIFIER      reduce using rule 263 (compound_stmt -> if_stmt .)
    ACCEPT          reduce using rule 263 (compound_stmt -> if_stmt .)
    SELECT          reduce using rule 263 (compound_stmt -> if_stmt .)
    STRING          reduce using rule 263 (compound_stmt -> if_stmt .)
    WHILE           reduce using rule 263 (compound_stmt -> if_stmt .)
    DECLARE         reduce using rule 263 (compound_stmt -> if_stmt .)
    FOR             reduce using rule 263 (compound_stmt -> if_stmt .)
    LOOP            reduce using rule 263 (compound_stmt -> if_stmt .)
    BEGIN           reduce using rule 263 (compound_stmt -> if_stmt .)
    END             reduce using rule 263 (compound_stmt -> if_stmt .)
    WHEN            reduce using rule 263 (compound_stmt -> if_stmt .)
    ELSIF           reduce using rule 263 (compound_stmt -> if_stmt .)
    ELSE            reduce using rule 263 (compound_stmt -> if_stmt .)
    OR              reduce using rule 263 (compound_stmt -> if_stmt .)
    EXCEPTION       reduce using rule 263 (compound_stmt -> if_stmt .)
    THEN            reduce using rule 263 (compound_stmt -> if_stmt .)


state 269

    (271) assign_stmt -> name . ASSIGNMENT expression ;
    (335) procedure_call -> name . ;
    (241) qualified -> name . TICK parenthesized_primary
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id

    ASSIGNMENT      shift and go to state 423
    ;               shift and go to state 424
    TICK            shift and go to state 245
    (               shift and go to state 243
    .               shift and go to state 244


state 270

    (428) abort_stmt -> ABORT . name_s ;
    (351) name_s -> . name
    (352) name_s -> . name_s , name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name_s                         shift and go to state 425
    name                           shift and go to state 155
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 271

    (270) null_stmt -> NuLL . ;

    ;               shift and go to state 426


state 272

    (269) label -> LESSLESS . IDENTIFIER MOREMORE

    IDENTIFIER      shift and go to state 427


state 273

    (267) compound_stmt -> accept_stmt .

    LESSLESS        reduce using rule 267 (compound_stmt -> accept_stmt .)
    error           reduce using rule 267 (compound_stmt -> accept_stmt .)
    PRAGMA          reduce using rule 267 (compound_stmt -> accept_stmt .)
    NuLL            reduce using rule 267 (compound_stmt -> accept_stmt .)
    EXIT            reduce using rule 267 (compound_stmt -> accept_stmt .)
    RETURN          reduce using rule 267 (compound_stmt -> accept_stmt .)
    GOTO            reduce using rule 267 (compound_stmt -> accept_stmt .)
    DELAY           reduce using rule 267 (compound_stmt -> accept_stmt .)
    ABORT           reduce using rule 267 (compound_stmt -> accept_stmt .)
    RAISE           reduce using rule 267 (compound_stmt -> accept_stmt .)
    REQUEUE         reduce using rule 267 (compound_stmt -> accept_stmt .)
    IF              reduce using rule 267 (compound_stmt -> accept_stmt .)
    CASE            reduce using rule 267 (compound_stmt -> accept_stmt .)
    IDENTIFIER      reduce using rule 267 (compound_stmt -> accept_stmt .)
    ACCEPT          reduce using rule 267 (compound_stmt -> accept_stmt .)
    SELECT          reduce using rule 267 (compound_stmt -> accept_stmt .)
    STRING          reduce using rule 267 (compound_stmt -> accept_stmt .)
    WHILE           reduce using rule 267 (compound_stmt -> accept_stmt .)
    DECLARE         reduce using rule 267 (compound_stmt -> accept_stmt .)
    FOR             reduce using rule 267 (compound_stmt -> accept_stmt .)
    LOOP            reduce using rule 267 (compound_stmt -> accept_stmt .)
    BEGIN           reduce using rule 267 (compound_stmt -> accept_stmt .)
    END             reduce using rule 267 (compound_stmt -> accept_stmt .)
    WHEN            reduce using rule 267 (compound_stmt -> accept_stmt .)
    ELSIF           reduce using rule 267 (compound_stmt -> accept_stmt .)
    ELSE            reduce using rule 267 (compound_stmt -> accept_stmt .)
    OR              reduce using rule 267 (compound_stmt -> accept_stmt .)
    EXCEPTION       reduce using rule 267 (compound_stmt -> accept_stmt .)
    THEN            reduce using rule 267 (compound_stmt -> accept_stmt .)


state 274

    (310) return_stmt -> RETURN . ;
    (311) return_stmt -> RETURN . expression ;
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    ;               shift and go to state 428
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 429

state 275

    (404) accept_hdr -> ACCEPT . entry_name formal_part_opt
    (405) entry_name -> . simple_name
    (406) entry_name -> . entry_name ( expression )
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    entry_name                     shift and go to state 430
    simple_name                    shift and go to state 431

state 276

    (256) simple_stmt -> procedure_call .

    LESSLESS        reduce using rule 256 (simple_stmt -> procedure_call .)
    error           reduce using rule 256 (simple_stmt -> procedure_call .)
    PRAGMA          reduce using rule 256 (simple_stmt -> procedure_call .)
    NuLL            reduce using rule 256 (simple_stmt -> procedure_call .)
    EXIT            reduce using rule 256 (simple_stmt -> procedure_call .)
    RETURN          reduce using rule 256 (simple_stmt -> procedure_call .)
    GOTO            reduce using rule 256 (simple_stmt -> procedure_call .)
    DELAY           reduce using rule 256 (simple_stmt -> procedure_call .)
    ABORT           reduce using rule 256 (simple_stmt -> procedure_call .)
    RAISE           reduce using rule 256 (simple_stmt -> procedure_call .)
    REQUEUE         reduce using rule 256 (simple_stmt -> procedure_call .)
    IF              reduce using rule 256 (simple_stmt -> procedure_call .)
    CASE            reduce using rule 256 (simple_stmt -> procedure_call .)
    IDENTIFIER      reduce using rule 256 (simple_stmt -> procedure_call .)
    ACCEPT          reduce using rule 256 (simple_stmt -> procedure_call .)
    SELECT          reduce using rule 256 (simple_stmt -> procedure_call .)
    STRING          reduce using rule 256 (simple_stmt -> procedure_call .)
    WHILE           reduce using rule 256 (simple_stmt -> procedure_call .)
    DECLARE         reduce using rule 256 (simple_stmt -> procedure_call .)
    FOR             reduce using rule 256 (simple_stmt -> procedure_call .)
    LOOP            reduce using rule 256 (simple_stmt -> procedure_call .)
    BEGIN           reduce using rule 256 (simple_stmt -> procedure_call .)
    END             reduce using rule 256 (simple_stmt -> procedure_call .)
    WHEN            reduce using rule 256 (simple_stmt -> procedure_call .)
    THEN            reduce using rule 256 (simple_stmt -> procedure_call .)
    OR              reduce using rule 256 (simple_stmt -> procedure_call .)
    ELSE            reduce using rule 256 (simple_stmt -> procedure_call .)
    EXCEPTION       reduce using rule 256 (simple_stmt -> procedure_call .)
    ELSIF           reduce using rule 256 (simple_stmt -> procedure_call .)


state 277

    (413) select_wait -> SELECT . guarded_select_alt or_select else_opt END SELECT ;
    (423) async_select -> SELECT . delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (424) timed_entry_call -> SELECT . entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (425) cond_entry_call -> SELECT . entry_call stmts_opt ELSE statement_s END SELECT ;
    (414) guarded_select_alt -> . select_alt
    (415) guarded_select_alt -> . WHEN condition ARROW select_alt
    (421) delay_or_entry_alt -> . delay_stmt stmts_opt
    (422) delay_or_entry_alt -> . entry_call stmts_opt
    (401) entry_call -> . procedure_call
    (418) select_alt -> . accept_stmt stmts_opt
    (419) select_alt -> . delay_stmt stmts_opt
    (420) select_alt -> . TERMINATE ;
    (407) delay_stmt -> . DELAY expression ;
    (408) delay_stmt -> . DELAY UNTIL expression ;
    (335) procedure_call -> . name ;
    (402) accept_stmt -> . accept_hdr ;
    (403) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (404) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    WHEN            shift and go to state 436
    TERMINATE       shift and go to state 441
    DELAY           shift and go to state 260
    ACCEPT          shift and go to state 275
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    accept_stmt                    shift and go to state 432
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    entry_call                     shift and go to state 433
    delay_or_entry_alt             shift and go to state 435
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157
    guarded_select_alt             shift and go to state 437
    select_alt                     shift and go to state 438
    delay_stmt                     shift and go to state 439
    accept_hdr                     shift and go to state 292
    name                           shift and go to state 440
    operator_symbol                shift and go to state 138
    procedure_call                 shift and go to state 434

state 278

    (264) compound_stmt -> case_stmt .

    LESSLESS        reduce using rule 264 (compound_stmt -> case_stmt .)
    error           reduce using rule 264 (compound_stmt -> case_stmt .)
    PRAGMA          reduce using rule 264 (compound_stmt -> case_stmt .)
    NuLL            reduce using rule 264 (compound_stmt -> case_stmt .)
    EXIT            reduce using rule 264 (compound_stmt -> case_stmt .)
    RETURN          reduce using rule 264 (compound_stmt -> case_stmt .)
    GOTO            reduce using rule 264 (compound_stmt -> case_stmt .)
    DELAY           reduce using rule 264 (compound_stmt -> case_stmt .)
    ABORT           reduce using rule 264 (compound_stmt -> case_stmt .)
    RAISE           reduce using rule 264 (compound_stmt -> case_stmt .)
    REQUEUE         reduce using rule 264 (compound_stmt -> case_stmt .)
    IF              reduce using rule 264 (compound_stmt -> case_stmt .)
    CASE            reduce using rule 264 (compound_stmt -> case_stmt .)
    IDENTIFIER      reduce using rule 264 (compound_stmt -> case_stmt .)
    ACCEPT          reduce using rule 264 (compound_stmt -> case_stmt .)
    SELECT          reduce using rule 264 (compound_stmt -> case_stmt .)
    STRING          reduce using rule 264 (compound_stmt -> case_stmt .)
    WHILE           reduce using rule 264 (compound_stmt -> case_stmt .)
    DECLARE         reduce using rule 264 (compound_stmt -> case_stmt .)
    FOR             reduce using rule 264 (compound_stmt -> case_stmt .)
    LOOP            reduce using rule 264 (compound_stmt -> case_stmt .)
    BEGIN           reduce using rule 264 (compound_stmt -> case_stmt .)
    END             reduce using rule 264 (compound_stmt -> case_stmt .)
    WHEN            reduce using rule 264 (compound_stmt -> case_stmt .)
    ELSIF           reduce using rule 264 (compound_stmt -> case_stmt .)
    ELSE            reduce using rule 264 (compound_stmt -> case_stmt .)
    OR              reduce using rule 264 (compound_stmt -> case_stmt .)
    EXCEPTION       reduce using rule 264 (compound_stmt -> case_stmt .)
    THEN            reduce using rule 264 (compound_stmt -> case_stmt .)


state 279

    (247) statement -> label . statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (305) exit_stmt -> . EXIT name_opt when_opt ;
    (310) return_stmt -> . RETURN ;
    (311) return_stmt -> . RETURN expression ;
    (312) goto_stmt -> . GOTO name ;
    (335) procedure_call -> . name ;
    (407) delay_stmt -> . DELAY expression ;
    (408) delay_stmt -> . DELAY UNTIL expression ;
    (428) abort_stmt -> . ABORT name_s ;
    (467) raise_stmt -> . RAISE name_opt ;
    (513) code_stmt -> . qualified ;
    (468) requeue_stmt -> . REQUEUE name ;
    (469) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (281) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (286) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (298) block -> . label_opt block_decl block_body END id_opt ;
    (402) accept_stmt -> . accept_hdr ;
    (403) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (409) select_stmt -> . select_wait
    (410) select_stmt -> . async_select
    (411) select_stmt -> . timed_entry_call
    (412) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (282) case_hdr -> . CASE expression IS
    (287) label_opt -> .
    (288) label_opt -> . IDENTIFIER :
    (404) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (413) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (423) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (424) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (425) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 287 (label_opt -> .)
    DECLARE         reduce using rule 287 (label_opt -> .)
    FOR             reduce using rule 287 (label_opt -> .)
    LOOP            reduce using rule 287 (label_opt -> .)
    BEGIN           reduce using rule 287 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 139

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    accept_hdr                     shift and go to state 292
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 138
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 442
    attribute                      shift and go to state 121
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 280

    (249) unlabeled -> compound_stmt .

    EXCEPTION       reduce using rule 249 (unlabeled -> compound_stmt .)
    LESSLESS        reduce using rule 249 (unlabeled -> compound_stmt .)
    error           reduce using rule 249 (unlabeled -> compound_stmt .)
    PRAGMA          reduce using rule 249 (unlabeled -> compound_stmt .)
    NuLL            reduce using rule 249 (unlabeled -> compound_stmt .)
    EXIT            reduce using rule 249 (unlabeled -> compound_stmt .)
    RETURN          reduce using rule 249 (unlabeled -> compound_stmt .)
    GOTO            reduce using rule 249 (unlabeled -> compound_stmt .)
    DELAY           reduce using rule 249 (unlabeled -> compound_stmt .)
    ABORT           reduce using rule 249 (unlabeled -> compound_stmt .)
    RAISE           reduce using rule 249 (unlabeled -> compound_stmt .)
    REQUEUE         reduce using rule 249 (unlabeled -> compound_stmt .)
    IF              reduce using rule 249 (unlabeled -> compound_stmt .)
    CASE            reduce using rule 249 (unlabeled -> compound_stmt .)
    IDENTIFIER      reduce using rule 249 (unlabeled -> compound_stmt .)
    ACCEPT          reduce using rule 249 (unlabeled -> compound_stmt .)
    SELECT          reduce using rule 249 (unlabeled -> compound_stmt .)
    STRING          reduce using rule 249 (unlabeled -> compound_stmt .)
    WHILE           reduce using rule 249 (unlabeled -> compound_stmt .)
    DECLARE         reduce using rule 249 (unlabeled -> compound_stmt .)
    FOR             reduce using rule 249 (unlabeled -> compound_stmt .)
    LOOP            reduce using rule 249 (unlabeled -> compound_stmt .)
    BEGIN           reduce using rule 249 (unlabeled -> compound_stmt .)
    END             reduce using rule 249 (unlabeled -> compound_stmt .)
    OR              reduce using rule 249 (unlabeled -> compound_stmt .)
    ELSE            reduce using rule 249 (unlabeled -> compound_stmt .)
    THEN            reduce using rule 249 (unlabeled -> compound_stmt .)
    ELSIF           reduce using rule 249 (unlabeled -> compound_stmt .)
    WHEN            reduce using rule 249 (unlabeled -> compound_stmt .)


state 281

    (255) simple_stmt -> goto_stmt .

    LESSLESS        reduce using rule 255 (simple_stmt -> goto_stmt .)
    error           reduce using rule 255 (simple_stmt -> goto_stmt .)
    PRAGMA          reduce using rule 255 (simple_stmt -> goto_stmt .)
    NuLL            reduce using rule 255 (simple_stmt -> goto_stmt .)
    EXIT            reduce using rule 255 (simple_stmt -> goto_stmt .)
    RETURN          reduce using rule 255 (simple_stmt -> goto_stmt .)
    GOTO            reduce using rule 255 (simple_stmt -> goto_stmt .)
    DELAY           reduce using rule 255 (simple_stmt -> goto_stmt .)
    ABORT           reduce using rule 255 (simple_stmt -> goto_stmt .)
    RAISE           reduce using rule 255 (simple_stmt -> goto_stmt .)
    REQUEUE         reduce using rule 255 (simple_stmt -> goto_stmt .)
    IF              reduce using rule 255 (simple_stmt -> goto_stmt .)
    CASE            reduce using rule 255 (simple_stmt -> goto_stmt .)
    IDENTIFIER      reduce using rule 255 (simple_stmt -> goto_stmt .)
    ACCEPT          reduce using rule 255 (simple_stmt -> goto_stmt .)
    SELECT          reduce using rule 255 (simple_stmt -> goto_stmt .)
    STRING          reduce using rule 255 (simple_stmt -> goto_stmt .)
    WHILE           reduce using rule 255 (simple_stmt -> goto_stmt .)
    DECLARE         reduce using rule 255 (simple_stmt -> goto_stmt .)
    FOR             reduce using rule 255 (simple_stmt -> goto_stmt .)
    LOOP            reduce using rule 255 (simple_stmt -> goto_stmt .)
    BEGIN           reduce using rule 255 (simple_stmt -> goto_stmt .)
    END             reduce using rule 255 (simple_stmt -> goto_stmt .)
    WHEN            reduce using rule 255 (simple_stmt -> goto_stmt .)
    THEN            reduce using rule 255 (simple_stmt -> goto_stmt .)
    OR              reduce using rule 255 (simple_stmt -> goto_stmt .)
    ELSE            reduce using rule 255 (simple_stmt -> goto_stmt .)
    EXCEPTION       reduce using rule 255 (simple_stmt -> goto_stmt .)
    ELSIF           reduce using rule 255 (simple_stmt -> goto_stmt .)


state 282

    (281) case_stmt -> case_hdr . pragma_s alternative_s END CASE ;
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 443

state 283

    (266) compound_stmt -> block .

    LESSLESS        reduce using rule 266 (compound_stmt -> block .)
    error           reduce using rule 266 (compound_stmt -> block .)
    PRAGMA          reduce using rule 266 (compound_stmt -> block .)
    NuLL            reduce using rule 266 (compound_stmt -> block .)
    EXIT            reduce using rule 266 (compound_stmt -> block .)
    RETURN          reduce using rule 266 (compound_stmt -> block .)
    GOTO            reduce using rule 266 (compound_stmt -> block .)
    DELAY           reduce using rule 266 (compound_stmt -> block .)
    ABORT           reduce using rule 266 (compound_stmt -> block .)
    RAISE           reduce using rule 266 (compound_stmt -> block .)
    REQUEUE         reduce using rule 266 (compound_stmt -> block .)
    IF              reduce using rule 266 (compound_stmt -> block .)
    CASE            reduce using rule 266 (compound_stmt -> block .)
    IDENTIFIER      reduce using rule 266 (compound_stmt -> block .)
    ACCEPT          reduce using rule 266 (compound_stmt -> block .)
    SELECT          reduce using rule 266 (compound_stmt -> block .)
    STRING          reduce using rule 266 (compound_stmt -> block .)
    WHILE           reduce using rule 266 (compound_stmt -> block .)
    DECLARE         reduce using rule 266 (compound_stmt -> block .)
    FOR             reduce using rule 266 (compound_stmt -> block .)
    LOOP            reduce using rule 266 (compound_stmt -> block .)
    BEGIN           reduce using rule 266 (compound_stmt -> block .)
    END             reduce using rule 266 (compound_stmt -> block .)
    WHEN            reduce using rule 266 (compound_stmt -> block .)
    ELSIF           reduce using rule 266 (compound_stmt -> block .)
    ELSE            reduce using rule 266 (compound_stmt -> block .)
    OR              reduce using rule 266 (compound_stmt -> block .)
    EXCEPTION       reduce using rule 266 (compound_stmt -> block .)
    THEN            reduce using rule 266 (compound_stmt -> block .)


state 284

    (467) raise_stmt -> RAISE . name_opt ;
    (306) name_opt -> .
    (307) name_opt -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    ;               reduce using rule 306 (name_opt -> .)
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 444
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    name_opt                       shift and go to state 445
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 285

    (254) simple_stmt -> return_stmt .

    LESSLESS        reduce using rule 254 (simple_stmt -> return_stmt .)
    error           reduce using rule 254 (simple_stmt -> return_stmt .)
    PRAGMA          reduce using rule 254 (simple_stmt -> return_stmt .)
    NuLL            reduce using rule 254 (simple_stmt -> return_stmt .)
    EXIT            reduce using rule 254 (simple_stmt -> return_stmt .)
    RETURN          reduce using rule 254 (simple_stmt -> return_stmt .)
    GOTO            reduce using rule 254 (simple_stmt -> return_stmt .)
    DELAY           reduce using rule 254 (simple_stmt -> return_stmt .)
    ABORT           reduce using rule 254 (simple_stmt -> return_stmt .)
    RAISE           reduce using rule 254 (simple_stmt -> return_stmt .)
    REQUEUE         reduce using rule 254 (simple_stmt -> return_stmt .)
    IF              reduce using rule 254 (simple_stmt -> return_stmt .)
    CASE            reduce using rule 254 (simple_stmt -> return_stmt .)
    IDENTIFIER      reduce using rule 254 (simple_stmt -> return_stmt .)
    ACCEPT          reduce using rule 254 (simple_stmt -> return_stmt .)
    SELECT          reduce using rule 254 (simple_stmt -> return_stmt .)
    STRING          reduce using rule 254 (simple_stmt -> return_stmt .)
    WHILE           reduce using rule 254 (simple_stmt -> return_stmt .)
    DECLARE         reduce using rule 254 (simple_stmt -> return_stmt .)
    FOR             reduce using rule 254 (simple_stmt -> return_stmt .)
    LOOP            reduce using rule 254 (simple_stmt -> return_stmt .)
    BEGIN           reduce using rule 254 (simple_stmt -> return_stmt .)
    END             reduce using rule 254 (simple_stmt -> return_stmt .)
    WHEN            reduce using rule 254 (simple_stmt -> return_stmt .)
    THEN            reduce using rule 254 (simple_stmt -> return_stmt .)
    OR              reduce using rule 254 (simple_stmt -> return_stmt .)
    ELSE            reduce using rule 254 (simple_stmt -> return_stmt .)
    EXCEPTION       reduce using rule 254 (simple_stmt -> return_stmt .)
    ELSIF           reduce using rule 254 (simple_stmt -> return_stmt .)


state 286

    (301) block_body -> BEGIN handled_stmt_s .

    END             reduce using rule 301 (block_body -> BEGIN handled_stmt_s .)


state 287

    (282) case_hdr -> CASE . expression IS
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 446

state 288

    (468) requeue_stmt -> REQUEUE . name ;
    (469) requeue_stmt -> REQUEUE . name WITH ABORT ;
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 447
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 289

    (244) statement_s -> statement .

    END             reduce using rule 244 (statement_s -> statement .)
    LESSLESS        reduce using rule 244 (statement_s -> statement .)
    error           reduce using rule 244 (statement_s -> statement .)
    PRAGMA          reduce using rule 244 (statement_s -> statement .)
    NuLL            reduce using rule 244 (statement_s -> statement .)
    EXIT            reduce using rule 244 (statement_s -> statement .)
    RETURN          reduce using rule 244 (statement_s -> statement .)
    GOTO            reduce using rule 244 (statement_s -> statement .)
    DELAY           reduce using rule 244 (statement_s -> statement .)
    ABORT           reduce using rule 244 (statement_s -> statement .)
    RAISE           reduce using rule 244 (statement_s -> statement .)
    REQUEUE         reduce using rule 244 (statement_s -> statement .)
    IF              reduce using rule 244 (statement_s -> statement .)
    CASE            reduce using rule 244 (statement_s -> statement .)
    IDENTIFIER      reduce using rule 244 (statement_s -> statement .)
    ACCEPT          reduce using rule 244 (statement_s -> statement .)
    SELECT          reduce using rule 244 (statement_s -> statement .)
    STRING          reduce using rule 244 (statement_s -> statement .)
    WHILE           reduce using rule 244 (statement_s -> statement .)
    DECLARE         reduce using rule 244 (statement_s -> statement .)
    FOR             reduce using rule 244 (statement_s -> statement .)
    LOOP            reduce using rule 244 (statement_s -> statement .)
    BEGIN           reduce using rule 244 (statement_s -> statement .)
    ELSIF           reduce using rule 244 (statement_s -> statement .)
    ELSE            reduce using rule 244 (statement_s -> statement .)
    OR              reduce using rule 244 (statement_s -> statement .)
    EXCEPTION       reduce using rule 244 (statement_s -> statement .)
    THEN            reduce using rule 244 (statement_s -> statement .)
    WHEN            reduce using rule 244 (statement_s -> statement .)


state 290

    (288) label_opt -> IDENTIFIER . :
    (161) simple_name -> IDENTIFIER .

    :               shift and go to state 448
    ASSIGNMENT      reduce using rule 161 (simple_name -> IDENTIFIER .)
    ;               reduce using rule 161 (simple_name -> IDENTIFIER .)
    TICK            reduce using rule 161 (simple_name -> IDENTIFIER .)
    (               reduce using rule 161 (simple_name -> IDENTIFIER .)
    .               reduce using rule 161 (simple_name -> IDENTIFIER .)


state 291

    (257) simple_stmt -> delay_stmt .

    LESSLESS        reduce using rule 257 (simple_stmt -> delay_stmt .)
    error           reduce using rule 257 (simple_stmt -> delay_stmt .)
    PRAGMA          reduce using rule 257 (simple_stmt -> delay_stmt .)
    NuLL            reduce using rule 257 (simple_stmt -> delay_stmt .)
    EXIT            reduce using rule 257 (simple_stmt -> delay_stmt .)
    RETURN          reduce using rule 257 (simple_stmt -> delay_stmt .)
    GOTO            reduce using rule 257 (simple_stmt -> delay_stmt .)
    DELAY           reduce using rule 257 (simple_stmt -> delay_stmt .)
    ABORT           reduce using rule 257 (simple_stmt -> delay_stmt .)
    RAISE           reduce using rule 257 (simple_stmt -> delay_stmt .)
    REQUEUE         reduce using rule 257 (simple_stmt -> delay_stmt .)
    IF              reduce using rule 257 (simple_stmt -> delay_stmt .)
    CASE            reduce using rule 257 (simple_stmt -> delay_stmt .)
    IDENTIFIER      reduce using rule 257 (simple_stmt -> delay_stmt .)
    ACCEPT          reduce using rule 257 (simple_stmt -> delay_stmt .)
    SELECT          reduce using rule 257 (simple_stmt -> delay_stmt .)
    STRING          reduce using rule 257 (simple_stmt -> delay_stmt .)
    WHILE           reduce using rule 257 (simple_stmt -> delay_stmt .)
    DECLARE         reduce using rule 257 (simple_stmt -> delay_stmt .)
    FOR             reduce using rule 257 (simple_stmt -> delay_stmt .)
    LOOP            reduce using rule 257 (simple_stmt -> delay_stmt .)
    BEGIN           reduce using rule 257 (simple_stmt -> delay_stmt .)
    END             reduce using rule 257 (simple_stmt -> delay_stmt .)
    WHEN            reduce using rule 257 (simple_stmt -> delay_stmt .)
    THEN            reduce using rule 257 (simple_stmt -> delay_stmt .)
    OR              reduce using rule 257 (simple_stmt -> delay_stmt .)
    ELSE            reduce using rule 257 (simple_stmt -> delay_stmt .)
    EXCEPTION       reduce using rule 257 (simple_stmt -> delay_stmt .)
    ELSIF           reduce using rule 257 (simple_stmt -> delay_stmt .)


state 292

    (402) accept_stmt -> accept_hdr . ;
    (403) accept_stmt -> accept_hdr . DO handled_stmt_s END id_opt ;

    ;               shift and go to state 450
    DO              shift and go to state 449


state 293

    (250) unlabeled -> pragma .

    EXCEPTION       reduce using rule 250 (unlabeled -> pragma .)
    LESSLESS        reduce using rule 250 (unlabeled -> pragma .)
    error           reduce using rule 250 (unlabeled -> pragma .)
    PRAGMA          reduce using rule 250 (unlabeled -> pragma .)
    NuLL            reduce using rule 250 (unlabeled -> pragma .)
    EXIT            reduce using rule 250 (unlabeled -> pragma .)
    RETURN          reduce using rule 250 (unlabeled -> pragma .)
    GOTO            reduce using rule 250 (unlabeled -> pragma .)
    DELAY           reduce using rule 250 (unlabeled -> pragma .)
    ABORT           reduce using rule 250 (unlabeled -> pragma .)
    RAISE           reduce using rule 250 (unlabeled -> pragma .)
    REQUEUE         reduce using rule 250 (unlabeled -> pragma .)
    IF              reduce using rule 250 (unlabeled -> pragma .)
    CASE            reduce using rule 250 (unlabeled -> pragma .)
    IDENTIFIER      reduce using rule 250 (unlabeled -> pragma .)
    ACCEPT          reduce using rule 250 (unlabeled -> pragma .)
    SELECT          reduce using rule 250 (unlabeled -> pragma .)
    STRING          reduce using rule 250 (unlabeled -> pragma .)
    WHILE           reduce using rule 250 (unlabeled -> pragma .)
    DECLARE         reduce using rule 250 (unlabeled -> pragma .)
    FOR             reduce using rule 250 (unlabeled -> pragma .)
    LOOP            reduce using rule 250 (unlabeled -> pragma .)
    BEGIN           reduce using rule 250 (unlabeled -> pragma .)
    END             reduce using rule 250 (unlabeled -> pragma .)
    OR              reduce using rule 250 (unlabeled -> pragma .)
    ELSE            reduce using rule 250 (unlabeled -> pragma .)
    THEN            reduce using rule 250 (unlabeled -> pragma .)
    ELSIF           reduce using rule 250 (unlabeled -> pragma .)
    WHEN            reduce using rule 250 (unlabeled -> pragma .)


state 294

    (261) simple_stmt -> requeue_stmt .

    LESSLESS        reduce using rule 261 (simple_stmt -> requeue_stmt .)
    error           reduce using rule 261 (simple_stmt -> requeue_stmt .)
    PRAGMA          reduce using rule 261 (simple_stmt -> requeue_stmt .)
    NuLL            reduce using rule 261 (simple_stmt -> requeue_stmt .)
    EXIT            reduce using rule 261 (simple_stmt -> requeue_stmt .)
    RETURN          reduce using rule 261 (simple_stmt -> requeue_stmt .)
    GOTO            reduce using rule 261 (simple_stmt -> requeue_stmt .)
    DELAY           reduce using rule 261 (simple_stmt -> requeue_stmt .)
    ABORT           reduce using rule 261 (simple_stmt -> requeue_stmt .)
    RAISE           reduce using rule 261 (simple_stmt -> requeue_stmt .)
    REQUEUE         reduce using rule 261 (simple_stmt -> requeue_stmt .)
    IF              reduce using rule 261 (simple_stmt -> requeue_stmt .)
    CASE            reduce using rule 261 (simple_stmt -> requeue_stmt .)
    IDENTIFIER      reduce using rule 261 (simple_stmt -> requeue_stmt .)
    ACCEPT          reduce using rule 261 (simple_stmt -> requeue_stmt .)
    SELECT          reduce using rule 261 (simple_stmt -> requeue_stmt .)
    STRING          reduce using rule 261 (simple_stmt -> requeue_stmt .)
    WHILE           reduce using rule 261 (simple_stmt -> requeue_stmt .)
    DECLARE         reduce using rule 261 (simple_stmt -> requeue_stmt .)
    FOR             reduce using rule 261 (simple_stmt -> requeue_stmt .)
    LOOP            reduce using rule 261 (simple_stmt -> requeue_stmt .)
    BEGIN           reduce using rule 261 (simple_stmt -> requeue_stmt .)
    END             reduce using rule 261 (simple_stmt -> requeue_stmt .)
    WHEN            reduce using rule 261 (simple_stmt -> requeue_stmt .)
    THEN            reduce using rule 261 (simple_stmt -> requeue_stmt .)
    OR              reduce using rule 261 (simple_stmt -> requeue_stmt .)
    ELSE            reduce using rule 261 (simple_stmt -> requeue_stmt .)
    EXCEPTION       reduce using rule 261 (simple_stmt -> requeue_stmt .)
    ELSIF           reduce using rule 261 (simple_stmt -> requeue_stmt .)


state 295

    (259) simple_stmt -> raise_stmt .

    LESSLESS        reduce using rule 259 (simple_stmt -> raise_stmt .)
    error           reduce using rule 259 (simple_stmt -> raise_stmt .)
    PRAGMA          reduce using rule 259 (simple_stmt -> raise_stmt .)
    NuLL            reduce using rule 259 (simple_stmt -> raise_stmt .)
    EXIT            reduce using rule 259 (simple_stmt -> raise_stmt .)
    RETURN          reduce using rule 259 (simple_stmt -> raise_stmt .)
    GOTO            reduce using rule 259 (simple_stmt -> raise_stmt .)
    DELAY           reduce using rule 259 (simple_stmt -> raise_stmt .)
    ABORT           reduce using rule 259 (simple_stmt -> raise_stmt .)
    RAISE           reduce using rule 259 (simple_stmt -> raise_stmt .)
    REQUEUE         reduce using rule 259 (simple_stmt -> raise_stmt .)
    IF              reduce using rule 259 (simple_stmt -> raise_stmt .)
    CASE            reduce using rule 259 (simple_stmt -> raise_stmt .)
    IDENTIFIER      reduce using rule 259 (simple_stmt -> raise_stmt .)
    ACCEPT          reduce using rule 259 (simple_stmt -> raise_stmt .)
    SELECT          reduce using rule 259 (simple_stmt -> raise_stmt .)
    STRING          reduce using rule 259 (simple_stmt -> raise_stmt .)
    WHILE           reduce using rule 259 (simple_stmt -> raise_stmt .)
    DECLARE         reduce using rule 259 (simple_stmt -> raise_stmt .)
    FOR             reduce using rule 259 (simple_stmt -> raise_stmt .)
    LOOP            reduce using rule 259 (simple_stmt -> raise_stmt .)
    BEGIN           reduce using rule 259 (simple_stmt -> raise_stmt .)
    END             reduce using rule 259 (simple_stmt -> raise_stmt .)
    WHEN            reduce using rule 259 (simple_stmt -> raise_stmt .)
    THEN            reduce using rule 259 (simple_stmt -> raise_stmt .)
    OR              reduce using rule 259 (simple_stmt -> raise_stmt .)
    ELSE            reduce using rule 259 (simple_stmt -> raise_stmt .)
    EXCEPTION       reduce using rule 259 (simple_stmt -> raise_stmt .)
    ELSIF           reduce using rule 259 (simple_stmt -> raise_stmt .)


state 296

    (411) select_stmt -> timed_entry_call .

    LESSLESS        reduce using rule 411 (select_stmt -> timed_entry_call .)
    error           reduce using rule 411 (select_stmt -> timed_entry_call .)
    PRAGMA          reduce using rule 411 (select_stmt -> timed_entry_call .)
    NuLL            reduce using rule 411 (select_stmt -> timed_entry_call .)
    EXIT            reduce using rule 411 (select_stmt -> timed_entry_call .)
    RETURN          reduce using rule 411 (select_stmt -> timed_entry_call .)
    GOTO            reduce using rule 411 (select_stmt -> timed_entry_call .)
    DELAY           reduce using rule 411 (select_stmt -> timed_entry_call .)
    ABORT           reduce using rule 411 (select_stmt -> timed_entry_call .)
    RAISE           reduce using rule 411 (select_stmt -> timed_entry_call .)
    REQUEUE         reduce using rule 411 (select_stmt -> timed_entry_call .)
    IF              reduce using rule 411 (select_stmt -> timed_entry_call .)
    CASE            reduce using rule 411 (select_stmt -> timed_entry_call .)
    IDENTIFIER      reduce using rule 411 (select_stmt -> timed_entry_call .)
    ACCEPT          reduce using rule 411 (select_stmt -> timed_entry_call .)
    SELECT          reduce using rule 411 (select_stmt -> timed_entry_call .)
    STRING          reduce using rule 411 (select_stmt -> timed_entry_call .)
    WHILE           reduce using rule 411 (select_stmt -> timed_entry_call .)
    DECLARE         reduce using rule 411 (select_stmt -> timed_entry_call .)
    FOR             reduce using rule 411 (select_stmt -> timed_entry_call .)
    LOOP            reduce using rule 411 (select_stmt -> timed_entry_call .)
    BEGIN           reduce using rule 411 (select_stmt -> timed_entry_call .)
    END             reduce using rule 411 (select_stmt -> timed_entry_call .)
    EXCEPTION       reduce using rule 411 (select_stmt -> timed_entry_call .)
    OR              reduce using rule 411 (select_stmt -> timed_entry_call .)
    ELSE            reduce using rule 411 (select_stmt -> timed_entry_call .)
    THEN            reduce using rule 411 (select_stmt -> timed_entry_call .)
    ELSIF           reduce using rule 411 (select_stmt -> timed_entry_call .)
    WHEN            reduce using rule 411 (select_stmt -> timed_entry_call .)


state 297

    (305) exit_stmt -> EXIT . name_opt when_opt ;
    (306) name_opt -> .
    (307) name_opt -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    WHEN            reduce using rule 306 (name_opt -> .)
    ;               reduce using rule 306 (name_opt -> .)
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 444
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    name_opt                       shift and go to state 451
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 298

    (262) simple_stmt -> error . ;

    ;               shift and go to state 452


state 299

    (258) simple_stmt -> abort_stmt .

    LESSLESS        reduce using rule 258 (simple_stmt -> abort_stmt .)
    error           reduce using rule 258 (simple_stmt -> abort_stmt .)
    PRAGMA          reduce using rule 258 (simple_stmt -> abort_stmt .)
    NuLL            reduce using rule 258 (simple_stmt -> abort_stmt .)
    EXIT            reduce using rule 258 (simple_stmt -> abort_stmt .)
    RETURN          reduce using rule 258 (simple_stmt -> abort_stmt .)
    GOTO            reduce using rule 258 (simple_stmt -> abort_stmt .)
    DELAY           reduce using rule 258 (simple_stmt -> abort_stmt .)
    ABORT           reduce using rule 258 (simple_stmt -> abort_stmt .)
    RAISE           reduce using rule 258 (simple_stmt -> abort_stmt .)
    REQUEUE         reduce using rule 258 (simple_stmt -> abort_stmt .)
    IF              reduce using rule 258 (simple_stmt -> abort_stmt .)
    CASE            reduce using rule 258 (simple_stmt -> abort_stmt .)
    IDENTIFIER      reduce using rule 258 (simple_stmt -> abort_stmt .)
    ACCEPT          reduce using rule 258 (simple_stmt -> abort_stmt .)
    SELECT          reduce using rule 258 (simple_stmt -> abort_stmt .)
    STRING          reduce using rule 258 (simple_stmt -> abort_stmt .)
    WHILE           reduce using rule 258 (simple_stmt -> abort_stmt .)
    DECLARE         reduce using rule 258 (simple_stmt -> abort_stmt .)
    FOR             reduce using rule 258 (simple_stmt -> abort_stmt .)
    LOOP            reduce using rule 258 (simple_stmt -> abort_stmt .)
    BEGIN           reduce using rule 258 (simple_stmt -> abort_stmt .)
    END             reduce using rule 258 (simple_stmt -> abort_stmt .)
    WHEN            reduce using rule 258 (simple_stmt -> abort_stmt .)
    THEN            reduce using rule 258 (simple_stmt -> abort_stmt .)
    OR              reduce using rule 258 (simple_stmt -> abort_stmt .)
    ELSE            reduce using rule 258 (simple_stmt -> abort_stmt .)
    EXCEPTION       reduce using rule 258 (simple_stmt -> abort_stmt .)
    ELSIF           reduce using rule 258 (simple_stmt -> abort_stmt .)


state 300

    (302) handled_stmt_s -> statement_s . except_handler_part_opt
    (245) statement_s -> statement_s . m statement
    (303) except_handler_part_opt -> .
    (304) except_handler_part_opt -> . except_handler_part
    (197) m -> .
    (459) except_handler_part -> . EXCEPTION exception_handler
    (460) except_handler_part -> . except_handler_part exception_handler

    END             reduce using rule 303 (except_handler_part_opt -> .)
    LESSLESS        reduce using rule 197 (m -> .)
    error           reduce using rule 197 (m -> .)
    PRAGMA          reduce using rule 197 (m -> .)
    NuLL            reduce using rule 197 (m -> .)
    EXIT            reduce using rule 197 (m -> .)
    RETURN          reduce using rule 197 (m -> .)
    GOTO            reduce using rule 197 (m -> .)
    DELAY           reduce using rule 197 (m -> .)
    ABORT           reduce using rule 197 (m -> .)
    RAISE           reduce using rule 197 (m -> .)
    REQUEUE         reduce using rule 197 (m -> .)
    IF              reduce using rule 197 (m -> .)
    CASE            reduce using rule 197 (m -> .)
    IDENTIFIER      reduce using rule 197 (m -> .)
    ACCEPT          reduce using rule 197 (m -> .)
    SELECT          reduce using rule 197 (m -> .)
    STRING          reduce using rule 197 (m -> .)
    WHILE           reduce using rule 197 (m -> .)
    DECLARE         reduce using rule 197 (m -> .)
    FOR             reduce using rule 197 (m -> .)
    LOOP            reduce using rule 197 (m -> .)
    BEGIN           reduce using rule 197 (m -> .)
    EXCEPTION       shift and go to state 453

    m                              shift and go to state 454
    except_handler_part            shift and go to state 455
    except_handler_part_opt        shift and go to state 456

state 301

    (260) simple_stmt -> code_stmt .

    LESSLESS        reduce using rule 260 (simple_stmt -> code_stmt .)
    error           reduce using rule 260 (simple_stmt -> code_stmt .)
    PRAGMA          reduce using rule 260 (simple_stmt -> code_stmt .)
    NuLL            reduce using rule 260 (simple_stmt -> code_stmt .)
    EXIT            reduce using rule 260 (simple_stmt -> code_stmt .)
    RETURN          reduce using rule 260 (simple_stmt -> code_stmt .)
    GOTO            reduce using rule 260 (simple_stmt -> code_stmt .)
    DELAY           reduce using rule 260 (simple_stmt -> code_stmt .)
    ABORT           reduce using rule 260 (simple_stmt -> code_stmt .)
    RAISE           reduce using rule 260 (simple_stmt -> code_stmt .)
    REQUEUE         reduce using rule 260 (simple_stmt -> code_stmt .)
    IF              reduce using rule 260 (simple_stmt -> code_stmt .)
    CASE            reduce using rule 260 (simple_stmt -> code_stmt .)
    IDENTIFIER      reduce using rule 260 (simple_stmt -> code_stmt .)
    ACCEPT          reduce using rule 260 (simple_stmt -> code_stmt .)
    SELECT          reduce using rule 260 (simple_stmt -> code_stmt .)
    STRING          reduce using rule 260 (simple_stmt -> code_stmt .)
    WHILE           reduce using rule 260 (simple_stmt -> code_stmt .)
    DECLARE         reduce using rule 260 (simple_stmt -> code_stmt .)
    FOR             reduce using rule 260 (simple_stmt -> code_stmt .)
    LOOP            reduce using rule 260 (simple_stmt -> code_stmt .)
    BEGIN           reduce using rule 260 (simple_stmt -> code_stmt .)
    END             reduce using rule 260 (simple_stmt -> code_stmt .)
    WHEN            reduce using rule 260 (simple_stmt -> code_stmt .)
    THEN            reduce using rule 260 (simple_stmt -> code_stmt .)
    OR              reduce using rule 260 (simple_stmt -> code_stmt .)
    ELSE            reduce using rule 260 (simple_stmt -> code_stmt .)
    EXCEPTION       reduce using rule 260 (simple_stmt -> code_stmt .)
    ELSIF           reduce using rule 260 (simple_stmt -> code_stmt .)


state 302

    (246) statement -> unlabeled .

    LESSLESS        reduce using rule 246 (statement -> unlabeled .)
    error           reduce using rule 246 (statement -> unlabeled .)
    PRAGMA          reduce using rule 246 (statement -> unlabeled .)
    NuLL            reduce using rule 246 (statement -> unlabeled .)
    EXIT            reduce using rule 246 (statement -> unlabeled .)
    RETURN          reduce using rule 246 (statement -> unlabeled .)
    GOTO            reduce using rule 246 (statement -> unlabeled .)
    DELAY           reduce using rule 246 (statement -> unlabeled .)
    ABORT           reduce using rule 246 (statement -> unlabeled .)
    RAISE           reduce using rule 246 (statement -> unlabeled .)
    REQUEUE         reduce using rule 246 (statement -> unlabeled .)
    IF              reduce using rule 246 (statement -> unlabeled .)
    CASE            reduce using rule 246 (statement -> unlabeled .)
    IDENTIFIER      reduce using rule 246 (statement -> unlabeled .)
    ACCEPT          reduce using rule 246 (statement -> unlabeled .)
    SELECT          reduce using rule 246 (statement -> unlabeled .)
    STRING          reduce using rule 246 (statement -> unlabeled .)
    WHILE           reduce using rule 246 (statement -> unlabeled .)
    DECLARE         reduce using rule 246 (statement -> unlabeled .)
    FOR             reduce using rule 246 (statement -> unlabeled .)
    LOOP            reduce using rule 246 (statement -> unlabeled .)
    BEGIN           reduce using rule 246 (statement -> unlabeled .)
    END             reduce using rule 246 (statement -> unlabeled .)
    WHEN            reduce using rule 246 (statement -> unlabeled .)
    ELSIF           reduce using rule 246 (statement -> unlabeled .)
    ELSE            reduce using rule 246 (statement -> unlabeled .)
    OR              reduce using rule 246 (statement -> unlabeled .)
    EXCEPTION       reduce using rule 246 (statement -> unlabeled .)
    THEN            reduce using rule 246 (statement -> unlabeled .)


state 303

    (253) simple_stmt -> exit_stmt .

    LESSLESS        reduce using rule 253 (simple_stmt -> exit_stmt .)
    error           reduce using rule 253 (simple_stmt -> exit_stmt .)
    PRAGMA          reduce using rule 253 (simple_stmt -> exit_stmt .)
    NuLL            reduce using rule 253 (simple_stmt -> exit_stmt .)
    EXIT            reduce using rule 253 (simple_stmt -> exit_stmt .)
    RETURN          reduce using rule 253 (simple_stmt -> exit_stmt .)
    GOTO            reduce using rule 253 (simple_stmt -> exit_stmt .)
    DELAY           reduce using rule 253 (simple_stmt -> exit_stmt .)
    ABORT           reduce using rule 253 (simple_stmt -> exit_stmt .)
    RAISE           reduce using rule 253 (simple_stmt -> exit_stmt .)
    REQUEUE         reduce using rule 253 (simple_stmt -> exit_stmt .)
    IF              reduce using rule 253 (simple_stmt -> exit_stmt .)
    CASE            reduce using rule 253 (simple_stmt -> exit_stmt .)
    IDENTIFIER      reduce using rule 253 (simple_stmt -> exit_stmt .)
    ACCEPT          reduce using rule 253 (simple_stmt -> exit_stmt .)
    SELECT          reduce using rule 253 (simple_stmt -> exit_stmt .)
    STRING          reduce using rule 253 (simple_stmt -> exit_stmt .)
    WHILE           reduce using rule 253 (simple_stmt -> exit_stmt .)
    DECLARE         reduce using rule 253 (simple_stmt -> exit_stmt .)
    FOR             reduce using rule 253 (simple_stmt -> exit_stmt .)
    LOOP            reduce using rule 253 (simple_stmt -> exit_stmt .)
    BEGIN           reduce using rule 253 (simple_stmt -> exit_stmt .)
    END             reduce using rule 253 (simple_stmt -> exit_stmt .)
    WHEN            reduce using rule 253 (simple_stmt -> exit_stmt .)
    THEN            reduce using rule 253 (simple_stmt -> exit_stmt .)
    OR              reduce using rule 253 (simple_stmt -> exit_stmt .)
    ELSE            reduce using rule 253 (simple_stmt -> exit_stmt .)
    EXCEPTION       reduce using rule 253 (simple_stmt -> exit_stmt .)
    ELSIF           reduce using rule 253 (simple_stmt -> exit_stmt .)


state 304

    (409) select_stmt -> select_wait .

    LESSLESS        reduce using rule 409 (select_stmt -> select_wait .)
    error           reduce using rule 409 (select_stmt -> select_wait .)
    PRAGMA          reduce using rule 409 (select_stmt -> select_wait .)
    NuLL            reduce using rule 409 (select_stmt -> select_wait .)
    EXIT            reduce using rule 409 (select_stmt -> select_wait .)
    RETURN          reduce using rule 409 (select_stmt -> select_wait .)
    GOTO            reduce using rule 409 (select_stmt -> select_wait .)
    DELAY           reduce using rule 409 (select_stmt -> select_wait .)
    ABORT           reduce using rule 409 (select_stmt -> select_wait .)
    RAISE           reduce using rule 409 (select_stmt -> select_wait .)
    REQUEUE         reduce using rule 409 (select_stmt -> select_wait .)
    IF              reduce using rule 409 (select_stmt -> select_wait .)
    CASE            reduce using rule 409 (select_stmt -> select_wait .)
    IDENTIFIER      reduce using rule 409 (select_stmt -> select_wait .)
    ACCEPT          reduce using rule 409 (select_stmt -> select_wait .)
    SELECT          reduce using rule 409 (select_stmt -> select_wait .)
    STRING          reduce using rule 409 (select_stmt -> select_wait .)
    WHILE           reduce using rule 409 (select_stmt -> select_wait .)
    DECLARE         reduce using rule 409 (select_stmt -> select_wait .)
    FOR             reduce using rule 409 (select_stmt -> select_wait .)
    LOOP            reduce using rule 409 (select_stmt -> select_wait .)
    BEGIN           reduce using rule 409 (select_stmt -> select_wait .)
    END             reduce using rule 409 (select_stmt -> select_wait .)
    EXCEPTION       reduce using rule 409 (select_stmt -> select_wait .)
    OR              reduce using rule 409 (select_stmt -> select_wait .)
    ELSE            reduce using rule 409 (select_stmt -> select_wait .)
    THEN            reduce using rule 409 (select_stmt -> select_wait .)
    ELSIF           reduce using rule 409 (select_stmt -> select_wait .)
    WHEN            reduce using rule 409 (select_stmt -> select_wait .)


state 305

    (272) if_stmt -> IF . cond_clause_s else_opt END IF ;
    (273) cond_clause_s -> . cond_clause
    (274) cond_clause_s -> . cond_clause ELSIF m cond_clause_s
    (276) cond_clause -> . cond_part m statement_s n
    (277) cond_part -> . condition THEN
    (278) condition -> . expression
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    cond_clause_s                  shift and go to state 457
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    simple_name                    shift and go to state 157
    indexed_comp                   shift and go to state 129
    cond_clause                    shift and go to state 458
    cond_part                      shift and go to state 459
    literal                        shift and go to state 135
    allocator                      shift and go to state 130
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    condition                      shift and go to state 460
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 461

state 306

    (412) select_stmt -> cond_entry_call .

    LESSLESS        reduce using rule 412 (select_stmt -> cond_entry_call .)
    error           reduce using rule 412 (select_stmt -> cond_entry_call .)
    PRAGMA          reduce using rule 412 (select_stmt -> cond_entry_call .)
    NuLL            reduce using rule 412 (select_stmt -> cond_entry_call .)
    EXIT            reduce using rule 412 (select_stmt -> cond_entry_call .)
    RETURN          reduce using rule 412 (select_stmt -> cond_entry_call .)
    GOTO            reduce using rule 412 (select_stmt -> cond_entry_call .)
    DELAY           reduce using rule 412 (select_stmt -> cond_entry_call .)
    ABORT           reduce using rule 412 (select_stmt -> cond_entry_call .)
    RAISE           reduce using rule 412 (select_stmt -> cond_entry_call .)
    REQUEUE         reduce using rule 412 (select_stmt -> cond_entry_call .)
    IF              reduce using rule 412 (select_stmt -> cond_entry_call .)
    CASE            reduce using rule 412 (select_stmt -> cond_entry_call .)
    IDENTIFIER      reduce using rule 412 (select_stmt -> cond_entry_call .)
    ACCEPT          reduce using rule 412 (select_stmt -> cond_entry_call .)
    SELECT          reduce using rule 412 (select_stmt -> cond_entry_call .)
    STRING          reduce using rule 412 (select_stmt -> cond_entry_call .)
    WHILE           reduce using rule 412 (select_stmt -> cond_entry_call .)
    DECLARE         reduce using rule 412 (select_stmt -> cond_entry_call .)
    FOR             reduce using rule 412 (select_stmt -> cond_entry_call .)
    LOOP            reduce using rule 412 (select_stmt -> cond_entry_call .)
    BEGIN           reduce using rule 412 (select_stmt -> cond_entry_call .)
    END             reduce using rule 412 (select_stmt -> cond_entry_call .)
    EXCEPTION       reduce using rule 412 (select_stmt -> cond_entry_call .)
    OR              reduce using rule 412 (select_stmt -> cond_entry_call .)
    ELSE            reduce using rule 412 (select_stmt -> cond_entry_call .)
    THEN            reduce using rule 412 (select_stmt -> cond_entry_call .)
    ELSIF           reduce using rule 412 (select_stmt -> cond_entry_call .)
    WHEN            reduce using rule 412 (select_stmt -> cond_entry_call .)


state 307

    (251) simple_stmt -> null_stmt .

    LESSLESS        reduce using rule 251 (simple_stmt -> null_stmt .)
    error           reduce using rule 251 (simple_stmt -> null_stmt .)
    PRAGMA          reduce using rule 251 (simple_stmt -> null_stmt .)
    NuLL            reduce using rule 251 (simple_stmt -> null_stmt .)
    EXIT            reduce using rule 251 (simple_stmt -> null_stmt .)
    RETURN          reduce using rule 251 (simple_stmt -> null_stmt .)
    GOTO            reduce using rule 251 (simple_stmt -> null_stmt .)
    DELAY           reduce using rule 251 (simple_stmt -> null_stmt .)
    ABORT           reduce using rule 251 (simple_stmt -> null_stmt .)
    RAISE           reduce using rule 251 (simple_stmt -> null_stmt .)
    REQUEUE         reduce using rule 251 (simple_stmt -> null_stmt .)
    IF              reduce using rule 251 (simple_stmt -> null_stmt .)
    CASE            reduce using rule 251 (simple_stmt -> null_stmt .)
    IDENTIFIER      reduce using rule 251 (simple_stmt -> null_stmt .)
    ACCEPT          reduce using rule 251 (simple_stmt -> null_stmt .)
    SELECT          reduce using rule 251 (simple_stmt -> null_stmt .)
    STRING          reduce using rule 251 (simple_stmt -> null_stmt .)
    WHILE           reduce using rule 251 (simple_stmt -> null_stmt .)
    DECLARE         reduce using rule 251 (simple_stmt -> null_stmt .)
    FOR             reduce using rule 251 (simple_stmt -> null_stmt .)
    LOOP            reduce using rule 251 (simple_stmt -> null_stmt .)
    BEGIN           reduce using rule 251 (simple_stmt -> null_stmt .)
    END             reduce using rule 251 (simple_stmt -> null_stmt .)
    WHEN            reduce using rule 251 (simple_stmt -> null_stmt .)
    THEN            reduce using rule 251 (simple_stmt -> null_stmt .)
    OR              reduce using rule 251 (simple_stmt -> null_stmt .)
    ELSE            reduce using rule 251 (simple_stmt -> null_stmt .)
    EXCEPTION       reduce using rule 251 (simple_stmt -> null_stmt .)
    ELSIF           reduce using rule 251 (simple_stmt -> null_stmt .)


state 308

    (252) simple_stmt -> assign_stmt .

    LESSLESS        reduce using rule 252 (simple_stmt -> assign_stmt .)
    error           reduce using rule 252 (simple_stmt -> assign_stmt .)
    PRAGMA          reduce using rule 252 (simple_stmt -> assign_stmt .)
    NuLL            reduce using rule 252 (simple_stmt -> assign_stmt .)
    EXIT            reduce using rule 252 (simple_stmt -> assign_stmt .)
    RETURN          reduce using rule 252 (simple_stmt -> assign_stmt .)
    GOTO            reduce using rule 252 (simple_stmt -> assign_stmt .)
    DELAY           reduce using rule 252 (simple_stmt -> assign_stmt .)
    ABORT           reduce using rule 252 (simple_stmt -> assign_stmt .)
    RAISE           reduce using rule 252 (simple_stmt -> assign_stmt .)
    REQUEUE         reduce using rule 252 (simple_stmt -> assign_stmt .)
    IF              reduce using rule 252 (simple_stmt -> assign_stmt .)
    CASE            reduce using rule 252 (simple_stmt -> assign_stmt .)
    IDENTIFIER      reduce using rule 252 (simple_stmt -> assign_stmt .)
    ACCEPT          reduce using rule 252 (simple_stmt -> assign_stmt .)
    SELECT          reduce using rule 252 (simple_stmt -> assign_stmt .)
    STRING          reduce using rule 252 (simple_stmt -> assign_stmt .)
    WHILE           reduce using rule 252 (simple_stmt -> assign_stmt .)
    DECLARE         reduce using rule 252 (simple_stmt -> assign_stmt .)
    FOR             reduce using rule 252 (simple_stmt -> assign_stmt .)
    LOOP            reduce using rule 252 (simple_stmt -> assign_stmt .)
    BEGIN           reduce using rule 252 (simple_stmt -> assign_stmt .)
    END             reduce using rule 252 (simple_stmt -> assign_stmt .)
    WHEN            reduce using rule 252 (simple_stmt -> assign_stmt .)
    THEN            reduce using rule 252 (simple_stmt -> assign_stmt .)
    OR              reduce using rule 252 (simple_stmt -> assign_stmt .)
    ELSE            reduce using rule 252 (simple_stmt -> assign_stmt .)
    EXCEPTION       reduce using rule 252 (simple_stmt -> assign_stmt .)
    ELSIF           reduce using rule 252 (simple_stmt -> assign_stmt .)


state 309

    (334) subprog_body -> subprog_spec_is_push decl_part block_body END . id_opt ;
    (296) id_opt -> .
    (297) id_opt -> . designator
    (319) designator -> . compound_name
    (320) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 296 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 462
    id_opt                         shift and go to state 463
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 310

    (506) attrib_def -> FOR mark USE . expression ;
    (507) record_type_spec -> FOR mark USE . RECORD align_opt comp_loc_s END RECORD ;
    (512) address_spec -> FOR mark USE . AT expression ;
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    RECORD          shift and go to state 464
    AT              shift and go to state 465
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 466

state 311

    (160) mark -> mark . . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 467

state 312

    (159) mark -> mark TICK . attribute_id
    (179) attribute_id -> . IDENTIFIER
    (180) attribute_id -> . DIGITS
    (181) attribute_id -> . DELTA
    (182) attribute_id -> . ACCESS

    IDENTIFIER      shift and go to state 389
    DIGITS          shift and go to state 388
    DELTA           shift and go to state 392
    ACCESS          shift and go to state 390

    attribute_id                   shift and go to state 468

state 313

    (368) task_body -> TASK BODY simple_name . IS decl_part block_body END id_opt ;
    (454) body_stub -> TASK BODY simple_name . IS SEPARATE ;

    IS              shift and go to state 469


state 314

    (363) task_spec -> TASK TYPE simple_name . discrim_part_opt task_def
    (37) discrim_part_opt -> .
    (38) discrim_part_opt -> . discrim_part
    (39) discrim_part_opt -> . ( LESSMORE )
    (110) discrim_part -> . ( discrim_spec_s )

    IS              reduce using rule 37 (discrim_part_opt -> .)
    ;               reduce using rule 37 (discrim_part_opt -> .)
    (               shift and go to state 318

    discrim_part_opt               shift and go to state 470
    discrim_part                   shift and go to state 320

state 315

    (365) task_def -> IS . entry_decl_s rep_spec_s task_private_opt END id_opt
    (391) entry_decl_s -> . pragma_s
    (392) entry_decl_s -> . entry_decl_s entry_decl pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    FOR             reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)

    entry_decl_s                   shift and go to state 471
    pragma_s                       shift and go to state 472

state 316

    (362) task_spec -> TASK simple_name task_def .

    ;               reduce using rule 362 (task_spec -> TASK simple_name task_def .)


state 317

    (343) pkg_body -> PACKAGE BODY compound_name . IS decl_part body_opt END c_id_opt ;
    (455) body_stub -> PACKAGE BODY compound_name . IS SEPARATE ;
    (163) compound_name -> compound_name . . simple_name

    IS              shift and go to state 473
    .               shift and go to state 119


state 318

    (39) discrim_part_opt -> ( . LESSMORE )
    (110) discrim_part -> ( . discrim_spec_s )
    (111) discrim_spec_s -> . discrim_spec
    (112) discrim_spec_s -> . discrim_spec_s ; discrim_spec
    (113) discrim_spec -> . def_id_s : access_opt mark init_opt
    (114) discrim_spec -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    LESSMORE        shift and go to state 478
    error           shift and go to state 474
    IDENTIFIER      shift and go to state 76

    discrim_spec                   shift and go to state 477
    discrim_spec_s                 shift and go to state 475
    def_id                         shift and go to state 89
    def_id_s                       shift and go to state 476

state 319

    (36) type_decl -> TYPE IDENTIFIER discrim_part_opt . type_completion ;
    (40) type_completion -> .
    (41) type_completion -> . IS type_def

    ;               reduce using rule 40 (type_completion -> .)
    IS              shift and go to state 479

    type_completion                shift and go to state 480

state 320

    (38) discrim_part_opt -> discrim_part .

    IS              reduce using rule 38 (discrim_part_opt -> discrim_part .)
    ;               reduce using rule 38 (discrim_part_opt -> discrim_part .)


state 321

    (50) subtype_decl -> SUBTYPE IDENTIFIER IS . subtype_ind ;
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 481
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    subtype_ind                    shift and go to state 482
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 322

    (456) body_stub -> subprog_spec IS SEPARATE . ;

    ;               shift and go to state 483


state 323

    (25) def_id_s -> def_id_s , def_id .

    :               reduce using rule 25 (def_id_s -> def_id_s , def_id .)
    ,               reduce using rule 25 (def_id_s -> def_id_s , def_id .)


state 324

    (458) exception_decl -> def_id_s : EXCEPTION . ;
    (354) rename_decl -> def_id_s : EXCEPTION . renames ;
    (360) renames -> . RENAMES name

    ;               shift and go to state 485
    RENAMES         shift and go to state 95

    renames                        shift and go to state 484

state 325

    (35) number_decl -> def_id_s : CONSTANT . ASSIGNMENT expression ;
    (30) object_qualifier_opt -> CONSTANT .

    ASSIGNMENT      shift and go to state 486
    ARRAY           reduce using rule 30 (object_qualifier_opt -> CONSTANT .)
    IDENTIFIER      reduce using rule 30 (object_qualifier_opt -> CONSTANT .)
    STRING          reduce using rule 30 (object_qualifier_opt -> CONSTANT .)


state 326

    (28) object_qualifier_opt -> ALIASED .
    (29) object_qualifier_opt -> ALIASED . CONSTANT

    ARRAY           reduce using rule 28 (object_qualifier_opt -> ALIASED .)
    IDENTIFIER      reduce using rule 28 (object_qualifier_opt -> ALIASED .)
    STRING          reduce using rule 28 (object_qualifier_opt -> ALIASED .)
    CONSTANT        shift and go to state 487


state 327

    (23) object_decl -> def_id_s : object_qualifier_opt . object_subtype_def init_opt ;
    (353) rename_decl -> def_id_s : object_qualifier_opt . subtype_ind renames ;
    (31) object_subtype_def -> . subtype_ind
    (32) object_subtype_def -> . array_type
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (78) array_type -> . unconstr_array_type
    (79) array_type -> . constr_array_type
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (80) unconstr_array_type -> . ARRAY ( index_s ) OF component_subtype_def
    (81) constr_array_type -> . ARRAY iter_index_constraint OF subtype_ind
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    ARRAY           shift and go to state 489
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157
    array_type                     shift and go to state 488
    name                           shift and go to state 481
    object_subtype_def             shift and go to state 490
    constr_array_type              shift and go to state 491
    operator_symbol                shift and go to state 138
    subtype_ind                    shift and go to state 492
    unconstr_array_type            shift and go to state 493

state 328

    (502) generic_inst -> NEW name .
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id

    ;               reduce using rule 502 (generic_inst -> NEW name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 329

    (343) pkg_body -> PACKAGE BODY compound_name IS . decl_part body_opt END c_id_opt ;
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (334) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (343) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (368) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (385) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (349) use_clause -> . USE name_s ;
    (350) use_clause -> . USE TYPE name_s ;
    (503) rep_spec -> . attrib_def
    (504) rep_spec -> . record_type_spec
    (505) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (333) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (313) subprog_decl -> . subprog_spec ;
    (314) subprog_decl -> . generic_subp_inst ;
    (315) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (336) pkg_decl -> . pkg_spec ;
    (337) pkg_decl -> . generic_pkg_inst ;
    (361) task_decl -> . task_spec ;
    (369) prot_decl -> . prot_spec ;
    (458) exception_decl -> . def_id_s : EXCEPTION ;
    (353) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (354) rename_decl -> . def_id_s : EXCEPTION renames ;
    (355) rename_decl -> . rename_unit
    (470) generic_decl -> . generic_formal_part subprog_spec ;
    (471) generic_decl -> . generic_formal_part pkg_spec ;
    (454) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (455) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (456) body_stub -> . subprog_spec IS SEPARATE ;
    (457) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (506) attrib_def -> . FOR mark USE expression ;
    (507) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (512) address_spec -> . FOR mark USE AT expression ;
    (316) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (317) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (318) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (500) generic_subp_inst -> . subprog_spec IS generic_inst
    (338) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (362) task_spec -> . TASK simple_name task_def
    (363) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (370) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (371) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (356) rename_unit -> . PACKAGE compound_name renames ;
    (357) rename_unit -> . subprog_spec renames ;
    (358) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (359) rename_unit -> . generic_formal_part subprog_spec renames ;
    (472) generic_formal_part -> . GENERIC
    (473) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 135 (decl_part -> .)
    END             reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 494
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 330

    (356) rename_unit -> PACKAGE compound_name renames ; .

    PACKAGE         reduce using rule 356 (rename_unit -> PACKAGE compound_name renames ; .)
    TASK            reduce using rule 356 (rename_unit -> PACKAGE compound_name renames ; .)
    PROTECTED       reduce using rule 356 (rename_unit -> PACKAGE compound_name renames ; .)
    error           reduce using rule 356 (rename_unit -> PACKAGE compound_name renames ; .)
    USE             reduce using rule 356 (rename_unit -> PACKAGE compound_name renames ; .)
    PRAGMA          reduce using rule 356 (rename_unit -> PACKAGE compound_name renames ; .)
    TYPE            reduce using rule 356 (rename_unit -> PACKAGE compound_name renames ; .)
    SUBTYPE         reduce using rule 356 (rename_unit -> PACKAGE compound_name renames ; .)
    FOR             reduce using rule 356 (rename_unit -> PACKAGE compound_name renames ; .)
    PROCEDURE       reduce using rule 356 (rename_unit -> PACKAGE compound_name renames ; .)
    FUNCTION        reduce using rule 356 (rename_unit -> PACKAGE compound_name renames ; .)
    GENERIC         reduce using rule 356 (rename_unit -> PACKAGE compound_name renames ; .)
    IDENTIFIER      reduce using rule 356 (rename_unit -> PACKAGE compound_name renames ; .)
    BEGIN           reduce using rule 356 (rename_unit -> PACKAGE compound_name renames ; .)
    END             reduce using rule 356 (rename_unit -> PACKAGE compound_name renames ; .)
    PRIVATE         reduce using rule 356 (rename_unit -> PACKAGE compound_name renames ; .)
    WITH            reduce using rule 356 (rename_unit -> PACKAGE compound_name renames ; .)
    SEPARATE        reduce using rule 356 (rename_unit -> PACKAGE compound_name renames ; .)
    $end            reduce using rule 356 (rename_unit -> PACKAGE compound_name renames ; .)


state 331

    (501) generic_pkg_inst -> PACKAGE compound_name IS generic_inst .

    ;               reduce using rule 501 (generic_pkg_inst -> PACKAGE compound_name IS generic_inst .)


state 332

    (138) decl_item_s -> decl_item_s1 .
    (140) decl_item_s1 -> decl_item_s1 . decl_item
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (349) use_clause -> . USE name_s ;
    (350) use_clause -> . USE TYPE name_s ;
    (503) rep_spec -> . attrib_def
    (504) rep_spec -> . record_type_spec
    (505) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (313) subprog_decl -> . subprog_spec ;
    (314) subprog_decl -> . generic_subp_inst ;
    (315) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (336) pkg_decl -> . pkg_spec ;
    (337) pkg_decl -> . generic_pkg_inst ;
    (361) task_decl -> . task_spec ;
    (369) prot_decl -> . prot_spec ;
    (458) exception_decl -> . def_id_s : EXCEPTION ;
    (353) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (354) rename_decl -> . def_id_s : EXCEPTION renames ;
    (355) rename_decl -> . rename_unit
    (470) generic_decl -> . generic_formal_part subprog_spec ;
    (471) generic_decl -> . generic_formal_part pkg_spec ;
    (454) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (455) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (456) body_stub -> . subprog_spec IS SEPARATE ;
    (457) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (506) attrib_def -> . FOR mark USE expression ;
    (507) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (512) address_spec -> . FOR mark USE AT expression ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (316) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (317) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (318) subprog_spec -> . FUNCTION designator
    (500) generic_subp_inst -> . subprog_spec IS generic_inst
    (333) subprog_spec_is_push -> . subprog_spec IS
    (338) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (362) task_spec -> . TASK simple_name task_def
    (363) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (370) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (371) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (356) rename_unit -> . PACKAGE compound_name renames ;
    (357) rename_unit -> . subprog_spec renames ;
    (358) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (359) rename_unit -> . generic_formal_part subprog_spec renames ;
    (472) generic_formal_part -> . GENERIC
    (473) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    PRIVATE         reduce using rule 138 (decl_item_s -> decl_item_s1 .)
    END             reduce using rule 138 (decl_item_s -> decl_item_s1 .)
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    TASK            shift and go to state 336
    PACKAGE         shift and go to state 337
    PROTECTED       shift and go to state 333
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    task_decl                      shift and go to state 60
    subtype_decl                   shift and go to state 61
    rep_spec                       shift and go to state 82
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    decl_item                      shift and go to state 495
    subprog_spec_is_push           shift and go to state 338
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 339
    def_id_s                       shift and go to state 88
    task_spec                      shift and go to state 65
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    generic_subp_inst              shift and go to state 29
    def_id                         shift and go to state 89
    rename_decl                    shift and go to state 90
    type_decl                      shift and go to state 56
    rename_unit                    shift and go to state 91
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    subprog_decl                   shift and go to state 58
    pragma                         shift and go to state 74
    pkg_spec                       shift and go to state 37
    number_decl                    shift and go to state 93

state 333

    (457) body_stub -> PROTECTED . BODY simple_name IS SEPARATE ;
    (370) prot_spec -> PROTECTED . IDENTIFIER prot_def
    (371) prot_spec -> PROTECTED . TYPE simple_name discrim_part_opt prot_def

    BODY            shift and go to state 496
    IDENTIFIER      shift and go to state 160
    TYPE            shift and go to state 161


state 334

    (139) decl_item_s1 -> decl_item .

    error           reduce using rule 139 (decl_item_s1 -> decl_item .)
    USE             reduce using rule 139 (decl_item_s1 -> decl_item .)
    PRAGMA          reduce using rule 139 (decl_item_s1 -> decl_item .)
    TYPE            reduce using rule 139 (decl_item_s1 -> decl_item .)
    SUBTYPE         reduce using rule 139 (decl_item_s1 -> decl_item .)
    TASK            reduce using rule 139 (decl_item_s1 -> decl_item .)
    PACKAGE         reduce using rule 139 (decl_item_s1 -> decl_item .)
    PROTECTED       reduce using rule 139 (decl_item_s1 -> decl_item .)
    FOR             reduce using rule 139 (decl_item_s1 -> decl_item .)
    PROCEDURE       reduce using rule 139 (decl_item_s1 -> decl_item .)
    FUNCTION        reduce using rule 139 (decl_item_s1 -> decl_item .)
    GENERIC         reduce using rule 139 (decl_item_s1 -> decl_item .)
    IDENTIFIER      reduce using rule 139 (decl_item_s1 -> decl_item .)
    END             reduce using rule 139 (decl_item_s1 -> decl_item .)
    PRIVATE         reduce using rule 139 (decl_item_s1 -> decl_item .)


state 335

    (338) pkg_spec -> PACKAGE compound_name IS decl_item_s . private_part END c_id_opt
    (339) private_part -> .
    (340) private_part -> . PRIVATE decl_item_s

    END             reduce using rule 339 (private_part -> .)
    PRIVATE         shift and go to state 497

    private_part                   shift and go to state 498

state 336

    (454) body_stub -> TASK . BODY simple_name IS SEPARATE ;
    (362) task_spec -> TASK . simple_name task_def
    (363) task_spec -> TASK . TYPE simple_name discrim_part_opt task_def
    (161) simple_name -> . IDENTIFIER

    BODY            shift and go to state 499
    TYPE            shift and go to state 168
    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 169

state 337

    (455) body_stub -> PACKAGE . BODY compound_name IS SEPARATE ;
    (338) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> PACKAGE . compound_name IS generic_inst
    (356) rename_unit -> PACKAGE . compound_name renames ;
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    BODY            shift and go to state 500
    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 41
    compound_name                  shift and go to state 172

state 338

    (315) subprog_decl -> subprog_spec_is_push . ABSTRACT ;

    ABSTRACT        shift and go to state 81


state 339

    (313) subprog_decl -> subprog_spec . ;
    (456) body_stub -> subprog_spec . IS SEPARATE ;
    (500) generic_subp_inst -> subprog_spec . IS generic_inst
    (333) subprog_spec_is_push -> subprog_spec . IS
    (357) rename_unit -> subprog_spec . renames ;
    (360) renames -> . RENAMES name

    ;               shift and go to state 97
    IS              shift and go to state 501
    RENAMES         shift and go to state 95

    renames                        shift and go to state 94

state 340

    (324) param_s -> param .

    )               reduce using rule 324 (param_s -> param .)
    ;               reduce using rule 324 (param_s -> param .)


state 341

    (323) formal_part -> ( param_s . )
    (325) param_s -> param_s . ; param

    )               shift and go to state 502
    ;               shift and go to state 503


state 342

    (477) generic_formal -> WITH FUNCTION designator . formal_part_opt RETURN name subp_default ;
    (321) formal_part_opt -> .
    (322) formal_part_opt -> . formal_part
    (323) formal_part -> . ( param_s )

    RETURN          reduce using rule 321 (formal_part_opt -> .)
    (               shift and go to state 189

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 504

state 343

    (478) generic_formal -> WITH PACKAGE simple_name . IS NEW name ( LESSMORE ) ;
    (479) generic_formal -> WITH PACKAGE simple_name . IS NEW name ;

    IS              shift and go to state 505


state 344

    (476) generic_formal -> WITH PROCEDURE simple_name . formal_part_opt subp_default ;
    (321) formal_part_opt -> .
    (322) formal_part_opt -> . formal_part
    (323) formal_part -> . ( param_s )

    IS              reduce using rule 321 (formal_part_opt -> .)
    ;               reduce using rule 321 (formal_part_opt -> .)
    (               shift and go to state 189

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 506

state 345

    (359) rename_unit -> generic_formal_part subprog_spec renames ; .

    PACKAGE         reduce using rule 359 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    TASK            reduce using rule 359 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    PROTECTED       reduce using rule 359 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    error           reduce using rule 359 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    USE             reduce using rule 359 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    PRAGMA          reduce using rule 359 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    TYPE            reduce using rule 359 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    SUBTYPE         reduce using rule 359 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    FOR             reduce using rule 359 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    PROCEDURE       reduce using rule 359 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    FUNCTION        reduce using rule 359 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    GENERIC         reduce using rule 359 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    IDENTIFIER      reduce using rule 359 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    BEGIN           reduce using rule 359 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    END             reduce using rule 359 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    PRIVATE         reduce using rule 359 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    WITH            reduce using rule 359 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    SEPARATE        reduce using rule 359 (rename_unit -> generic_formal_part subprog_spec renames ; .)
    $end            reduce using rule 359 (rename_unit -> generic_formal_part subprog_spec renames ; .)


state 346

    (332) mode -> ACCESS .

    IDENTIFIER      reduce using rule 332 (mode -> ACCESS .)


state 347

    (330) mode -> OUT .

    IDENTIFIER      reduce using rule 330 (mode -> OUT .)


state 348

    (329) mode -> IN .
    (331) mode -> IN . OUT

    IDENTIFIER      reduce using rule 329 (mode -> IN .)
    OUT             shift and go to state 507


state 349

    (326) param -> def_id_s : mode . mark init_opt
    (158) mark -> . simple_name
    (159) mark -> . mark TICK attribute_id
    (160) mark -> . mark . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    mark                           shift and go to state 508
    simple_name                    shift and go to state 165

state 350

    (358) rename_unit -> generic_formal_part PACKAGE compound_name renames . ;

    ;               shift and go to state 509


state 351

    (338) pkg_spec -> PACKAGE compound_name IS . decl_item_s private_part END c_id_opt
    (137) decl_item_s -> .
    (138) decl_item_s -> . decl_item_s1
    (139) decl_item_s1 -> . decl_item
    (140) decl_item_s1 -> . decl_item_s1 decl_item
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (349) use_clause -> . USE name_s ;
    (350) use_clause -> . USE TYPE name_s ;
    (503) rep_spec -> . attrib_def
    (504) rep_spec -> . record_type_spec
    (505) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (313) subprog_decl -> . subprog_spec ;
    (314) subprog_decl -> . generic_subp_inst ;
    (315) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (336) pkg_decl -> . pkg_spec ;
    (337) pkg_decl -> . generic_pkg_inst ;
    (361) task_decl -> . task_spec ;
    (369) prot_decl -> . prot_spec ;
    (458) exception_decl -> . def_id_s : EXCEPTION ;
    (353) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (354) rename_decl -> . def_id_s : EXCEPTION renames ;
    (355) rename_decl -> . rename_unit
    (470) generic_decl -> . generic_formal_part subprog_spec ;
    (471) generic_decl -> . generic_formal_part pkg_spec ;
    (454) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (455) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (456) body_stub -> . subprog_spec IS SEPARATE ;
    (457) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (506) attrib_def -> . FOR mark USE expression ;
    (507) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (512) address_spec -> . FOR mark USE AT expression ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (316) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (317) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (318) subprog_spec -> . FUNCTION designator
    (500) generic_subp_inst -> . subprog_spec IS generic_inst
    (333) subprog_spec_is_push -> . subprog_spec IS
    (338) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (362) task_spec -> . TASK simple_name task_def
    (363) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (370) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (371) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (356) rename_unit -> . PACKAGE compound_name renames ;
    (357) rename_unit -> . subprog_spec renames ;
    (358) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (359) rename_unit -> . generic_formal_part subprog_spec renames ;
    (472) generic_formal_part -> . GENERIC
    (473) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    PRIVATE         reduce using rule 137 (decl_item_s -> .)
    END             reduce using rule 137 (decl_item_s -> .)
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    TASK            shift and go to state 336
    PACKAGE         shift and go to state 337
    PROTECTED       shift and go to state 333
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    task_decl                      shift and go to state 60
    subtype_decl                   shift and go to state 61
    rep_spec                       shift and go to state 82
    decl_item_s1                   shift and go to state 332
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 338
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 339
    def_id_s                       shift and go to state 88
    decl_item                      shift and go to state 334
    task_spec                      shift and go to state 65
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    generic_subp_inst              shift and go to state 29
    def_id                         shift and go to state 89
    rename_decl                    shift and go to state 90
    type_decl                      shift and go to state 56
    rename_unit                    shift and go to state 91
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    subprog_decl                   shift and go to state 58
    decl_item_s                    shift and go to state 335
    pragma                         shift and go to state 74
    pkg_spec                       shift and go to state 37
    number_decl                    shift and go to state 93

state 352

    (475) generic_formal -> TYPE simple_name generic_discrim_part_opt . IS generic_type_def ;

    IS              shift and go to state 510


state 353

    (483) generic_discrim_part_opt -> ( . LESSMORE )
    (110) discrim_part -> ( . discrim_spec_s )
    (111) discrim_spec_s -> . discrim_spec
    (112) discrim_spec_s -> . discrim_spec_s ; discrim_spec
    (113) discrim_spec -> . def_id_s : access_opt mark init_opt
    (114) discrim_spec -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    LESSMORE        shift and go to state 511
    error           shift and go to state 474
    IDENTIFIER      shift and go to state 76

    discrim_spec                   shift and go to state 477
    discrim_spec_s                 shift and go to state 475
    def_id                         shift and go to state 89
    def_id_s                       shift and go to state 476

state 354

    (482) generic_discrim_part_opt -> discrim_part .

    IS              reduce using rule 482 (generic_discrim_part_opt -> discrim_part .)


state 355

    (317) subprog_spec -> FUNCTION designator formal_part_opt RETURN . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 512
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    indexed_comp                   shift and go to state 129
    operator_symbol                shift and go to state 138
    simple_name                    shift and go to state 157

state 356

    (233) factor -> primary STARSTAR primary .

    *               reduce using rule 233 (factor -> primary STARSTAR primary .)
    /               reduce using rule 233 (factor -> primary STARSTAR primary .)
    MOD             reduce using rule 233 (factor -> primary STARSTAR primary .)
    REM             reduce using rule 233 (factor -> primary STARSTAR primary .)
    =               reduce using rule 233 (factor -> primary STARSTAR primary .)
    NOTEQUAL        reduce using rule 233 (factor -> primary STARSTAR primary .)
    <               reduce using rule 233 (factor -> primary STARSTAR primary .)
    LESSEQ          reduce using rule 233 (factor -> primary STARSTAR primary .)
    >               reduce using rule 233 (factor -> primary STARSTAR primary .)
    GREATEREQ       reduce using rule 233 (factor -> primary STARSTAR primary .)
    IN              reduce using rule 233 (factor -> primary STARSTAR primary .)
    NOT             reduce using rule 233 (factor -> primary STARSTAR primary .)
    +               reduce using rule 233 (factor -> primary STARSTAR primary .)
    -               reduce using rule 233 (factor -> primary STARSTAR primary .)
    &               reduce using rule 233 (factor -> primary STARSTAR primary .)
    AND             reduce using rule 233 (factor -> primary STARSTAR primary .)
    OR              reduce using rule 233 (factor -> primary STARSTAR primary .)
    )               reduce using rule 233 (factor -> primary STARSTAR primary .)
    ,               reduce using rule 233 (factor -> primary STARSTAR primary .)
    DOTDOT          reduce using rule 233 (factor -> primary STARSTAR primary .)
    ;               reduce using rule 233 (factor -> primary STARSTAR primary .)
    ARROW           reduce using rule 233 (factor -> primary STARSTAR primary .)
    |               reduce using rule 233 (factor -> primary STARSTAR primary .)
    RANGE           reduce using rule 233 (factor -> primary STARSTAR primary .)
    DIGITS          reduce using rule 233 (factor -> primary STARSTAR primary .)
    WITH            reduce using rule 233 (factor -> primary STARSTAR primary .)
    IS              reduce using rule 233 (factor -> primary STARSTAR primary .)
    THEN            reduce using rule 233 (factor -> primary STARSTAR primary .)
    LOOP            reduce using rule 233 (factor -> primary STARSTAR primary .)
    RENAMES         reduce using rule 233 (factor -> primary STARSTAR primary .)
    ASSIGNMENT      reduce using rule 233 (factor -> primary STARSTAR primary .)


state 357

    (219) simple_expression -> simple_expression adding term .
    (226) term -> term . multiplying factor
    (227) multiplying -> . *
    (228) multiplying -> . /
    (229) multiplying -> . MOD
    (230) multiplying -> . REM

    +               reduce using rule 219 (simple_expression -> simple_expression adding term .)
    -               reduce using rule 219 (simple_expression -> simple_expression adding term .)
    &               reduce using rule 219 (simple_expression -> simple_expression adding term .)
    ARROW           reduce using rule 219 (simple_expression -> simple_expression adding term .)
    |               reduce using rule 219 (simple_expression -> simple_expression adding term .)
    AND             reduce using rule 219 (simple_expression -> simple_expression adding term .)
    OR              reduce using rule 219 (simple_expression -> simple_expression adding term .)
    )               reduce using rule 219 (simple_expression -> simple_expression adding term .)
    ,               reduce using rule 219 (simple_expression -> simple_expression adding term .)
    WITH            reduce using rule 219 (simple_expression -> simple_expression adding term .)
    ;               reduce using rule 219 (simple_expression -> simple_expression adding term .)
    IS              reduce using rule 219 (simple_expression -> simple_expression adding term .)
    THEN            reduce using rule 219 (simple_expression -> simple_expression adding term .)
    LOOP            reduce using rule 219 (simple_expression -> simple_expression adding term .)
    RANGE           reduce using rule 219 (simple_expression -> simple_expression adding term .)
    DIGITS          reduce using rule 219 (simple_expression -> simple_expression adding term .)
    RENAMES         reduce using rule 219 (simple_expression -> simple_expression adding term .)
    ASSIGNMENT      reduce using rule 219 (simple_expression -> simple_expression adding term .)
    =               reduce using rule 219 (simple_expression -> simple_expression adding term .)
    NOTEQUAL        reduce using rule 219 (simple_expression -> simple_expression adding term .)
    <               reduce using rule 219 (simple_expression -> simple_expression adding term .)
    LESSEQ          reduce using rule 219 (simple_expression -> simple_expression adding term .)
    >               reduce using rule 219 (simple_expression -> simple_expression adding term .)
    GREATEREQ       reduce using rule 219 (simple_expression -> simple_expression adding term .)
    IN              reduce using rule 219 (simple_expression -> simple_expression adding term .)
    NOT             reduce using rule 219 (simple_expression -> simple_expression adding term .)
    DOTDOT          reduce using rule 219 (simple_expression -> simple_expression adding term .)
    *               shift and go to state 240
    /               shift and go to state 241
    MOD             shift and go to state 242
    REM             shift and go to state 238

    multiplying                    shift and go to state 239

state 358

    (62) range -> simple_expression . DOTDOT simple_expression
    (219) simple_expression -> simple_expression . adding term
    (222) adding -> . +
    (223) adding -> . -
    (224) adding -> . &

    DOTDOT          shift and go to state 364
    +               shift and go to state 210
    -               shift and go to state 212
    &               shift and go to state 211

    adding                         shift and go to state 208

state 359

    (208) relation -> simple_expression membership name .
    (63) range -> name .
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id
    (235) primary -> name .
    (241) qualified -> name . TICK parenthesized_primary

  ! reduce/reduce conflict for AND resolved using rule 63 (range -> name .)
  ! reduce/reduce conflict for OR resolved using rule 63 (range -> name .)
  ! reduce/reduce conflict for ) resolved using rule 63 (range -> name .)
  ! reduce/reduce conflict for , resolved using rule 63 (range -> name .)
  ! reduce/reduce conflict for WITH resolved using rule 63 (range -> name .)
  ! reduce/reduce conflict for ARROW resolved using rule 63 (range -> name .)
  ! reduce/reduce conflict for | resolved using rule 63 (range -> name .)
  ! reduce/reduce conflict for ; resolved using rule 63 (range -> name .)
  ! reduce/reduce conflict for IS resolved using rule 63 (range -> name .)
  ! reduce/reduce conflict for THEN resolved using rule 63 (range -> name .)
  ! reduce/reduce conflict for LOOP resolved using rule 63 (range -> name .)
  ! reduce/reduce conflict for RANGE resolved using rule 63 (range -> name .)
  ! reduce/reduce conflict for DIGITS resolved using rule 63 (range -> name .)
  ! reduce/reduce conflict for RENAMES resolved using rule 63 (range -> name .)
  ! reduce/reduce conflict for ASSIGNMENT resolved using rule 63 (range -> name .)
    AND             reduce using rule 63 (range -> name .)
    OR              reduce using rule 63 (range -> name .)
    )               reduce using rule 63 (range -> name .)
    ,               reduce using rule 63 (range -> name .)
    WITH            reduce using rule 63 (range -> name .)
    ARROW           reduce using rule 63 (range -> name .)
    |               reduce using rule 63 (range -> name .)
    ;               reduce using rule 63 (range -> name .)
    IS              reduce using rule 63 (range -> name .)
    THEN            reduce using rule 63 (range -> name .)
    LOOP            reduce using rule 63 (range -> name .)
    RANGE           reduce using rule 63 (range -> name .)
    DIGITS          reduce using rule 63 (range -> name .)
    RENAMES         reduce using rule 63 (range -> name .)
    ASSIGNMENT      reduce using rule 63 (range -> name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 370
    STARSTAR        reduce using rule 235 (primary -> name .)
    *               reduce using rule 235 (primary -> name .)
    /               reduce using rule 235 (primary -> name .)
    MOD             reduce using rule 235 (primary -> name .)
    REM             reduce using rule 235 (primary -> name .)
    DOTDOT          reduce using rule 235 (primary -> name .)
    +               reduce using rule 235 (primary -> name .)
    -               reduce using rule 235 (primary -> name .)
    &               reduce using rule 235 (primary -> name .)

  ! AND             [ reduce using rule 208 (relation -> simple_expression membership name .) ]
  ! OR              [ reduce using rule 208 (relation -> simple_expression membership name .) ]
  ! )               [ reduce using rule 208 (relation -> simple_expression membership name .) ]
  ! ,               [ reduce using rule 208 (relation -> simple_expression membership name .) ]
  ! ARROW           [ reduce using rule 208 (relation -> simple_expression membership name .) ]
  ! |               [ reduce using rule 208 (relation -> simple_expression membership name .) ]
  ! RANGE           [ reduce using rule 208 (relation -> simple_expression membership name .) ]
  ! ;               [ reduce using rule 208 (relation -> simple_expression membership name .) ]
  ! THEN            [ reduce using rule 208 (relation -> simple_expression membership name .) ]
  ! LOOP            [ reduce using rule 208 (relation -> simple_expression membership name .) ]
  ! WITH            [ reduce using rule 208 (relation -> simple_expression membership name .) ]
  ! IS              [ reduce using rule 208 (relation -> simple_expression membership name .) ]
  ! DIGITS          [ reduce using rule 208 (relation -> simple_expression membership name .) ]
  ! RENAMES         [ reduce using rule 208 (relation -> simple_expression membership name .) ]
  ! ASSIGNMENT      [ reduce using rule 208 (relation -> simple_expression membership name .) ]


state 360

    (207) relation -> simple_expression membership range .

    AND             reduce using rule 207 (relation -> simple_expression membership range .)
    OR              reduce using rule 207 (relation -> simple_expression membership range .)
    )               reduce using rule 207 (relation -> simple_expression membership range .)
    ,               reduce using rule 207 (relation -> simple_expression membership range .)
    ARROW           reduce using rule 207 (relation -> simple_expression membership range .)
    |               reduce using rule 207 (relation -> simple_expression membership range .)
    RANGE           reduce using rule 207 (relation -> simple_expression membership range .)
    ;               reduce using rule 207 (relation -> simple_expression membership range .)
    THEN            reduce using rule 207 (relation -> simple_expression membership range .)
    LOOP            reduce using rule 207 (relation -> simple_expression membership range .)
    WITH            reduce using rule 207 (relation -> simple_expression membership range .)
    IS              reduce using rule 207 (relation -> simple_expression membership range .)
    DIGITS          reduce using rule 207 (relation -> simple_expression membership range .)
    RENAMES         reduce using rule 207 (relation -> simple_expression membership range .)
    ASSIGNMENT      reduce using rule 207 (relation -> simple_expression membership range .)


state 361

    (216) membership -> NOT IN .

    IDENTIFIER      reduce using rule 216 (membership -> NOT IN .)
    STRING          reduce using rule 216 (membership -> NOT IN .)
    +               reduce using rule 216 (membership -> NOT IN .)
    -               reduce using rule 216 (membership -> NOT IN .)
    NOT             reduce using rule 216 (membership -> NOT IN .)
    INTEGER         reduce using rule 216 (membership -> NOT IN .)
    BASE_INTEGER    reduce using rule 216 (membership -> NOT IN .)
    FLOAT           reduce using rule 216 (membership -> NOT IN .)
    BASE_FLOAT      reduce using rule 216 (membership -> NOT IN .)
    NuLL            reduce using rule 216 (membership -> NOT IN .)
    NEW             reduce using rule 216 (membership -> NOT IN .)
    (               reduce using rule 216 (membership -> NOT IN .)
    CHAR            reduce using rule 216 (membership -> NOT IN .)


state 362

    (206) relation -> simple_expression relational simple_expression .
    (219) simple_expression -> simple_expression . adding term
    (222) adding -> . +
    (223) adding -> . -
    (224) adding -> . &

    AND             reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    OR              reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    )               reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    ,               reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    ARROW           reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    |               reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    RANGE           reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    ;               reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    THEN            reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    LOOP            reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    WITH            reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    IS              reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    DIGITS          reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    RENAMES         reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    ASSIGNMENT      reduce using rule 206 (relation -> simple_expression relational simple_expression .)
    +               shift and go to state 210
    -               shift and go to state 212
    &               shift and go to state 211

    adding                         shift and go to state 208

state 363

    (7) pragma_arg -> simple_name ARROW expression .
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    )               reduce using rule 7 (pragma_arg -> simple_name ARROW expression .)
    ,               reduce using rule 7 (pragma_arg -> simple_name ARROW expression .)
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 364

    (62) range -> simple_expression DOTDOT . simple_expression
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    simple_expression              shift and go to state 513
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148
    operator_symbol                shift and go to state 138

state 365

    (122) choice_s -> choice_s | . choice
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    OTHERS          shift and go to state 223
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 514
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    operator_symbol                shift and go to state 138
    factor                         shift and go to state 137
    choice                         shift and go to state 515
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 147
    name                           shift and go to state 516
    range                          shift and go to state 232
    expression                     shift and go to state 517

state 366

    (196) comp_assoc -> choice_s ARROW . expression
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 518

state 367

    (189) aggregate -> ( comp_assoc ) .

    STARSTAR        reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    *               reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    /               reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    MOD             reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    REM             reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    =               reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    NOTEQUAL        reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    <               reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    LESSEQ          reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    >               reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    GREATEREQ       reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    IN              reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    NOT             reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    +               reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    -               reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    &               reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    AND             reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    OR              reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    )               reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    ,               reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    DOTDOT          reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    WITH            reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    ARROW           reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    |               reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    ;               reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    IS              reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    THEN            reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    LOOP            reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    RANGE           reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    DIGITS          reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    RENAMES         reduce using rule 189 (aggregate -> ( comp_assoc ) .)
    ASSIGNMENT      reduce using rule 189 (aggregate -> ( comp_assoc ) .)


state 368

    (190) aggregate -> ( value_s_2 ) .

    STARSTAR        reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    *               reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    /               reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    MOD             reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    REM             reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    =               reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    NOTEQUAL        reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    <               reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    LESSEQ          reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    >               reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    GREATEREQ       reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    IN              reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    NOT             reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    +               reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    -               reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    &               reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    AND             reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    OR              reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    )               reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    ,               reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    DOTDOT          reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    WITH            reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    ARROW           reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    |               reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    ;               reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    IS              reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    THEN            reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    LOOP            reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    RANGE           reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    DIGITS          reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    RENAMES         reduce using rule 190 (aggregate -> ( value_s_2 ) .)
    ASSIGNMENT      reduce using rule 190 (aggregate -> ( value_s_2 ) .)


state 369

    (195) value_s_2 -> value_s_2 , . value
    (171) value -> . expression
    (172) value -> . comp_assoc
    (173) value -> . error
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (196) comp_assoc -> . choice_s ARROW expression
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 233
    OTHERS          shift and go to state 223
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 224
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    comp_assoc                     shift and go to state 381
    choice_s                       shift and go to state 225
    choice                         shift and go to state 227
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 147
    name                           shift and go to state 230
    value                          shift and go to state 519
    range                          shift and go to state 232
    expression                     shift and go to state 383

state 370

    (178) attribute -> name TICK . attribute_id
    (241) qualified -> name TICK . parenthesized_primary
    (179) attribute_id -> . IDENTIFIER
    (180) attribute_id -> . DIGITS
    (181) attribute_id -> . DELTA
    (182) attribute_id -> . ACCESS
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 389
    DIGITS          shift and go to state 388
    DELTA           shift and go to state 392
    ACCESS          shift and go to state 390
    (               shift and go to state 132

    parenthesized_primary          shift and go to state 393
    aggregate                      shift and go to state 144
    attribute_id                   shift and go to state 391

state 371

    (61) range_constraint -> RANGE . range
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    simple_expression              shift and go to state 358
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 520
    operator_symbol                shift and go to state 138
    range                          shift and go to state 521

state 372

    (126) discrete_with_range -> name range_constraint .

    ARROW           reduce using rule 126 (discrete_with_range -> name range_constraint .)
    |               reduce using rule 126 (discrete_with_range -> name range_constraint .)


state 373

    (194) value_s_2 -> value , . value
    (171) value -> . expression
    (172) value -> . comp_assoc
    (173) value -> . error
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (196) comp_assoc -> . choice_s ARROW expression
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 233
    OTHERS          shift and go to state 223
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 224
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    comp_assoc                     shift and go to state 381
    choice_s                       shift and go to state 225
    choice                         shift and go to state 227
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 147
    name                           shift and go to state 230
    value                          shift and go to state 522
    range                          shift and go to state 232
    expression                     shift and go to state 383

state 374

    (193) aggregate -> ( NuLL RECORD . )

    )               shift and go to state 523


state 375

    (240) parenthesized_primary -> ( expression ) .

    STARSTAR        reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    *               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    /               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    MOD             reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    REM             reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    DOTDOT          reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    =               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    NOTEQUAL        reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    <               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    LESSEQ          reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    >               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    GREATEREQ       reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    IN              reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    NOT             reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    +               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    -               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    &               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    )               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    WITH            reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    AND             reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    OR              reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    ,               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    ARROW           reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    |               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    ;               reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    IS              reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    THEN            reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    LOOP            reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    RANGE           reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    DIGITS          reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    RENAMES         reduce using rule 240 (parenthesized_primary -> ( expression ) .)
    ASSIGNMENT      reduce using rule 240 (parenthesized_primary -> ( expression ) .)


state 376

    (191) aggregate -> ( expression WITH . value_s )
    (192) aggregate -> ( expression WITH . NuLL RECORD )
    (169) value_s -> . value
    (170) value_s -> . value_s , value
    (171) value -> . expression
    (172) value -> . comp_assoc
    (173) value -> . error
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (196) comp_assoc -> . choice_s ARROW expression
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    NuLL            shift and go to state 525
    error           shift and go to state 233
    OTHERS          shift and go to state 223
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    value                          shift and go to state 382
    simple_expression              shift and go to state 224
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    comp_assoc                     shift and go to state 381
    choice_s                       shift and go to state 225
    choice                         shift and go to state 227
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 147
    name                           shift and go to state 230
    value_s                        shift and go to state 524
    range                          shift and go to state 232
    expression                     shift and go to state 383

state 377

    (3) pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .

    PRAGMA          reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    PRIVATE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    WITH            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    PACKAGE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    SEPARATE        reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    PROCEDURE       reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    FUNCTION        reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    GENERIC         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    $end            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    LESSLESS        reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    error           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    NuLL            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    EXIT            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    RETURN          reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    GOTO            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    DELAY           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    ABORT           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    RAISE           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    REQUEUE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    IF              reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    CASE            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    IDENTIFIER      reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    ACCEPT          reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    SELECT          reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    STRING          reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    WHILE           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    DECLARE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    FOR             reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    LOOP            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    BEGIN           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    WHEN            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    END             reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    ENTRY           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    TASK            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    PROTECTED       reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    USE             reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    TYPE            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    SUBTYPE         reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    ELSIF           reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    ELSE            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    EXCEPTION       reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    OR              reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)
    THEN            reduce using rule 3 (pragma -> PRAGMA simple_name ( pragma_arg_s ) ; .)


state 378

    (5) pragma_arg_s -> pragma_arg_s , pragma_arg .

    )               reduce using rule 5 (pragma_arg_s -> pragma_arg_s , pragma_arg .)
    ,               reduce using rule 5 (pragma_arg_s -> pragma_arg_s , pragma_arg .)


state 379

    (226) term -> term multiplying factor .

    *               reduce using rule 226 (term -> term multiplying factor .)
    /               reduce using rule 226 (term -> term multiplying factor .)
    MOD             reduce using rule 226 (term -> term multiplying factor .)
    REM             reduce using rule 226 (term -> term multiplying factor .)
    =               reduce using rule 226 (term -> term multiplying factor .)
    NOTEQUAL        reduce using rule 226 (term -> term multiplying factor .)
    <               reduce using rule 226 (term -> term multiplying factor .)
    LESSEQ          reduce using rule 226 (term -> term multiplying factor .)
    >               reduce using rule 226 (term -> term multiplying factor .)
    GREATEREQ       reduce using rule 226 (term -> term multiplying factor .)
    IN              reduce using rule 226 (term -> term multiplying factor .)
    NOT             reduce using rule 226 (term -> term multiplying factor .)
    +               reduce using rule 226 (term -> term multiplying factor .)
    -               reduce using rule 226 (term -> term multiplying factor .)
    &               reduce using rule 226 (term -> term multiplying factor .)
    IS              reduce using rule 226 (term -> term multiplying factor .)
    AND             reduce using rule 226 (term -> term multiplying factor .)
    OR              reduce using rule 226 (term -> term multiplying factor .)
    )               reduce using rule 226 (term -> term multiplying factor .)
    ,               reduce using rule 226 (term -> term multiplying factor .)
    DOTDOT          reduce using rule 226 (term -> term multiplying factor .)
    WITH            reduce using rule 226 (term -> term multiplying factor .)
    ARROW           reduce using rule 226 (term -> term multiplying factor .)
    |               reduce using rule 226 (term -> term multiplying factor .)
    ;               reduce using rule 226 (term -> term multiplying factor .)
    THEN            reduce using rule 226 (term -> term multiplying factor .)
    LOOP            reduce using rule 226 (term -> term multiplying factor .)
    RANGE           reduce using rule 226 (term -> term multiplying factor .)
    DIGITS          reduce using rule 226 (term -> term multiplying factor .)
    RENAMES         reduce using rule 226 (term -> term multiplying factor .)
    ASSIGNMENT      reduce using rule 226 (term -> term multiplying factor .)


state 380

    (168) indexed_comp -> name ( value_s . )
    (170) value_s -> value_s . , value

    )               shift and go to state 526
    ,               shift and go to state 527


state 381

    (172) value -> comp_assoc .

    )               reduce using rule 172 (value -> comp_assoc .)
    ,               reduce using rule 172 (value -> comp_assoc .)


state 382

    (169) value_s -> value .

    )               reduce using rule 169 (value_s -> value .)
    ,               reduce using rule 169 (value_s -> value .)


state 383

    (171) value -> expression .
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (123) choice -> expression .
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    )               reduce using rule 171 (value -> expression .)
    ,               reduce using rule 171 (value -> expression .)
    ARROW           reduce using rule 123 (choice -> expression .)
    |               reduce using rule 123 (choice -> expression .)
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 384

    (177) selected_comp -> name . ALL .

    (               reduce using rule 177 (selected_comp -> name . ALL .)
    .               reduce using rule 177 (selected_comp -> name . ALL .)
    TICK            reduce using rule 177 (selected_comp -> name . ALL .)
    ARROW           reduce using rule 177 (selected_comp -> name . ALL .)
    |               reduce using rule 177 (selected_comp -> name . ALL .)
    )               reduce using rule 177 (selected_comp -> name . ALL .)
    ,               reduce using rule 177 (selected_comp -> name . ALL .)
    STARSTAR        reduce using rule 177 (selected_comp -> name . ALL .)
    *               reduce using rule 177 (selected_comp -> name . ALL .)
    /               reduce using rule 177 (selected_comp -> name . ALL .)
    MOD             reduce using rule 177 (selected_comp -> name . ALL .)
    REM             reduce using rule 177 (selected_comp -> name . ALL .)
    DOTDOT          reduce using rule 177 (selected_comp -> name . ALL .)
    +               reduce using rule 177 (selected_comp -> name . ALL .)
    -               reduce using rule 177 (selected_comp -> name . ALL .)
    &               reduce using rule 177 (selected_comp -> name . ALL .)
    RANGE           reduce using rule 177 (selected_comp -> name . ALL .)
    DIGITS          reduce using rule 177 (selected_comp -> name . ALL .)
    WITH            reduce using rule 177 (selected_comp -> name . ALL .)
    ;               reduce using rule 177 (selected_comp -> name . ALL .)
    ASSIGNMENT      reduce using rule 177 (selected_comp -> name . ALL .)
    =               reduce using rule 177 (selected_comp -> name . ALL .)
    NOTEQUAL        reduce using rule 177 (selected_comp -> name . ALL .)
    <               reduce using rule 177 (selected_comp -> name . ALL .)
    LESSEQ          reduce using rule 177 (selected_comp -> name . ALL .)
    >               reduce using rule 177 (selected_comp -> name . ALL .)
    GREATEREQ       reduce using rule 177 (selected_comp -> name . ALL .)
    IN              reduce using rule 177 (selected_comp -> name . ALL .)
    NOT             reduce using rule 177 (selected_comp -> name . ALL .)
    AND             reduce using rule 177 (selected_comp -> name . ALL .)
    OR              reduce using rule 177 (selected_comp -> name . ALL .)
    IS              reduce using rule 177 (selected_comp -> name . ALL .)
    THEN            reduce using rule 177 (selected_comp -> name . ALL .)
    LOOP            reduce using rule 177 (selected_comp -> name . ALL .)
    RENAMES         reduce using rule 177 (selected_comp -> name . ALL .)
    WHEN            reduce using rule 177 (selected_comp -> name . ALL .)


state 385

    (176) selected_comp -> name . operator_symbol .

    (               reduce using rule 176 (selected_comp -> name . operator_symbol .)
    .               reduce using rule 176 (selected_comp -> name . operator_symbol .)
    TICK            reduce using rule 176 (selected_comp -> name . operator_symbol .)
    ARROW           reduce using rule 176 (selected_comp -> name . operator_symbol .)
    |               reduce using rule 176 (selected_comp -> name . operator_symbol .)
    )               reduce using rule 176 (selected_comp -> name . operator_symbol .)
    ,               reduce using rule 176 (selected_comp -> name . operator_symbol .)
    STARSTAR        reduce using rule 176 (selected_comp -> name . operator_symbol .)
    *               reduce using rule 176 (selected_comp -> name . operator_symbol .)
    /               reduce using rule 176 (selected_comp -> name . operator_symbol .)
    MOD             reduce using rule 176 (selected_comp -> name . operator_symbol .)
    REM             reduce using rule 176 (selected_comp -> name . operator_symbol .)
    DOTDOT          reduce using rule 176 (selected_comp -> name . operator_symbol .)
    +               reduce using rule 176 (selected_comp -> name . operator_symbol .)
    -               reduce using rule 176 (selected_comp -> name . operator_symbol .)
    &               reduce using rule 176 (selected_comp -> name . operator_symbol .)
    RANGE           reduce using rule 176 (selected_comp -> name . operator_symbol .)
    DIGITS          reduce using rule 176 (selected_comp -> name . operator_symbol .)
    WITH            reduce using rule 176 (selected_comp -> name . operator_symbol .)
    ;               reduce using rule 176 (selected_comp -> name . operator_symbol .)
    ASSIGNMENT      reduce using rule 176 (selected_comp -> name . operator_symbol .)
    =               reduce using rule 176 (selected_comp -> name . operator_symbol .)
    NOTEQUAL        reduce using rule 176 (selected_comp -> name . operator_symbol .)
    <               reduce using rule 176 (selected_comp -> name . operator_symbol .)
    LESSEQ          reduce using rule 176 (selected_comp -> name . operator_symbol .)
    >               reduce using rule 176 (selected_comp -> name . operator_symbol .)
    GREATEREQ       reduce using rule 176 (selected_comp -> name . operator_symbol .)
    IN              reduce using rule 176 (selected_comp -> name . operator_symbol .)
    NOT             reduce using rule 176 (selected_comp -> name . operator_symbol .)
    AND             reduce using rule 176 (selected_comp -> name . operator_symbol .)
    OR              reduce using rule 176 (selected_comp -> name . operator_symbol .)
    IS              reduce using rule 176 (selected_comp -> name . operator_symbol .)
    THEN            reduce using rule 176 (selected_comp -> name . operator_symbol .)
    LOOP            reduce using rule 176 (selected_comp -> name . operator_symbol .)
    RENAMES         reduce using rule 176 (selected_comp -> name . operator_symbol .)
    WHEN            reduce using rule 176 (selected_comp -> name . operator_symbol .)


state 386

    (175) selected_comp -> name . used_char .

    (               reduce using rule 175 (selected_comp -> name . used_char .)
    .               reduce using rule 175 (selected_comp -> name . used_char .)
    TICK            reduce using rule 175 (selected_comp -> name . used_char .)
    ARROW           reduce using rule 175 (selected_comp -> name . used_char .)
    |               reduce using rule 175 (selected_comp -> name . used_char .)
    )               reduce using rule 175 (selected_comp -> name . used_char .)
    ,               reduce using rule 175 (selected_comp -> name . used_char .)
    STARSTAR        reduce using rule 175 (selected_comp -> name . used_char .)
    *               reduce using rule 175 (selected_comp -> name . used_char .)
    /               reduce using rule 175 (selected_comp -> name . used_char .)
    MOD             reduce using rule 175 (selected_comp -> name . used_char .)
    REM             reduce using rule 175 (selected_comp -> name . used_char .)
    DOTDOT          reduce using rule 175 (selected_comp -> name . used_char .)
    +               reduce using rule 175 (selected_comp -> name . used_char .)
    -               reduce using rule 175 (selected_comp -> name . used_char .)
    &               reduce using rule 175 (selected_comp -> name . used_char .)
    RANGE           reduce using rule 175 (selected_comp -> name . used_char .)
    DIGITS          reduce using rule 175 (selected_comp -> name . used_char .)
    WITH            reduce using rule 175 (selected_comp -> name . used_char .)
    ;               reduce using rule 175 (selected_comp -> name . used_char .)
    ASSIGNMENT      reduce using rule 175 (selected_comp -> name . used_char .)
    =               reduce using rule 175 (selected_comp -> name . used_char .)
    NOTEQUAL        reduce using rule 175 (selected_comp -> name . used_char .)
    <               reduce using rule 175 (selected_comp -> name . used_char .)
    LESSEQ          reduce using rule 175 (selected_comp -> name . used_char .)
    >               reduce using rule 175 (selected_comp -> name . used_char .)
    GREATEREQ       reduce using rule 175 (selected_comp -> name . used_char .)
    IN              reduce using rule 175 (selected_comp -> name . used_char .)
    NOT             reduce using rule 175 (selected_comp -> name . used_char .)
    AND             reduce using rule 175 (selected_comp -> name . used_char .)
    OR              reduce using rule 175 (selected_comp -> name . used_char .)
    IS              reduce using rule 175 (selected_comp -> name . used_char .)
    THEN            reduce using rule 175 (selected_comp -> name . used_char .)
    LOOP            reduce using rule 175 (selected_comp -> name . used_char .)
    RENAMES         reduce using rule 175 (selected_comp -> name . used_char .)
    WHEN            reduce using rule 175 (selected_comp -> name . used_char .)


state 387

    (174) selected_comp -> name . simple_name .

    (               reduce using rule 174 (selected_comp -> name . simple_name .)
    .               reduce using rule 174 (selected_comp -> name . simple_name .)
    TICK            reduce using rule 174 (selected_comp -> name . simple_name .)
    ARROW           reduce using rule 174 (selected_comp -> name . simple_name .)
    |               reduce using rule 174 (selected_comp -> name . simple_name .)
    )               reduce using rule 174 (selected_comp -> name . simple_name .)
    ,               reduce using rule 174 (selected_comp -> name . simple_name .)
    STARSTAR        reduce using rule 174 (selected_comp -> name . simple_name .)
    *               reduce using rule 174 (selected_comp -> name . simple_name .)
    /               reduce using rule 174 (selected_comp -> name . simple_name .)
    MOD             reduce using rule 174 (selected_comp -> name . simple_name .)
    REM             reduce using rule 174 (selected_comp -> name . simple_name .)
    DOTDOT          reduce using rule 174 (selected_comp -> name . simple_name .)
    +               reduce using rule 174 (selected_comp -> name . simple_name .)
    -               reduce using rule 174 (selected_comp -> name . simple_name .)
    &               reduce using rule 174 (selected_comp -> name . simple_name .)
    RANGE           reduce using rule 174 (selected_comp -> name . simple_name .)
    DIGITS          reduce using rule 174 (selected_comp -> name . simple_name .)
    WITH            reduce using rule 174 (selected_comp -> name . simple_name .)
    ;               reduce using rule 174 (selected_comp -> name . simple_name .)
    ASSIGNMENT      reduce using rule 174 (selected_comp -> name . simple_name .)
    =               reduce using rule 174 (selected_comp -> name . simple_name .)
    NOTEQUAL        reduce using rule 174 (selected_comp -> name . simple_name .)
    <               reduce using rule 174 (selected_comp -> name . simple_name .)
    LESSEQ          reduce using rule 174 (selected_comp -> name . simple_name .)
    >               reduce using rule 174 (selected_comp -> name . simple_name .)
    GREATEREQ       reduce using rule 174 (selected_comp -> name . simple_name .)
    IN              reduce using rule 174 (selected_comp -> name . simple_name .)
    NOT             reduce using rule 174 (selected_comp -> name . simple_name .)
    AND             reduce using rule 174 (selected_comp -> name . simple_name .)
    OR              reduce using rule 174 (selected_comp -> name . simple_name .)
    IS              reduce using rule 174 (selected_comp -> name . simple_name .)
    THEN            reduce using rule 174 (selected_comp -> name . simple_name .)
    LOOP            reduce using rule 174 (selected_comp -> name . simple_name .)
    RENAMES         reduce using rule 174 (selected_comp -> name . simple_name .)
    WHEN            reduce using rule 174 (selected_comp -> name . simple_name .)


state 388

    (180) attribute_id -> DIGITS .

    (               reduce using rule 180 (attribute_id -> DIGITS .)
    .               reduce using rule 180 (attribute_id -> DIGITS .)
    TICK            reduce using rule 180 (attribute_id -> DIGITS .)
    ;               reduce using rule 180 (attribute_id -> DIGITS .)
    ,               reduce using rule 180 (attribute_id -> DIGITS .)
    WITH            reduce using rule 180 (attribute_id -> DIGITS .)
    WHEN            reduce using rule 180 (attribute_id -> DIGITS .)
    RANGE           reduce using rule 180 (attribute_id -> DIGITS .)
    DIGITS          reduce using rule 180 (attribute_id -> DIGITS .)
    RENAMES         reduce using rule 180 (attribute_id -> DIGITS .)
    ASSIGNMENT      reduce using rule 180 (attribute_id -> DIGITS .)
    IS              reduce using rule 180 (attribute_id -> DIGITS .)
    ARROW           reduce using rule 180 (attribute_id -> DIGITS .)
    |               reduce using rule 180 (attribute_id -> DIGITS .)
    USE             reduce using rule 180 (attribute_id -> DIGITS .)
    )               reduce using rule 180 (attribute_id -> DIGITS .)
    AT              reduce using rule 180 (attribute_id -> DIGITS .)
    STARSTAR        reduce using rule 180 (attribute_id -> DIGITS .)
    *               reduce using rule 180 (attribute_id -> DIGITS .)
    /               reduce using rule 180 (attribute_id -> DIGITS .)
    MOD             reduce using rule 180 (attribute_id -> DIGITS .)
    REM             reduce using rule 180 (attribute_id -> DIGITS .)
    =               reduce using rule 180 (attribute_id -> DIGITS .)
    NOTEQUAL        reduce using rule 180 (attribute_id -> DIGITS .)
    <               reduce using rule 180 (attribute_id -> DIGITS .)
    LESSEQ          reduce using rule 180 (attribute_id -> DIGITS .)
    >               reduce using rule 180 (attribute_id -> DIGITS .)
    GREATEREQ       reduce using rule 180 (attribute_id -> DIGITS .)
    IN              reduce using rule 180 (attribute_id -> DIGITS .)
    NOT             reduce using rule 180 (attribute_id -> DIGITS .)
    +               reduce using rule 180 (attribute_id -> DIGITS .)
    -               reduce using rule 180 (attribute_id -> DIGITS .)
    &               reduce using rule 180 (attribute_id -> DIGITS .)
    AND             reduce using rule 180 (attribute_id -> DIGITS .)
    OR              reduce using rule 180 (attribute_id -> DIGITS .)
    DOTDOT          reduce using rule 180 (attribute_id -> DIGITS .)
    THEN            reduce using rule 180 (attribute_id -> DIGITS .)
    LOOP            reduce using rule 180 (attribute_id -> DIGITS .)


state 389

    (179) attribute_id -> IDENTIFIER .

    (               reduce using rule 179 (attribute_id -> IDENTIFIER .)
    .               reduce using rule 179 (attribute_id -> IDENTIFIER .)
    TICK            reduce using rule 179 (attribute_id -> IDENTIFIER .)
    ;               reduce using rule 179 (attribute_id -> IDENTIFIER .)
    ,               reduce using rule 179 (attribute_id -> IDENTIFIER .)
    WITH            reduce using rule 179 (attribute_id -> IDENTIFIER .)
    WHEN            reduce using rule 179 (attribute_id -> IDENTIFIER .)
    RANGE           reduce using rule 179 (attribute_id -> IDENTIFIER .)
    DIGITS          reduce using rule 179 (attribute_id -> IDENTIFIER .)
    RENAMES         reduce using rule 179 (attribute_id -> IDENTIFIER .)
    ASSIGNMENT      reduce using rule 179 (attribute_id -> IDENTIFIER .)
    IS              reduce using rule 179 (attribute_id -> IDENTIFIER .)
    ARROW           reduce using rule 179 (attribute_id -> IDENTIFIER .)
    |               reduce using rule 179 (attribute_id -> IDENTIFIER .)
    USE             reduce using rule 179 (attribute_id -> IDENTIFIER .)
    )               reduce using rule 179 (attribute_id -> IDENTIFIER .)
    AT              reduce using rule 179 (attribute_id -> IDENTIFIER .)
    STARSTAR        reduce using rule 179 (attribute_id -> IDENTIFIER .)
    *               reduce using rule 179 (attribute_id -> IDENTIFIER .)
    /               reduce using rule 179 (attribute_id -> IDENTIFIER .)
    MOD             reduce using rule 179 (attribute_id -> IDENTIFIER .)
    REM             reduce using rule 179 (attribute_id -> IDENTIFIER .)
    =               reduce using rule 179 (attribute_id -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 179 (attribute_id -> IDENTIFIER .)
    <               reduce using rule 179 (attribute_id -> IDENTIFIER .)
    LESSEQ          reduce using rule 179 (attribute_id -> IDENTIFIER .)
    >               reduce using rule 179 (attribute_id -> IDENTIFIER .)
    GREATEREQ       reduce using rule 179 (attribute_id -> IDENTIFIER .)
    IN              reduce using rule 179 (attribute_id -> IDENTIFIER .)
    NOT             reduce using rule 179 (attribute_id -> IDENTIFIER .)
    +               reduce using rule 179 (attribute_id -> IDENTIFIER .)
    -               reduce using rule 179 (attribute_id -> IDENTIFIER .)
    &               reduce using rule 179 (attribute_id -> IDENTIFIER .)
    AND             reduce using rule 179 (attribute_id -> IDENTIFIER .)
    OR              reduce using rule 179 (attribute_id -> IDENTIFIER .)
    DOTDOT          reduce using rule 179 (attribute_id -> IDENTIFIER .)
    THEN            reduce using rule 179 (attribute_id -> IDENTIFIER .)
    LOOP            reduce using rule 179 (attribute_id -> IDENTIFIER .)


state 390

    (182) attribute_id -> ACCESS .

    (               reduce using rule 182 (attribute_id -> ACCESS .)
    .               reduce using rule 182 (attribute_id -> ACCESS .)
    TICK            reduce using rule 182 (attribute_id -> ACCESS .)
    ;               reduce using rule 182 (attribute_id -> ACCESS .)
    ,               reduce using rule 182 (attribute_id -> ACCESS .)
    WITH            reduce using rule 182 (attribute_id -> ACCESS .)
    WHEN            reduce using rule 182 (attribute_id -> ACCESS .)
    RANGE           reduce using rule 182 (attribute_id -> ACCESS .)
    DIGITS          reduce using rule 182 (attribute_id -> ACCESS .)
    RENAMES         reduce using rule 182 (attribute_id -> ACCESS .)
    ASSIGNMENT      reduce using rule 182 (attribute_id -> ACCESS .)
    IS              reduce using rule 182 (attribute_id -> ACCESS .)
    ARROW           reduce using rule 182 (attribute_id -> ACCESS .)
    |               reduce using rule 182 (attribute_id -> ACCESS .)
    USE             reduce using rule 182 (attribute_id -> ACCESS .)
    )               reduce using rule 182 (attribute_id -> ACCESS .)
    AT              reduce using rule 182 (attribute_id -> ACCESS .)
    STARSTAR        reduce using rule 182 (attribute_id -> ACCESS .)
    *               reduce using rule 182 (attribute_id -> ACCESS .)
    /               reduce using rule 182 (attribute_id -> ACCESS .)
    MOD             reduce using rule 182 (attribute_id -> ACCESS .)
    REM             reduce using rule 182 (attribute_id -> ACCESS .)
    =               reduce using rule 182 (attribute_id -> ACCESS .)
    NOTEQUAL        reduce using rule 182 (attribute_id -> ACCESS .)
    <               reduce using rule 182 (attribute_id -> ACCESS .)
    LESSEQ          reduce using rule 182 (attribute_id -> ACCESS .)
    >               reduce using rule 182 (attribute_id -> ACCESS .)
    GREATEREQ       reduce using rule 182 (attribute_id -> ACCESS .)
    IN              reduce using rule 182 (attribute_id -> ACCESS .)
    NOT             reduce using rule 182 (attribute_id -> ACCESS .)
    +               reduce using rule 182 (attribute_id -> ACCESS .)
    -               reduce using rule 182 (attribute_id -> ACCESS .)
    &               reduce using rule 182 (attribute_id -> ACCESS .)
    AND             reduce using rule 182 (attribute_id -> ACCESS .)
    OR              reduce using rule 182 (attribute_id -> ACCESS .)
    DOTDOT          reduce using rule 182 (attribute_id -> ACCESS .)
    THEN            reduce using rule 182 (attribute_id -> ACCESS .)
    LOOP            reduce using rule 182 (attribute_id -> ACCESS .)


state 391

    (178) attribute -> name TICK attribute_id .

    TICK            reduce using rule 178 (attribute -> name TICK attribute_id .)
    (               reduce using rule 178 (attribute -> name TICK attribute_id .)
    .               reduce using rule 178 (attribute -> name TICK attribute_id .)
    STARSTAR        reduce using rule 178 (attribute -> name TICK attribute_id .)
    *               reduce using rule 178 (attribute -> name TICK attribute_id .)
    /               reduce using rule 178 (attribute -> name TICK attribute_id .)
    MOD             reduce using rule 178 (attribute -> name TICK attribute_id .)
    REM             reduce using rule 178 (attribute -> name TICK attribute_id .)
    =               reduce using rule 178 (attribute -> name TICK attribute_id .)
    NOTEQUAL        reduce using rule 178 (attribute -> name TICK attribute_id .)
    <               reduce using rule 178 (attribute -> name TICK attribute_id .)
    LESSEQ          reduce using rule 178 (attribute -> name TICK attribute_id .)
    >               reduce using rule 178 (attribute -> name TICK attribute_id .)
    GREATEREQ       reduce using rule 178 (attribute -> name TICK attribute_id .)
    IN              reduce using rule 178 (attribute -> name TICK attribute_id .)
    NOT             reduce using rule 178 (attribute -> name TICK attribute_id .)
    +               reduce using rule 178 (attribute -> name TICK attribute_id .)
    -               reduce using rule 178 (attribute -> name TICK attribute_id .)
    &               reduce using rule 178 (attribute -> name TICK attribute_id .)
    AND             reduce using rule 178 (attribute -> name TICK attribute_id .)
    OR              reduce using rule 178 (attribute -> name TICK attribute_id .)
    LOOP            reduce using rule 178 (attribute -> name TICK attribute_id .)
    )               reduce using rule 178 (attribute -> name TICK attribute_id .)
    ,               reduce using rule 178 (attribute -> name TICK attribute_id .)
    WITH            reduce using rule 178 (attribute -> name TICK attribute_id .)
    ARROW           reduce using rule 178 (attribute -> name TICK attribute_id .)
    |               reduce using rule 178 (attribute -> name TICK attribute_id .)
    ;               reduce using rule 178 (attribute -> name TICK attribute_id .)
    IS              reduce using rule 178 (attribute -> name TICK attribute_id .)
    THEN            reduce using rule 178 (attribute -> name TICK attribute_id .)
    RANGE           reduce using rule 178 (attribute -> name TICK attribute_id .)
    DIGITS          reduce using rule 178 (attribute -> name TICK attribute_id .)
    RENAMES         reduce using rule 178 (attribute -> name TICK attribute_id .)
    ASSIGNMENT      reduce using rule 178 (attribute -> name TICK attribute_id .)
    DOTDOT          reduce using rule 178 (attribute -> name TICK attribute_id .)
    WHEN            reduce using rule 178 (attribute -> name TICK attribute_id .)


state 392

    (181) attribute_id -> DELTA .

    (               reduce using rule 181 (attribute_id -> DELTA .)
    .               reduce using rule 181 (attribute_id -> DELTA .)
    TICK            reduce using rule 181 (attribute_id -> DELTA .)
    ;               reduce using rule 181 (attribute_id -> DELTA .)
    ,               reduce using rule 181 (attribute_id -> DELTA .)
    WITH            reduce using rule 181 (attribute_id -> DELTA .)
    WHEN            reduce using rule 181 (attribute_id -> DELTA .)
    RANGE           reduce using rule 181 (attribute_id -> DELTA .)
    DIGITS          reduce using rule 181 (attribute_id -> DELTA .)
    RENAMES         reduce using rule 181 (attribute_id -> DELTA .)
    ASSIGNMENT      reduce using rule 181 (attribute_id -> DELTA .)
    IS              reduce using rule 181 (attribute_id -> DELTA .)
    ARROW           reduce using rule 181 (attribute_id -> DELTA .)
    |               reduce using rule 181 (attribute_id -> DELTA .)
    USE             reduce using rule 181 (attribute_id -> DELTA .)
    )               reduce using rule 181 (attribute_id -> DELTA .)
    AT              reduce using rule 181 (attribute_id -> DELTA .)
    STARSTAR        reduce using rule 181 (attribute_id -> DELTA .)
    *               reduce using rule 181 (attribute_id -> DELTA .)
    /               reduce using rule 181 (attribute_id -> DELTA .)
    MOD             reduce using rule 181 (attribute_id -> DELTA .)
    REM             reduce using rule 181 (attribute_id -> DELTA .)
    =               reduce using rule 181 (attribute_id -> DELTA .)
    NOTEQUAL        reduce using rule 181 (attribute_id -> DELTA .)
    <               reduce using rule 181 (attribute_id -> DELTA .)
    LESSEQ          reduce using rule 181 (attribute_id -> DELTA .)
    >               reduce using rule 181 (attribute_id -> DELTA .)
    GREATEREQ       reduce using rule 181 (attribute_id -> DELTA .)
    IN              reduce using rule 181 (attribute_id -> DELTA .)
    NOT             reduce using rule 181 (attribute_id -> DELTA .)
    +               reduce using rule 181 (attribute_id -> DELTA .)
    -               reduce using rule 181 (attribute_id -> DELTA .)
    &               reduce using rule 181 (attribute_id -> DELTA .)
    AND             reduce using rule 181 (attribute_id -> DELTA .)
    OR              reduce using rule 181 (attribute_id -> DELTA .)
    DOTDOT          reduce using rule 181 (attribute_id -> DELTA .)
    THEN            reduce using rule 181 (attribute_id -> DELTA .)
    LOOP            reduce using rule 181 (attribute_id -> DELTA .)


state 393

    (241) qualified -> name TICK parenthesized_primary .

    STARSTAR        reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    *               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    /               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    MOD             reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    REM             reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    =               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    NOTEQUAL        reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    <               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    LESSEQ          reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    >               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    GREATEREQ       reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    IN              reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    NOT             reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    +               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    -               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    &               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    DIGITS          reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    AND             reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    OR              reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    RANGE           reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    ;               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    )               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    ,               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    DOTDOT          reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    WITH            reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    ARROW           reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    |               reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    IS              reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    THEN            reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    LOOP            reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    RENAMES         reduce using rule 241 (qualified -> name TICK parenthesized_primary .)
    ASSIGNMENT      reduce using rule 241 (qualified -> name TICK parenthesized_primary .)


state 394

    (203) short_circuit -> AND THEN .

    +               reduce using rule 203 (short_circuit -> AND THEN .)
    -               reduce using rule 203 (short_circuit -> AND THEN .)
    NOT             reduce using rule 203 (short_circuit -> AND THEN .)
    INTEGER         reduce using rule 203 (short_circuit -> AND THEN .)
    BASE_INTEGER    reduce using rule 203 (short_circuit -> AND THEN .)
    FLOAT           reduce using rule 203 (short_circuit -> AND THEN .)
    BASE_FLOAT      reduce using rule 203 (short_circuit -> AND THEN .)
    NuLL            reduce using rule 203 (short_circuit -> AND THEN .)
    NEW             reduce using rule 203 (short_circuit -> AND THEN .)
    (               reduce using rule 203 (short_circuit -> AND THEN .)
    CHAR            reduce using rule 203 (short_circuit -> AND THEN .)
    IDENTIFIER      reduce using rule 203 (short_circuit -> AND THEN .)
    STRING          reduce using rule 203 (short_circuit -> AND THEN .)


state 395

    (199) expression -> expression logical m . relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 528
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148

state 396

    (200) expression -> expression short_circuit m . relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 529
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148

state 397

    (204) short_circuit -> OR ELSE .

    +               reduce using rule 204 (short_circuit -> OR ELSE .)
    -               reduce using rule 204 (short_circuit -> OR ELSE .)
    NOT             reduce using rule 204 (short_circuit -> OR ELSE .)
    INTEGER         reduce using rule 204 (short_circuit -> OR ELSE .)
    BASE_INTEGER    reduce using rule 204 (short_circuit -> OR ELSE .)
    FLOAT           reduce using rule 204 (short_circuit -> OR ELSE .)
    BASE_FLOAT      reduce using rule 204 (short_circuit -> OR ELSE .)
    NuLL            reduce using rule 204 (short_circuit -> OR ELSE .)
    NEW             reduce using rule 204 (short_circuit -> OR ELSE .)
    (               reduce using rule 204 (short_circuit -> OR ELSE .)
    CHAR            reduce using rule 204 (short_circuit -> OR ELSE .)
    IDENTIFIER      reduce using rule 204 (short_circuit -> OR ELSE .)
    STRING          reduce using rule 204 (short_circuit -> OR ELSE .)


state 398

    (352) name_s -> name_s , name .
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id

    ;               reduce using rule 352 (name_s -> name_s , name .)
    ,               reduce using rule 352 (name_s -> name_s , name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 399

    (350) use_clause -> USE TYPE name_s ; .

    PACKAGE         reduce using rule 350 (use_clause -> USE TYPE name_s ; .)
    TASK            reduce using rule 350 (use_clause -> USE TYPE name_s ; .)
    PROTECTED       reduce using rule 350 (use_clause -> USE TYPE name_s ; .)
    error           reduce using rule 350 (use_clause -> USE TYPE name_s ; .)
    USE             reduce using rule 350 (use_clause -> USE TYPE name_s ; .)
    PRAGMA          reduce using rule 350 (use_clause -> USE TYPE name_s ; .)
    TYPE            reduce using rule 350 (use_clause -> USE TYPE name_s ; .)
    SUBTYPE         reduce using rule 350 (use_clause -> USE TYPE name_s ; .)
    FOR             reduce using rule 350 (use_clause -> USE TYPE name_s ; .)
    PROCEDURE       reduce using rule 350 (use_clause -> USE TYPE name_s ; .)
    FUNCTION        reduce using rule 350 (use_clause -> USE TYPE name_s ; .)
    GENERIC         reduce using rule 350 (use_clause -> USE TYPE name_s ; .)
    IDENTIFIER      reduce using rule 350 (use_clause -> USE TYPE name_s ; .)
    BEGIN           reduce using rule 350 (use_clause -> USE TYPE name_s ; .)
    PRIVATE         reduce using rule 350 (use_clause -> USE TYPE name_s ; .)
    WITH            reduce using rule 350 (use_clause -> USE TYPE name_s ; .)
    SEPARATE        reduce using rule 350 (use_clause -> USE TYPE name_s ; .)
    END             reduce using rule 350 (use_clause -> USE TYPE name_s ; .)


state 400

    (450) subunit_body -> subprog_body .

    PRAGMA          reduce using rule 450 (subunit_body -> subprog_body .)
    PRIVATE         reduce using rule 450 (subunit_body -> subprog_body .)
    WITH            reduce using rule 450 (subunit_body -> subprog_body .)
    PACKAGE         reduce using rule 450 (subunit_body -> subprog_body .)
    SEPARATE        reduce using rule 450 (subunit_body -> subprog_body .)
    PROCEDURE       reduce using rule 450 (subunit_body -> subprog_body .)
    FUNCTION        reduce using rule 450 (subunit_body -> subprog_body .)
    GENERIC         reduce using rule 450 (subunit_body -> subprog_body .)
    $end            reduce using rule 450 (subunit_body -> subprog_body .)


state 401

    (452) subunit_body -> task_body .

    PRAGMA          reduce using rule 452 (subunit_body -> task_body .)
    PRIVATE         reduce using rule 452 (subunit_body -> task_body .)
    WITH            reduce using rule 452 (subunit_body -> task_body .)
    PACKAGE         reduce using rule 452 (subunit_body -> task_body .)
    SEPARATE        reduce using rule 452 (subunit_body -> task_body .)
    PROCEDURE       reduce using rule 452 (subunit_body -> task_body .)
    FUNCTION        reduce using rule 452 (subunit_body -> task_body .)
    GENERIC         reduce using rule 452 (subunit_body -> task_body .)
    $end            reduce using rule 452 (subunit_body -> task_body .)


state 402

    (385) prot_body -> PROTECTED . BODY simple_name IS prot_op_body_s END id_opt ;

    BODY            shift and go to state 530


state 403

    (449) subunit -> SEPARATE ( compound_name ) subunit_body .

    PRAGMA          reduce using rule 449 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    PRIVATE         reduce using rule 449 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    WITH            reduce using rule 449 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    PACKAGE         reduce using rule 449 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    SEPARATE        reduce using rule 449 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    PROCEDURE       reduce using rule 449 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    FUNCTION        reduce using rule 449 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    GENERIC         reduce using rule 449 (subunit -> SEPARATE ( compound_name ) subunit_body .)
    $end            reduce using rule 449 (subunit -> SEPARATE ( compound_name ) subunit_body .)


state 404

    (368) task_body -> TASK . BODY simple_name IS decl_part block_body END id_opt ;

    BODY            shift and go to state 531


state 405

    (334) subprog_body -> subprog_spec_is_push . decl_part block_body END id_opt ;
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (334) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (343) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (368) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (385) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (349) use_clause -> . USE name_s ;
    (350) use_clause -> . USE TYPE name_s ;
    (503) rep_spec -> . attrib_def
    (504) rep_spec -> . record_type_spec
    (505) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (333) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (313) subprog_decl -> . subprog_spec ;
    (314) subprog_decl -> . generic_subp_inst ;
    (315) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (336) pkg_decl -> . pkg_spec ;
    (337) pkg_decl -> . generic_pkg_inst ;
    (361) task_decl -> . task_spec ;
    (369) prot_decl -> . prot_spec ;
    (458) exception_decl -> . def_id_s : EXCEPTION ;
    (353) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (354) rename_decl -> . def_id_s : EXCEPTION renames ;
    (355) rename_decl -> . rename_unit
    (470) generic_decl -> . generic_formal_part subprog_spec ;
    (471) generic_decl -> . generic_formal_part pkg_spec ;
    (454) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (455) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (456) body_stub -> . subprog_spec IS SEPARATE ;
    (457) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (506) attrib_def -> . FOR mark USE expression ;
    (507) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (512) address_spec -> . FOR mark USE AT expression ;
    (316) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (317) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (318) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (500) generic_subp_inst -> . subprog_spec IS generic_inst
    (338) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (362) task_spec -> . TASK simple_name task_def
    (363) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (370) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (371) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (356) rename_unit -> . PACKAGE compound_name renames ;
    (357) rename_unit -> . subprog_spec renames ;
    (358) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (359) rename_unit -> . generic_formal_part subprog_spec renames ;
    (472) generic_formal_part -> . GENERIC
    (473) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 54
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 406

    (333) subprog_spec_is_push -> subprog_spec . IS

    IS              shift and go to state 532


state 407

    (343) pkg_body -> PACKAGE . BODY compound_name IS decl_part body_opt END c_id_opt ;

    BODY            shift and go to state 98


state 408

    (453) subunit_body -> prot_body .

    PRAGMA          reduce using rule 453 (subunit_body -> prot_body .)
    PRIVATE         reduce using rule 453 (subunit_body -> prot_body .)
    WITH            reduce using rule 453 (subunit_body -> prot_body .)
    PACKAGE         reduce using rule 453 (subunit_body -> prot_body .)
    SEPARATE        reduce using rule 453 (subunit_body -> prot_body .)
    PROCEDURE       reduce using rule 453 (subunit_body -> prot_body .)
    FUNCTION        reduce using rule 453 (subunit_body -> prot_body .)
    GENERIC         reduce using rule 453 (subunit_body -> prot_body .)
    $end            reduce using rule 453 (subunit_body -> prot_body .)


state 409

    (451) subunit_body -> pkg_body .

    PRAGMA          reduce using rule 451 (subunit_body -> pkg_body .)
    PRIVATE         reduce using rule 451 (subunit_body -> pkg_body .)
    WITH            reduce using rule 451 (subunit_body -> pkg_body .)
    PACKAGE         reduce using rule 451 (subunit_body -> pkg_body .)
    SEPARATE        reduce using rule 451 (subunit_body -> pkg_body .)
    PROCEDURE       reduce using rule 451 (subunit_body -> pkg_body .)
    FUNCTION        reduce using rule 451 (subunit_body -> pkg_body .)
    GENERIC         reduce using rule 451 (subunit_body -> pkg_body .)
    $end            reduce using rule 451 (subunit_body -> pkg_body .)


state 410

    (385) prot_body -> PROTECTED BODY simple_name IS . prot_op_body_s END id_opt ;
    (457) body_stub -> PROTECTED BODY simple_name IS . SEPARATE ;
    (386) prot_op_body_s -> . pragma_s
    (387) prot_op_body_s -> . prot_op_body_s prot_op_body pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    SEPARATE        shift and go to state 533
    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)

    prot_op_body_s                 shift and go to state 534
    pragma_s                       shift and go to state 535

state 411

    (372) prot_def -> IS prot_op_decl_s . prot_private_opt END id_opt
    (376) prot_op_decl_s -> prot_op_decl_s . prot_op_decl
    (373) prot_private_opt -> .
    (374) prot_private_opt -> . PRIVATE prot_elem_decl_s
    (377) prot_op_decl -> . entry_decl
    (378) prot_op_decl -> . subprog_spec ;
    (379) prot_op_decl -> . rep_spec
    (380) prot_op_decl -> . pragma
    (393) entry_decl -> . ENTRY IDENTIFIER formal_part_opt ;
    (394) entry_decl -> . ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ;
    (316) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (317) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (318) subprog_spec -> . FUNCTION designator
    (503) rep_spec -> . attrib_def
    (504) rep_spec -> . record_type_spec
    (505) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (506) attrib_def -> . FOR mark USE expression ;
    (507) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (512) address_spec -> . FOR mark USE AT expression ;

    END             reduce using rule 373 (prot_private_opt -> .)
    PRIVATE         shift and go to state 538
    ENTRY           shift and go to state 542
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    PRAGMA          shift and go to state 4
    FOR             shift and go to state 63

    rep_spec                       shift and go to state 536
    entry_decl                     shift and go to state 537
    address_spec                   shift and go to state 52
    record_type_spec               shift and go to state 68
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 539
    prot_private_opt               shift and go to state 540
    pragma                         shift and go to state 541
    prot_op_decl                   shift and go to state 543

state 412

    (371) prot_spec -> PROTECTED TYPE simple_name discrim_part_opt . prot_def
    (372) prot_def -> . IS prot_op_decl_s prot_private_opt END id_opt

    IS              shift and go to state 257

    prot_def                       shift and go to state 544

state 413

    (408) delay_stmt -> DELAY UNTIL . expression ;
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 545

state 414

    (407) delay_stmt -> DELAY expression . ;
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ;               shift and go to state 546
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 415

    (291) iteration -> iter_part . reverse_opt discrete_range
    (293) reverse_opt -> .
    (294) reverse_opt -> . REVERSE

    IDENTIFIER      reduce using rule 293 (reverse_opt -> .)
    STRING          reduce using rule 293 (reverse_opt -> .)
    +               reduce using rule 293 (reverse_opt -> .)
    -               reduce using rule 293 (reverse_opt -> .)
    NOT             reduce using rule 293 (reverse_opt -> .)
    INTEGER         reduce using rule 293 (reverse_opt -> .)
    BASE_INTEGER    reduce using rule 293 (reverse_opt -> .)
    FLOAT           reduce using rule 293 (reverse_opt -> .)
    BASE_FLOAT      reduce using rule 293 (reverse_opt -> .)
    NuLL            reduce using rule 293 (reverse_opt -> .)
    NEW             reduce using rule 293 (reverse_opt -> .)
    (               reduce using rule 293 (reverse_opt -> .)
    CHAR            reduce using rule 293 (reverse_opt -> .)
    REVERSE         shift and go to state 548

    reverse_opt                    shift and go to state 547

state 416

    (292) iter_part -> FOR . IDENTIFIER IN

    IDENTIFIER      shift and go to state 549


state 417

    (286) loop_stmt -> label_opt iteration . m basic_loop id_opt ;
    (197) m -> .

    LOOP            reduce using rule 197 (m -> .)

    m                              shift and go to state 550

state 418

    (298) block -> label_opt block_decl . block_body END id_opt ;
    (301) block_body -> . BEGIN handled_stmt_s

    BEGIN           shift and go to state 162

    block_body                     shift and go to state 551

state 419

    (290) iteration -> WHILE . m condition
    (197) m -> .

    +               reduce using rule 197 (m -> .)
    -               reduce using rule 197 (m -> .)
    NOT             reduce using rule 197 (m -> .)
    INTEGER         reduce using rule 197 (m -> .)
    BASE_INTEGER    reduce using rule 197 (m -> .)
    FLOAT           reduce using rule 197 (m -> .)
    BASE_FLOAT      reduce using rule 197 (m -> .)
    NuLL            reduce using rule 197 (m -> .)
    NEW             reduce using rule 197 (m -> .)
    (               reduce using rule 197 (m -> .)
    CHAR            reduce using rule 197 (m -> .)
    IDENTIFIER      reduce using rule 197 (m -> .)
    STRING          reduce using rule 197 (m -> .)

    m                              shift and go to state 552

state 420

    (300) block_decl -> DECLARE . decl_part
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (334) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (343) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (368) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (385) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (349) use_clause -> . USE name_s ;
    (350) use_clause -> . USE TYPE name_s ;
    (503) rep_spec -> . attrib_def
    (504) rep_spec -> . record_type_spec
    (505) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (333) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (313) subprog_decl -> . subprog_spec ;
    (314) subprog_decl -> . generic_subp_inst ;
    (315) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (336) pkg_decl -> . pkg_spec ;
    (337) pkg_decl -> . generic_pkg_inst ;
    (361) task_decl -> . task_spec ;
    (369) prot_decl -> . prot_spec ;
    (458) exception_decl -> . def_id_s : EXCEPTION ;
    (353) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (354) rename_decl -> . def_id_s : EXCEPTION renames ;
    (355) rename_decl -> . rename_unit
    (470) generic_decl -> . generic_formal_part subprog_spec ;
    (471) generic_decl -> . generic_formal_part pkg_spec ;
    (454) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (455) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (456) body_stub -> . subprog_spec IS SEPARATE ;
    (457) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (506) attrib_def -> . FOR mark USE expression ;
    (507) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (512) address_spec -> . FOR mark USE AT expression ;
    (316) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (317) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (318) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (500) generic_subp_inst -> . subprog_spec IS generic_inst
    (338) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (362) task_spec -> . TASK simple_name task_def
    (363) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (370) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (371) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (356) rename_unit -> . PACKAGE compound_name renames ;
    (357) rename_unit -> . subprog_spec renames ;
    (358) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (359) rename_unit -> . generic_formal_part subprog_spec renames ;
    (472) generic_formal_part -> . GENERIC
    (473) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 553
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 421

    (312) goto_stmt -> GOTO name . ;
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id

    ;               shift and go to state 554
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 422

    (513) code_stmt -> qualified ; .

    LESSLESS        reduce using rule 513 (code_stmt -> qualified ; .)
    error           reduce using rule 513 (code_stmt -> qualified ; .)
    PRAGMA          reduce using rule 513 (code_stmt -> qualified ; .)
    NuLL            reduce using rule 513 (code_stmt -> qualified ; .)
    EXIT            reduce using rule 513 (code_stmt -> qualified ; .)
    RETURN          reduce using rule 513 (code_stmt -> qualified ; .)
    GOTO            reduce using rule 513 (code_stmt -> qualified ; .)
    DELAY           reduce using rule 513 (code_stmt -> qualified ; .)
    ABORT           reduce using rule 513 (code_stmt -> qualified ; .)
    RAISE           reduce using rule 513 (code_stmt -> qualified ; .)
    REQUEUE         reduce using rule 513 (code_stmt -> qualified ; .)
    IF              reduce using rule 513 (code_stmt -> qualified ; .)
    CASE            reduce using rule 513 (code_stmt -> qualified ; .)
    IDENTIFIER      reduce using rule 513 (code_stmt -> qualified ; .)
    ACCEPT          reduce using rule 513 (code_stmt -> qualified ; .)
    SELECT          reduce using rule 513 (code_stmt -> qualified ; .)
    STRING          reduce using rule 513 (code_stmt -> qualified ; .)
    WHILE           reduce using rule 513 (code_stmt -> qualified ; .)
    DECLARE         reduce using rule 513 (code_stmt -> qualified ; .)
    FOR             reduce using rule 513 (code_stmt -> qualified ; .)
    LOOP            reduce using rule 513 (code_stmt -> qualified ; .)
    BEGIN           reduce using rule 513 (code_stmt -> qualified ; .)
    END             reduce using rule 513 (code_stmt -> qualified ; .)
    OR              reduce using rule 513 (code_stmt -> qualified ; .)
    ELSE            reduce using rule 513 (code_stmt -> qualified ; .)
    THEN            reduce using rule 513 (code_stmt -> qualified ; .)
    EXCEPTION       reduce using rule 513 (code_stmt -> qualified ; .)
    ELSIF           reduce using rule 513 (code_stmt -> qualified ; .)
    WHEN            reduce using rule 513 (code_stmt -> qualified ; .)


state 423

    (271) assign_stmt -> name ASSIGNMENT . expression ;
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 555

state 424

    (335) procedure_call -> name ; .

    LESSLESS        reduce using rule 335 (procedure_call -> name ; .)
    error           reduce using rule 335 (procedure_call -> name ; .)
    PRAGMA          reduce using rule 335 (procedure_call -> name ; .)
    NuLL            reduce using rule 335 (procedure_call -> name ; .)
    EXIT            reduce using rule 335 (procedure_call -> name ; .)
    RETURN          reduce using rule 335 (procedure_call -> name ; .)
    GOTO            reduce using rule 335 (procedure_call -> name ; .)
    DELAY           reduce using rule 335 (procedure_call -> name ; .)
    ABORT           reduce using rule 335 (procedure_call -> name ; .)
    RAISE           reduce using rule 335 (procedure_call -> name ; .)
    REQUEUE         reduce using rule 335 (procedure_call -> name ; .)
    IF              reduce using rule 335 (procedure_call -> name ; .)
    CASE            reduce using rule 335 (procedure_call -> name ; .)
    IDENTIFIER      reduce using rule 335 (procedure_call -> name ; .)
    ACCEPT          reduce using rule 335 (procedure_call -> name ; .)
    SELECT          reduce using rule 335 (procedure_call -> name ; .)
    STRING          reduce using rule 335 (procedure_call -> name ; .)
    WHILE           reduce using rule 335 (procedure_call -> name ; .)
    DECLARE         reduce using rule 335 (procedure_call -> name ; .)
    FOR             reduce using rule 335 (procedure_call -> name ; .)
    LOOP            reduce using rule 335 (procedure_call -> name ; .)
    BEGIN           reduce using rule 335 (procedure_call -> name ; .)
    END             reduce using rule 335 (procedure_call -> name ; .)
    EXCEPTION       reduce using rule 335 (procedure_call -> name ; .)
    OR              reduce using rule 335 (procedure_call -> name ; .)
    ELSE            reduce using rule 335 (procedure_call -> name ; .)
    THEN            reduce using rule 335 (procedure_call -> name ; .)
    ELSIF           reduce using rule 335 (procedure_call -> name ; .)
    WHEN            reduce using rule 335 (procedure_call -> name ; .)


state 425

    (428) abort_stmt -> ABORT name_s . ;
    (352) name_s -> name_s . , name

    ;               shift and go to state 556
    ,               shift and go to state 252


state 426

    (270) null_stmt -> NuLL ; .

    LESSLESS        reduce using rule 270 (null_stmt -> NuLL ; .)
    error           reduce using rule 270 (null_stmt -> NuLL ; .)
    PRAGMA          reduce using rule 270 (null_stmt -> NuLL ; .)
    NuLL            reduce using rule 270 (null_stmt -> NuLL ; .)
    EXIT            reduce using rule 270 (null_stmt -> NuLL ; .)
    RETURN          reduce using rule 270 (null_stmt -> NuLL ; .)
    GOTO            reduce using rule 270 (null_stmt -> NuLL ; .)
    DELAY           reduce using rule 270 (null_stmt -> NuLL ; .)
    ABORT           reduce using rule 270 (null_stmt -> NuLL ; .)
    RAISE           reduce using rule 270 (null_stmt -> NuLL ; .)
    REQUEUE         reduce using rule 270 (null_stmt -> NuLL ; .)
    IF              reduce using rule 270 (null_stmt -> NuLL ; .)
    CASE            reduce using rule 270 (null_stmt -> NuLL ; .)
    IDENTIFIER      reduce using rule 270 (null_stmt -> NuLL ; .)
    ACCEPT          reduce using rule 270 (null_stmt -> NuLL ; .)
    SELECT          reduce using rule 270 (null_stmt -> NuLL ; .)
    STRING          reduce using rule 270 (null_stmt -> NuLL ; .)
    WHILE           reduce using rule 270 (null_stmt -> NuLL ; .)
    DECLARE         reduce using rule 270 (null_stmt -> NuLL ; .)
    FOR             reduce using rule 270 (null_stmt -> NuLL ; .)
    LOOP            reduce using rule 270 (null_stmt -> NuLL ; .)
    BEGIN           reduce using rule 270 (null_stmt -> NuLL ; .)
    WHEN            reduce using rule 270 (null_stmt -> NuLL ; .)
    END             reduce using rule 270 (null_stmt -> NuLL ; .)
    EXCEPTION       reduce using rule 270 (null_stmt -> NuLL ; .)
    OR              reduce using rule 270 (null_stmt -> NuLL ; .)
    ELSE            reduce using rule 270 (null_stmt -> NuLL ; .)
    THEN            reduce using rule 270 (null_stmt -> NuLL ; .)
    ELSIF           reduce using rule 270 (null_stmt -> NuLL ; .)


state 427

    (269) label -> LESSLESS IDENTIFIER . MOREMORE

    MOREMORE        shift and go to state 557


state 428

    (310) return_stmt -> RETURN ; .

    LESSLESS        reduce using rule 310 (return_stmt -> RETURN ; .)
    error           reduce using rule 310 (return_stmt -> RETURN ; .)
    PRAGMA          reduce using rule 310 (return_stmt -> RETURN ; .)
    NuLL            reduce using rule 310 (return_stmt -> RETURN ; .)
    EXIT            reduce using rule 310 (return_stmt -> RETURN ; .)
    RETURN          reduce using rule 310 (return_stmt -> RETURN ; .)
    GOTO            reduce using rule 310 (return_stmt -> RETURN ; .)
    DELAY           reduce using rule 310 (return_stmt -> RETURN ; .)
    ABORT           reduce using rule 310 (return_stmt -> RETURN ; .)
    RAISE           reduce using rule 310 (return_stmt -> RETURN ; .)
    REQUEUE         reduce using rule 310 (return_stmt -> RETURN ; .)
    IF              reduce using rule 310 (return_stmt -> RETURN ; .)
    CASE            reduce using rule 310 (return_stmt -> RETURN ; .)
    IDENTIFIER      reduce using rule 310 (return_stmt -> RETURN ; .)
    ACCEPT          reduce using rule 310 (return_stmt -> RETURN ; .)
    SELECT          reduce using rule 310 (return_stmt -> RETURN ; .)
    STRING          reduce using rule 310 (return_stmt -> RETURN ; .)
    WHILE           reduce using rule 310 (return_stmt -> RETURN ; .)
    DECLARE         reduce using rule 310 (return_stmt -> RETURN ; .)
    FOR             reduce using rule 310 (return_stmt -> RETURN ; .)
    LOOP            reduce using rule 310 (return_stmt -> RETURN ; .)
    BEGIN           reduce using rule 310 (return_stmt -> RETURN ; .)
    END             reduce using rule 310 (return_stmt -> RETURN ; .)
    OR              reduce using rule 310 (return_stmt -> RETURN ; .)
    ELSE            reduce using rule 310 (return_stmt -> RETURN ; .)
    EXCEPTION       reduce using rule 310 (return_stmt -> RETURN ; .)
    ELSIF           reduce using rule 310 (return_stmt -> RETURN ; .)
    THEN            reduce using rule 310 (return_stmt -> RETURN ; .)
    WHEN            reduce using rule 310 (return_stmt -> RETURN ; .)


state 429

    (311) return_stmt -> RETURN expression . ;
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ;               shift and go to state 558
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 430

    (404) accept_hdr -> ACCEPT entry_name . formal_part_opt
    (406) entry_name -> entry_name . ( expression )
    (321) formal_part_opt -> .
    (322) formal_part_opt -> . formal_part
    (323) formal_part -> . ( param_s )

    (               shift and go to state 559
    ;               reduce using rule 321 (formal_part_opt -> .)
    DO              reduce using rule 321 (formal_part_opt -> .)

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 560

state 431

    (405) entry_name -> simple_name .

    (               reduce using rule 405 (entry_name -> simple_name .)
    ;               reduce using rule 405 (entry_name -> simple_name .)
    DO              reduce using rule 405 (entry_name -> simple_name .)


state 432

    (418) select_alt -> accept_stmt . stmts_opt
    (426) stmts_opt -> .
    (427) stmts_opt -> . statement_s
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s m statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (305) exit_stmt -> . EXIT name_opt when_opt ;
    (310) return_stmt -> . RETURN ;
    (311) return_stmt -> . RETURN expression ;
    (312) goto_stmt -> . GOTO name ;
    (335) procedure_call -> . name ;
    (407) delay_stmt -> . DELAY expression ;
    (408) delay_stmt -> . DELAY UNTIL expression ;
    (428) abort_stmt -> . ABORT name_s ;
    (467) raise_stmt -> . RAISE name_opt ;
    (513) code_stmt -> . qualified ;
    (468) requeue_stmt -> . REQUEUE name ;
    (469) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (281) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (286) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (298) block -> . label_opt block_decl block_body END id_opt ;
    (402) accept_stmt -> . accept_hdr ;
    (403) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (409) select_stmt -> . select_wait
    (410) select_stmt -> . async_select
    (411) select_stmt -> . timed_entry_call
    (412) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (282) case_hdr -> . CASE expression IS
    (287) label_opt -> .
    (288) label_opt -> . IDENTIFIER :
    (404) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (413) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (423) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (424) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (425) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    OR              reduce using rule 426 (stmts_opt -> .)
    ELSE            reduce using rule 426 (stmts_opt -> .)
    END             reduce using rule 426 (stmts_opt -> .)
    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 287 (label_opt -> .)
    DECLARE         reduce using rule 287 (label_opt -> .)
    FOR             reduce using rule 287 (label_opt -> .)
    LOOP            reduce using rule 287 (label_opt -> .)
    BEGIN           reduce using rule 287 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 139

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 562
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 138
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    attribute                      shift and go to state 121
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    stmts_opt                      shift and go to state 561
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 433

    (424) timed_entry_call -> SELECT entry_call . stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (425) cond_entry_call -> SELECT entry_call . stmts_opt ELSE statement_s END SELECT ;
    (422) delay_or_entry_alt -> entry_call . stmts_opt
    (426) stmts_opt -> .
    (427) stmts_opt -> . statement_s
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s m statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (305) exit_stmt -> . EXIT name_opt when_opt ;
    (310) return_stmt -> . RETURN ;
    (311) return_stmt -> . RETURN expression ;
    (312) goto_stmt -> . GOTO name ;
    (335) procedure_call -> . name ;
    (407) delay_stmt -> . DELAY expression ;
    (408) delay_stmt -> . DELAY UNTIL expression ;
    (428) abort_stmt -> . ABORT name_s ;
    (467) raise_stmt -> . RAISE name_opt ;
    (513) code_stmt -> . qualified ;
    (468) requeue_stmt -> . REQUEUE name ;
    (469) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (281) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (286) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (298) block -> . label_opt block_decl block_body END id_opt ;
    (402) accept_stmt -> . accept_hdr ;
    (403) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (409) select_stmt -> . select_wait
    (410) select_stmt -> . async_select
    (411) select_stmt -> . timed_entry_call
    (412) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (282) case_hdr -> . CASE expression IS
    (287) label_opt -> .
    (288) label_opt -> . IDENTIFIER :
    (404) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (413) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (423) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (424) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (425) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    OR              reduce using rule 426 (stmts_opt -> .)
    ELSE            reduce using rule 426 (stmts_opt -> .)
    THEN            reduce using rule 426 (stmts_opt -> .)
    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 287 (label_opt -> .)
    DECLARE         reduce using rule 287 (label_opt -> .)
    FOR             reduce using rule 287 (label_opt -> .)
    LOOP            reduce using rule 287 (label_opt -> .)
    BEGIN           reduce using rule 287 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 139

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 562
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 138
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    attribute                      shift and go to state 121
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    stmts_opt                      shift and go to state 563
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 434

    (401) entry_call -> procedure_call .

    LESSLESS        reduce using rule 401 (entry_call -> procedure_call .)
    error           reduce using rule 401 (entry_call -> procedure_call .)
    PRAGMA          reduce using rule 401 (entry_call -> procedure_call .)
    NuLL            reduce using rule 401 (entry_call -> procedure_call .)
    EXIT            reduce using rule 401 (entry_call -> procedure_call .)
    RETURN          reduce using rule 401 (entry_call -> procedure_call .)
    GOTO            reduce using rule 401 (entry_call -> procedure_call .)
    DELAY           reduce using rule 401 (entry_call -> procedure_call .)
    ABORT           reduce using rule 401 (entry_call -> procedure_call .)
    RAISE           reduce using rule 401 (entry_call -> procedure_call .)
    REQUEUE         reduce using rule 401 (entry_call -> procedure_call .)
    IF              reduce using rule 401 (entry_call -> procedure_call .)
    CASE            reduce using rule 401 (entry_call -> procedure_call .)
    IDENTIFIER      reduce using rule 401 (entry_call -> procedure_call .)
    ACCEPT          reduce using rule 401 (entry_call -> procedure_call .)
    SELECT          reduce using rule 401 (entry_call -> procedure_call .)
    STRING          reduce using rule 401 (entry_call -> procedure_call .)
    OR              reduce using rule 401 (entry_call -> procedure_call .)
    ELSE            reduce using rule 401 (entry_call -> procedure_call .)
    WHILE           reduce using rule 401 (entry_call -> procedure_call .)
    DECLARE         reduce using rule 401 (entry_call -> procedure_call .)
    FOR             reduce using rule 401 (entry_call -> procedure_call .)
    LOOP            reduce using rule 401 (entry_call -> procedure_call .)
    BEGIN           reduce using rule 401 (entry_call -> procedure_call .)
    THEN            reduce using rule 401 (entry_call -> procedure_call .)


state 435

    (423) async_select -> SELECT delay_or_entry_alt . THEN ABORT statement_s END SELECT ;

    THEN            shift and go to state 564


state 436

    (415) guarded_select_alt -> WHEN . condition ARROW select_alt
    (278) condition -> . expression
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    condition                      shift and go to state 565
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 461

state 437

    (413) select_wait -> SELECT guarded_select_alt . or_select else_opt END SELECT ;
    (416) or_select -> .
    (417) or_select -> . or_select OR guarded_select_alt

    OR              reduce using rule 416 (or_select -> .)
    ELSE            reduce using rule 416 (or_select -> .)
    END             reduce using rule 416 (or_select -> .)

    or_select                      shift and go to state 566

state 438

    (414) guarded_select_alt -> select_alt .

    OR              reduce using rule 414 (guarded_select_alt -> select_alt .)
    ELSE            reduce using rule 414 (guarded_select_alt -> select_alt .)
    END             reduce using rule 414 (guarded_select_alt -> select_alt .)


state 439

    (421) delay_or_entry_alt -> delay_stmt . stmts_opt
    (419) select_alt -> delay_stmt . stmts_opt
    (426) stmts_opt -> .
    (427) stmts_opt -> . statement_s
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s m statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (305) exit_stmt -> . EXIT name_opt when_opt ;
    (310) return_stmt -> . RETURN ;
    (311) return_stmt -> . RETURN expression ;
    (312) goto_stmt -> . GOTO name ;
    (335) procedure_call -> . name ;
    (407) delay_stmt -> . DELAY expression ;
    (408) delay_stmt -> . DELAY UNTIL expression ;
    (428) abort_stmt -> . ABORT name_s ;
    (467) raise_stmt -> . RAISE name_opt ;
    (513) code_stmt -> . qualified ;
    (468) requeue_stmt -> . REQUEUE name ;
    (469) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (281) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (286) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (298) block -> . label_opt block_decl block_body END id_opt ;
    (402) accept_stmt -> . accept_hdr ;
    (403) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (409) select_stmt -> . select_wait
    (410) select_stmt -> . async_select
    (411) select_stmt -> . timed_entry_call
    (412) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (282) case_hdr -> . CASE expression IS
    (287) label_opt -> .
    (288) label_opt -> . IDENTIFIER :
    (404) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (413) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (423) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (424) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (425) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    THEN            reduce using rule 426 (stmts_opt -> .)
    OR              reduce using rule 426 (stmts_opt -> .)
    ELSE            reduce using rule 426 (stmts_opt -> .)
    END             reduce using rule 426 (stmts_opt -> .)
    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 287 (label_opt -> .)
    DECLARE         reduce using rule 287 (label_opt -> .)
    FOR             reduce using rule 287 (label_opt -> .)
    LOOP            reduce using rule 287 (label_opt -> .)
    BEGIN           reduce using rule 287 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 139

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 562
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 138
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    attribute                      shift and go to state 121
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    stmts_opt                      shift and go to state 567
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 440

    (335) procedure_call -> name . ;
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id

    ;               shift and go to state 424
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 441

    (420) select_alt -> TERMINATE . ;

    ;               shift and go to state 568


state 442

    (247) statement -> label statement .

    LESSLESS        reduce using rule 247 (statement -> label statement .)
    error           reduce using rule 247 (statement -> label statement .)
    PRAGMA          reduce using rule 247 (statement -> label statement .)
    NuLL            reduce using rule 247 (statement -> label statement .)
    EXIT            reduce using rule 247 (statement -> label statement .)
    RETURN          reduce using rule 247 (statement -> label statement .)
    GOTO            reduce using rule 247 (statement -> label statement .)
    DELAY           reduce using rule 247 (statement -> label statement .)
    ABORT           reduce using rule 247 (statement -> label statement .)
    RAISE           reduce using rule 247 (statement -> label statement .)
    REQUEUE         reduce using rule 247 (statement -> label statement .)
    IF              reduce using rule 247 (statement -> label statement .)
    CASE            reduce using rule 247 (statement -> label statement .)
    IDENTIFIER      reduce using rule 247 (statement -> label statement .)
    ACCEPT          reduce using rule 247 (statement -> label statement .)
    SELECT          reduce using rule 247 (statement -> label statement .)
    STRING          reduce using rule 247 (statement -> label statement .)
    WHILE           reduce using rule 247 (statement -> label statement .)
    DECLARE         reduce using rule 247 (statement -> label statement .)
    FOR             reduce using rule 247 (statement -> label statement .)
    LOOP            reduce using rule 247 (statement -> label statement .)
    BEGIN           reduce using rule 247 (statement -> label statement .)
    END             reduce using rule 247 (statement -> label statement .)
    WHEN            reduce using rule 247 (statement -> label statement .)
    ELSIF           reduce using rule 247 (statement -> label statement .)
    ELSE            reduce using rule 247 (statement -> label statement .)
    OR              reduce using rule 247 (statement -> label statement .)
    EXCEPTION       reduce using rule 247 (statement -> label statement .)
    THEN            reduce using rule 247 (statement -> label statement .)


state 443

    (281) case_stmt -> case_hdr pragma_s . alternative_s END CASE ;
    (9) pragma_s -> pragma_s . pragma
    (283) alternative_s -> .
    (284) alternative_s -> . alternative_s alternative
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 283 (alternative_s -> .)
    WHEN            reduce using rule 283 (alternative_s -> .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14
    alternative_s                  shift and go to state 569

state 444

    (307) name_opt -> name .
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id

    ;               reduce using rule 307 (name_opt -> name .)
    WHEN            reduce using rule 307 (name_opt -> name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 445

    (467) raise_stmt -> RAISE name_opt . ;

    ;               shift and go to state 570


state 446

    (282) case_hdr -> CASE expression . IS
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    IS              shift and go to state 571
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 447

    (468) requeue_stmt -> REQUEUE name . ;
    (469) requeue_stmt -> REQUEUE name . WITH ABORT ;
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id

    ;               shift and go to state 572
    WITH            shift and go to state 573
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 448

    (288) label_opt -> IDENTIFIER : .

    WHILE           reduce using rule 288 (label_opt -> IDENTIFIER : .)
    DECLARE         reduce using rule 288 (label_opt -> IDENTIFIER : .)
    FOR             reduce using rule 288 (label_opt -> IDENTIFIER : .)
    LOOP            reduce using rule 288 (label_opt -> IDENTIFIER : .)
    BEGIN           reduce using rule 288 (label_opt -> IDENTIFIER : .)


state 449

    (403) accept_stmt -> accept_hdr DO . handled_stmt_s END id_opt ;
    (302) handled_stmt_s -> . statement_s except_handler_part_opt
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s m statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (305) exit_stmt -> . EXIT name_opt when_opt ;
    (310) return_stmt -> . RETURN ;
    (311) return_stmt -> . RETURN expression ;
    (312) goto_stmt -> . GOTO name ;
    (335) procedure_call -> . name ;
    (407) delay_stmt -> . DELAY expression ;
    (408) delay_stmt -> . DELAY UNTIL expression ;
    (428) abort_stmt -> . ABORT name_s ;
    (467) raise_stmt -> . RAISE name_opt ;
    (513) code_stmt -> . qualified ;
    (468) requeue_stmt -> . REQUEUE name ;
    (469) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (281) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (286) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (298) block -> . label_opt block_decl block_body END id_opt ;
    (402) accept_stmt -> . accept_hdr ;
    (403) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (409) select_stmt -> . select_wait
    (410) select_stmt -> . async_select
    (411) select_stmt -> . timed_entry_call
    (412) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (282) case_hdr -> . CASE expression IS
    (287) label_opt -> .
    (288) label_opt -> . IDENTIFIER :
    (404) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (413) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (423) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (424) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (425) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 287 (label_opt -> .)
    DECLARE         reduce using rule 287 (label_opt -> .)
    FOR             reduce using rule 287 (label_opt -> .)
    LOOP            reduce using rule 287 (label_opt -> .)
    BEGIN           reduce using rule 287 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 139

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    label                          shift and go to state 279
    statement_s                    shift and go to state 300
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    handled_stmt_s                 shift and go to state 574
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 138
    assign_stmt                    shift and go to state 308
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    attribute                      shift and go to state 121
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    accept_hdr                     shift and go to state 292
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    qualified                      shift and go to state 267
    label_opt                      shift and go to state 263
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 450

    (402) accept_stmt -> accept_hdr ; .

    LESSLESS        reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    error           reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    PRAGMA          reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    NuLL            reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    EXIT            reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    RETURN          reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    GOTO            reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    DELAY           reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    ABORT           reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    RAISE           reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    REQUEUE         reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    IF              reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    CASE            reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    IDENTIFIER      reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    ACCEPT          reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    SELECT          reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    STRING          reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    WHILE           reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    DECLARE         reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    FOR             reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    LOOP            reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    BEGIN           reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    WHEN            reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    END             reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    EXCEPTION       reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    OR              reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    ELSE            reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    THEN            reduce using rule 402 (accept_stmt -> accept_hdr ; .)
    ELSIF           reduce using rule 402 (accept_stmt -> accept_hdr ; .)


state 451

    (305) exit_stmt -> EXIT name_opt . when_opt ;
    (308) when_opt -> .
    (309) when_opt -> . WHEN condition

    ;               reduce using rule 308 (when_opt -> .)
    WHEN            shift and go to state 576

    when_opt                       shift and go to state 575

state 452

    (262) simple_stmt -> error ; .

    LESSLESS        reduce using rule 262 (simple_stmt -> error ; .)
    error           reduce using rule 262 (simple_stmt -> error ; .)
    PRAGMA          reduce using rule 262 (simple_stmt -> error ; .)
    NuLL            reduce using rule 262 (simple_stmt -> error ; .)
    EXIT            reduce using rule 262 (simple_stmt -> error ; .)
    RETURN          reduce using rule 262 (simple_stmt -> error ; .)
    GOTO            reduce using rule 262 (simple_stmt -> error ; .)
    DELAY           reduce using rule 262 (simple_stmt -> error ; .)
    ABORT           reduce using rule 262 (simple_stmt -> error ; .)
    RAISE           reduce using rule 262 (simple_stmt -> error ; .)
    REQUEUE         reduce using rule 262 (simple_stmt -> error ; .)
    IF              reduce using rule 262 (simple_stmt -> error ; .)
    CASE            reduce using rule 262 (simple_stmt -> error ; .)
    IDENTIFIER      reduce using rule 262 (simple_stmt -> error ; .)
    ACCEPT          reduce using rule 262 (simple_stmt -> error ; .)
    SELECT          reduce using rule 262 (simple_stmt -> error ; .)
    STRING          reduce using rule 262 (simple_stmt -> error ; .)
    WHILE           reduce using rule 262 (simple_stmt -> error ; .)
    DECLARE         reduce using rule 262 (simple_stmt -> error ; .)
    FOR             reduce using rule 262 (simple_stmt -> error ; .)
    LOOP            reduce using rule 262 (simple_stmt -> error ; .)
    BEGIN           reduce using rule 262 (simple_stmt -> error ; .)
    END             reduce using rule 262 (simple_stmt -> error ; .)
    WHEN            reduce using rule 262 (simple_stmt -> error ; .)
    THEN            reduce using rule 262 (simple_stmt -> error ; .)
    OR              reduce using rule 262 (simple_stmt -> error ; .)
    ELSE            reduce using rule 262 (simple_stmt -> error ; .)
    EXCEPTION       reduce using rule 262 (simple_stmt -> error ; .)
    ELSIF           reduce using rule 262 (simple_stmt -> error ; .)


state 453

    (459) except_handler_part -> EXCEPTION . exception_handler
    (461) exception_handler -> . WHEN except_choice_s ARROW statement_s
    (462) exception_handler -> . WHEN IDENTIFIER : except_choice_s ARROW statement_s

    WHEN            shift and go to state 578

    exception_handler              shift and go to state 577

state 454

    (245) statement_s -> statement_s m . statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (305) exit_stmt -> . EXIT name_opt when_opt ;
    (310) return_stmt -> . RETURN ;
    (311) return_stmt -> . RETURN expression ;
    (312) goto_stmt -> . GOTO name ;
    (335) procedure_call -> . name ;
    (407) delay_stmt -> . DELAY expression ;
    (408) delay_stmt -> . DELAY UNTIL expression ;
    (428) abort_stmt -> . ABORT name_s ;
    (467) raise_stmt -> . RAISE name_opt ;
    (513) code_stmt -> . qualified ;
    (468) requeue_stmt -> . REQUEUE name ;
    (469) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (281) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (286) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (298) block -> . label_opt block_decl block_body END id_opt ;
    (402) accept_stmt -> . accept_hdr ;
    (403) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (409) select_stmt -> . select_wait
    (410) select_stmt -> . async_select
    (411) select_stmt -> . timed_entry_call
    (412) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (282) case_hdr -> . CASE expression IS
    (287) label_opt -> .
    (288) label_opt -> . IDENTIFIER :
    (404) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (413) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (423) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (424) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (425) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 287 (label_opt -> .)
    DECLARE         reduce using rule 287 (label_opt -> .)
    FOR             reduce using rule 287 (label_opt -> .)
    LOOP            reduce using rule 287 (label_opt -> .)
    BEGIN           reduce using rule 287 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 139

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 138
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 579
    attribute                      shift and go to state 121
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 455

    (304) except_handler_part_opt -> except_handler_part .
    (460) except_handler_part -> except_handler_part . exception_handler
    (461) exception_handler -> . WHEN except_choice_s ARROW statement_s
    (462) exception_handler -> . WHEN IDENTIFIER : except_choice_s ARROW statement_s

    END             reduce using rule 304 (except_handler_part_opt -> except_handler_part .)
    WHEN            shift and go to state 578

    exception_handler              shift and go to state 580

state 456

    (302) handled_stmt_s -> statement_s except_handler_part_opt .

    END             reduce using rule 302 (handled_stmt_s -> statement_s except_handler_part_opt .)


state 457

    (272) if_stmt -> IF cond_clause_s . else_opt END IF ;
    (279) else_opt -> .
    (280) else_opt -> . ELSE m statement_s

    END             reduce using rule 279 (else_opt -> .)
    ELSE            shift and go to state 581

    else_opt                       shift and go to state 582

state 458

    (273) cond_clause_s -> cond_clause .
    (274) cond_clause_s -> cond_clause . ELSIF m cond_clause_s

    ELSE            reduce using rule 273 (cond_clause_s -> cond_clause .)
    END             reduce using rule 273 (cond_clause_s -> cond_clause .)
    ELSIF           shift and go to state 583


state 459

    (276) cond_clause -> cond_part . m statement_s n
    (197) m -> .

    LESSLESS        reduce using rule 197 (m -> .)
    error           reduce using rule 197 (m -> .)
    PRAGMA          reduce using rule 197 (m -> .)
    NuLL            reduce using rule 197 (m -> .)
    EXIT            reduce using rule 197 (m -> .)
    RETURN          reduce using rule 197 (m -> .)
    GOTO            reduce using rule 197 (m -> .)
    DELAY           reduce using rule 197 (m -> .)
    ABORT           reduce using rule 197 (m -> .)
    RAISE           reduce using rule 197 (m -> .)
    REQUEUE         reduce using rule 197 (m -> .)
    IF              reduce using rule 197 (m -> .)
    CASE            reduce using rule 197 (m -> .)
    IDENTIFIER      reduce using rule 197 (m -> .)
    ACCEPT          reduce using rule 197 (m -> .)
    SELECT          reduce using rule 197 (m -> .)
    STRING          reduce using rule 197 (m -> .)
    WHILE           reduce using rule 197 (m -> .)
    DECLARE         reduce using rule 197 (m -> .)
    FOR             reduce using rule 197 (m -> .)
    LOOP            reduce using rule 197 (m -> .)
    BEGIN           reduce using rule 197 (m -> .)

    m                              shift and go to state 584

state 460

    (277) cond_part -> condition . THEN

    THEN            shift and go to state 585


state 461

    (278) condition -> expression .
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ;               reduce using rule 278 (condition -> expression .)
    IS              reduce using rule 278 (condition -> expression .)
    ARROW           reduce using rule 278 (condition -> expression .)
    THEN            reduce using rule 278 (condition -> expression .)
    LOOP            reduce using rule 278 (condition -> expression .)
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 462

    (297) id_opt -> designator .

    ;               reduce using rule 297 (id_opt -> designator .)


state 463

    (334) subprog_body -> subprog_spec_is_push decl_part block_body END id_opt . ;

    ;               shift and go to state 586


state 464

    (507) record_type_spec -> FOR mark USE RECORD . align_opt comp_loc_s END RECORD ;
    (508) align_opt -> .
    (509) align_opt -> . AT MOD expression ;

    END             reduce using rule 508 (align_opt -> .)
    IDENTIFIER      reduce using rule 508 (align_opt -> .)
    AT              shift and go to state 588

    align_opt                      shift and go to state 587

state 465

    (512) address_spec -> FOR mark USE AT . expression ;
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 589

state 466

    (506) attrib_def -> FOR mark USE expression . ;
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ;               shift and go to state 590
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 467

    (160) mark -> mark . simple_name .

    TICK            reduce using rule 160 (mark -> mark . simple_name .)
    .               reduce using rule 160 (mark -> mark . simple_name .)
    ;               reduce using rule 160 (mark -> mark . simple_name .)
    USE             reduce using rule 160 (mark -> mark . simple_name .)
    AT              reduce using rule 160 (mark -> mark . simple_name .)
    ASSIGNMENT      reduce using rule 160 (mark -> mark . simple_name .)
    )               reduce using rule 160 (mark -> mark . simple_name .)


state 468

    (159) mark -> mark TICK attribute_id .

    TICK            reduce using rule 159 (mark -> mark TICK attribute_id .)
    .               reduce using rule 159 (mark -> mark TICK attribute_id .)
    ;               reduce using rule 159 (mark -> mark TICK attribute_id .)
    USE             reduce using rule 159 (mark -> mark TICK attribute_id .)
    AT              reduce using rule 159 (mark -> mark TICK attribute_id .)
    ASSIGNMENT      reduce using rule 159 (mark -> mark TICK attribute_id .)
    )               reduce using rule 159 (mark -> mark TICK attribute_id .)


state 469

    (368) task_body -> TASK BODY simple_name IS . decl_part block_body END id_opt ;
    (454) body_stub -> TASK BODY simple_name IS . SEPARATE ;
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (334) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (343) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (368) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (385) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (349) use_clause -> . USE name_s ;
    (350) use_clause -> . USE TYPE name_s ;
    (503) rep_spec -> . attrib_def
    (504) rep_spec -> . record_type_spec
    (505) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (333) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (313) subprog_decl -> . subprog_spec ;
    (314) subprog_decl -> . generic_subp_inst ;
    (315) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (336) pkg_decl -> . pkg_spec ;
    (337) pkg_decl -> . generic_pkg_inst ;
    (361) task_decl -> . task_spec ;
    (369) prot_decl -> . prot_spec ;
    (458) exception_decl -> . def_id_s : EXCEPTION ;
    (353) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (354) rename_decl -> . def_id_s : EXCEPTION renames ;
    (355) rename_decl -> . rename_unit
    (470) generic_decl -> . generic_formal_part subprog_spec ;
    (471) generic_decl -> . generic_formal_part pkg_spec ;
    (454) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (455) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (456) body_stub -> . subprog_spec IS SEPARATE ;
    (457) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (506) attrib_def -> . FOR mark USE expression ;
    (507) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (512) address_spec -> . FOR mark USE AT expression ;
    (316) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (317) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (318) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (500) generic_subp_inst -> . subprog_spec IS generic_inst
    (338) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (362) task_spec -> . TASK simple_name task_def
    (363) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (370) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (371) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (356) rename_unit -> . PACKAGE compound_name renames ;
    (357) rename_unit -> . subprog_spec renames ;
    (358) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (359) rename_unit -> . generic_formal_part subprog_spec renames ;
    (472) generic_formal_part -> . GENERIC
    (473) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    SEPARATE        shift and go to state 591
    BEGIN           reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    decl_item                      shift and go to state 53
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 592
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 470

    (363) task_spec -> TASK TYPE simple_name discrim_part_opt . task_def
    (364) task_def -> .
    (365) task_def -> . IS entry_decl_s rep_spec_s task_private_opt END id_opt

    ;               reduce using rule 364 (task_def -> .)
    IS              shift and go to state 315

    task_def                       shift and go to state 593

state 471

    (365) task_def -> IS entry_decl_s . rep_spec_s task_private_opt END id_opt
    (392) entry_decl_s -> entry_decl_s . entry_decl pragma_s
    (399) rep_spec_s -> .
    (400) rep_spec_s -> . rep_spec_s rep_spec pragma_s
    (393) entry_decl -> . ENTRY IDENTIFIER formal_part_opt ;
    (394) entry_decl -> . ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ;

    PRIVATE         reduce using rule 399 (rep_spec_s -> .)
    FOR             reduce using rule 399 (rep_spec_s -> .)
    END             reduce using rule 399 (rep_spec_s -> .)
    ENTRY           shift and go to state 542

    rep_spec_s                     shift and go to state 594
    entry_decl                     shift and go to state 595

state 472

    (391) entry_decl_s -> pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    ENTRY           reduce using rule 391 (entry_decl_s -> pragma_s .)
    FOR             reduce using rule 391 (entry_decl_s -> pragma_s .)
    END             reduce using rule 391 (entry_decl_s -> pragma_s .)
    PRIVATE         reduce using rule 391 (entry_decl_s -> pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 473

    (343) pkg_body -> PACKAGE BODY compound_name IS . decl_part body_opt END c_id_opt ;
    (455) body_stub -> PACKAGE BODY compound_name IS . SEPARATE ;
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (334) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (343) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (368) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (385) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (349) use_clause -> . USE name_s ;
    (350) use_clause -> . USE TYPE name_s ;
    (503) rep_spec -> . attrib_def
    (504) rep_spec -> . record_type_spec
    (505) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (333) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (313) subprog_decl -> . subprog_spec ;
    (314) subprog_decl -> . generic_subp_inst ;
    (315) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (336) pkg_decl -> . pkg_spec ;
    (337) pkg_decl -> . generic_pkg_inst ;
    (361) task_decl -> . task_spec ;
    (369) prot_decl -> . prot_spec ;
    (458) exception_decl -> . def_id_s : EXCEPTION ;
    (353) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (354) rename_decl -> . def_id_s : EXCEPTION renames ;
    (355) rename_decl -> . rename_unit
    (470) generic_decl -> . generic_formal_part subprog_spec ;
    (471) generic_decl -> . generic_formal_part pkg_spec ;
    (454) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (455) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (456) body_stub -> . subprog_spec IS SEPARATE ;
    (457) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (506) attrib_def -> . FOR mark USE expression ;
    (507) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (512) address_spec -> . FOR mark USE AT expression ;
    (316) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (317) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (318) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (500) generic_subp_inst -> . subprog_spec IS generic_inst
    (338) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (362) task_spec -> . TASK simple_name task_def
    (363) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (370) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (371) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (356) rename_unit -> . PACKAGE compound_name renames ;
    (357) rename_unit -> . subprog_spec renames ;
    (358) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (359) rename_unit -> . generic_formal_part subprog_spec renames ;
    (472) generic_formal_part -> . GENERIC
    (473) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    SEPARATE        shift and go to state 596
    BEGIN           reduce using rule 135 (decl_part -> .)
    END             reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 494
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 474

    (114) discrim_spec -> error .

    )               reduce using rule 114 (discrim_spec -> error .)
    ;               reduce using rule 114 (discrim_spec -> error .)


state 475

    (110) discrim_part -> ( discrim_spec_s . )
    (112) discrim_spec_s -> discrim_spec_s . ; discrim_spec

    )               shift and go to state 597
    ;               shift and go to state 598


state 476

    (113) discrim_spec -> def_id_s . : access_opt mark init_opt
    (25) def_id_s -> def_id_s . , def_id

    :               shift and go to state 599
    ,               shift and go to state 179


state 477

    (111) discrim_spec_s -> discrim_spec .

    )               reduce using rule 111 (discrim_spec_s -> discrim_spec .)
    ;               reduce using rule 111 (discrim_spec_s -> discrim_spec .)


state 478

    (39) discrim_part_opt -> ( LESSMORE . )

    )               shift and go to state 600


state 479

    (41) type_completion -> IS . type_def
    (42) type_def -> . enumeration_type
    (43) type_def -> . integer_type
    (44) type_def -> . real_type
    (45) type_def -> . array_type
    (46) type_def -> . record_type
    (47) type_def -> . access_type
    (48) type_def -> . derived_type
    (49) type_def -> . private_type
    (64) enumeration_type -> . ( enum_id_s )
    (69) integer_type -> . range_spec
    (73) real_type -> . float_type
    (74) real_type -> . fixed_type
    (78) array_type -> . unconstr_array_type
    (79) array_type -> . constr_array_type
    (95) record_type -> . tagged_opt limited_opt record_def
    (128) access_type -> . ACCESS subtype_ind
    (129) access_type -> . ACCESS CONSTANT subtype_ind
    (130) access_type -> . ACCESS ALL subtype_ind
    (131) access_type -> . ACCESS prot_opt PROCEDURE formal_part_opt
    (132) access_type -> . ACCESS prot_opt FUNCTION formal_part_opt RETURN mark
    (56) derived_type -> . NEW subtype_ind
    (57) derived_type -> . NEW subtype_ind WITH PRIVATE
    (58) derived_type -> . NEW subtype_ind WITH record_def
    (59) derived_type -> . ABSTRACT NEW subtype_ind WITH PRIVATE
    (60) derived_type -> . ABSTRACT NEW subtype_ind WITH record_def
    (346) private_type -> . tagged_opt limited_opt PRIVATE
    (70) range_spec -> . range_constraint
    (75) float_type -> . DIGITS expression range_spec_opt
    (76) fixed_type -> . DELTA expression range_spec
    (77) fixed_type -> . DELTA expression DIGITS expression range_spec_opt
    (80) unconstr_array_type -> . ARRAY ( index_s ) OF component_subtype_def
    (81) constr_array_type -> . ARRAY iter_index_constraint OF subtype_ind
    (98) tagged_opt -> .
    (99) tagged_opt -> . TAGGED
    (100) tagged_opt -> . ABSTRACT TAGGED
    (61) range_constraint -> . RANGE range

    (               shift and go to state 610
    ACCESS          shift and go to state 618
    NEW             shift and go to state 606
    ABSTRACT        shift and go to state 601
    DIGITS          shift and go to state 611
    DELTA           shift and go to state 613
    ARRAY           shift and go to state 489
    LIMITED         reduce using rule 98 (tagged_opt -> .)
    PRIVATE         reduce using rule 98 (tagged_opt -> .)
    RECORD          reduce using rule 98 (tagged_opt -> .)
    NuLL            reduce using rule 98 (tagged_opt -> .)
    TAGGED          shift and go to state 612
    RANGE           shift and go to state 371

    access_type                    shift and go to state 603
    record_type                    shift and go to state 604
    real_type                      shift and go to state 605
    range_constraint               shift and go to state 602
    enumeration_type               shift and go to state 607
    private_type                   shift and go to state 608
    float_type                     shift and go to state 609
    tagged_opt                     shift and go to state 619
    integer_type                   shift and go to state 614
    array_type                     shift and go to state 615
    range_spec                     shift and go to state 616
    type_def                       shift and go to state 617
    constr_array_type              shift and go to state 491
    derived_type                   shift and go to state 620
    fixed_type                     shift and go to state 621
    unconstr_array_type            shift and go to state 493

state 480

    (36) type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion . ;

    ;               shift and go to state 622


state 481

    (51) subtype_ind -> name . constraint
    (52) subtype_ind -> name .
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id
    (53) constraint -> . range_constraint
    (54) constraint -> . decimal_digits_constraint
    (61) range_constraint -> . RANGE range
    (55) decimal_digits_constraint -> . DIGITS expression range_constr_opt

    WITH            reduce using rule 52 (subtype_ind -> name .)
    ;               reduce using rule 52 (subtype_ind -> name .)
    ASSIGNMENT      reduce using rule 52 (subtype_ind -> name .)
    RENAMES         reduce using rule 52 (subtype_ind -> name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253
    RANGE           shift and go to state 371
    DIGITS          shift and go to state 623

    constraint                     shift and go to state 624
    range_constraint               shift and go to state 625
    decimal_digits_constraint      shift and go to state 626

state 482

    (50) subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind . ;

    ;               shift and go to state 627


state 483

    (456) body_stub -> subprog_spec IS SEPARATE ; .

    PACKAGE         reduce using rule 456 (body_stub -> subprog_spec IS SEPARATE ; .)
    TASK            reduce using rule 456 (body_stub -> subprog_spec IS SEPARATE ; .)
    PROTECTED       reduce using rule 456 (body_stub -> subprog_spec IS SEPARATE ; .)
    error           reduce using rule 456 (body_stub -> subprog_spec IS SEPARATE ; .)
    USE             reduce using rule 456 (body_stub -> subprog_spec IS SEPARATE ; .)
    PRAGMA          reduce using rule 456 (body_stub -> subprog_spec IS SEPARATE ; .)
    TYPE            reduce using rule 456 (body_stub -> subprog_spec IS SEPARATE ; .)
    SUBTYPE         reduce using rule 456 (body_stub -> subprog_spec IS SEPARATE ; .)
    FOR             reduce using rule 456 (body_stub -> subprog_spec IS SEPARATE ; .)
    PROCEDURE       reduce using rule 456 (body_stub -> subprog_spec IS SEPARATE ; .)
    FUNCTION        reduce using rule 456 (body_stub -> subprog_spec IS SEPARATE ; .)
    GENERIC         reduce using rule 456 (body_stub -> subprog_spec IS SEPARATE ; .)
    IDENTIFIER      reduce using rule 456 (body_stub -> subprog_spec IS SEPARATE ; .)
    BEGIN           reduce using rule 456 (body_stub -> subprog_spec IS SEPARATE ; .)
    END             reduce using rule 456 (body_stub -> subprog_spec IS SEPARATE ; .)
    PRIVATE         reduce using rule 456 (body_stub -> subprog_spec IS SEPARATE ; .)


state 484

    (354) rename_decl -> def_id_s : EXCEPTION renames . ;

    ;               shift and go to state 628


state 485

    (458) exception_decl -> def_id_s : EXCEPTION ; .

    PACKAGE         reduce using rule 458 (exception_decl -> def_id_s : EXCEPTION ; .)
    TASK            reduce using rule 458 (exception_decl -> def_id_s : EXCEPTION ; .)
    PROTECTED       reduce using rule 458 (exception_decl -> def_id_s : EXCEPTION ; .)
    error           reduce using rule 458 (exception_decl -> def_id_s : EXCEPTION ; .)
    USE             reduce using rule 458 (exception_decl -> def_id_s : EXCEPTION ; .)
    PRAGMA          reduce using rule 458 (exception_decl -> def_id_s : EXCEPTION ; .)
    TYPE            reduce using rule 458 (exception_decl -> def_id_s : EXCEPTION ; .)
    SUBTYPE         reduce using rule 458 (exception_decl -> def_id_s : EXCEPTION ; .)
    FOR             reduce using rule 458 (exception_decl -> def_id_s : EXCEPTION ; .)
    PROCEDURE       reduce using rule 458 (exception_decl -> def_id_s : EXCEPTION ; .)
    FUNCTION        reduce using rule 458 (exception_decl -> def_id_s : EXCEPTION ; .)
    GENERIC         reduce using rule 458 (exception_decl -> def_id_s : EXCEPTION ; .)
    IDENTIFIER      reduce using rule 458 (exception_decl -> def_id_s : EXCEPTION ; .)
    BEGIN           reduce using rule 458 (exception_decl -> def_id_s : EXCEPTION ; .)
    PRIVATE         reduce using rule 458 (exception_decl -> def_id_s : EXCEPTION ; .)
    END             reduce using rule 458 (exception_decl -> def_id_s : EXCEPTION ; .)


state 486

    (35) number_decl -> def_id_s : CONSTANT ASSIGNMENT . expression ;
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 629

state 487

    (29) object_qualifier_opt -> ALIASED CONSTANT .

    ARRAY           reduce using rule 29 (object_qualifier_opt -> ALIASED CONSTANT .)
    IDENTIFIER      reduce using rule 29 (object_qualifier_opt -> ALIASED CONSTANT .)
    STRING          reduce using rule 29 (object_qualifier_opt -> ALIASED CONSTANT .)


state 488

    (32) object_subtype_def -> array_type .

    ASSIGNMENT      reduce using rule 32 (object_subtype_def -> array_type .)
    ;               reduce using rule 32 (object_subtype_def -> array_type .)


state 489

    (80) unconstr_array_type -> ARRAY . ( index_s ) OF component_subtype_def
    (81) constr_array_type -> ARRAY . iter_index_constraint OF subtype_ind
    (88) iter_index_constraint -> . ( iter_discrete_range_s )

    (               shift and go to state 630

    iter_index_constraint          shift and go to state 631

state 490

    (23) object_decl -> def_id_s : object_qualifier_opt object_subtype_def . init_opt ;
    (33) init_opt -> .
    (34) init_opt -> . ASSIGNMENT expression

    ;               reduce using rule 33 (init_opt -> .)
    ASSIGNMENT      shift and go to state 632

    init_opt                       shift and go to state 633

state 491

    (79) array_type -> constr_array_type .

    ;               reduce using rule 79 (array_type -> constr_array_type .)
    ASSIGNMENT      reduce using rule 79 (array_type -> constr_array_type .)


state 492

    (353) rename_decl -> def_id_s : object_qualifier_opt subtype_ind . renames ;
    (31) object_subtype_def -> subtype_ind .
    (360) renames -> . RENAMES name

    ASSIGNMENT      reduce using rule 31 (object_subtype_def -> subtype_ind .)
    ;               reduce using rule 31 (object_subtype_def -> subtype_ind .)
    RENAMES         shift and go to state 95

    renames                        shift and go to state 634

state 493

    (78) array_type -> unconstr_array_type .

    ;               reduce using rule 78 (array_type -> unconstr_array_type .)
    ASSIGNMENT      reduce using rule 78 (array_type -> unconstr_array_type .)


state 494

    (343) pkg_body -> PACKAGE BODY compound_name IS decl_part . body_opt END c_id_opt ;
    (344) body_opt -> .
    (345) body_opt -> . block_body
    (301) block_body -> . BEGIN handled_stmt_s

    END             reduce using rule 344 (body_opt -> .)
    BEGIN           shift and go to state 162

    body_opt                       shift and go to state 635
    block_body                     shift and go to state 636

state 495

    (140) decl_item_s1 -> decl_item_s1 decl_item .

    error           reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    USE             reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    PRAGMA          reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    TYPE            reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    SUBTYPE         reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    TASK            reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    PACKAGE         reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    PROTECTED       reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    FOR             reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    PROCEDURE       reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    FUNCTION        reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    GENERIC         reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    IDENTIFIER      reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    END             reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    PRIVATE         reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)


state 496

    (457) body_stub -> PROTECTED BODY . simple_name IS SEPARATE ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 637

state 497

    (340) private_part -> PRIVATE . decl_item_s
    (137) decl_item_s -> .
    (138) decl_item_s -> . decl_item_s1
    (139) decl_item_s1 -> . decl_item
    (140) decl_item_s1 -> . decl_item_s1 decl_item
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (349) use_clause -> . USE name_s ;
    (350) use_clause -> . USE TYPE name_s ;
    (503) rep_spec -> . attrib_def
    (504) rep_spec -> . record_type_spec
    (505) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (313) subprog_decl -> . subprog_spec ;
    (314) subprog_decl -> . generic_subp_inst ;
    (315) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (336) pkg_decl -> . pkg_spec ;
    (337) pkg_decl -> . generic_pkg_inst ;
    (361) task_decl -> . task_spec ;
    (369) prot_decl -> . prot_spec ;
    (458) exception_decl -> . def_id_s : EXCEPTION ;
    (353) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (354) rename_decl -> . def_id_s : EXCEPTION renames ;
    (355) rename_decl -> . rename_unit
    (470) generic_decl -> . generic_formal_part subprog_spec ;
    (471) generic_decl -> . generic_formal_part pkg_spec ;
    (454) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (455) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (456) body_stub -> . subprog_spec IS SEPARATE ;
    (457) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (506) attrib_def -> . FOR mark USE expression ;
    (507) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (512) address_spec -> . FOR mark USE AT expression ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (316) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (317) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (318) subprog_spec -> . FUNCTION designator
    (500) generic_subp_inst -> . subprog_spec IS generic_inst
    (333) subprog_spec_is_push -> . subprog_spec IS
    (338) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (362) task_spec -> . TASK simple_name task_def
    (363) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (370) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (371) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (356) rename_unit -> . PACKAGE compound_name renames ;
    (357) rename_unit -> . subprog_spec renames ;
    (358) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (359) rename_unit -> . generic_formal_part subprog_spec renames ;
    (472) generic_formal_part -> . GENERIC
    (473) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    END             reduce using rule 137 (decl_item_s -> .)
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    TASK            shift and go to state 336
    PACKAGE         shift and go to state 337
    PROTECTED       shift and go to state 333
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    task_decl                      shift and go to state 60
    subtype_decl                   shift and go to state 61
    rep_spec                       shift and go to state 82
    decl_item_s1                   shift and go to state 332
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    decl_item                      shift and go to state 334
    subprog_spec_is_push           shift and go to state 338
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 339
    def_id_s                       shift and go to state 88
    task_spec                      shift and go to state 65
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    generic_subp_inst              shift and go to state 29
    def_id                         shift and go to state 89
    rename_decl                    shift and go to state 90
    type_decl                      shift and go to state 56
    rename_unit                    shift and go to state 91
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    subprog_decl                   shift and go to state 58
    decl_item_s                    shift and go to state 638
    pragma                         shift and go to state 74
    pkg_spec                       shift and go to state 37
    number_decl                    shift and go to state 93

state 498

    (338) pkg_spec -> PACKAGE compound_name IS decl_item_s private_part . END c_id_opt

    END             shift and go to state 639


state 499

    (454) body_stub -> TASK BODY . simple_name IS SEPARATE ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 640

state 500

    (455) body_stub -> PACKAGE BODY . compound_name IS SEPARATE ;
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 641
    simple_name                    shift and go to state 41

state 501

    (456) body_stub -> subprog_spec IS . SEPARATE ;
    (500) generic_subp_inst -> subprog_spec IS . generic_inst
    (333) subprog_spec_is_push -> subprog_spec IS .
    (502) generic_inst -> . NEW name

    SEPARATE        shift and go to state 322
    ABSTRACT        reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    NEW             shift and go to state 183

    generic_inst                   shift and go to state 184

state 502

    (323) formal_part -> ( param_s ) .

    ;               reduce using rule 323 (formal_part -> ( param_s ) .)
    RETURN          reduce using rule 323 (formal_part -> ( param_s ) .)
    IS              reduce using rule 323 (formal_part -> ( param_s ) .)
    RENAMES         reduce using rule 323 (formal_part -> ( param_s ) .)
    WHEN            reduce using rule 323 (formal_part -> ( param_s ) .)
    DO              reduce using rule 323 (formal_part -> ( param_s ) .)


state 503

    (325) param_s -> param_s ; . param
    (326) param -> . def_id_s : mode mark init_opt
    (327) param -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    error           shift and go to state 109
    IDENTIFIER      shift and go to state 76

    param                          shift and go to state 642
    def_id                         shift and go to state 89
    def_id_s                       shift and go to state 105

state 504

    (477) generic_formal -> WITH FUNCTION designator formal_part_opt . RETURN name subp_default ;

    RETURN          shift and go to state 643


state 505

    (478) generic_formal -> WITH PACKAGE simple_name IS . NEW name ( LESSMORE ) ;
    (479) generic_formal -> WITH PACKAGE simple_name IS . NEW name ;

    NEW             shift and go to state 644


state 506

    (476) generic_formal -> WITH PROCEDURE simple_name formal_part_opt . subp_default ;
    (484) subp_default -> .
    (485) subp_default -> . IS name
    (486) subp_default -> . IS LESSMORE

    ;               reduce using rule 484 (subp_default -> .)
    IS              shift and go to state 645

    subp_default                   shift and go to state 646

state 507

    (331) mode -> IN OUT .

    IDENTIFIER      reduce using rule 331 (mode -> IN OUT .)


state 508

    (326) param -> def_id_s : mode mark . init_opt
    (159) mark -> mark . TICK attribute_id
    (160) mark -> mark . . simple_name
    (33) init_opt -> .
    (34) init_opt -> . ASSIGNMENT expression

    TICK            shift and go to state 312
    .               shift and go to state 311
    ;               reduce using rule 33 (init_opt -> .)
    )               reduce using rule 33 (init_opt -> .)
    ASSIGNMENT      shift and go to state 632

    init_opt                       shift and go to state 647

state 509

    (358) rename_unit -> generic_formal_part PACKAGE compound_name renames ; .

    PACKAGE         reduce using rule 358 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    TASK            reduce using rule 358 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    PROTECTED       reduce using rule 358 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    error           reduce using rule 358 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    USE             reduce using rule 358 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    PRAGMA          reduce using rule 358 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    TYPE            reduce using rule 358 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    SUBTYPE         reduce using rule 358 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    FOR             reduce using rule 358 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    PROCEDURE       reduce using rule 358 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    FUNCTION        reduce using rule 358 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    GENERIC         reduce using rule 358 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    IDENTIFIER      reduce using rule 358 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    BEGIN           reduce using rule 358 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    END             reduce using rule 358 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    PRIVATE         reduce using rule 358 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    WITH            reduce using rule 358 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    SEPARATE        reduce using rule 358 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)
    $end            reduce using rule 358 (rename_unit -> generic_formal_part PACKAGE compound_name renames ; .)


state 510

    (475) generic_formal -> TYPE simple_name generic_discrim_part_opt IS . generic_type_def ;
    (487) generic_type_def -> . ( LESSMORE )
    (488) generic_type_def -> . RANGE LESSMORE
    (489) generic_type_def -> . MOD LESSMORE
    (490) generic_type_def -> . DELTA LESSMORE
    (491) generic_type_def -> . DELTA LESSMORE DIGITS LESSMORE
    (492) generic_type_def -> . DIGITS LESSMORE
    (493) generic_type_def -> . array_type
    (494) generic_type_def -> . access_type
    (495) generic_type_def -> . private_type
    (496) generic_type_def -> . generic_derived_type
    (78) array_type -> . unconstr_array_type
    (79) array_type -> . constr_array_type
    (128) access_type -> . ACCESS subtype_ind
    (129) access_type -> . ACCESS CONSTANT subtype_ind
    (130) access_type -> . ACCESS ALL subtype_ind
    (131) access_type -> . ACCESS prot_opt PROCEDURE formal_part_opt
    (132) access_type -> . ACCESS prot_opt FUNCTION formal_part_opt RETURN mark
    (346) private_type -> . tagged_opt limited_opt PRIVATE
    (497) generic_derived_type -> . NEW subtype_ind
    (498) generic_derived_type -> . NEW subtype_ind WITH PRIVATE
    (499) generic_derived_type -> . ABSTRACT NEW subtype_ind WITH PRIVATE
    (80) unconstr_array_type -> . ARRAY ( index_s ) OF component_subtype_def
    (81) constr_array_type -> . ARRAY iter_index_constraint OF subtype_ind
    (98) tagged_opt -> .
    (99) tagged_opt -> . TAGGED
    (100) tagged_opt -> . ABSTRACT TAGGED

    (               shift and go to state 653
    RANGE           shift and go to state 655
    MOD             shift and go to state 660
    DELTA           shift and go to state 659
    DIGITS          shift and go to state 652
    ACCESS          shift and go to state 618
    NEW             shift and go to state 650
    ABSTRACT        shift and go to state 648
    ARRAY           shift and go to state 489
    LIMITED         reduce using rule 98 (tagged_opt -> .)
    PRIVATE         reduce using rule 98 (tagged_opt -> .)
    TAGGED          shift and go to state 612

    private_type                   shift and go to state 654
    tagged_opt                     shift and go to state 658
    constr_array_type              shift and go to state 491
    access_type                    shift and go to state 656
    generic_derived_type           shift and go to state 651
    generic_type_def               shift and go to state 649
    array_type                     shift and go to state 657
    unconstr_array_type            shift and go to state 493

state 511

    (483) generic_discrim_part_opt -> ( LESSMORE . )

    )               shift and go to state 661


state 512

    (317) subprog_spec -> FUNCTION designator formal_part_opt RETURN name .
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id

    ;               reduce using rule 317 (subprog_spec -> FUNCTION designator formal_part_opt RETURN name .)
    IS              reduce using rule 317 (subprog_spec -> FUNCTION designator formal_part_opt RETURN name .)
    RENAMES         reduce using rule 317 (subprog_spec -> FUNCTION designator formal_part_opt RETURN name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 513

    (62) range -> simple_expression DOTDOT simple_expression .
    (219) simple_expression -> simple_expression . adding term
    (222) adding -> . +
    (223) adding -> . -
    (224) adding -> . &

    ARROW           reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    |               reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    LOOP            reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    ;               reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    )               reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    ,               reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    AND             reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    OR              reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    WITH            reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    IS              reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    THEN            reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    RANGE           reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    DIGITS          reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    RENAMES         reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    ASSIGNMENT      reduce using rule 62 (range -> simple_expression DOTDOT simple_expression .)
    +               shift and go to state 210
    -               shift and go to state 212
    &               shift and go to state 211

    adding                         shift and go to state 208

state 514

    (205) relation -> simple_expression .
    (206) relation -> simple_expression . relational simple_expression
    (207) relation -> simple_expression . membership range
    (208) relation -> simple_expression . membership name
    (62) range -> simple_expression . DOTDOT simple_expression
    (219) simple_expression -> simple_expression . adding term
    (209) relational -> . =
    (210) relational -> . NOTEQUAL
    (211) relational -> . <
    (212) relational -> . LESSEQ
    (213) relational -> . >
    (214) relational -> . GREATEREQ
    (215) membership -> . IN
    (216) membership -> . NOT IN
    (222) adding -> . +
    (223) adding -> . -
    (224) adding -> . &

    AND             reduce using rule 205 (relation -> simple_expression .)
    OR              reduce using rule 205 (relation -> simple_expression .)
    ARROW           reduce using rule 205 (relation -> simple_expression .)
    |               reduce using rule 205 (relation -> simple_expression .)
    DOTDOT          shift and go to state 364
    =               shift and go to state 219
    NOTEQUAL        shift and go to state 209
    <               shift and go to state 220
    LESSEQ          shift and go to state 215
    >               shift and go to state 221
    GREATEREQ       shift and go to state 214
    IN              shift and go to state 216
    NOT             shift and go to state 217
    +               shift and go to state 210
    -               shift and go to state 212
    &               shift and go to state 211

    adding                         shift and go to state 208
    membership                     shift and go to state 213
    relational                     shift and go to state 218

state 515

    (122) choice_s -> choice_s | choice .

    ARROW           reduce using rule 122 (choice_s -> choice_s | choice .)
    |               reduce using rule 122 (choice_s -> choice_s | choice .)


state 516

    (126) discrete_with_range -> name . range_constraint
    (63) range -> name .
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id
    (235) primary -> name .
    (241) qualified -> name . TICK parenthesized_primary
    (61) range_constraint -> . RANGE range

  ! reduce/reduce conflict for ARROW resolved using rule 63 (range -> name .)
  ! reduce/reduce conflict for | resolved using rule 63 (range -> name .)
    ARROW           reduce using rule 63 (range -> name .)
    |               reduce using rule 63 (range -> name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 370
    STARSTAR        reduce using rule 235 (primary -> name .)
    *               reduce using rule 235 (primary -> name .)
    /               reduce using rule 235 (primary -> name .)
    MOD             reduce using rule 235 (primary -> name .)
    REM             reduce using rule 235 (primary -> name .)
    DOTDOT          reduce using rule 235 (primary -> name .)
    =               reduce using rule 235 (primary -> name .)
    NOTEQUAL        reduce using rule 235 (primary -> name .)
    <               reduce using rule 235 (primary -> name .)
    LESSEQ          reduce using rule 235 (primary -> name .)
    >               reduce using rule 235 (primary -> name .)
    GREATEREQ       reduce using rule 235 (primary -> name .)
    IN              reduce using rule 235 (primary -> name .)
    NOT             reduce using rule 235 (primary -> name .)
    +               reduce using rule 235 (primary -> name .)
    -               reduce using rule 235 (primary -> name .)
    &               reduce using rule 235 (primary -> name .)
    AND             reduce using rule 235 (primary -> name .)
    OR              reduce using rule 235 (primary -> name .)
    RANGE           shift and go to state 371

  ! ARROW           [ reduce using rule 235 (primary -> name .) ]
  ! |               [ reduce using rule 235 (primary -> name .) ]

    range_constraint               shift and go to state 372

state 517

    (123) choice -> expression .
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ARROW           reduce using rule 123 (choice -> expression .)
    |               reduce using rule 123 (choice -> expression .)
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 518

    (196) comp_assoc -> choice_s ARROW expression .
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    )               reduce using rule 196 (comp_assoc -> choice_s ARROW expression .)
    ,               reduce using rule 196 (comp_assoc -> choice_s ARROW expression .)
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 519

    (195) value_s_2 -> value_s_2 , value .

    )               reduce using rule 195 (value_s_2 -> value_s_2 , value .)
    ,               reduce using rule 195 (value_s_2 -> value_s_2 , value .)


state 520

    (63) range -> name .
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id
    (235) primary -> name .
    (241) qualified -> name . TICK parenthesized_primary

    ;               reduce using rule 63 (range -> name .)
    )               reduce using rule 63 (range -> name .)
    ,               reduce using rule 63 (range -> name .)
    ARROW           reduce using rule 63 (range -> name .)
    |               reduce using rule 63 (range -> name .)
    RENAMES         reduce using rule 63 (range -> name .)
    ASSIGNMENT      reduce using rule 63 (range -> name .)
    WITH            reduce using rule 63 (range -> name .)
    LOOP            reduce using rule 63 (range -> name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 370
    STARSTAR        reduce using rule 235 (primary -> name .)
    *               reduce using rule 235 (primary -> name .)
    /               reduce using rule 235 (primary -> name .)
    MOD             reduce using rule 235 (primary -> name .)
    REM             reduce using rule 235 (primary -> name .)
    DOTDOT          reduce using rule 235 (primary -> name .)
    +               reduce using rule 235 (primary -> name .)
    -               reduce using rule 235 (primary -> name .)
    &               reduce using rule 235 (primary -> name .)


state 521

    (61) range_constraint -> RANGE range .

    ;               reduce using rule 61 (range_constraint -> RANGE range .)
    )               reduce using rule 61 (range_constraint -> RANGE range .)
    ,               reduce using rule 61 (range_constraint -> RANGE range .)
    ARROW           reduce using rule 61 (range_constraint -> RANGE range .)
    |               reduce using rule 61 (range_constraint -> RANGE range .)
    RENAMES         reduce using rule 61 (range_constraint -> RANGE range .)
    ASSIGNMENT      reduce using rule 61 (range_constraint -> RANGE range .)
    WITH            reduce using rule 61 (range_constraint -> RANGE range .)
    LOOP            reduce using rule 61 (range_constraint -> RANGE range .)


state 522

    (194) value_s_2 -> value , value .

    )               reduce using rule 194 (value_s_2 -> value , value .)
    ,               reduce using rule 194 (value_s_2 -> value , value .)


state 523

    (193) aggregate -> ( NuLL RECORD ) .

    STARSTAR        reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    *               reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    /               reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    MOD             reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    REM             reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    =               reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    NOTEQUAL        reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    <               reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    LESSEQ          reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    >               reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    GREATEREQ       reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    IN              reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    NOT             reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    +               reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    -               reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    &               reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    AND             reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    OR              reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    )               reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    ,               reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    DOTDOT          reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    WITH            reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    ARROW           reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    |               reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    ;               reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    IS              reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    THEN            reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    LOOP            reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    RANGE           reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    DIGITS          reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    RENAMES         reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)
    ASSIGNMENT      reduce using rule 193 (aggregate -> ( NuLL RECORD ) .)


state 524

    (191) aggregate -> ( expression WITH value_s . )
    (170) value_s -> value_s . , value

    )               shift and go to state 662
    ,               shift and go to state 527


state 525

    (192) aggregate -> ( expression WITH NuLL . RECORD )
    (188) literal -> NuLL .

    RECORD          shift and go to state 663
    STARSTAR        reduce using rule 188 (literal -> NuLL .)
    *               reduce using rule 188 (literal -> NuLL .)
    /               reduce using rule 188 (literal -> NuLL .)
    MOD             reduce using rule 188 (literal -> NuLL .)
    REM             reduce using rule 188 (literal -> NuLL .)
    DOTDOT          reduce using rule 188 (literal -> NuLL .)
    =               reduce using rule 188 (literal -> NuLL .)
    NOTEQUAL        reduce using rule 188 (literal -> NuLL .)
    <               reduce using rule 188 (literal -> NuLL .)
    LESSEQ          reduce using rule 188 (literal -> NuLL .)
    >               reduce using rule 188 (literal -> NuLL .)
    GREATEREQ       reduce using rule 188 (literal -> NuLL .)
    IN              reduce using rule 188 (literal -> NuLL .)
    NOT             reduce using rule 188 (literal -> NuLL .)
    +               reduce using rule 188 (literal -> NuLL .)
    -               reduce using rule 188 (literal -> NuLL .)
    &               reduce using rule 188 (literal -> NuLL .)
    AND             reduce using rule 188 (literal -> NuLL .)
    OR              reduce using rule 188 (literal -> NuLL .)
    )               reduce using rule 188 (literal -> NuLL .)
    ,               reduce using rule 188 (literal -> NuLL .)
    ARROW           reduce using rule 188 (literal -> NuLL .)
    |               reduce using rule 188 (literal -> NuLL .)


state 526

    (168) indexed_comp -> name ( value_s ) .

    TICK            reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    (               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    .               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    STARSTAR        reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    *               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    /               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    MOD             reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    REM             reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    =               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    NOTEQUAL        reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    <               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    LESSEQ          reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    >               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    GREATEREQ       reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    IN              reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    NOT             reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    +               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    -               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    &               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    AND             reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    OR              reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    THEN            reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    )               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    ,               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    WITH            reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    ARROW           reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    |               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    ;               reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    IS              reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    LOOP            reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    RANGE           reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    DIGITS          reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    RENAMES         reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    ASSIGNMENT      reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    DOTDOT          reduce using rule 168 (indexed_comp -> name ( value_s ) .)
    WHEN            reduce using rule 168 (indexed_comp -> name ( value_s ) .)


state 527

    (170) value_s -> value_s , . value
    (171) value -> . expression
    (172) value -> . comp_assoc
    (173) value -> . error
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (196) comp_assoc -> . choice_s ARROW expression
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 233
    OTHERS          shift and go to state 223
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    value                          shift and go to state 664
    simple_expression              shift and go to state 224
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    comp_assoc                     shift and go to state 381
    choice_s                       shift and go to state 225
    choice                         shift and go to state 227
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 147
    name                           shift and go to state 230
    range                          shift and go to state 232
    expression                     shift and go to state 383

state 528

    (199) expression -> expression logical m relation .

    AND             reduce using rule 199 (expression -> expression logical m relation .)
    OR              reduce using rule 199 (expression -> expression logical m relation .)
    LOOP            reduce using rule 199 (expression -> expression logical m relation .)
    )               reduce using rule 199 (expression -> expression logical m relation .)
    ,               reduce using rule 199 (expression -> expression logical m relation .)
    ARROW           reduce using rule 199 (expression -> expression logical m relation .)
    |               reduce using rule 199 (expression -> expression logical m relation .)
    ;               reduce using rule 199 (expression -> expression logical m relation .)
    IS              reduce using rule 199 (expression -> expression logical m relation .)
    RANGE           reduce using rule 199 (expression -> expression logical m relation .)
    RENAMES         reduce using rule 199 (expression -> expression logical m relation .)
    ASSIGNMENT      reduce using rule 199 (expression -> expression logical m relation .)
    WITH            reduce using rule 199 (expression -> expression logical m relation .)
    THEN            reduce using rule 199 (expression -> expression logical m relation .)
    DIGITS          reduce using rule 199 (expression -> expression logical m relation .)


state 529

    (200) expression -> expression short_circuit m relation .

    AND             reduce using rule 200 (expression -> expression short_circuit m relation .)
    OR              reduce using rule 200 (expression -> expression short_circuit m relation .)
    LOOP            reduce using rule 200 (expression -> expression short_circuit m relation .)
    )               reduce using rule 200 (expression -> expression short_circuit m relation .)
    ,               reduce using rule 200 (expression -> expression short_circuit m relation .)
    ARROW           reduce using rule 200 (expression -> expression short_circuit m relation .)
    |               reduce using rule 200 (expression -> expression short_circuit m relation .)
    ;               reduce using rule 200 (expression -> expression short_circuit m relation .)
    IS              reduce using rule 200 (expression -> expression short_circuit m relation .)
    RANGE           reduce using rule 200 (expression -> expression short_circuit m relation .)
    RENAMES         reduce using rule 200 (expression -> expression short_circuit m relation .)
    ASSIGNMENT      reduce using rule 200 (expression -> expression short_circuit m relation .)
    WITH            reduce using rule 200 (expression -> expression short_circuit m relation .)
    THEN            reduce using rule 200 (expression -> expression short_circuit m relation .)
    DIGITS          reduce using rule 200 (expression -> expression short_circuit m relation .)


state 530

    (385) prot_body -> PROTECTED BODY . simple_name IS prot_op_body_s END id_opt ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 665

state 531

    (368) task_body -> TASK BODY . simple_name IS decl_part block_body END id_opt ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 666

state 532

    (333) subprog_spec_is_push -> subprog_spec IS .

    PACKAGE         reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    TASK            reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    PROTECTED       reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    error           reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    USE             reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    PRAGMA          reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    TYPE            reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    SUBTYPE         reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    FOR             reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    PROCEDURE       reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    FUNCTION        reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    GENERIC         reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    IDENTIFIER      reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)
    BEGIN           reduce using rule 333 (subprog_spec_is_push -> subprog_spec IS .)


state 533

    (457) body_stub -> PROTECTED BODY simple_name IS SEPARATE . ;

    ;               shift and go to state 667


state 534

    (385) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s . END id_opt ;
    (387) prot_op_body_s -> prot_op_body_s . prot_op_body pragma_s
    (388) prot_op_body -> . entry_body
    (389) prot_op_body -> . subprog_body
    (390) prot_op_body -> . subprog_spec ;
    (395) entry_body -> . ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part
    (396) entry_body -> . ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part
    (334) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (316) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (317) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (318) subprog_spec -> . FUNCTION designator
    (333) subprog_spec_is_push -> . subprog_spec IS

    END             shift and go to state 670
    ENTRY           shift and go to state 673
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36

    subprog_body                   shift and go to state 668
    prot_op_body                   shift and go to state 672
    entry_body                     shift and go to state 671
    subprog_spec                   shift and go to state 669
    subprog_spec_is_push           shift and go to state 405

state 535

    (386) prot_op_body_s -> pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 386 (prot_op_body_s -> pragma_s .)
    ENTRY           reduce using rule 386 (prot_op_body_s -> pragma_s .)
    PROCEDURE       reduce using rule 386 (prot_op_body_s -> pragma_s .)
    FUNCTION        reduce using rule 386 (prot_op_body_s -> pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 536

    (379) prot_op_decl -> rep_spec .

    PRIVATE         reduce using rule 379 (prot_op_decl -> rep_spec .)
    ENTRY           reduce using rule 379 (prot_op_decl -> rep_spec .)
    PROCEDURE       reduce using rule 379 (prot_op_decl -> rep_spec .)
    FUNCTION        reduce using rule 379 (prot_op_decl -> rep_spec .)
    PRAGMA          reduce using rule 379 (prot_op_decl -> rep_spec .)
    FOR             reduce using rule 379 (prot_op_decl -> rep_spec .)
    END             reduce using rule 379 (prot_op_decl -> rep_spec .)
    error           reduce using rule 379 (prot_op_decl -> rep_spec .)
    IDENTIFIER      reduce using rule 379 (prot_op_decl -> rep_spec .)


state 537

    (377) prot_op_decl -> entry_decl .

    PRIVATE         reduce using rule 377 (prot_op_decl -> entry_decl .)
    ENTRY           reduce using rule 377 (prot_op_decl -> entry_decl .)
    PROCEDURE       reduce using rule 377 (prot_op_decl -> entry_decl .)
    FUNCTION        reduce using rule 377 (prot_op_decl -> entry_decl .)
    PRAGMA          reduce using rule 377 (prot_op_decl -> entry_decl .)
    FOR             reduce using rule 377 (prot_op_decl -> entry_decl .)
    END             reduce using rule 377 (prot_op_decl -> entry_decl .)
    error           reduce using rule 377 (prot_op_decl -> entry_decl .)
    IDENTIFIER      reduce using rule 377 (prot_op_decl -> entry_decl .)


state 538

    (374) prot_private_opt -> PRIVATE . prot_elem_decl_s
    (381) prot_elem_decl_s -> .
    (382) prot_elem_decl_s -> . prot_elem_decl_s prot_elem_decl

    error           reduce using rule 381 (prot_elem_decl_s -> .)
    ENTRY           reduce using rule 381 (prot_elem_decl_s -> .)
    PROCEDURE       reduce using rule 381 (prot_elem_decl_s -> .)
    FUNCTION        reduce using rule 381 (prot_elem_decl_s -> .)
    PRAGMA          reduce using rule 381 (prot_elem_decl_s -> .)
    FOR             reduce using rule 381 (prot_elem_decl_s -> .)
    IDENTIFIER      reduce using rule 381 (prot_elem_decl_s -> .)
    END             reduce using rule 381 (prot_elem_decl_s -> .)

    prot_elem_decl_s               shift and go to state 674

state 539

    (378) prot_op_decl -> subprog_spec . ;

    ;               shift and go to state 675


state 540

    (372) prot_def -> IS prot_op_decl_s prot_private_opt . END id_opt

    END             shift and go to state 676


state 541

    (380) prot_op_decl -> pragma .

    PRIVATE         reduce using rule 380 (prot_op_decl -> pragma .)
    ENTRY           reduce using rule 380 (prot_op_decl -> pragma .)
    PROCEDURE       reduce using rule 380 (prot_op_decl -> pragma .)
    FUNCTION        reduce using rule 380 (prot_op_decl -> pragma .)
    PRAGMA          reduce using rule 380 (prot_op_decl -> pragma .)
    FOR             reduce using rule 380 (prot_op_decl -> pragma .)
    END             reduce using rule 380 (prot_op_decl -> pragma .)
    error           reduce using rule 380 (prot_op_decl -> pragma .)
    IDENTIFIER      reduce using rule 380 (prot_op_decl -> pragma .)


state 542

    (393) entry_decl -> ENTRY . IDENTIFIER formal_part_opt ;
    (394) entry_decl -> ENTRY . IDENTIFIER ( discrete_range ) formal_part_opt ;

    IDENTIFIER      shift and go to state 677


state 543

    (376) prot_op_decl_s -> prot_op_decl_s prot_op_decl .

    PRIVATE         reduce using rule 376 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    ENTRY           reduce using rule 376 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    PROCEDURE       reduce using rule 376 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    FUNCTION        reduce using rule 376 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    PRAGMA          reduce using rule 376 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    FOR             reduce using rule 376 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    END             reduce using rule 376 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)


state 544

    (371) prot_spec -> PROTECTED TYPE simple_name discrim_part_opt prot_def .

    ;               reduce using rule 371 (prot_spec -> PROTECTED TYPE simple_name discrim_part_opt prot_def .)


state 545

    (408) delay_stmt -> DELAY UNTIL expression . ;
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ;               shift and go to state 678
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 546

    (407) delay_stmt -> DELAY expression ; .

    EXCEPTION       reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    LESSLESS        reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    error           reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    PRAGMA          reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    NuLL            reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    EXIT            reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    RETURN          reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    GOTO            reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    DELAY           reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    ABORT           reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    RAISE           reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    REQUEUE         reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    IF              reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    CASE            reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    IDENTIFIER      reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    ACCEPT          reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    SELECT          reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    STRING          reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    WHILE           reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    DECLARE         reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    FOR             reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    LOOP            reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    BEGIN           reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    END             reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    OR              reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    ELSE            reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    THEN            reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    ELSIF           reduce using rule 407 (delay_stmt -> DELAY expression ; .)
    WHEN            reduce using rule 407 (delay_stmt -> DELAY expression ; .)


state 547

    (291) iteration -> iter_part reverse_opt . discrete_range
    (91) discrete_range -> . name range_constr_opt
    (92) discrete_range -> . range
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    simple_expression              shift and go to state 358
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    parenthesized_primary          shift and go to state 142
    discrete_range                 shift and go to state 679
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 680
    operator_symbol                shift and go to state 138
    range                          shift and go to state 681
    qualified                      shift and go to state 141

state 548

    (294) reverse_opt -> REVERSE .

    IDENTIFIER      reduce using rule 294 (reverse_opt -> REVERSE .)
    STRING          reduce using rule 294 (reverse_opt -> REVERSE .)
    +               reduce using rule 294 (reverse_opt -> REVERSE .)
    -               reduce using rule 294 (reverse_opt -> REVERSE .)
    NOT             reduce using rule 294 (reverse_opt -> REVERSE .)
    INTEGER         reduce using rule 294 (reverse_opt -> REVERSE .)
    BASE_INTEGER    reduce using rule 294 (reverse_opt -> REVERSE .)
    FLOAT           reduce using rule 294 (reverse_opt -> REVERSE .)
    BASE_FLOAT      reduce using rule 294 (reverse_opt -> REVERSE .)
    NuLL            reduce using rule 294 (reverse_opt -> REVERSE .)
    NEW             reduce using rule 294 (reverse_opt -> REVERSE .)
    (               reduce using rule 294 (reverse_opt -> REVERSE .)
    CHAR            reduce using rule 294 (reverse_opt -> REVERSE .)


state 549

    (292) iter_part -> FOR IDENTIFIER . IN

    IN              shift and go to state 682


state 550

    (286) loop_stmt -> label_opt iteration m . basic_loop id_opt ;
    (295) basic_loop -> . LOOP statement_s END LOOP

    LOOP            shift and go to state 684

    basic_loop                     shift and go to state 683

state 551

    (298) block -> label_opt block_decl block_body . END id_opt ;

    END             shift and go to state 685


state 552

    (290) iteration -> WHILE m . condition
    (278) condition -> . expression
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    condition                      shift and go to state 686
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 461

state 553

    (300) block_decl -> DECLARE decl_part .

    BEGIN           reduce using rule 300 (block_decl -> DECLARE decl_part .)


state 554

    (312) goto_stmt -> GOTO name ; .

    EXCEPTION       reduce using rule 312 (goto_stmt -> GOTO name ; .)
    LESSLESS        reduce using rule 312 (goto_stmt -> GOTO name ; .)
    error           reduce using rule 312 (goto_stmt -> GOTO name ; .)
    PRAGMA          reduce using rule 312 (goto_stmt -> GOTO name ; .)
    NuLL            reduce using rule 312 (goto_stmt -> GOTO name ; .)
    EXIT            reduce using rule 312 (goto_stmt -> GOTO name ; .)
    RETURN          reduce using rule 312 (goto_stmt -> GOTO name ; .)
    GOTO            reduce using rule 312 (goto_stmt -> GOTO name ; .)
    DELAY           reduce using rule 312 (goto_stmt -> GOTO name ; .)
    ABORT           reduce using rule 312 (goto_stmt -> GOTO name ; .)
    RAISE           reduce using rule 312 (goto_stmt -> GOTO name ; .)
    REQUEUE         reduce using rule 312 (goto_stmt -> GOTO name ; .)
    IF              reduce using rule 312 (goto_stmt -> GOTO name ; .)
    CASE            reduce using rule 312 (goto_stmt -> GOTO name ; .)
    IDENTIFIER      reduce using rule 312 (goto_stmt -> GOTO name ; .)
    ACCEPT          reduce using rule 312 (goto_stmt -> GOTO name ; .)
    SELECT          reduce using rule 312 (goto_stmt -> GOTO name ; .)
    STRING          reduce using rule 312 (goto_stmt -> GOTO name ; .)
    WHILE           reduce using rule 312 (goto_stmt -> GOTO name ; .)
    DECLARE         reduce using rule 312 (goto_stmt -> GOTO name ; .)
    FOR             reduce using rule 312 (goto_stmt -> GOTO name ; .)
    LOOP            reduce using rule 312 (goto_stmt -> GOTO name ; .)
    BEGIN           reduce using rule 312 (goto_stmt -> GOTO name ; .)
    END             reduce using rule 312 (goto_stmt -> GOTO name ; .)
    OR              reduce using rule 312 (goto_stmt -> GOTO name ; .)
    ELSE            reduce using rule 312 (goto_stmt -> GOTO name ; .)
    THEN            reduce using rule 312 (goto_stmt -> GOTO name ; .)
    ELSIF           reduce using rule 312 (goto_stmt -> GOTO name ; .)
    WHEN            reduce using rule 312 (goto_stmt -> GOTO name ; .)


state 555

    (271) assign_stmt -> name ASSIGNMENT expression . ;
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ;               shift and go to state 687
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 556

    (428) abort_stmt -> ABORT name_s ; .

    LESSLESS        reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    error           reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    PRAGMA          reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    NuLL            reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    EXIT            reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    RETURN          reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    GOTO            reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    DELAY           reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    ABORT           reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    RAISE           reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    REQUEUE         reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    IF              reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    CASE            reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    IDENTIFIER      reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    ACCEPT          reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    SELECT          reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    STRING          reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    WHILE           reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    DECLARE         reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    FOR             reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    LOOP            reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    BEGIN           reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    OR              reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    ELSE            reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    END             reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    ELSIF           reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    EXCEPTION       reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    THEN            reduce using rule 428 (abort_stmt -> ABORT name_s ; .)
    WHEN            reduce using rule 428 (abort_stmt -> ABORT name_s ; .)


state 557

    (269) label -> LESSLESS IDENTIFIER MOREMORE .

    LESSLESS        reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    error           reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    PRAGMA          reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    NuLL            reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    EXIT            reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    RETURN          reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    GOTO            reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    DELAY           reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    ABORT           reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    RAISE           reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    REQUEUE         reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    IF              reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    CASE            reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    IDENTIFIER      reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    ACCEPT          reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    SELECT          reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    STRING          reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    WHILE           reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    DECLARE         reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    FOR             reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    LOOP            reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)
    BEGIN           reduce using rule 269 (label -> LESSLESS IDENTIFIER MOREMORE .)


state 558

    (311) return_stmt -> RETURN expression ; .

    LESSLESS        reduce using rule 311 (return_stmt -> RETURN expression ; .)
    error           reduce using rule 311 (return_stmt -> RETURN expression ; .)
    PRAGMA          reduce using rule 311 (return_stmt -> RETURN expression ; .)
    NuLL            reduce using rule 311 (return_stmt -> RETURN expression ; .)
    EXIT            reduce using rule 311 (return_stmt -> RETURN expression ; .)
    RETURN          reduce using rule 311 (return_stmt -> RETURN expression ; .)
    GOTO            reduce using rule 311 (return_stmt -> RETURN expression ; .)
    DELAY           reduce using rule 311 (return_stmt -> RETURN expression ; .)
    ABORT           reduce using rule 311 (return_stmt -> RETURN expression ; .)
    RAISE           reduce using rule 311 (return_stmt -> RETURN expression ; .)
    REQUEUE         reduce using rule 311 (return_stmt -> RETURN expression ; .)
    IF              reduce using rule 311 (return_stmt -> RETURN expression ; .)
    CASE            reduce using rule 311 (return_stmt -> RETURN expression ; .)
    IDENTIFIER      reduce using rule 311 (return_stmt -> RETURN expression ; .)
    ACCEPT          reduce using rule 311 (return_stmt -> RETURN expression ; .)
    SELECT          reduce using rule 311 (return_stmt -> RETURN expression ; .)
    STRING          reduce using rule 311 (return_stmt -> RETURN expression ; .)
    WHILE           reduce using rule 311 (return_stmt -> RETURN expression ; .)
    DECLARE         reduce using rule 311 (return_stmt -> RETURN expression ; .)
    FOR             reduce using rule 311 (return_stmt -> RETURN expression ; .)
    LOOP            reduce using rule 311 (return_stmt -> RETURN expression ; .)
    BEGIN           reduce using rule 311 (return_stmt -> RETURN expression ; .)
    END             reduce using rule 311 (return_stmt -> RETURN expression ; .)
    OR              reduce using rule 311 (return_stmt -> RETURN expression ; .)
    ELSE            reduce using rule 311 (return_stmt -> RETURN expression ; .)
    EXCEPTION       reduce using rule 311 (return_stmt -> RETURN expression ; .)
    ELSIF           reduce using rule 311 (return_stmt -> RETURN expression ; .)
    THEN            reduce using rule 311 (return_stmt -> RETURN expression ; .)
    WHEN            reduce using rule 311 (return_stmt -> RETURN expression ; .)


state 559

    (406) entry_name -> entry_name ( . expression )
    (323) formal_part -> ( . param_s )
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (324) param_s -> . param
    (325) param_s -> . param_s ; param
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (326) param -> . def_id_s : mode mark init_opt
    (327) param -> . error
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (26) def_id -> . IDENTIFIER
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 109
    +               shift and go to state 133
    -               shift and go to state 134
    IDENTIFIER      shift and go to state 688
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    param                          shift and go to state 340
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    param_s                        shift and go to state 341
    literal                        shift and go to state 135
    def_id_s                       shift and go to state 105
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    def_id                         shift and go to state 89
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148
    relation                       shift and go to state 125
    expression                     shift and go to state 689

state 560

    (404) accept_hdr -> ACCEPT entry_name formal_part_opt .

    ;               reduce using rule 404 (accept_hdr -> ACCEPT entry_name formal_part_opt .)
    DO              reduce using rule 404 (accept_hdr -> ACCEPT entry_name formal_part_opt .)


state 561

    (418) select_alt -> accept_stmt stmts_opt .

    OR              reduce using rule 418 (select_alt -> accept_stmt stmts_opt .)
    ELSE            reduce using rule 418 (select_alt -> accept_stmt stmts_opt .)
    END             reduce using rule 418 (select_alt -> accept_stmt stmts_opt .)


state 562

    (427) stmts_opt -> statement_s .
    (245) statement_s -> statement_s . m statement
    (197) m -> .

    OR              reduce using rule 427 (stmts_opt -> statement_s .)
    ELSE            reduce using rule 427 (stmts_opt -> statement_s .)
    THEN            reduce using rule 427 (stmts_opt -> statement_s .)
    END             reduce using rule 427 (stmts_opt -> statement_s .)
    LESSLESS        reduce using rule 197 (m -> .)
    error           reduce using rule 197 (m -> .)
    PRAGMA          reduce using rule 197 (m -> .)
    NuLL            reduce using rule 197 (m -> .)
    EXIT            reduce using rule 197 (m -> .)
    RETURN          reduce using rule 197 (m -> .)
    GOTO            reduce using rule 197 (m -> .)
    DELAY           reduce using rule 197 (m -> .)
    ABORT           reduce using rule 197 (m -> .)
    RAISE           reduce using rule 197 (m -> .)
    REQUEUE         reduce using rule 197 (m -> .)
    IF              reduce using rule 197 (m -> .)
    CASE            reduce using rule 197 (m -> .)
    IDENTIFIER      reduce using rule 197 (m -> .)
    ACCEPT          reduce using rule 197 (m -> .)
    SELECT          reduce using rule 197 (m -> .)
    STRING          reduce using rule 197 (m -> .)
    WHILE           reduce using rule 197 (m -> .)
    DECLARE         reduce using rule 197 (m -> .)
    FOR             reduce using rule 197 (m -> .)
    LOOP            reduce using rule 197 (m -> .)
    BEGIN           reduce using rule 197 (m -> .)

    m                              shift and go to state 454

state 563

    (424) timed_entry_call -> SELECT entry_call stmts_opt . OR delay_stmt stmts_opt END SELECT ;
    (425) cond_entry_call -> SELECT entry_call stmts_opt . ELSE statement_s END SELECT ;
    (422) delay_or_entry_alt -> entry_call stmts_opt .

    OR              shift and go to state 691
    ELSE            shift and go to state 690
    THEN            reduce using rule 422 (delay_or_entry_alt -> entry_call stmts_opt .)


state 564

    (423) async_select -> SELECT delay_or_entry_alt THEN . ABORT statement_s END SELECT ;

    ABORT           shift and go to state 692


state 565

    (415) guarded_select_alt -> WHEN condition . ARROW select_alt

    ARROW           shift and go to state 693


state 566

    (413) select_wait -> SELECT guarded_select_alt or_select . else_opt END SELECT ;
    (417) or_select -> or_select . OR guarded_select_alt
    (279) else_opt -> .
    (280) else_opt -> . ELSE m statement_s

    OR              shift and go to state 695
    END             reduce using rule 279 (else_opt -> .)
    ELSE            shift and go to state 581

    else_opt                       shift and go to state 694

state 567

    (421) delay_or_entry_alt -> delay_stmt stmts_opt .
    (419) select_alt -> delay_stmt stmts_opt .

    THEN            reduce using rule 421 (delay_or_entry_alt -> delay_stmt stmts_opt .)
    OR              reduce using rule 419 (select_alt -> delay_stmt stmts_opt .)
    ELSE            reduce using rule 419 (select_alt -> delay_stmt stmts_opt .)
    END             reduce using rule 419 (select_alt -> delay_stmt stmts_opt .)


state 568

    (420) select_alt -> TERMINATE ; .

    OR              reduce using rule 420 (select_alt -> TERMINATE ; .)
    ELSE            reduce using rule 420 (select_alt -> TERMINATE ; .)
    END             reduce using rule 420 (select_alt -> TERMINATE ; .)


state 569

    (281) case_stmt -> case_hdr pragma_s alternative_s . END CASE ;
    (284) alternative_s -> alternative_s . alternative
    (285) alternative -> . WHEN choice_s ARROW statement_s

    END             shift and go to state 697
    WHEN            shift and go to state 698

    alternative                    shift and go to state 696

state 570

    (467) raise_stmt -> RAISE name_opt ; .

    LESSLESS        reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    error           reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    PRAGMA          reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    NuLL            reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    EXIT            reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    RETURN          reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    GOTO            reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    DELAY           reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    ABORT           reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    RAISE           reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    REQUEUE         reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    IF              reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    CASE            reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    IDENTIFIER      reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    ACCEPT          reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    SELECT          reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    STRING          reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    WHILE           reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    DECLARE         reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    FOR             reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    LOOP            reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    BEGIN           reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    WHEN            reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    END             reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    EXCEPTION       reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    OR              reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    ELSE            reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    THEN            reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)
    ELSIF           reduce using rule 467 (raise_stmt -> RAISE name_opt ; .)


state 571

    (282) case_hdr -> CASE expression IS .

    PRAGMA          reduce using rule 282 (case_hdr -> CASE expression IS .)
    END             reduce using rule 282 (case_hdr -> CASE expression IS .)
    WHEN            reduce using rule 282 (case_hdr -> CASE expression IS .)


state 572

    (468) requeue_stmt -> REQUEUE name ; .

    EXCEPTION       reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    LESSLESS        reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    error           reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    PRAGMA          reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    NuLL            reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    EXIT            reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    RETURN          reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    GOTO            reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    DELAY           reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    ABORT           reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    RAISE           reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    REQUEUE         reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    IF              reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    CASE            reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    IDENTIFIER      reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    ACCEPT          reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    SELECT          reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    STRING          reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    WHILE           reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    DECLARE         reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    FOR             reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    LOOP            reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    BEGIN           reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    END             reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    OR              reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    ELSE            reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    THEN            reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    ELSIF           reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)
    WHEN            reduce using rule 468 (requeue_stmt -> REQUEUE name ; .)


state 573

    (469) requeue_stmt -> REQUEUE name WITH . ABORT ;

    ABORT           shift and go to state 699


state 574

    (403) accept_stmt -> accept_hdr DO handled_stmt_s . END id_opt ;

    END             shift and go to state 700


state 575

    (305) exit_stmt -> EXIT name_opt when_opt . ;

    ;               shift and go to state 701


state 576

    (309) when_opt -> WHEN . condition
    (278) condition -> . expression
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    condition                      shift and go to state 702
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 461

state 577

    (459) except_handler_part -> EXCEPTION exception_handler .

    WHEN            reduce using rule 459 (except_handler_part -> EXCEPTION exception_handler .)
    END             reduce using rule 459 (except_handler_part -> EXCEPTION exception_handler .)


state 578

    (461) exception_handler -> WHEN . except_choice_s ARROW statement_s
    (462) exception_handler -> WHEN . IDENTIFIER : except_choice_s ARROW statement_s
    (463) except_choice_s -> . except_choice
    (464) except_choice_s -> . except_choice_s | except_choice
    (465) except_choice -> . name
    (466) except_choice -> . OTHERS
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 704
    OTHERS          shift and go to state 706
    STRING          shift and go to state 139

    name                           shift and go to state 707
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    except_choice_s                shift and go to state 703
    except_choice                  shift and go to state 705
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 579

    (245) statement_s -> statement_s m statement .

    END             reduce using rule 245 (statement_s -> statement_s m statement .)
    LESSLESS        reduce using rule 245 (statement_s -> statement_s m statement .)
    error           reduce using rule 245 (statement_s -> statement_s m statement .)
    PRAGMA          reduce using rule 245 (statement_s -> statement_s m statement .)
    NuLL            reduce using rule 245 (statement_s -> statement_s m statement .)
    EXIT            reduce using rule 245 (statement_s -> statement_s m statement .)
    RETURN          reduce using rule 245 (statement_s -> statement_s m statement .)
    GOTO            reduce using rule 245 (statement_s -> statement_s m statement .)
    DELAY           reduce using rule 245 (statement_s -> statement_s m statement .)
    ABORT           reduce using rule 245 (statement_s -> statement_s m statement .)
    RAISE           reduce using rule 245 (statement_s -> statement_s m statement .)
    REQUEUE         reduce using rule 245 (statement_s -> statement_s m statement .)
    IF              reduce using rule 245 (statement_s -> statement_s m statement .)
    CASE            reduce using rule 245 (statement_s -> statement_s m statement .)
    IDENTIFIER      reduce using rule 245 (statement_s -> statement_s m statement .)
    ACCEPT          reduce using rule 245 (statement_s -> statement_s m statement .)
    SELECT          reduce using rule 245 (statement_s -> statement_s m statement .)
    STRING          reduce using rule 245 (statement_s -> statement_s m statement .)
    WHILE           reduce using rule 245 (statement_s -> statement_s m statement .)
    DECLARE         reduce using rule 245 (statement_s -> statement_s m statement .)
    FOR             reduce using rule 245 (statement_s -> statement_s m statement .)
    LOOP            reduce using rule 245 (statement_s -> statement_s m statement .)
    BEGIN           reduce using rule 245 (statement_s -> statement_s m statement .)
    ELSIF           reduce using rule 245 (statement_s -> statement_s m statement .)
    ELSE            reduce using rule 245 (statement_s -> statement_s m statement .)
    OR              reduce using rule 245 (statement_s -> statement_s m statement .)
    EXCEPTION       reduce using rule 245 (statement_s -> statement_s m statement .)
    THEN            reduce using rule 245 (statement_s -> statement_s m statement .)
    WHEN            reduce using rule 245 (statement_s -> statement_s m statement .)


state 580

    (460) except_handler_part -> except_handler_part exception_handler .

    WHEN            reduce using rule 460 (except_handler_part -> except_handler_part exception_handler .)
    END             reduce using rule 460 (except_handler_part -> except_handler_part exception_handler .)


state 581

    (280) else_opt -> ELSE . m statement_s
    (197) m -> .

    LESSLESS        reduce using rule 197 (m -> .)
    error           reduce using rule 197 (m -> .)
    PRAGMA          reduce using rule 197 (m -> .)
    NuLL            reduce using rule 197 (m -> .)
    EXIT            reduce using rule 197 (m -> .)
    RETURN          reduce using rule 197 (m -> .)
    GOTO            reduce using rule 197 (m -> .)
    DELAY           reduce using rule 197 (m -> .)
    ABORT           reduce using rule 197 (m -> .)
    RAISE           reduce using rule 197 (m -> .)
    REQUEUE         reduce using rule 197 (m -> .)
    IF              reduce using rule 197 (m -> .)
    CASE            reduce using rule 197 (m -> .)
    IDENTIFIER      reduce using rule 197 (m -> .)
    ACCEPT          reduce using rule 197 (m -> .)
    SELECT          reduce using rule 197 (m -> .)
    STRING          reduce using rule 197 (m -> .)
    WHILE           reduce using rule 197 (m -> .)
    DECLARE         reduce using rule 197 (m -> .)
    FOR             reduce using rule 197 (m -> .)
    LOOP            reduce using rule 197 (m -> .)
    BEGIN           reduce using rule 197 (m -> .)

    m                              shift and go to state 708

state 582

    (272) if_stmt -> IF cond_clause_s else_opt . END IF ;

    END             shift and go to state 709


state 583

    (274) cond_clause_s -> cond_clause ELSIF . m cond_clause_s
    (197) m -> .

    +               reduce using rule 197 (m -> .)
    -               reduce using rule 197 (m -> .)
    NOT             reduce using rule 197 (m -> .)
    INTEGER         reduce using rule 197 (m -> .)
    BASE_INTEGER    reduce using rule 197 (m -> .)
    FLOAT           reduce using rule 197 (m -> .)
    BASE_FLOAT      reduce using rule 197 (m -> .)
    NuLL            reduce using rule 197 (m -> .)
    NEW             reduce using rule 197 (m -> .)
    (               reduce using rule 197 (m -> .)
    CHAR            reduce using rule 197 (m -> .)
    IDENTIFIER      reduce using rule 197 (m -> .)
    STRING          reduce using rule 197 (m -> .)

    m                              shift and go to state 710

state 584

    (276) cond_clause -> cond_part m . statement_s n
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s m statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (305) exit_stmt -> . EXIT name_opt when_opt ;
    (310) return_stmt -> . RETURN ;
    (311) return_stmt -> . RETURN expression ;
    (312) goto_stmt -> . GOTO name ;
    (335) procedure_call -> . name ;
    (407) delay_stmt -> . DELAY expression ;
    (408) delay_stmt -> . DELAY UNTIL expression ;
    (428) abort_stmt -> . ABORT name_s ;
    (467) raise_stmt -> . RAISE name_opt ;
    (513) code_stmt -> . qualified ;
    (468) requeue_stmt -> . REQUEUE name ;
    (469) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (281) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (286) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (298) block -> . label_opt block_decl block_body END id_opt ;
    (402) accept_stmt -> . accept_hdr ;
    (403) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (409) select_stmt -> . select_wait
    (410) select_stmt -> . async_select
    (411) select_stmt -> . timed_entry_call
    (412) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (282) case_hdr -> . CASE expression IS
    (287) label_opt -> .
    (288) label_opt -> . IDENTIFIER :
    (404) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (413) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (423) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (424) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (425) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 287 (label_opt -> .)
    DECLARE         reduce using rule 287 (label_opt -> .)
    FOR             reduce using rule 287 (label_opt -> .)
    LOOP            reduce using rule 287 (label_opt -> .)
    BEGIN           reduce using rule 287 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 139

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    label                          shift and go to state 279
    statement_s                    shift and go to state 711
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 138
    assign_stmt                    shift and go to state 308
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    attribute                      shift and go to state 121
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    timed_entry_call               shift and go to state 296
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 585

    (277) cond_part -> condition THEN .

    LESSLESS        reduce using rule 277 (cond_part -> condition THEN .)
    error           reduce using rule 277 (cond_part -> condition THEN .)
    PRAGMA          reduce using rule 277 (cond_part -> condition THEN .)
    NuLL            reduce using rule 277 (cond_part -> condition THEN .)
    EXIT            reduce using rule 277 (cond_part -> condition THEN .)
    RETURN          reduce using rule 277 (cond_part -> condition THEN .)
    GOTO            reduce using rule 277 (cond_part -> condition THEN .)
    DELAY           reduce using rule 277 (cond_part -> condition THEN .)
    ABORT           reduce using rule 277 (cond_part -> condition THEN .)
    RAISE           reduce using rule 277 (cond_part -> condition THEN .)
    REQUEUE         reduce using rule 277 (cond_part -> condition THEN .)
    IF              reduce using rule 277 (cond_part -> condition THEN .)
    CASE            reduce using rule 277 (cond_part -> condition THEN .)
    IDENTIFIER      reduce using rule 277 (cond_part -> condition THEN .)
    ACCEPT          reduce using rule 277 (cond_part -> condition THEN .)
    SELECT          reduce using rule 277 (cond_part -> condition THEN .)
    STRING          reduce using rule 277 (cond_part -> condition THEN .)
    WHILE           reduce using rule 277 (cond_part -> condition THEN .)
    DECLARE         reduce using rule 277 (cond_part -> condition THEN .)
    FOR             reduce using rule 277 (cond_part -> condition THEN .)
    LOOP            reduce using rule 277 (cond_part -> condition THEN .)
    BEGIN           reduce using rule 277 (cond_part -> condition THEN .)


state 586

    (334) subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .

    PACKAGE         reduce using rule 334 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    TASK            reduce using rule 334 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    PROTECTED       reduce using rule 334 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    error           reduce using rule 334 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    USE             reduce using rule 334 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    PRAGMA          reduce using rule 334 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    TYPE            reduce using rule 334 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    SUBTYPE         reduce using rule 334 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    FOR             reduce using rule 334 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    PROCEDURE       reduce using rule 334 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    FUNCTION        reduce using rule 334 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    GENERIC         reduce using rule 334 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    IDENTIFIER      reduce using rule 334 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    BEGIN           reduce using rule 334 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    END             reduce using rule 334 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    PRIVATE         reduce using rule 334 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    WITH            reduce using rule 334 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    SEPARATE        reduce using rule 334 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    $end            reduce using rule 334 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)
    ENTRY           reduce using rule 334 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt ; .)


state 587

    (507) record_type_spec -> FOR mark USE RECORD align_opt . comp_loc_s END RECORD ;
    (510) comp_loc_s -> .
    (511) comp_loc_s -> . comp_loc_s mark AT expression RANGE range ;

    END             reduce using rule 510 (comp_loc_s -> .)
    IDENTIFIER      reduce using rule 510 (comp_loc_s -> .)

    comp_loc_s                     shift and go to state 712

state 588

    (509) align_opt -> AT . MOD expression ;

    MOD             shift and go to state 713


state 589

    (512) address_spec -> FOR mark USE AT expression . ;
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ;               shift and go to state 714
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 590

    (506) attrib_def -> FOR mark USE expression ; .

    PACKAGE         reduce using rule 506 (attrib_def -> FOR mark USE expression ; .)
    TASK            reduce using rule 506 (attrib_def -> FOR mark USE expression ; .)
    PROTECTED       reduce using rule 506 (attrib_def -> FOR mark USE expression ; .)
    error           reduce using rule 506 (attrib_def -> FOR mark USE expression ; .)
    USE             reduce using rule 506 (attrib_def -> FOR mark USE expression ; .)
    PRAGMA          reduce using rule 506 (attrib_def -> FOR mark USE expression ; .)
    TYPE            reduce using rule 506 (attrib_def -> FOR mark USE expression ; .)
    SUBTYPE         reduce using rule 506 (attrib_def -> FOR mark USE expression ; .)
    FOR             reduce using rule 506 (attrib_def -> FOR mark USE expression ; .)
    PROCEDURE       reduce using rule 506 (attrib_def -> FOR mark USE expression ; .)
    FUNCTION        reduce using rule 506 (attrib_def -> FOR mark USE expression ; .)
    GENERIC         reduce using rule 506 (attrib_def -> FOR mark USE expression ; .)
    IDENTIFIER      reduce using rule 506 (attrib_def -> FOR mark USE expression ; .)
    BEGIN           reduce using rule 506 (attrib_def -> FOR mark USE expression ; .)
    PRIVATE         reduce using rule 506 (attrib_def -> FOR mark USE expression ; .)
    END             reduce using rule 506 (attrib_def -> FOR mark USE expression ; .)
    ENTRY           reduce using rule 506 (attrib_def -> FOR mark USE expression ; .)


state 591

    (454) body_stub -> TASK BODY simple_name IS SEPARATE . ;

    ;               shift and go to state 715


state 592

    (368) task_body -> TASK BODY simple_name IS decl_part . block_body END id_opt ;
    (301) block_body -> . BEGIN handled_stmt_s

    BEGIN           shift and go to state 162

    block_body                     shift and go to state 716

state 593

    (363) task_spec -> TASK TYPE simple_name discrim_part_opt task_def .

    ;               reduce using rule 363 (task_spec -> TASK TYPE simple_name discrim_part_opt task_def .)


state 594

    (365) task_def -> IS entry_decl_s rep_spec_s . task_private_opt END id_opt
    (400) rep_spec_s -> rep_spec_s . rep_spec pragma_s
    (366) task_private_opt -> .
    (367) task_private_opt -> . PRIVATE entry_decl_s rep_spec_s
    (503) rep_spec -> . attrib_def
    (504) rep_spec -> . record_type_spec
    (505) rep_spec -> . address_spec
    (506) attrib_def -> . FOR mark USE expression ;
    (507) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (512) address_spec -> . FOR mark USE AT expression ;

    END             reduce using rule 366 (task_private_opt -> .)
    PRIVATE         shift and go to state 718
    FOR             shift and go to state 63

    record_type_spec               shift and go to state 68
    rep_spec                       shift and go to state 717
    attrib_def                     shift and go to state 70
    address_spec                   shift and go to state 52
    task_private_opt               shift and go to state 719

state 595

    (392) entry_decl_s -> entry_decl_s entry_decl . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    FOR             reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 720

state 596

    (455) body_stub -> PACKAGE BODY compound_name IS SEPARATE . ;

    ;               shift and go to state 721


state 597

    (110) discrim_part -> ( discrim_spec_s ) .

    IS              reduce using rule 110 (discrim_part -> ( discrim_spec_s ) .)
    ;               reduce using rule 110 (discrim_part -> ( discrim_spec_s ) .)


state 598

    (112) discrim_spec_s -> discrim_spec_s ; . discrim_spec
    (113) discrim_spec -> . def_id_s : access_opt mark init_opt
    (114) discrim_spec -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    error           shift and go to state 474
    IDENTIFIER      shift and go to state 76

    discrim_spec                   shift and go to state 722
    def_id                         shift and go to state 89
    def_id_s                       shift and go to state 476

state 599

    (113) discrim_spec -> def_id_s : . access_opt mark init_opt
    (115) access_opt -> .
    (116) access_opt -> . ACCESS

    IDENTIFIER      reduce using rule 115 (access_opt -> .)
    ACCESS          shift and go to state 723

    access_opt                     shift and go to state 724

state 600

    (39) discrim_part_opt -> ( LESSMORE ) .

    IS              reduce using rule 39 (discrim_part_opt -> ( LESSMORE ) .)
    ;               reduce using rule 39 (discrim_part_opt -> ( LESSMORE ) .)


state 601

    (59) derived_type -> ABSTRACT . NEW subtype_ind WITH PRIVATE
    (60) derived_type -> ABSTRACT . NEW subtype_ind WITH record_def
    (100) tagged_opt -> ABSTRACT . TAGGED

    NEW             shift and go to state 726
    TAGGED          shift and go to state 725


state 602

    (70) range_spec -> range_constraint .

    ;               reduce using rule 70 (range_spec -> range_constraint .)


state 603

    (47) type_def -> access_type .

    ;               reduce using rule 47 (type_def -> access_type .)


state 604

    (46) type_def -> record_type .

    ;               reduce using rule 46 (type_def -> record_type .)


state 605

    (44) type_def -> real_type .

    ;               reduce using rule 44 (type_def -> real_type .)


state 606

    (56) derived_type -> NEW . subtype_ind
    (57) derived_type -> NEW . subtype_ind WITH PRIVATE
    (58) derived_type -> NEW . subtype_ind WITH record_def
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 481
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    subtype_ind                    shift and go to state 727
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 607

    (42) type_def -> enumeration_type .

    ;               reduce using rule 42 (type_def -> enumeration_type .)


state 608

    (49) type_def -> private_type .

    ;               reduce using rule 49 (type_def -> private_type .)


state 609

    (73) real_type -> float_type .

    ;               reduce using rule 73 (real_type -> float_type .)


state 610

    (64) enumeration_type -> ( . enum_id_s )
    (65) enum_id_s -> . enum_id
    (66) enum_id_s -> . enum_id_s , enum_id
    (67) enum_id -> . IDENTIFIER
    (68) enum_id -> . CHAR

    IDENTIFIER      shift and go to state 730
    CHAR            shift and go to state 729

    enum_id                        shift and go to state 731
    enum_id_s                      shift and go to state 728

state 611

    (75) float_type -> DIGITS . expression range_spec_opt
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 732

state 612

    (99) tagged_opt -> TAGGED .

    LIMITED         reduce using rule 99 (tagged_opt -> TAGGED .)
    PRIVATE         reduce using rule 99 (tagged_opt -> TAGGED .)
    RECORD          reduce using rule 99 (tagged_opt -> TAGGED .)
    NuLL            reduce using rule 99 (tagged_opt -> TAGGED .)


state 613

    (76) fixed_type -> DELTA . expression range_spec
    (77) fixed_type -> DELTA . expression DIGITS expression range_spec_opt
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 733

state 614

    (43) type_def -> integer_type .

    ;               reduce using rule 43 (type_def -> integer_type .)


state 615

    (45) type_def -> array_type .

    ;               reduce using rule 45 (type_def -> array_type .)


state 616

    (69) integer_type -> range_spec .

    ;               reduce using rule 69 (integer_type -> range_spec .)


state 617

    (41) type_completion -> IS type_def .

    ;               reduce using rule 41 (type_completion -> IS type_def .)


state 618

    (128) access_type -> ACCESS . subtype_ind
    (129) access_type -> ACCESS . CONSTANT subtype_ind
    (130) access_type -> ACCESS . ALL subtype_ind
    (131) access_type -> ACCESS . prot_opt PROCEDURE formal_part_opt
    (132) access_type -> ACCESS . prot_opt FUNCTION formal_part_opt RETURN mark
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (133) prot_opt -> .
    (134) prot_opt -> . PROTECTED
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    CONSTANT        shift and go to state 734
    ALL             shift and go to state 737
    PROCEDURE       reduce using rule 133 (prot_opt -> .)
    FUNCTION        reduce using rule 133 (prot_opt -> .)
    PROTECTED       shift and go to state 736
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 481
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    prot_opt                       shift and go to state 735
    subtype_ind                    shift and go to state 738
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 619

    (95) record_type -> tagged_opt . limited_opt record_def
    (346) private_type -> tagged_opt . limited_opt PRIVATE
    (347) limited_opt -> .
    (348) limited_opt -> . LIMITED

    PRIVATE         reduce using rule 347 (limited_opt -> .)
    RECORD          reduce using rule 347 (limited_opt -> .)
    NuLL            reduce using rule 347 (limited_opt -> .)
    LIMITED         shift and go to state 739

    limited_opt                    shift and go to state 740

state 620

    (48) type_def -> derived_type .

    ;               reduce using rule 48 (type_def -> derived_type .)


state 621

    (74) real_type -> fixed_type .

    ;               reduce using rule 74 (real_type -> fixed_type .)


state 622

    (36) type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .

    error           reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    USE             reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    PRAGMA          reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    TYPE            reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    SUBTYPE         reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    TASK            reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    PACKAGE         reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    PROTECTED       reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    FOR             reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    PROCEDURE       reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    FUNCTION        reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    GENERIC         reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    IDENTIFIER      reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    PRIVATE         reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    END             reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)
    BEGIN           reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion ; .)


state 623

    (55) decimal_digits_constraint -> DIGITS . expression range_constr_opt
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 741

state 624

    (51) subtype_ind -> name constraint .

    WITH            reduce using rule 51 (subtype_ind -> name constraint .)
    ;               reduce using rule 51 (subtype_ind -> name constraint .)
    ASSIGNMENT      reduce using rule 51 (subtype_ind -> name constraint .)
    RENAMES         reduce using rule 51 (subtype_ind -> name constraint .)


state 625

    (53) constraint -> range_constraint .

    ;               reduce using rule 53 (constraint -> range_constraint .)
    RENAMES         reduce using rule 53 (constraint -> range_constraint .)
    ASSIGNMENT      reduce using rule 53 (constraint -> range_constraint .)
    WITH            reduce using rule 53 (constraint -> range_constraint .)


state 626

    (54) constraint -> decimal_digits_constraint .

    ;               reduce using rule 54 (constraint -> decimal_digits_constraint .)
    RENAMES         reduce using rule 54 (constraint -> decimal_digits_constraint .)
    ASSIGNMENT      reduce using rule 54 (constraint -> decimal_digits_constraint .)
    WITH            reduce using rule 54 (constraint -> decimal_digits_constraint .)


state 627

    (50) subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .

    PACKAGE         reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    TASK            reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    PROTECTED       reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    error           reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    USE             reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    PRAGMA          reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    TYPE            reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    SUBTYPE         reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    FOR             reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    PROCEDURE       reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    FUNCTION        reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    GENERIC         reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    IDENTIFIER      reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    BEGIN           reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    PRIVATE         reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)
    END             reduce using rule 50 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind ; .)


state 628

    (354) rename_decl -> def_id_s : EXCEPTION renames ; .

    PACKAGE         reduce using rule 354 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    TASK            reduce using rule 354 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    PROTECTED       reduce using rule 354 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    error           reduce using rule 354 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    USE             reduce using rule 354 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    PRAGMA          reduce using rule 354 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    TYPE            reduce using rule 354 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    SUBTYPE         reduce using rule 354 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    FOR             reduce using rule 354 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    PROCEDURE       reduce using rule 354 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    FUNCTION        reduce using rule 354 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    GENERIC         reduce using rule 354 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    IDENTIFIER      reduce using rule 354 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    BEGIN           reduce using rule 354 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    END             reduce using rule 354 (rename_decl -> def_id_s : EXCEPTION renames ; .)
    PRIVATE         reduce using rule 354 (rename_decl -> def_id_s : EXCEPTION renames ; .)


state 629

    (35) number_decl -> def_id_s : CONSTANT ASSIGNMENT expression . ;
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ;               shift and go to state 742
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 630

    (80) unconstr_array_type -> ARRAY ( . index_s ) OF component_subtype_def
    (88) iter_index_constraint -> ( . iter_discrete_range_s )
    (85) index_s -> . index
    (86) index_s -> . index_s , index
    (89) iter_discrete_range_s -> . discrete_range
    (90) iter_discrete_range_s -> . iter_discrete_range_s , discrete_range
    (87) index -> . name RANGE LESSMORE
    (91) discrete_range -> . name range_constr_opt
    (92) discrete_range -> . range
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    iter_discrete_range_s          shift and go to state 743
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    simple_expression              shift and go to state 358
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    index                          shift and go to state 744
    index_s                        shift and go to state 745
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    primary                        shift and go to state 122
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    discrete_range                 shift and go to state 746
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 747
    operator_symbol                shift and go to state 138
    range                          shift and go to state 681

state 631

    (81) constr_array_type -> ARRAY iter_index_constraint . OF subtype_ind

    OF              shift and go to state 748


state 632

    (34) init_opt -> ASSIGNMENT . expression
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 749

state 633

    (23) object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt . ;

    ;               shift and go to state 750


state 634

    (353) rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames . ;

    ;               shift and go to state 751


state 635

    (343) pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt . END c_id_opt ;

    END             shift and go to state 752


state 636

    (345) body_opt -> block_body .

    END             reduce using rule 345 (body_opt -> block_body .)


state 637

    (457) body_stub -> PROTECTED BODY simple_name . IS SEPARATE ;

    IS              shift and go to state 753


state 638

    (340) private_part -> PRIVATE decl_item_s .

    END             reduce using rule 340 (private_part -> PRIVATE decl_item_s .)


state 639

    (338) pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END . c_id_opt
    (341) c_id_opt -> .
    (342) c_id_opt -> . compound_name
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 341 (c_id_opt -> .)
    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 41
    compound_name                  shift and go to state 754
    c_id_opt                       shift and go to state 755

state 640

    (454) body_stub -> TASK BODY simple_name . IS SEPARATE ;

    IS              shift and go to state 756


state 641

    (455) body_stub -> PACKAGE BODY compound_name . IS SEPARATE ;
    (163) compound_name -> compound_name . . simple_name

    IS              shift and go to state 757
    .               shift and go to state 119


state 642

    (325) param_s -> param_s ; param .

    )               reduce using rule 325 (param_s -> param_s ; param .)
    ;               reduce using rule 325 (param_s -> param_s ; param .)


state 643

    (477) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN . name subp_default ;
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 758
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    indexed_comp                   shift and go to state 129
    operator_symbol                shift and go to state 138
    simple_name                    shift and go to state 157

state 644

    (478) generic_formal -> WITH PACKAGE simple_name IS NEW . name ( LESSMORE ) ;
    (479) generic_formal -> WITH PACKAGE simple_name IS NEW . name ;
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 759
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 645

    (485) subp_default -> IS . name
    (486) subp_default -> IS . LESSMORE
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSMORE        shift and go to state 761
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 760
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 646

    (476) generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default . ;

    ;               shift and go to state 762


state 647

    (326) param -> def_id_s : mode mark init_opt .

    )               reduce using rule 326 (param -> def_id_s : mode mark init_opt .)
    ;               reduce using rule 326 (param -> def_id_s : mode mark init_opt .)


state 648

    (499) generic_derived_type -> ABSTRACT . NEW subtype_ind WITH PRIVATE
    (100) tagged_opt -> ABSTRACT . TAGGED

    NEW             shift and go to state 763
    TAGGED          shift and go to state 725


state 649

    (475) generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def . ;

    ;               shift and go to state 764


state 650

    (497) generic_derived_type -> NEW . subtype_ind
    (498) generic_derived_type -> NEW . subtype_ind WITH PRIVATE
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 481
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    subtype_ind                    shift and go to state 765
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 651

    (496) generic_type_def -> generic_derived_type .

    ;               reduce using rule 496 (generic_type_def -> generic_derived_type .)


state 652

    (492) generic_type_def -> DIGITS . LESSMORE

    LESSMORE        shift and go to state 766


state 653

    (487) generic_type_def -> ( . LESSMORE )

    LESSMORE        shift and go to state 767


state 654

    (495) generic_type_def -> private_type .

    ;               reduce using rule 495 (generic_type_def -> private_type .)


state 655

    (488) generic_type_def -> RANGE . LESSMORE

    LESSMORE        shift and go to state 768


state 656

    (494) generic_type_def -> access_type .

    ;               reduce using rule 494 (generic_type_def -> access_type .)


state 657

    (493) generic_type_def -> array_type .

    ;               reduce using rule 493 (generic_type_def -> array_type .)


state 658

    (346) private_type -> tagged_opt . limited_opt PRIVATE
    (347) limited_opt -> .
    (348) limited_opt -> . LIMITED

    PRIVATE         reduce using rule 347 (limited_opt -> .)
    LIMITED         shift and go to state 739

    limited_opt                    shift and go to state 769

state 659

    (490) generic_type_def -> DELTA . LESSMORE
    (491) generic_type_def -> DELTA . LESSMORE DIGITS LESSMORE

    LESSMORE        shift and go to state 770


state 660

    (489) generic_type_def -> MOD . LESSMORE

    LESSMORE        shift and go to state 771


state 661

    (483) generic_discrim_part_opt -> ( LESSMORE ) .

    IS              reduce using rule 483 (generic_discrim_part_opt -> ( LESSMORE ) .)


state 662

    (191) aggregate -> ( expression WITH value_s ) .

    STARSTAR        reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    *               reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    /               reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    MOD             reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    REM             reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    =               reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    NOTEQUAL        reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    <               reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    LESSEQ          reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    >               reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    GREATEREQ       reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    IN              reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    NOT             reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    +               reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    -               reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    &               reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    AND             reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    OR              reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    )               reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    ,               reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    DOTDOT          reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    WITH            reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    ARROW           reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    |               reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    ;               reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    IS              reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    THEN            reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    LOOP            reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    RANGE           reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    DIGITS          reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    RENAMES         reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)
    ASSIGNMENT      reduce using rule 191 (aggregate -> ( expression WITH value_s ) .)


state 663

    (192) aggregate -> ( expression WITH NuLL RECORD . )

    )               shift and go to state 772


state 664

    (170) value_s -> value_s , value .

    )               reduce using rule 170 (value_s -> value_s , value .)
    ,               reduce using rule 170 (value_s -> value_s , value .)


state 665

    (385) prot_body -> PROTECTED BODY simple_name . IS prot_op_body_s END id_opt ;

    IS              shift and go to state 773


state 666

    (368) task_body -> TASK BODY simple_name . IS decl_part block_body END id_opt ;

    IS              shift and go to state 774


state 667

    (457) body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .

    PACKAGE         reduce using rule 457 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    TASK            reduce using rule 457 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    PROTECTED       reduce using rule 457 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    error           reduce using rule 457 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    USE             reduce using rule 457 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    PRAGMA          reduce using rule 457 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    TYPE            reduce using rule 457 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    SUBTYPE         reduce using rule 457 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    FOR             reduce using rule 457 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    PROCEDURE       reduce using rule 457 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    FUNCTION        reduce using rule 457 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    GENERIC         reduce using rule 457 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    IDENTIFIER      reduce using rule 457 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    BEGIN           reduce using rule 457 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    END             reduce using rule 457 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)
    PRIVATE         reduce using rule 457 (body_stub -> PROTECTED BODY simple_name IS SEPARATE ; .)


state 668

    (389) prot_op_body -> subprog_body .

    PRAGMA          reduce using rule 389 (prot_op_body -> subprog_body .)
    END             reduce using rule 389 (prot_op_body -> subprog_body .)
    ENTRY           reduce using rule 389 (prot_op_body -> subprog_body .)
    PROCEDURE       reduce using rule 389 (prot_op_body -> subprog_body .)
    FUNCTION        reduce using rule 389 (prot_op_body -> subprog_body .)


state 669

    (390) prot_op_body -> subprog_spec . ;
    (333) subprog_spec_is_push -> subprog_spec . IS

    ;               shift and go to state 775
    IS              shift and go to state 532


state 670

    (385) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END . id_opt ;
    (296) id_opt -> .
    (297) id_opt -> . designator
    (319) designator -> . compound_name
    (320) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 296 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 114
    id_opt                         shift and go to state 776
    designator                     shift and go to state 462
    simple_name                    shift and go to state 41

state 671

    (388) prot_op_body -> entry_body .

    PRAGMA          reduce using rule 388 (prot_op_body -> entry_body .)
    END             reduce using rule 388 (prot_op_body -> entry_body .)
    ENTRY           reduce using rule 388 (prot_op_body -> entry_body .)
    PROCEDURE       reduce using rule 388 (prot_op_body -> entry_body .)
    FUNCTION        reduce using rule 388 (prot_op_body -> entry_body .)


state 672

    (387) prot_op_body_s -> prot_op_body_s prot_op_body . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 777

state 673

    (395) entry_body -> ENTRY . IDENTIFIER formal_part_opt WHEN condition entry_body_part
    (396) entry_body -> ENTRY . IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part

    IDENTIFIER      shift and go to state 778


state 674

    (374) prot_private_opt -> PRIVATE prot_elem_decl_s .
    (382) prot_elem_decl_s -> prot_elem_decl_s . prot_elem_decl
    (383) prot_elem_decl -> . prot_op_decl
    (384) prot_elem_decl -> . comp_decl
    (377) prot_op_decl -> . entry_decl
    (378) prot_op_decl -> . subprog_spec ;
    (379) prot_op_decl -> . rep_spec
    (380) prot_op_decl -> . pragma
    (108) comp_decl -> . def_id_s : component_subtype_def init_opt ;
    (109) comp_decl -> . error ;
    (393) entry_decl -> . ENTRY IDENTIFIER formal_part_opt ;
    (394) entry_decl -> . ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ;
    (316) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (317) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (318) subprog_spec -> . FUNCTION designator
    (503) rep_spec -> . attrib_def
    (504) rep_spec -> . record_type_spec
    (505) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (506) attrib_def -> . FOR mark USE expression ;
    (507) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (512) address_spec -> . FOR mark USE AT expression ;
    (26) def_id -> . IDENTIFIER

    END             reduce using rule 374 (prot_private_opt -> PRIVATE prot_elem_decl_s .)
    error           shift and go to state 783
    ENTRY           shift and go to state 542
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    PRAGMA          shift and go to state 4
    FOR             shift and go to state 63
    IDENTIFIER      shift and go to state 76

    rep_spec                       shift and go to state 536
    entry_decl                     shift and go to state 537
    address_spec                   shift and go to state 52
    record_type_spec               shift and go to state 68
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 539
    def_id_s                       shift and go to state 779
    comp_decl                      shift and go to state 780
    def_id                         shift and go to state 89
    pragma                         shift and go to state 541
    prot_op_decl                   shift and go to state 781
    prot_elem_decl                 shift and go to state 782

state 675

    (378) prot_op_decl -> subprog_spec ; .

    PRIVATE         reduce using rule 378 (prot_op_decl -> subprog_spec ; .)
    ENTRY           reduce using rule 378 (prot_op_decl -> subprog_spec ; .)
    PROCEDURE       reduce using rule 378 (prot_op_decl -> subprog_spec ; .)
    FUNCTION        reduce using rule 378 (prot_op_decl -> subprog_spec ; .)
    PRAGMA          reduce using rule 378 (prot_op_decl -> subprog_spec ; .)
    FOR             reduce using rule 378 (prot_op_decl -> subprog_spec ; .)
    END             reduce using rule 378 (prot_op_decl -> subprog_spec ; .)
    error           reduce using rule 378 (prot_op_decl -> subprog_spec ; .)
    IDENTIFIER      reduce using rule 378 (prot_op_decl -> subprog_spec ; .)


state 676

    (372) prot_def -> IS prot_op_decl_s prot_private_opt END . id_opt
    (296) id_opt -> .
    (297) id_opt -> . designator
    (319) designator -> . compound_name
    (320) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 296 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 462
    id_opt                         shift and go to state 784
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 677

    (393) entry_decl -> ENTRY IDENTIFIER . formal_part_opt ;
    (394) entry_decl -> ENTRY IDENTIFIER . ( discrete_range ) formal_part_opt ;
    (321) formal_part_opt -> .
    (322) formal_part_opt -> . formal_part
    (323) formal_part -> . ( param_s )

    (               shift and go to state 785
    ;               reduce using rule 321 (formal_part_opt -> .)

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 786

state 678

    (408) delay_stmt -> DELAY UNTIL expression ; .

    EXCEPTION       reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    LESSLESS        reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    error           reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    PRAGMA          reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    NuLL            reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    EXIT            reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    RETURN          reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    GOTO            reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    DELAY           reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    ABORT           reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    RAISE           reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    REQUEUE         reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    IF              reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    CASE            reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    IDENTIFIER      reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    ACCEPT          reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    SELECT          reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    STRING          reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    WHILE           reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    DECLARE         reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    FOR             reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    LOOP            reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    BEGIN           reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    END             reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    OR              reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    ELSE            reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    THEN            reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    ELSIF           reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)
    WHEN            reduce using rule 408 (delay_stmt -> DELAY UNTIL expression ; .)


state 679

    (291) iteration -> iter_part reverse_opt discrete_range .

    LOOP            reduce using rule 291 (iteration -> iter_part reverse_opt discrete_range .)


state 680

    (91) discrete_range -> name . range_constr_opt
    (63) range -> name .
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id
    (235) primary -> name .
    (241) qualified -> name . TICK parenthesized_primary
    (93) range_constr_opt -> .
    (94) range_constr_opt -> . range_constraint
    (61) range_constraint -> . RANGE range

  ! reduce/reduce conflict for LOOP resolved using rule 63 (range -> name .)
  ! reduce/reduce conflict for ) resolved using rule 63 (range -> name .)
  ! reduce/reduce conflict for , resolved using rule 63 (range -> name .)
    LOOP            reduce using rule 63 (range -> name .)
    )               reduce using rule 63 (range -> name .)
    ,               reduce using rule 63 (range -> name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 370
    STARSTAR        reduce using rule 235 (primary -> name .)
    *               reduce using rule 235 (primary -> name .)
    /               reduce using rule 235 (primary -> name .)
    MOD             reduce using rule 235 (primary -> name .)
    REM             reduce using rule 235 (primary -> name .)
    DOTDOT          reduce using rule 235 (primary -> name .)
    +               reduce using rule 235 (primary -> name .)
    -               reduce using rule 235 (primary -> name .)
    &               reduce using rule 235 (primary -> name .)
    RANGE           shift and go to state 371

  ! LOOP            [ reduce using rule 93 (range_constr_opt -> .) ]
  ! )               [ reduce using rule 93 (range_constr_opt -> .) ]
  ! ,               [ reduce using rule 93 (range_constr_opt -> .) ]

    range_constr_opt               shift and go to state 787
    range_constraint               shift and go to state 788

state 681

    (92) discrete_range -> range .

    )               reduce using rule 92 (discrete_range -> range .)
    ,               reduce using rule 92 (discrete_range -> range .)
    LOOP            reduce using rule 92 (discrete_range -> range .)


state 682

    (292) iter_part -> FOR IDENTIFIER IN .

    REVERSE         reduce using rule 292 (iter_part -> FOR IDENTIFIER IN .)
    IDENTIFIER      reduce using rule 292 (iter_part -> FOR IDENTIFIER IN .)
    STRING          reduce using rule 292 (iter_part -> FOR IDENTIFIER IN .)
    +               reduce using rule 292 (iter_part -> FOR IDENTIFIER IN .)
    -               reduce using rule 292 (iter_part -> FOR IDENTIFIER IN .)
    NOT             reduce using rule 292 (iter_part -> FOR IDENTIFIER IN .)
    INTEGER         reduce using rule 292 (iter_part -> FOR IDENTIFIER IN .)
    BASE_INTEGER    reduce using rule 292 (iter_part -> FOR IDENTIFIER IN .)
    FLOAT           reduce using rule 292 (iter_part -> FOR IDENTIFIER IN .)
    BASE_FLOAT      reduce using rule 292 (iter_part -> FOR IDENTIFIER IN .)
    NuLL            reduce using rule 292 (iter_part -> FOR IDENTIFIER IN .)
    NEW             reduce using rule 292 (iter_part -> FOR IDENTIFIER IN .)
    (               reduce using rule 292 (iter_part -> FOR IDENTIFIER IN .)
    CHAR            reduce using rule 292 (iter_part -> FOR IDENTIFIER IN .)


state 683

    (286) loop_stmt -> label_opt iteration m basic_loop . id_opt ;
    (296) id_opt -> .
    (297) id_opt -> . designator
    (319) designator -> . compound_name
    (320) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 296 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 462
    id_opt                         shift and go to state 789
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 684

    (295) basic_loop -> LOOP . statement_s END LOOP
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s m statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (305) exit_stmt -> . EXIT name_opt when_opt ;
    (310) return_stmt -> . RETURN ;
    (311) return_stmt -> . RETURN expression ;
    (312) goto_stmt -> . GOTO name ;
    (335) procedure_call -> . name ;
    (407) delay_stmt -> . DELAY expression ;
    (408) delay_stmt -> . DELAY UNTIL expression ;
    (428) abort_stmt -> . ABORT name_s ;
    (467) raise_stmt -> . RAISE name_opt ;
    (513) code_stmt -> . qualified ;
    (468) requeue_stmt -> . REQUEUE name ;
    (469) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (281) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (286) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (298) block -> . label_opt block_decl block_body END id_opt ;
    (402) accept_stmt -> . accept_hdr ;
    (403) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (409) select_stmt -> . select_wait
    (410) select_stmt -> . async_select
    (411) select_stmt -> . timed_entry_call
    (412) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (282) case_hdr -> . CASE expression IS
    (287) label_opt -> .
    (288) label_opt -> . IDENTIFIER :
    (404) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (413) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (423) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (424) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (425) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 287 (label_opt -> .)
    DECLARE         reduce using rule 287 (label_opt -> .)
    FOR             reduce using rule 287 (label_opt -> .)
    LOOP            reduce using rule 287 (label_opt -> .)
    BEGIN           reduce using rule 287 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 139

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 790
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 138
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    attribute                      shift and go to state 121
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 685

    (298) block -> label_opt block_decl block_body END . id_opt ;
    (296) id_opt -> .
    (297) id_opt -> . designator
    (319) designator -> . compound_name
    (320) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 296 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 462
    id_opt                         shift and go to state 791
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 686

    (290) iteration -> WHILE m condition .

    LOOP            reduce using rule 290 (iteration -> WHILE m condition .)


state 687

    (271) assign_stmt -> name ASSIGNMENT expression ; .

    EXCEPTION       reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    LESSLESS        reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    error           reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    PRAGMA          reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    NuLL            reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    EXIT            reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    RETURN          reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    GOTO            reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    DELAY           reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    ABORT           reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    RAISE           reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    REQUEUE         reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    IF              reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    CASE            reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    IDENTIFIER      reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    ACCEPT          reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    SELECT          reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    STRING          reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    WHILE           reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    DECLARE         reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    FOR             reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    LOOP            reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    BEGIN           reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    END             reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    OR              reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    ELSE            reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    THEN            reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    ELSIF           reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)
    WHEN            reduce using rule 271 (assign_stmt -> name ASSIGNMENT expression ; .)


state 688

    (26) def_id -> IDENTIFIER .
    (161) simple_name -> IDENTIFIER .

    :               reduce using rule 26 (def_id -> IDENTIFIER .)
    ,               reduce using rule 26 (def_id -> IDENTIFIER .)
    TICK            reduce using rule 161 (simple_name -> IDENTIFIER .)
    (               reduce using rule 161 (simple_name -> IDENTIFIER .)
    .               reduce using rule 161 (simple_name -> IDENTIFIER .)
    STARSTAR        reduce using rule 161 (simple_name -> IDENTIFIER .)
    *               reduce using rule 161 (simple_name -> IDENTIFIER .)
    /               reduce using rule 161 (simple_name -> IDENTIFIER .)
    MOD             reduce using rule 161 (simple_name -> IDENTIFIER .)
    REM             reduce using rule 161 (simple_name -> IDENTIFIER .)
    =               reduce using rule 161 (simple_name -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 161 (simple_name -> IDENTIFIER .)
    <               reduce using rule 161 (simple_name -> IDENTIFIER .)
    LESSEQ          reduce using rule 161 (simple_name -> IDENTIFIER .)
    >               reduce using rule 161 (simple_name -> IDENTIFIER .)
    GREATEREQ       reduce using rule 161 (simple_name -> IDENTIFIER .)
    IN              reduce using rule 161 (simple_name -> IDENTIFIER .)
    NOT             reduce using rule 161 (simple_name -> IDENTIFIER .)
    +               reduce using rule 161 (simple_name -> IDENTIFIER .)
    -               reduce using rule 161 (simple_name -> IDENTIFIER .)
    &               reduce using rule 161 (simple_name -> IDENTIFIER .)
    )               reduce using rule 161 (simple_name -> IDENTIFIER .)
    AND             reduce using rule 161 (simple_name -> IDENTIFIER .)
    OR              reduce using rule 161 (simple_name -> IDENTIFIER .)


state 689

    (406) entry_name -> entry_name ( expression . )
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    )               shift and go to state 792
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 690

    (425) cond_entry_call -> SELECT entry_call stmts_opt ELSE . statement_s END SELECT ;
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s m statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (305) exit_stmt -> . EXIT name_opt when_opt ;
    (310) return_stmt -> . RETURN ;
    (311) return_stmt -> . RETURN expression ;
    (312) goto_stmt -> . GOTO name ;
    (335) procedure_call -> . name ;
    (407) delay_stmt -> . DELAY expression ;
    (408) delay_stmt -> . DELAY UNTIL expression ;
    (428) abort_stmt -> . ABORT name_s ;
    (467) raise_stmt -> . RAISE name_opt ;
    (513) code_stmt -> . qualified ;
    (468) requeue_stmt -> . REQUEUE name ;
    (469) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (281) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (286) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (298) block -> . label_opt block_decl block_body END id_opt ;
    (402) accept_stmt -> . accept_hdr ;
    (403) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (409) select_stmt -> . select_wait
    (410) select_stmt -> . async_select
    (411) select_stmt -> . timed_entry_call
    (412) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (282) case_hdr -> . CASE expression IS
    (287) label_opt -> .
    (288) label_opt -> . IDENTIFIER :
    (404) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (413) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (423) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (424) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (425) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 287 (label_opt -> .)
    DECLARE         reduce using rule 287 (label_opt -> .)
    FOR             reduce using rule 287 (label_opt -> .)
    LOOP            reduce using rule 287 (label_opt -> .)
    BEGIN           reduce using rule 287 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 139

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 793
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 138
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    attribute                      shift and go to state 121
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 691

    (424) timed_entry_call -> SELECT entry_call stmts_opt OR . delay_stmt stmts_opt END SELECT ;
    (407) delay_stmt -> . DELAY expression ;
    (408) delay_stmt -> . DELAY UNTIL expression ;

    DELAY           shift and go to state 260

    delay_stmt                     shift and go to state 794

state 692

    (423) async_select -> SELECT delay_or_entry_alt THEN ABORT . statement_s END SELECT ;
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s m statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (305) exit_stmt -> . EXIT name_opt when_opt ;
    (310) return_stmt -> . RETURN ;
    (311) return_stmt -> . RETURN expression ;
    (312) goto_stmt -> . GOTO name ;
    (335) procedure_call -> . name ;
    (407) delay_stmt -> . DELAY expression ;
    (408) delay_stmt -> . DELAY UNTIL expression ;
    (428) abort_stmt -> . ABORT name_s ;
    (467) raise_stmt -> . RAISE name_opt ;
    (513) code_stmt -> . qualified ;
    (468) requeue_stmt -> . REQUEUE name ;
    (469) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (281) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (286) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (298) block -> . label_opt block_decl block_body END id_opt ;
    (402) accept_stmt -> . accept_hdr ;
    (403) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (409) select_stmt -> . select_wait
    (410) select_stmt -> . async_select
    (411) select_stmt -> . timed_entry_call
    (412) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (282) case_hdr -> . CASE expression IS
    (287) label_opt -> .
    (288) label_opt -> . IDENTIFIER :
    (404) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (413) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (423) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (424) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (425) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 287 (label_opt -> .)
    DECLARE         reduce using rule 287 (label_opt -> .)
    FOR             reduce using rule 287 (label_opt -> .)
    LOOP            reduce using rule 287 (label_opt -> .)
    BEGIN           reduce using rule 287 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 139

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 795
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 138
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    attribute                      shift and go to state 121
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    procedure_call                 shift and go to state 276
    block                          shift and go to state 283

state 693

    (415) guarded_select_alt -> WHEN condition ARROW . select_alt
    (418) select_alt -> . accept_stmt stmts_opt
    (419) select_alt -> . delay_stmt stmts_opt
    (420) select_alt -> . TERMINATE ;
    (402) accept_stmt -> . accept_hdr ;
    (403) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (407) delay_stmt -> . DELAY expression ;
    (408) delay_stmt -> . DELAY UNTIL expression ;
    (404) accept_hdr -> . ACCEPT entry_name formal_part_opt

    TERMINATE       shift and go to state 441
    DELAY           shift and go to state 260
    ACCEPT          shift and go to state 275

    delay_stmt                     shift and go to state 796
    accept_hdr                     shift and go to state 292
    accept_stmt                    shift and go to state 432
    select_alt                     shift and go to state 797

state 694

    (413) select_wait -> SELECT guarded_select_alt or_select else_opt . END SELECT ;

    END             shift and go to state 798


state 695

    (417) or_select -> or_select OR . guarded_select_alt
    (414) guarded_select_alt -> . select_alt
    (415) guarded_select_alt -> . WHEN condition ARROW select_alt
    (418) select_alt -> . accept_stmt stmts_opt
    (419) select_alt -> . delay_stmt stmts_opt
    (420) select_alt -> . TERMINATE ;
    (402) accept_stmt -> . accept_hdr ;
    (403) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (407) delay_stmt -> . DELAY expression ;
    (408) delay_stmt -> . DELAY UNTIL expression ;
    (404) accept_hdr -> . ACCEPT entry_name formal_part_opt

    WHEN            shift and go to state 436
    TERMINATE       shift and go to state 441
    DELAY           shift and go to state 260
    ACCEPT          shift and go to state 275

    delay_stmt                     shift and go to state 796
    accept_hdr                     shift and go to state 292
    accept_stmt                    shift and go to state 432
    guarded_select_alt             shift and go to state 799
    select_alt                     shift and go to state 438

state 696

    (284) alternative_s -> alternative_s alternative .

    END             reduce using rule 284 (alternative_s -> alternative_s alternative .)
    WHEN            reduce using rule 284 (alternative_s -> alternative_s alternative .)


state 697

    (281) case_stmt -> case_hdr pragma_s alternative_s END . CASE ;

    CASE            shift and go to state 800


state 698

    (285) alternative -> WHEN . choice_s ARROW statement_s
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    OTHERS          shift and go to state 223
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 514
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    allocator                      shift and go to state 130
    choice_s                       shift and go to state 801
    operator_symbol                shift and go to state 138
    factor                         shift and go to state 137
    choice                         shift and go to state 227
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 147
    name                           shift and go to state 516
    range                          shift and go to state 232
    expression                     shift and go to state 517

state 699

    (469) requeue_stmt -> REQUEUE name WITH ABORT . ;

    ;               shift and go to state 802


state 700

    (403) accept_stmt -> accept_hdr DO handled_stmt_s END . id_opt ;
    (296) id_opt -> .
    (297) id_opt -> . designator
    (319) designator -> . compound_name
    (320) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 296 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 462
    id_opt                         shift and go to state 803
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 701

    (305) exit_stmt -> EXIT name_opt when_opt ; .

    EXCEPTION       reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    LESSLESS        reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    error           reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    PRAGMA          reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    NuLL            reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    EXIT            reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    RETURN          reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    GOTO            reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    DELAY           reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    ABORT           reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    RAISE           reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    REQUEUE         reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    IF              reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    CASE            reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    IDENTIFIER      reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    ACCEPT          reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    SELECT          reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    STRING          reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    WHILE           reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    DECLARE         reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    FOR             reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    LOOP            reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    BEGIN           reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    END             reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    OR              reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    ELSE            reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    THEN            reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    ELSIF           reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)
    WHEN            reduce using rule 305 (exit_stmt -> EXIT name_opt when_opt ; .)


state 702

    (309) when_opt -> WHEN condition .

    ;               reduce using rule 309 (when_opt -> WHEN condition .)


state 703

    (461) exception_handler -> WHEN except_choice_s . ARROW statement_s
    (464) except_choice_s -> except_choice_s . | except_choice

    ARROW           shift and go to state 804
    |               shift and go to state 805


state 704

    (462) exception_handler -> WHEN IDENTIFIER . : except_choice_s ARROW statement_s
    (161) simple_name -> IDENTIFIER .

    :               shift and go to state 806
    (               reduce using rule 161 (simple_name -> IDENTIFIER .)
    .               reduce using rule 161 (simple_name -> IDENTIFIER .)
    TICK            reduce using rule 161 (simple_name -> IDENTIFIER .)
    ARROW           reduce using rule 161 (simple_name -> IDENTIFIER .)
    |               reduce using rule 161 (simple_name -> IDENTIFIER .)


state 705

    (463) except_choice_s -> except_choice .

    ARROW           reduce using rule 463 (except_choice_s -> except_choice .)
    |               reduce using rule 463 (except_choice_s -> except_choice .)


state 706

    (466) except_choice -> OTHERS .

    ARROW           reduce using rule 466 (except_choice -> OTHERS .)
    |               reduce using rule 466 (except_choice -> OTHERS .)


state 707

    (465) except_choice -> name .
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id

    ARROW           reduce using rule 465 (except_choice -> name .)
    |               reduce using rule 465 (except_choice -> name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 708

    (280) else_opt -> ELSE m . statement_s
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s m statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (305) exit_stmt -> . EXIT name_opt when_opt ;
    (310) return_stmt -> . RETURN ;
    (311) return_stmt -> . RETURN expression ;
    (312) goto_stmt -> . GOTO name ;
    (335) procedure_call -> . name ;
    (407) delay_stmt -> . DELAY expression ;
    (408) delay_stmt -> . DELAY UNTIL expression ;
    (428) abort_stmt -> . ABORT name_s ;
    (467) raise_stmt -> . RAISE name_opt ;
    (513) code_stmt -> . qualified ;
    (468) requeue_stmt -> . REQUEUE name ;
    (469) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (281) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (286) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (298) block -> . label_opt block_decl block_body END id_opt ;
    (402) accept_stmt -> . accept_hdr ;
    (403) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (409) select_stmt -> . select_wait
    (410) select_stmt -> . async_select
    (411) select_stmt -> . timed_entry_call
    (412) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (282) case_hdr -> . CASE expression IS
    (287) label_opt -> .
    (288) label_opt -> . IDENTIFIER :
    (404) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (413) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (423) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (424) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (425) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 287 (label_opt -> .)
    DECLARE         reduce using rule 287 (label_opt -> .)
    FOR             reduce using rule 287 (label_opt -> .)
    LOOP            reduce using rule 287 (label_opt -> .)
    BEGIN           reduce using rule 287 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 139

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 807
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 138
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    attribute                      shift and go to state 121
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 709

    (272) if_stmt -> IF cond_clause_s else_opt END . IF ;

    IF              shift and go to state 808


state 710

    (274) cond_clause_s -> cond_clause ELSIF m . cond_clause_s
    (273) cond_clause_s -> . cond_clause
    (274) cond_clause_s -> . cond_clause ELSIF m cond_clause_s
    (276) cond_clause -> . cond_part m statement_s n
    (277) cond_part -> . condition THEN
    (278) condition -> . expression
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    cond_clause_s                  shift and go to state 809
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    simple_name                    shift and go to state 157
    indexed_comp                   shift and go to state 129
    cond_clause                    shift and go to state 458
    cond_part                      shift and go to state 459
    literal                        shift and go to state 135
    allocator                      shift and go to state 130
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    condition                      shift and go to state 460
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 461

state 711

    (276) cond_clause -> cond_part m statement_s . n
    (245) statement_s -> statement_s . m statement
    (275) n -> .
    (197) m -> .

    ELSIF           reduce using rule 275 (n -> .)
    ELSE            reduce using rule 275 (n -> .)
    END             reduce using rule 275 (n -> .)
    LESSLESS        reduce using rule 197 (m -> .)
    error           reduce using rule 197 (m -> .)
    PRAGMA          reduce using rule 197 (m -> .)
    NuLL            reduce using rule 197 (m -> .)
    EXIT            reduce using rule 197 (m -> .)
    RETURN          reduce using rule 197 (m -> .)
    GOTO            reduce using rule 197 (m -> .)
    DELAY           reduce using rule 197 (m -> .)
    ABORT           reduce using rule 197 (m -> .)
    RAISE           reduce using rule 197 (m -> .)
    REQUEUE         reduce using rule 197 (m -> .)
    IF              reduce using rule 197 (m -> .)
    CASE            reduce using rule 197 (m -> .)
    IDENTIFIER      reduce using rule 197 (m -> .)
    ACCEPT          reduce using rule 197 (m -> .)
    SELECT          reduce using rule 197 (m -> .)
    STRING          reduce using rule 197 (m -> .)
    WHILE           reduce using rule 197 (m -> .)
    DECLARE         reduce using rule 197 (m -> .)
    FOR             reduce using rule 197 (m -> .)
    LOOP            reduce using rule 197 (m -> .)
    BEGIN           reduce using rule 197 (m -> .)

    m                              shift and go to state 454
    n                              shift and go to state 810

state 712

    (507) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s . END RECORD ;
    (511) comp_loc_s -> comp_loc_s . mark AT expression RANGE range ;
    (158) mark -> . simple_name
    (159) mark -> . mark TICK attribute_id
    (160) mark -> . mark . simple_name
    (161) simple_name -> . IDENTIFIER

    END             shift and go to state 811
    IDENTIFIER      shift and go to state 39

    mark                           shift and go to state 812
    simple_name                    shift and go to state 165

state 713

    (509) align_opt -> AT MOD . expression ;
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 813

state 714

    (512) address_spec -> FOR mark USE AT expression ; .

    PACKAGE         reduce using rule 512 (address_spec -> FOR mark USE AT expression ; .)
    TASK            reduce using rule 512 (address_spec -> FOR mark USE AT expression ; .)
    PROTECTED       reduce using rule 512 (address_spec -> FOR mark USE AT expression ; .)
    error           reduce using rule 512 (address_spec -> FOR mark USE AT expression ; .)
    USE             reduce using rule 512 (address_spec -> FOR mark USE AT expression ; .)
    PRAGMA          reduce using rule 512 (address_spec -> FOR mark USE AT expression ; .)
    TYPE            reduce using rule 512 (address_spec -> FOR mark USE AT expression ; .)
    SUBTYPE         reduce using rule 512 (address_spec -> FOR mark USE AT expression ; .)
    FOR             reduce using rule 512 (address_spec -> FOR mark USE AT expression ; .)
    PROCEDURE       reduce using rule 512 (address_spec -> FOR mark USE AT expression ; .)
    FUNCTION        reduce using rule 512 (address_spec -> FOR mark USE AT expression ; .)
    GENERIC         reduce using rule 512 (address_spec -> FOR mark USE AT expression ; .)
    IDENTIFIER      reduce using rule 512 (address_spec -> FOR mark USE AT expression ; .)
    BEGIN           reduce using rule 512 (address_spec -> FOR mark USE AT expression ; .)
    END             reduce using rule 512 (address_spec -> FOR mark USE AT expression ; .)
    ENTRY           reduce using rule 512 (address_spec -> FOR mark USE AT expression ; .)
    PRIVATE         reduce using rule 512 (address_spec -> FOR mark USE AT expression ; .)


state 715

    (454) body_stub -> TASK BODY simple_name IS SEPARATE ; .

    PACKAGE         reduce using rule 454 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    TASK            reduce using rule 454 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    PROTECTED       reduce using rule 454 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    error           reduce using rule 454 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    USE             reduce using rule 454 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    PRAGMA          reduce using rule 454 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    TYPE            reduce using rule 454 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    SUBTYPE         reduce using rule 454 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    FOR             reduce using rule 454 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    PROCEDURE       reduce using rule 454 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    FUNCTION        reduce using rule 454 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    GENERIC         reduce using rule 454 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    IDENTIFIER      reduce using rule 454 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    BEGIN           reduce using rule 454 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    END             reduce using rule 454 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)
    PRIVATE         reduce using rule 454 (body_stub -> TASK BODY simple_name IS SEPARATE ; .)


state 716

    (368) task_body -> TASK BODY simple_name IS decl_part block_body . END id_opt ;

    END             shift and go to state 814


state 717

    (400) rep_spec_s -> rep_spec_s rep_spec . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    FOR             reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 815

state 718

    (367) task_private_opt -> PRIVATE . entry_decl_s rep_spec_s
    (391) entry_decl_s -> . pragma_s
    (392) entry_decl_s -> . entry_decl_s entry_decl pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    FOR             reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)

    entry_decl_s                   shift and go to state 816
    pragma_s                       shift and go to state 472

state 719

    (365) task_def -> IS entry_decl_s rep_spec_s task_private_opt . END id_opt

    END             shift and go to state 817


state 720

    (392) entry_decl_s -> entry_decl_s entry_decl pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    ENTRY           reduce using rule 392 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
    FOR             reduce using rule 392 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
    END             reduce using rule 392 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
    PRIVATE         reduce using rule 392 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 721

    (455) body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .

    PACKAGE         reduce using rule 455 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    TASK            reduce using rule 455 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    PROTECTED       reduce using rule 455 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    error           reduce using rule 455 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    USE             reduce using rule 455 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    PRAGMA          reduce using rule 455 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    TYPE            reduce using rule 455 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    SUBTYPE         reduce using rule 455 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    FOR             reduce using rule 455 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    PROCEDURE       reduce using rule 455 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    FUNCTION        reduce using rule 455 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    GENERIC         reduce using rule 455 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    IDENTIFIER      reduce using rule 455 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    BEGIN           reduce using rule 455 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    END             reduce using rule 455 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)
    PRIVATE         reduce using rule 455 (body_stub -> PACKAGE BODY compound_name IS SEPARATE ; .)


state 722

    (112) discrim_spec_s -> discrim_spec_s ; discrim_spec .

    )               reduce using rule 112 (discrim_spec_s -> discrim_spec_s ; discrim_spec .)
    ;               reduce using rule 112 (discrim_spec_s -> discrim_spec_s ; discrim_spec .)


state 723

    (116) access_opt -> ACCESS .

    IDENTIFIER      reduce using rule 116 (access_opt -> ACCESS .)


state 724

    (113) discrim_spec -> def_id_s : access_opt . mark init_opt
    (158) mark -> . simple_name
    (159) mark -> . mark TICK attribute_id
    (160) mark -> . mark . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    mark                           shift and go to state 818
    simple_name                    shift and go to state 165

state 725

    (100) tagged_opt -> ABSTRACT TAGGED .

    LIMITED         reduce using rule 100 (tagged_opt -> ABSTRACT TAGGED .)
    PRIVATE         reduce using rule 100 (tagged_opt -> ABSTRACT TAGGED .)
    RECORD          reduce using rule 100 (tagged_opt -> ABSTRACT TAGGED .)
    NuLL            reduce using rule 100 (tagged_opt -> ABSTRACT TAGGED .)


state 726

    (59) derived_type -> ABSTRACT NEW . subtype_ind WITH PRIVATE
    (60) derived_type -> ABSTRACT NEW . subtype_ind WITH record_def
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 481
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    subtype_ind                    shift and go to state 819
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 727

    (56) derived_type -> NEW subtype_ind .
    (57) derived_type -> NEW subtype_ind . WITH PRIVATE
    (58) derived_type -> NEW subtype_ind . WITH record_def

    ;               reduce using rule 56 (derived_type -> NEW subtype_ind .)
    WITH            shift and go to state 820


state 728

    (64) enumeration_type -> ( enum_id_s . )
    (66) enum_id_s -> enum_id_s . , enum_id

    )               shift and go to state 821
    ,               shift and go to state 822


state 729

    (68) enum_id -> CHAR .

    )               reduce using rule 68 (enum_id -> CHAR .)
    ,               reduce using rule 68 (enum_id -> CHAR .)


state 730

    (67) enum_id -> IDENTIFIER .

    )               reduce using rule 67 (enum_id -> IDENTIFIER .)
    ,               reduce using rule 67 (enum_id -> IDENTIFIER .)


state 731

    (65) enum_id_s -> enum_id .

    )               reduce using rule 65 (enum_id_s -> enum_id .)
    ,               reduce using rule 65 (enum_id_s -> enum_id .)


state 732

    (75) float_type -> DIGITS expression . range_spec_opt
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (71) range_spec_opt -> .
    (72) range_spec_opt -> . range_spec
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE
    (70) range_spec -> . range_constraint
    (61) range_constraint -> . RANGE range

    ;               reduce using rule 71 (range_spec_opt -> .)
    AND             shift and go to state 247
    OR              shift and go to state 250
    RANGE           shift and go to state 371

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249
    range_constraint               shift and go to state 602
    range_spec                     shift and go to state 824
    range_spec_opt                 shift and go to state 823

state 733

    (76) fixed_type -> DELTA expression . range_spec
    (77) fixed_type -> DELTA expression . DIGITS expression range_spec_opt
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (70) range_spec -> . range_constraint
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE
    (61) range_constraint -> . RANGE range

    DIGITS          shift and go to state 825
    AND             shift and go to state 247
    OR              shift and go to state 250
    RANGE           shift and go to state 371

    logical                        shift and go to state 248
    range_constraint               shift and go to state 602
    range_spec                     shift and go to state 826
    short_circuit                  shift and go to state 249

state 734

    (129) access_type -> ACCESS CONSTANT . subtype_ind
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 481
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    subtype_ind                    shift and go to state 827
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 735

    (131) access_type -> ACCESS prot_opt . PROCEDURE formal_part_opt
    (132) access_type -> ACCESS prot_opt . FUNCTION formal_part_opt RETURN mark

    PROCEDURE       shift and go to state 829
    FUNCTION        shift and go to state 828


state 736

    (134) prot_opt -> PROTECTED .

    PROCEDURE       reduce using rule 134 (prot_opt -> PROTECTED .)
    FUNCTION        reduce using rule 134 (prot_opt -> PROTECTED .)


state 737

    (130) access_type -> ACCESS ALL . subtype_ind
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 481
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    subtype_ind                    shift and go to state 830
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 738

    (128) access_type -> ACCESS subtype_ind .

    ;               reduce using rule 128 (access_type -> ACCESS subtype_ind .)


state 739

    (348) limited_opt -> LIMITED .

    PRIVATE         reduce using rule 348 (limited_opt -> LIMITED .)
    RECORD          reduce using rule 348 (limited_opt -> LIMITED .)
    NuLL            reduce using rule 348 (limited_opt -> LIMITED .)


state 740

    (95) record_type -> tagged_opt limited_opt . record_def
    (346) private_type -> tagged_opt limited_opt . PRIVATE
    (96) record_def -> . RECORD pragma_s comp_list END RECORD
    (97) record_def -> . NuLL RECORD

    PRIVATE         shift and go to state 831
    RECORD          shift and go to state 832
    NuLL            shift and go to state 833

    record_def                     shift and go to state 834

state 741

    (55) decimal_digits_constraint -> DIGITS expression . range_constr_opt
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (93) range_constr_opt -> .
    (94) range_constr_opt -> . range_constraint
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE
    (61) range_constraint -> . RANGE range

    ;               reduce using rule 93 (range_constr_opt -> .)
    RENAMES         reduce using rule 93 (range_constr_opt -> .)
    ASSIGNMENT      reduce using rule 93 (range_constr_opt -> .)
    WITH            reduce using rule 93 (range_constr_opt -> .)
    AND             shift and go to state 247
    OR              shift and go to state 250
    RANGE           shift and go to state 371

    range_constr_opt               shift and go to state 835
    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249
    range_constraint               shift and go to state 788

state 742

    (35) number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .

    PACKAGE         reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    TASK            reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    PROTECTED       reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    error           reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    USE             reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    PRAGMA          reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    TYPE            reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    SUBTYPE         reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    FOR             reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    PROCEDURE       reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    FUNCTION        reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    GENERIC         reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    IDENTIFIER      reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    BEGIN           reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    END             reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)
    PRIVATE         reduce using rule 35 (number_decl -> def_id_s : CONSTANT ASSIGNMENT expression ; .)


state 743

    (88) iter_index_constraint -> ( iter_discrete_range_s . )
    (90) iter_discrete_range_s -> iter_discrete_range_s . , discrete_range

    )               shift and go to state 836
    ,               shift and go to state 837


state 744

    (85) index_s -> index .

    )               reduce using rule 85 (index_s -> index .)
    ,               reduce using rule 85 (index_s -> index .)


state 745

    (80) unconstr_array_type -> ARRAY ( index_s . ) OF component_subtype_def
    (86) index_s -> index_s . , index

    )               shift and go to state 838
    ,               shift and go to state 839


state 746

    (89) iter_discrete_range_s -> discrete_range .

    )               reduce using rule 89 (iter_discrete_range_s -> discrete_range .)
    ,               reduce using rule 89 (iter_discrete_range_s -> discrete_range .)


state 747

    (87) index -> name . RANGE LESSMORE
    (91) discrete_range -> name . range_constr_opt
    (63) range -> name .
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id
    (235) primary -> name .
    (241) qualified -> name . TICK parenthesized_primary
    (93) range_constr_opt -> .
    (94) range_constr_opt -> . range_constraint
    (61) range_constraint -> . RANGE range

  ! reduce/reduce conflict for ) resolved using rule 63 (range -> name .)
  ! reduce/reduce conflict for , resolved using rule 63 (range -> name .)
    RANGE           shift and go to state 840
    )               reduce using rule 63 (range -> name .)
    ,               reduce using rule 63 (range -> name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 370
    STARSTAR        reduce using rule 235 (primary -> name .)
    *               reduce using rule 235 (primary -> name .)
    /               reduce using rule 235 (primary -> name .)
    MOD             reduce using rule 235 (primary -> name .)
    REM             reduce using rule 235 (primary -> name .)
    DOTDOT          reduce using rule 235 (primary -> name .)
    +               reduce using rule 235 (primary -> name .)
    -               reduce using rule 235 (primary -> name .)
    &               reduce using rule 235 (primary -> name .)

  ! )               [ reduce using rule 93 (range_constr_opt -> .) ]
  ! ,               [ reduce using rule 93 (range_constr_opt -> .) ]

    range_constr_opt               shift and go to state 787
    range_constraint               shift and go to state 788

state 748

    (81) constr_array_type -> ARRAY iter_index_constraint OF . subtype_ind
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 481
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    subtype_ind                    shift and go to state 841
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 749

    (34) init_opt -> ASSIGNMENT expression .
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    )               reduce using rule 34 (init_opt -> ASSIGNMENT expression .)
    ;               reduce using rule 34 (init_opt -> ASSIGNMENT expression .)
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 750

    (23) object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .

    error           reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    USE             reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    PRAGMA          reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    TYPE            reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    SUBTYPE         reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    TASK            reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    PACKAGE         reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    PROTECTED       reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    FOR             reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    PROCEDURE       reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    FUNCTION        reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    GENERIC         reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    IDENTIFIER      reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    PRIVATE         reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    END             reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)
    BEGIN           reduce using rule 23 (object_decl -> def_id_s : object_qualifier_opt object_subtype_def init_opt ; .)


state 751

    (353) rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .

    PACKAGE         reduce using rule 353 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    TASK            reduce using rule 353 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    PROTECTED       reduce using rule 353 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    error           reduce using rule 353 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    USE             reduce using rule 353 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    PRAGMA          reduce using rule 353 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    TYPE            reduce using rule 353 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    SUBTYPE         reduce using rule 353 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    FOR             reduce using rule 353 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    PROCEDURE       reduce using rule 353 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    FUNCTION        reduce using rule 353 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    GENERIC         reduce using rule 353 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    IDENTIFIER      reduce using rule 353 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    BEGIN           reduce using rule 353 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    END             reduce using rule 353 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)
    PRIVATE         reduce using rule 353 (rename_decl -> def_id_s : object_qualifier_opt subtype_ind renames ; .)


state 752

    (343) pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END . c_id_opt ;
    (341) c_id_opt -> .
    (342) c_id_opt -> . compound_name
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 341 (c_id_opt -> .)
    IDENTIFIER      shift and go to state 39

    compound_name                  shift and go to state 754
    c_id_opt                       shift and go to state 842
    simple_name                    shift and go to state 41

state 753

    (457) body_stub -> PROTECTED BODY simple_name IS . SEPARATE ;

    SEPARATE        shift and go to state 533


state 754

    (342) c_id_opt -> compound_name .
    (163) compound_name -> compound_name . . simple_name

    ;               reduce using rule 342 (c_id_opt -> compound_name .)
    .               shift and go to state 119


state 755

    (338) pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END c_id_opt .

    ;               reduce using rule 338 (pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END c_id_opt .)


state 756

    (454) body_stub -> TASK BODY simple_name IS . SEPARATE ;

    SEPARATE        shift and go to state 591


state 757

    (455) body_stub -> PACKAGE BODY compound_name IS . SEPARATE ;

    SEPARATE        shift and go to state 596


state 758

    (477) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name . subp_default ;
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id
    (484) subp_default -> .
    (485) subp_default -> . IS name
    (486) subp_default -> . IS LESSMORE

    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253
    ;               reduce using rule 484 (subp_default -> .)
    IS              shift and go to state 645

    subp_default                   shift and go to state 843

state 759

    (478) generic_formal -> WITH PACKAGE simple_name IS NEW name . ( LESSMORE ) ;
    (479) generic_formal -> WITH PACKAGE simple_name IS NEW name . ;
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id

    (               shift and go to state 844
    ;               shift and go to state 845
    .               shift and go to state 244
    TICK            shift and go to state 253


state 760

    (485) subp_default -> IS name .
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id

    ;               reduce using rule 485 (subp_default -> IS name .)
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 761

    (486) subp_default -> IS LESSMORE .

    ;               reduce using rule 486 (subp_default -> IS LESSMORE .)


state 762

    (476) generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .

    PACKAGE         reduce using rule 476 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    PROCEDURE       reduce using rule 476 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    FUNCTION        reduce using rule 476 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    TYPE            reduce using rule 476 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    WITH            reduce using rule 476 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    error           reduce using rule 476 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    USE             reduce using rule 476 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)
    IDENTIFIER      reduce using rule 476 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default ; .)


state 763

    (499) generic_derived_type -> ABSTRACT NEW . subtype_ind WITH PRIVATE
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 481
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    subtype_ind                    shift and go to state 846
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 764

    (475) generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .

    PACKAGE         reduce using rule 475 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    PROCEDURE       reduce using rule 475 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    FUNCTION        reduce using rule 475 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    TYPE            reduce using rule 475 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    WITH            reduce using rule 475 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    error           reduce using rule 475 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    USE             reduce using rule 475 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)
    IDENTIFIER      reduce using rule 475 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def ; .)


state 765

    (497) generic_derived_type -> NEW subtype_ind .
    (498) generic_derived_type -> NEW subtype_ind . WITH PRIVATE

    ;               reduce using rule 497 (generic_derived_type -> NEW subtype_ind .)
    WITH            shift and go to state 847


state 766

    (492) generic_type_def -> DIGITS LESSMORE .

    ;               reduce using rule 492 (generic_type_def -> DIGITS LESSMORE .)


state 767

    (487) generic_type_def -> ( LESSMORE . )

    )               shift and go to state 848


state 768

    (488) generic_type_def -> RANGE LESSMORE .

    ;               reduce using rule 488 (generic_type_def -> RANGE LESSMORE .)


state 769

    (346) private_type -> tagged_opt limited_opt . PRIVATE

    PRIVATE         shift and go to state 831


state 770

    (490) generic_type_def -> DELTA LESSMORE .
    (491) generic_type_def -> DELTA LESSMORE . DIGITS LESSMORE

    ;               reduce using rule 490 (generic_type_def -> DELTA LESSMORE .)
    DIGITS          shift and go to state 849


state 771

    (489) generic_type_def -> MOD LESSMORE .

    ;               reduce using rule 489 (generic_type_def -> MOD LESSMORE .)


state 772

    (192) aggregate -> ( expression WITH NuLL RECORD ) .

    STARSTAR        reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    *               reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    /               reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    MOD             reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    REM             reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    =               reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    NOTEQUAL        reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    <               reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    LESSEQ          reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    >               reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    GREATEREQ       reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    IN              reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    NOT             reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    +               reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    -               reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    &               reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    AND             reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    OR              reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    )               reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    ,               reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    DOTDOT          reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    WITH            reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    ARROW           reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    |               reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    ;               reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    IS              reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    THEN            reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    LOOP            reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    RANGE           reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    DIGITS          reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    RENAMES         reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)
    ASSIGNMENT      reduce using rule 192 (aggregate -> ( expression WITH NuLL RECORD ) .)


state 773

    (385) prot_body -> PROTECTED BODY simple_name IS . prot_op_body_s END id_opt ;
    (386) prot_op_body_s -> . pragma_s
    (387) prot_op_body_s -> . prot_op_body_s prot_op_body pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)

    prot_op_body_s                 shift and go to state 534
    pragma_s                       shift and go to state 535

state 774

    (368) task_body -> TASK BODY simple_name IS . decl_part block_body END id_opt ;
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (334) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (343) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (368) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (385) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (349) use_clause -> . USE name_s ;
    (350) use_clause -> . USE TYPE name_s ;
    (503) rep_spec -> . attrib_def
    (504) rep_spec -> . record_type_spec
    (505) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (333) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (313) subprog_decl -> . subprog_spec ;
    (314) subprog_decl -> . generic_subp_inst ;
    (315) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (336) pkg_decl -> . pkg_spec ;
    (337) pkg_decl -> . generic_pkg_inst ;
    (361) task_decl -> . task_spec ;
    (369) prot_decl -> . prot_spec ;
    (458) exception_decl -> . def_id_s : EXCEPTION ;
    (353) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (354) rename_decl -> . def_id_s : EXCEPTION renames ;
    (355) rename_decl -> . rename_unit
    (470) generic_decl -> . generic_formal_part subprog_spec ;
    (471) generic_decl -> . generic_formal_part pkg_spec ;
    (454) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (455) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (456) body_stub -> . subprog_spec IS SEPARATE ;
    (457) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (506) attrib_def -> . FOR mark USE expression ;
    (507) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (512) address_spec -> . FOR mark USE AT expression ;
    (316) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (317) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (318) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (500) generic_subp_inst -> . subprog_spec IS generic_inst
    (338) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (362) task_spec -> . TASK simple_name task_def
    (363) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (370) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (371) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (356) rename_unit -> . PACKAGE compound_name renames ;
    (357) rename_unit -> . subprog_spec renames ;
    (358) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (359) rename_unit -> . generic_formal_part subprog_spec renames ;
    (472) generic_formal_part -> . GENERIC
    (473) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    decl_item                      shift and go to state 53
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 592
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 775

    (390) prot_op_body -> subprog_spec ; .

    PRAGMA          reduce using rule 390 (prot_op_body -> subprog_spec ; .)
    END             reduce using rule 390 (prot_op_body -> subprog_spec ; .)
    ENTRY           reduce using rule 390 (prot_op_body -> subprog_spec ; .)
    PROCEDURE       reduce using rule 390 (prot_op_body -> subprog_spec ; .)
    FUNCTION        reduce using rule 390 (prot_op_body -> subprog_spec ; .)


state 776

    (385) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt . ;

    ;               shift and go to state 850


state 777

    (387) prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 387 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
    ENTRY           reduce using rule 387 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
    PROCEDURE       reduce using rule 387 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
    FUNCTION        reduce using rule 387 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 778

    (395) entry_body -> ENTRY IDENTIFIER . formal_part_opt WHEN condition entry_body_part
    (396) entry_body -> ENTRY IDENTIFIER . ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part
    (321) formal_part_opt -> .
    (322) formal_part_opt -> . formal_part
    (323) formal_part -> . ( param_s )

    (               shift and go to state 851
    WHEN            reduce using rule 321 (formal_part_opt -> .)

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 852

state 779

    (108) comp_decl -> def_id_s . : component_subtype_def init_opt ;
    (25) def_id_s -> def_id_s . , def_id

    :               shift and go to state 853
    ,               shift and go to state 179


state 780

    (384) prot_elem_decl -> comp_decl .

    error           reduce using rule 384 (prot_elem_decl -> comp_decl .)
    ENTRY           reduce using rule 384 (prot_elem_decl -> comp_decl .)
    PROCEDURE       reduce using rule 384 (prot_elem_decl -> comp_decl .)
    FUNCTION        reduce using rule 384 (prot_elem_decl -> comp_decl .)
    PRAGMA          reduce using rule 384 (prot_elem_decl -> comp_decl .)
    FOR             reduce using rule 384 (prot_elem_decl -> comp_decl .)
    IDENTIFIER      reduce using rule 384 (prot_elem_decl -> comp_decl .)
    END             reduce using rule 384 (prot_elem_decl -> comp_decl .)


state 781

    (383) prot_elem_decl -> prot_op_decl .

    error           reduce using rule 383 (prot_elem_decl -> prot_op_decl .)
    ENTRY           reduce using rule 383 (prot_elem_decl -> prot_op_decl .)
    PROCEDURE       reduce using rule 383 (prot_elem_decl -> prot_op_decl .)
    FUNCTION        reduce using rule 383 (prot_elem_decl -> prot_op_decl .)
    PRAGMA          reduce using rule 383 (prot_elem_decl -> prot_op_decl .)
    FOR             reduce using rule 383 (prot_elem_decl -> prot_op_decl .)
    IDENTIFIER      reduce using rule 383 (prot_elem_decl -> prot_op_decl .)
    END             reduce using rule 383 (prot_elem_decl -> prot_op_decl .)


state 782

    (382) prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .

    error           reduce using rule 382 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    ENTRY           reduce using rule 382 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    PROCEDURE       reduce using rule 382 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    FUNCTION        reduce using rule 382 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    PRAGMA          reduce using rule 382 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    FOR             reduce using rule 382 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    IDENTIFIER      reduce using rule 382 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    END             reduce using rule 382 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)


state 783

    (109) comp_decl -> error . ;

    ;               shift and go to state 854


state 784

    (372) prot_def -> IS prot_op_decl_s prot_private_opt END id_opt .

    ;               reduce using rule 372 (prot_def -> IS prot_op_decl_s prot_private_opt END id_opt .)


state 785

    (394) entry_decl -> ENTRY IDENTIFIER ( . discrete_range ) formal_part_opt ;
    (323) formal_part -> ( . param_s )
    (91) discrete_range -> . name range_constr_opt
    (92) discrete_range -> . range
    (324) param_s -> . param
    (325) param_s -> . param_s ; param
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name
    (326) param -> . def_id_s : mode mark init_opt
    (327) param -> . error
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (26) def_id -> . IDENTIFIER
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    error           shift and go to state 109
    IDENTIFIER      shift and go to state 856
    STRING          shift and go to state 139
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    param                          shift and go to state 340
    simple_expression              shift and go to state 358
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    param_s                        shift and go to state 341
    literal                        shift and go to state 135
    def_id_s                       shift and go to state 105
    factor                         shift and go to state 137
    def_id                         shift and go to state 89
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    discrete_range                 shift and go to state 855
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 680
    operator_symbol                shift and go to state 138
    range                          shift and go to state 681

state 786

    (393) entry_decl -> ENTRY IDENTIFIER formal_part_opt . ;

    ;               shift and go to state 857


state 787

    (91) discrete_range -> name range_constr_opt .

    )               reduce using rule 91 (discrete_range -> name range_constr_opt .)
    ,               reduce using rule 91 (discrete_range -> name range_constr_opt .)
    LOOP            reduce using rule 91 (discrete_range -> name range_constr_opt .)


state 788

    (94) range_constr_opt -> range_constraint .

    LOOP            reduce using rule 94 (range_constr_opt -> range_constraint .)
    )               reduce using rule 94 (range_constr_opt -> range_constraint .)
    ,               reduce using rule 94 (range_constr_opt -> range_constraint .)
    ;               reduce using rule 94 (range_constr_opt -> range_constraint .)
    RENAMES         reduce using rule 94 (range_constr_opt -> range_constraint .)
    ASSIGNMENT      reduce using rule 94 (range_constr_opt -> range_constraint .)
    WITH            reduce using rule 94 (range_constr_opt -> range_constraint .)


state 789

    (286) loop_stmt -> label_opt iteration m basic_loop id_opt . ;

    ;               shift and go to state 858


state 790

    (295) basic_loop -> LOOP statement_s . END LOOP
    (245) statement_s -> statement_s . m statement
    (197) m -> .

    END             shift and go to state 859
    LESSLESS        reduce using rule 197 (m -> .)
    error           reduce using rule 197 (m -> .)
    PRAGMA          reduce using rule 197 (m -> .)
    NuLL            reduce using rule 197 (m -> .)
    EXIT            reduce using rule 197 (m -> .)
    RETURN          reduce using rule 197 (m -> .)
    GOTO            reduce using rule 197 (m -> .)
    DELAY           reduce using rule 197 (m -> .)
    ABORT           reduce using rule 197 (m -> .)
    RAISE           reduce using rule 197 (m -> .)
    REQUEUE         reduce using rule 197 (m -> .)
    IF              reduce using rule 197 (m -> .)
    CASE            reduce using rule 197 (m -> .)
    IDENTIFIER      reduce using rule 197 (m -> .)
    ACCEPT          reduce using rule 197 (m -> .)
    SELECT          reduce using rule 197 (m -> .)
    STRING          reduce using rule 197 (m -> .)
    WHILE           reduce using rule 197 (m -> .)
    DECLARE         reduce using rule 197 (m -> .)
    FOR             reduce using rule 197 (m -> .)
    LOOP            reduce using rule 197 (m -> .)
    BEGIN           reduce using rule 197 (m -> .)

    m                              shift and go to state 454

state 791

    (298) block -> label_opt block_decl block_body END id_opt . ;

    ;               shift and go to state 860


state 792

    (406) entry_name -> entry_name ( expression ) .

    (               reduce using rule 406 (entry_name -> entry_name ( expression ) .)
    ;               reduce using rule 406 (entry_name -> entry_name ( expression ) .)
    DO              reduce using rule 406 (entry_name -> entry_name ( expression ) .)


state 793

    (425) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s . END SELECT ;
    (245) statement_s -> statement_s . m statement
    (197) m -> .

    END             shift and go to state 861
    LESSLESS        reduce using rule 197 (m -> .)
    error           reduce using rule 197 (m -> .)
    PRAGMA          reduce using rule 197 (m -> .)
    NuLL            reduce using rule 197 (m -> .)
    EXIT            reduce using rule 197 (m -> .)
    RETURN          reduce using rule 197 (m -> .)
    GOTO            reduce using rule 197 (m -> .)
    DELAY           reduce using rule 197 (m -> .)
    ABORT           reduce using rule 197 (m -> .)
    RAISE           reduce using rule 197 (m -> .)
    REQUEUE         reduce using rule 197 (m -> .)
    IF              reduce using rule 197 (m -> .)
    CASE            reduce using rule 197 (m -> .)
    IDENTIFIER      reduce using rule 197 (m -> .)
    ACCEPT          reduce using rule 197 (m -> .)
    SELECT          reduce using rule 197 (m -> .)
    STRING          reduce using rule 197 (m -> .)
    WHILE           reduce using rule 197 (m -> .)
    DECLARE         reduce using rule 197 (m -> .)
    FOR             reduce using rule 197 (m -> .)
    LOOP            reduce using rule 197 (m -> .)
    BEGIN           reduce using rule 197 (m -> .)

    m                              shift and go to state 454

state 794

    (424) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt . stmts_opt END SELECT ;
    (426) stmts_opt -> .
    (427) stmts_opt -> . statement_s
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s m statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (305) exit_stmt -> . EXIT name_opt when_opt ;
    (310) return_stmt -> . RETURN ;
    (311) return_stmt -> . RETURN expression ;
    (312) goto_stmt -> . GOTO name ;
    (335) procedure_call -> . name ;
    (407) delay_stmt -> . DELAY expression ;
    (408) delay_stmt -> . DELAY UNTIL expression ;
    (428) abort_stmt -> . ABORT name_s ;
    (467) raise_stmt -> . RAISE name_opt ;
    (513) code_stmt -> . qualified ;
    (468) requeue_stmt -> . REQUEUE name ;
    (469) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (281) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (286) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (298) block -> . label_opt block_decl block_body END id_opt ;
    (402) accept_stmt -> . accept_hdr ;
    (403) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (409) select_stmt -> . select_wait
    (410) select_stmt -> . async_select
    (411) select_stmt -> . timed_entry_call
    (412) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (282) case_hdr -> . CASE expression IS
    (287) label_opt -> .
    (288) label_opt -> . IDENTIFIER :
    (404) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (413) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (423) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (424) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (425) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    END             reduce using rule 426 (stmts_opt -> .)
    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 287 (label_opt -> .)
    DECLARE         reduce using rule 287 (label_opt -> .)
    FOR             reduce using rule 287 (label_opt -> .)
    LOOP            reduce using rule 287 (label_opt -> .)
    BEGIN           reduce using rule 287 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 139

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 562
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 138
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    attribute                      shift and go to state 121
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    stmts_opt                      shift and go to state 862
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 795

    (423) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s . END SELECT ;
    (245) statement_s -> statement_s . m statement
    (197) m -> .

    END             shift and go to state 863
    LESSLESS        reduce using rule 197 (m -> .)
    error           reduce using rule 197 (m -> .)
    PRAGMA          reduce using rule 197 (m -> .)
    NuLL            reduce using rule 197 (m -> .)
    EXIT            reduce using rule 197 (m -> .)
    RETURN          reduce using rule 197 (m -> .)
    GOTO            reduce using rule 197 (m -> .)
    DELAY           reduce using rule 197 (m -> .)
    ABORT           reduce using rule 197 (m -> .)
    RAISE           reduce using rule 197 (m -> .)
    REQUEUE         reduce using rule 197 (m -> .)
    IF              reduce using rule 197 (m -> .)
    CASE            reduce using rule 197 (m -> .)
    IDENTIFIER      reduce using rule 197 (m -> .)
    ACCEPT          reduce using rule 197 (m -> .)
    SELECT          reduce using rule 197 (m -> .)
    STRING          reduce using rule 197 (m -> .)
    WHILE           reduce using rule 197 (m -> .)
    DECLARE         reduce using rule 197 (m -> .)
    FOR             reduce using rule 197 (m -> .)
    LOOP            reduce using rule 197 (m -> .)
    BEGIN           reduce using rule 197 (m -> .)

    m                              shift and go to state 454

state 796

    (419) select_alt -> delay_stmt . stmts_opt
    (426) stmts_opt -> .
    (427) stmts_opt -> . statement_s
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s m statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (305) exit_stmt -> . EXIT name_opt when_opt ;
    (310) return_stmt -> . RETURN ;
    (311) return_stmt -> . RETURN expression ;
    (312) goto_stmt -> . GOTO name ;
    (335) procedure_call -> . name ;
    (407) delay_stmt -> . DELAY expression ;
    (408) delay_stmt -> . DELAY UNTIL expression ;
    (428) abort_stmt -> . ABORT name_s ;
    (467) raise_stmt -> . RAISE name_opt ;
    (513) code_stmt -> . qualified ;
    (468) requeue_stmt -> . REQUEUE name ;
    (469) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (281) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (286) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (298) block -> . label_opt block_decl block_body END id_opt ;
    (402) accept_stmt -> . accept_hdr ;
    (403) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (409) select_stmt -> . select_wait
    (410) select_stmt -> . async_select
    (411) select_stmt -> . timed_entry_call
    (412) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (282) case_hdr -> . CASE expression IS
    (287) label_opt -> .
    (288) label_opt -> . IDENTIFIER :
    (404) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (413) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (423) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (424) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (425) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    OR              reduce using rule 426 (stmts_opt -> .)
    ELSE            reduce using rule 426 (stmts_opt -> .)
    END             reduce using rule 426 (stmts_opt -> .)
    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 287 (label_opt -> .)
    DECLARE         reduce using rule 287 (label_opt -> .)
    FOR             reduce using rule 287 (label_opt -> .)
    LOOP            reduce using rule 287 (label_opt -> .)
    BEGIN           reduce using rule 287 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 139

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 562
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 138
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    attribute                      shift and go to state 121
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    stmts_opt                      shift and go to state 864
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 797

    (415) guarded_select_alt -> WHEN condition ARROW select_alt .

    OR              reduce using rule 415 (guarded_select_alt -> WHEN condition ARROW select_alt .)
    ELSE            reduce using rule 415 (guarded_select_alt -> WHEN condition ARROW select_alt .)
    END             reduce using rule 415 (guarded_select_alt -> WHEN condition ARROW select_alt .)


state 798

    (413) select_wait -> SELECT guarded_select_alt or_select else_opt END . SELECT ;

    SELECT          shift and go to state 865


state 799

    (417) or_select -> or_select OR guarded_select_alt .

    OR              reduce using rule 417 (or_select -> or_select OR guarded_select_alt .)
    ELSE            reduce using rule 417 (or_select -> or_select OR guarded_select_alt .)
    END             reduce using rule 417 (or_select -> or_select OR guarded_select_alt .)


state 800

    (281) case_stmt -> case_hdr pragma_s alternative_s END CASE . ;

    ;               shift and go to state 866


state 801

    (285) alternative -> WHEN choice_s . ARROW statement_s
    (122) choice_s -> choice_s . | choice

    ARROW           shift and go to state 867
    |               shift and go to state 365


state 802

    (469) requeue_stmt -> REQUEUE name WITH ABORT ; .

    EXCEPTION       reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    LESSLESS        reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    error           reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    PRAGMA          reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    NuLL            reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    EXIT            reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    RETURN          reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    GOTO            reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    DELAY           reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    ABORT           reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    RAISE           reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    REQUEUE         reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    IF              reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    CASE            reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    IDENTIFIER      reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    ACCEPT          reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    SELECT          reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    STRING          reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    WHILE           reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    DECLARE         reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    FOR             reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    LOOP            reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    BEGIN           reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    END             reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    OR              reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    ELSE            reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    THEN            reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    ELSIF           reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)
    WHEN            reduce using rule 469 (requeue_stmt -> REQUEUE name WITH ABORT ; .)


state 803

    (403) accept_stmt -> accept_hdr DO handled_stmt_s END id_opt . ;

    ;               shift and go to state 868


state 804

    (461) exception_handler -> WHEN except_choice_s ARROW . statement_s
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s m statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (305) exit_stmt -> . EXIT name_opt when_opt ;
    (310) return_stmt -> . RETURN ;
    (311) return_stmt -> . RETURN expression ;
    (312) goto_stmt -> . GOTO name ;
    (335) procedure_call -> . name ;
    (407) delay_stmt -> . DELAY expression ;
    (408) delay_stmt -> . DELAY UNTIL expression ;
    (428) abort_stmt -> . ABORT name_s ;
    (467) raise_stmt -> . RAISE name_opt ;
    (513) code_stmt -> . qualified ;
    (468) requeue_stmt -> . REQUEUE name ;
    (469) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (281) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (286) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (298) block -> . label_opt block_decl block_body END id_opt ;
    (402) accept_stmt -> . accept_hdr ;
    (403) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (409) select_stmt -> . select_wait
    (410) select_stmt -> . async_select
    (411) select_stmt -> . timed_entry_call
    (412) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (282) case_hdr -> . CASE expression IS
    (287) label_opt -> .
    (288) label_opt -> . IDENTIFIER :
    (404) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (413) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (423) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (424) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (425) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 287 (label_opt -> .)
    DECLARE         reduce using rule 287 (label_opt -> .)
    FOR             reduce using rule 287 (label_opt -> .)
    LOOP            reduce using rule 287 (label_opt -> .)
    BEGIN           reduce using rule 287 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 139

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 869
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 138
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    attribute                      shift and go to state 121
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 805

    (464) except_choice_s -> except_choice_s | . except_choice
    (465) except_choice -> . name
    (466) except_choice -> . OTHERS
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    OTHERS          shift and go to state 706
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 707
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    indexed_comp                   shift and go to state 129
    except_choice                  shift and go to state 870
    simple_name                    shift and go to state 157

state 806

    (462) exception_handler -> WHEN IDENTIFIER : . except_choice_s ARROW statement_s
    (463) except_choice_s -> . except_choice
    (464) except_choice_s -> . except_choice_s | except_choice
    (465) except_choice -> . name
    (466) except_choice -> . OTHERS
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    OTHERS          shift and go to state 706
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 707
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    except_choice_s                shift and go to state 871
    except_choice                  shift and go to state 705
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 807

    (280) else_opt -> ELSE m statement_s .
    (245) statement_s -> statement_s . m statement
    (197) m -> .

    END             reduce using rule 280 (else_opt -> ELSE m statement_s .)
    LESSLESS        reduce using rule 197 (m -> .)
    error           reduce using rule 197 (m -> .)
    PRAGMA          reduce using rule 197 (m -> .)
    NuLL            reduce using rule 197 (m -> .)
    EXIT            reduce using rule 197 (m -> .)
    RETURN          reduce using rule 197 (m -> .)
    GOTO            reduce using rule 197 (m -> .)
    DELAY           reduce using rule 197 (m -> .)
    ABORT           reduce using rule 197 (m -> .)
    RAISE           reduce using rule 197 (m -> .)
    REQUEUE         reduce using rule 197 (m -> .)
    IF              reduce using rule 197 (m -> .)
    CASE            reduce using rule 197 (m -> .)
    IDENTIFIER      reduce using rule 197 (m -> .)
    ACCEPT          reduce using rule 197 (m -> .)
    SELECT          reduce using rule 197 (m -> .)
    STRING          reduce using rule 197 (m -> .)
    WHILE           reduce using rule 197 (m -> .)
    DECLARE         reduce using rule 197 (m -> .)
    FOR             reduce using rule 197 (m -> .)
    LOOP            reduce using rule 197 (m -> .)
    BEGIN           reduce using rule 197 (m -> .)

    m                              shift and go to state 454

state 808

    (272) if_stmt -> IF cond_clause_s else_opt END IF . ;

    ;               shift and go to state 872


state 809

    (274) cond_clause_s -> cond_clause ELSIF m cond_clause_s .

    ELSE            reduce using rule 274 (cond_clause_s -> cond_clause ELSIF m cond_clause_s .)
    END             reduce using rule 274 (cond_clause_s -> cond_clause ELSIF m cond_clause_s .)


state 810

    (276) cond_clause -> cond_part m statement_s n .

    ELSIF           reduce using rule 276 (cond_clause -> cond_part m statement_s n .)
    ELSE            reduce using rule 276 (cond_clause -> cond_part m statement_s n .)
    END             reduce using rule 276 (cond_clause -> cond_part m statement_s n .)


state 811

    (507) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END . RECORD ;

    RECORD          shift and go to state 873


state 812

    (511) comp_loc_s -> comp_loc_s mark . AT expression RANGE range ;
    (159) mark -> mark . TICK attribute_id
    (160) mark -> mark . . simple_name

    AT              shift and go to state 874
    TICK            shift and go to state 312
    .               shift and go to state 311


state 813

    (509) align_opt -> AT MOD expression . ;
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    ;               shift and go to state 875
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 814

    (368) task_body -> TASK BODY simple_name IS decl_part block_body END . id_opt ;
    (296) id_opt -> .
    (297) id_opt -> . designator
    (319) designator -> . compound_name
    (320) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 296 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 462
    id_opt                         shift and go to state 876
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 815

    (400) rep_spec_s -> rep_spec_s rep_spec pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    PRIVATE         reduce using rule 400 (rep_spec_s -> rep_spec_s rep_spec pragma_s .)
    FOR             reduce using rule 400 (rep_spec_s -> rep_spec_s rep_spec pragma_s .)
    END             reduce using rule 400 (rep_spec_s -> rep_spec_s rep_spec pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 816

    (367) task_private_opt -> PRIVATE entry_decl_s . rep_spec_s
    (392) entry_decl_s -> entry_decl_s . entry_decl pragma_s
    (399) rep_spec_s -> .
    (400) rep_spec_s -> . rep_spec_s rep_spec pragma_s
    (393) entry_decl -> . ENTRY IDENTIFIER formal_part_opt ;
    (394) entry_decl -> . ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ;

    FOR             reduce using rule 399 (rep_spec_s -> .)
    END             reduce using rule 399 (rep_spec_s -> .)
    ENTRY           shift and go to state 542

    rep_spec_s                     shift and go to state 877
    entry_decl                     shift and go to state 595

state 817

    (365) task_def -> IS entry_decl_s rep_spec_s task_private_opt END . id_opt
    (296) id_opt -> .
    (297) id_opt -> . designator
    (319) designator -> . compound_name
    (320) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 296 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 462
    id_opt                         shift and go to state 878
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 818

    (113) discrim_spec -> def_id_s : access_opt mark . init_opt
    (159) mark -> mark . TICK attribute_id
    (160) mark -> mark . . simple_name
    (33) init_opt -> .
    (34) init_opt -> . ASSIGNMENT expression

    TICK            shift and go to state 312
    .               shift and go to state 311
    )               reduce using rule 33 (init_opt -> .)
    ;               reduce using rule 33 (init_opt -> .)
    ASSIGNMENT      shift and go to state 632

    init_opt                       shift and go to state 879

state 819

    (59) derived_type -> ABSTRACT NEW subtype_ind . WITH PRIVATE
    (60) derived_type -> ABSTRACT NEW subtype_ind . WITH record_def

    WITH            shift and go to state 880


state 820

    (57) derived_type -> NEW subtype_ind WITH . PRIVATE
    (58) derived_type -> NEW subtype_ind WITH . record_def
    (96) record_def -> . RECORD pragma_s comp_list END RECORD
    (97) record_def -> . NuLL RECORD

    PRIVATE         shift and go to state 881
    RECORD          shift and go to state 832
    NuLL            shift and go to state 833

    record_def                     shift and go to state 882

state 821

    (64) enumeration_type -> ( enum_id_s ) .

    ;               reduce using rule 64 (enumeration_type -> ( enum_id_s ) .)


state 822

    (66) enum_id_s -> enum_id_s , . enum_id
    (67) enum_id -> . IDENTIFIER
    (68) enum_id -> . CHAR

    IDENTIFIER      shift and go to state 730
    CHAR            shift and go to state 729

    enum_id                        shift and go to state 883

state 823

    (75) float_type -> DIGITS expression range_spec_opt .

    ;               reduce using rule 75 (float_type -> DIGITS expression range_spec_opt .)


state 824

    (72) range_spec_opt -> range_spec .

    ;               reduce using rule 72 (range_spec_opt -> range_spec .)


state 825

    (77) fixed_type -> DELTA expression DIGITS . expression range_spec_opt
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 884

state 826

    (76) fixed_type -> DELTA expression range_spec .

    ;               reduce using rule 76 (fixed_type -> DELTA expression range_spec .)


state 827

    (129) access_type -> ACCESS CONSTANT subtype_ind .

    ;               reduce using rule 129 (access_type -> ACCESS CONSTANT subtype_ind .)


state 828

    (132) access_type -> ACCESS prot_opt FUNCTION . formal_part_opt RETURN mark
    (321) formal_part_opt -> .
    (322) formal_part_opt -> . formal_part
    (323) formal_part -> . ( param_s )

    RETURN          reduce using rule 321 (formal_part_opt -> .)
    (               shift and go to state 189

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 885

state 829

    (131) access_type -> ACCESS prot_opt PROCEDURE . formal_part_opt
    (321) formal_part_opt -> .
    (322) formal_part_opt -> . formal_part
    (323) formal_part -> . ( param_s )

    ;               reduce using rule 321 (formal_part_opt -> .)
    (               shift and go to state 189

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 886

state 830

    (130) access_type -> ACCESS ALL subtype_ind .

    ;               reduce using rule 130 (access_type -> ACCESS ALL subtype_ind .)


state 831

    (346) private_type -> tagged_opt limited_opt PRIVATE .

    ;               reduce using rule 346 (private_type -> tagged_opt limited_opt PRIVATE .)


state 832

    (96) record_def -> RECORD . pragma_s comp_list END RECORD
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    NuLL            reduce using rule 8 (pragma_s -> .)
    PRAGMA          reduce using rule 8 (pragma_s -> .)
    CASE            reduce using rule 8 (pragma_s -> .)
    error           reduce using rule 8 (pragma_s -> .)
    IDENTIFIER      reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 887

state 833

    (97) record_def -> NuLL . RECORD

    RECORD          shift and go to state 888


state 834

    (95) record_type -> tagged_opt limited_opt record_def .

    ;               reduce using rule 95 (record_type -> tagged_opt limited_opt record_def .)


state 835

    (55) decimal_digits_constraint -> DIGITS expression range_constr_opt .

    ;               reduce using rule 55 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)
    RENAMES         reduce using rule 55 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)
    ASSIGNMENT      reduce using rule 55 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)
    WITH            reduce using rule 55 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)


state 836

    (88) iter_index_constraint -> ( iter_discrete_range_s ) .

    OF              reduce using rule 88 (iter_index_constraint -> ( iter_discrete_range_s ) .)


state 837

    (90) iter_discrete_range_s -> iter_discrete_range_s , . discrete_range
    (91) discrete_range -> . name range_constr_opt
    (92) discrete_range -> . range
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    simple_expression              shift and go to state 358
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    discrete_range                 shift and go to state 889
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 680
    operator_symbol                shift and go to state 138
    range                          shift and go to state 681

state 838

    (80) unconstr_array_type -> ARRAY ( index_s ) . OF component_subtype_def

    OF              shift and go to state 890


state 839

    (86) index_s -> index_s , . index
    (87) index -> . name RANGE LESSMORE
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    index                          shift and go to state 891
    name                           shift and go to state 892
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 840

    (87) index -> name RANGE . LESSMORE
    (61) range_constraint -> RANGE . range
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    LESSMORE        shift and go to state 893
    +               shift and go to state 133
    -               shift and go to state 134
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    simple_expression              shift and go to state 358
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 520
    operator_symbol                shift and go to state 138
    range                          shift and go to state 521

state 841

    (81) constr_array_type -> ARRAY iter_index_constraint OF subtype_ind .

    ;               reduce using rule 81 (constr_array_type -> ARRAY iter_index_constraint OF subtype_ind .)
    ASSIGNMENT      reduce using rule 81 (constr_array_type -> ARRAY iter_index_constraint OF subtype_ind .)


state 842

    (343) pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt . ;

    ;               shift and go to state 894


state 843

    (477) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default . ;

    ;               shift and go to state 895


state 844

    (478) generic_formal -> WITH PACKAGE simple_name IS NEW name ( . LESSMORE ) ;
    (168) indexed_comp -> name ( . value_s )
    (169) value_s -> . value
    (170) value_s -> . value_s , value
    (171) value -> . expression
    (172) value -> . comp_assoc
    (173) value -> . error
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (196) comp_assoc -> . choice_s ARROW expression
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    LESSMORE        shift and go to state 896
    error           shift and go to state 233
    OTHERS          shift and go to state 223
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    value_s                        shift and go to state 380
    simple_expression              shift and go to state 224
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    comp_assoc                     shift and go to state 381
    choice_s                       shift and go to state 225
    choice                         shift and go to state 227
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 147
    name                           shift and go to state 230
    value                          shift and go to state 382
    range                          shift and go to state 232
    expression                     shift and go to state 383

state 845

    (479) generic_formal -> WITH PACKAGE simple_name IS NEW name ; .

    PACKAGE         reduce using rule 479 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    PROCEDURE       reduce using rule 479 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    FUNCTION        reduce using rule 479 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    TYPE            reduce using rule 479 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    WITH            reduce using rule 479 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    error           reduce using rule 479 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    USE             reduce using rule 479 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)
    IDENTIFIER      reduce using rule 479 (generic_formal -> WITH PACKAGE simple_name IS NEW name ; .)


state 846

    (499) generic_derived_type -> ABSTRACT NEW subtype_ind . WITH PRIVATE

    WITH            shift and go to state 897


state 847

    (498) generic_derived_type -> NEW subtype_ind WITH . PRIVATE

    PRIVATE         shift and go to state 898


state 848

    (487) generic_type_def -> ( LESSMORE ) .

    ;               reduce using rule 487 (generic_type_def -> ( LESSMORE ) .)


state 849

    (491) generic_type_def -> DELTA LESSMORE DIGITS . LESSMORE

    LESSMORE        shift and go to state 899


state 850

    (385) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .

    PRAGMA          reduce using rule 385 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    PRIVATE         reduce using rule 385 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    WITH            reduce using rule 385 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    PACKAGE         reduce using rule 385 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    SEPARATE        reduce using rule 385 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    PROCEDURE       reduce using rule 385 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    FUNCTION        reduce using rule 385 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    GENERIC         reduce using rule 385 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    $end            reduce using rule 385 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    TASK            reduce using rule 385 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    PROTECTED       reduce using rule 385 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    error           reduce using rule 385 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    USE             reduce using rule 385 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    TYPE            reduce using rule 385 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    SUBTYPE         reduce using rule 385 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    FOR             reduce using rule 385 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    IDENTIFIER      reduce using rule 385 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    BEGIN           reduce using rule 385 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)
    END             reduce using rule 385 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt ; .)


state 851

    (396) entry_body -> ENTRY IDENTIFIER ( . iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part
    (323) formal_part -> ( . param_s )
    (292) iter_part -> . FOR IDENTIFIER IN
    (324) param_s -> . param
    (325) param_s -> . param_s ; param
    (326) param -> . def_id_s : mode mark init_opt
    (327) param -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    FOR             shift and go to state 416
    error           shift and go to state 109
    IDENTIFIER      shift and go to state 76

    def_id                         shift and go to state 89
    param_s                        shift and go to state 341
    iter_part                      shift and go to state 900
    param                          shift and go to state 340
    def_id_s                       shift and go to state 105

state 852

    (395) entry_body -> ENTRY IDENTIFIER formal_part_opt . WHEN condition entry_body_part

    WHEN            shift and go to state 901


state 853

    (108) comp_decl -> def_id_s : . component_subtype_def init_opt ;
    (82) component_subtype_def -> . aliased_opt subtype_ind
    (83) aliased_opt -> .
    (84) aliased_opt -> . ALIASED

    IDENTIFIER      reduce using rule 83 (aliased_opt -> .)
    STRING          reduce using rule 83 (aliased_opt -> .)
    ALIASED         shift and go to state 902

    aliased_opt                    shift and go to state 903
    component_subtype_def          shift and go to state 904

state 854

    (109) comp_decl -> error ; .

    error           reduce using rule 109 (comp_decl -> error ; .)
    ENTRY           reduce using rule 109 (comp_decl -> error ; .)
    PROCEDURE       reduce using rule 109 (comp_decl -> error ; .)
    FUNCTION        reduce using rule 109 (comp_decl -> error ; .)
    PRAGMA          reduce using rule 109 (comp_decl -> error ; .)
    FOR             reduce using rule 109 (comp_decl -> error ; .)
    IDENTIFIER      reduce using rule 109 (comp_decl -> error ; .)
    END             reduce using rule 109 (comp_decl -> error ; .)
    CASE            reduce using rule 109 (comp_decl -> error ; .)
    WHEN            reduce using rule 109 (comp_decl -> error ; .)


state 855

    (394) entry_decl -> ENTRY IDENTIFIER ( discrete_range . ) formal_part_opt ;

    )               shift and go to state 905


state 856

    (161) simple_name -> IDENTIFIER .
    (26) def_id -> IDENTIFIER .

    (               reduce using rule 161 (simple_name -> IDENTIFIER .)
    .               reduce using rule 161 (simple_name -> IDENTIFIER .)
    TICK            reduce using rule 161 (simple_name -> IDENTIFIER .)
    RANGE           reduce using rule 161 (simple_name -> IDENTIFIER .)
    )               reduce using rule 161 (simple_name -> IDENTIFIER .)
    STARSTAR        reduce using rule 161 (simple_name -> IDENTIFIER .)
    *               reduce using rule 161 (simple_name -> IDENTIFIER .)
    /               reduce using rule 161 (simple_name -> IDENTIFIER .)
    MOD             reduce using rule 161 (simple_name -> IDENTIFIER .)
    REM             reduce using rule 161 (simple_name -> IDENTIFIER .)
    DOTDOT          reduce using rule 161 (simple_name -> IDENTIFIER .)
    +               reduce using rule 161 (simple_name -> IDENTIFIER .)
    -               reduce using rule 161 (simple_name -> IDENTIFIER .)
    &               reduce using rule 161 (simple_name -> IDENTIFIER .)
    :               reduce using rule 26 (def_id -> IDENTIFIER .)
    ,               reduce using rule 26 (def_id -> IDENTIFIER .)


state 857

    (393) entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .

    PRAGMA          reduce using rule 393 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    ENTRY           reduce using rule 393 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    FOR             reduce using rule 393 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    END             reduce using rule 393 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    PRIVATE         reduce using rule 393 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    PROCEDURE       reduce using rule 393 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    FUNCTION        reduce using rule 393 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    error           reduce using rule 393 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)
    IDENTIFIER      reduce using rule 393 (entry_decl -> ENTRY IDENTIFIER formal_part_opt ; .)


state 858

    (286) loop_stmt -> label_opt iteration m basic_loop id_opt ; .

    LESSLESS        reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    error           reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    PRAGMA          reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    NuLL            reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    EXIT            reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    RETURN          reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    GOTO            reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    DELAY           reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    ABORT           reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    RAISE           reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    REQUEUE         reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    IF              reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    CASE            reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    IDENTIFIER      reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    ACCEPT          reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    SELECT          reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    STRING          reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    WHILE           reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    DECLARE         reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    FOR             reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    LOOP            reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    BEGIN           reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    OR              reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    ELSE            reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    END             reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    WHEN            reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    THEN            reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    EXCEPTION       reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)
    ELSIF           reduce using rule 286 (loop_stmt -> label_opt iteration m basic_loop id_opt ; .)


state 859

    (295) basic_loop -> LOOP statement_s END . LOOP

    LOOP            shift and go to state 906


state 860

    (298) block -> label_opt block_decl block_body END id_opt ; .

    LESSLESS        reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    error           reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    PRAGMA          reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    NuLL            reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    EXIT            reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    RETURN          reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    GOTO            reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    DELAY           reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    ABORT           reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    RAISE           reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    REQUEUE         reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    IF              reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    CASE            reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    IDENTIFIER      reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    ACCEPT          reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    SELECT          reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    STRING          reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    WHILE           reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    DECLARE         reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    FOR             reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    LOOP            reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    BEGIN           reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    OR              reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    ELSE            reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    END             reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    EXCEPTION       reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    WHEN            reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    THEN            reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)
    ELSIF           reduce using rule 298 (block -> label_opt block_decl block_body END id_opt ; .)


state 861

    (425) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END . SELECT ;

    SELECT          shift and go to state 907


state 862

    (424) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt . END SELECT ;

    END             shift and go to state 908


state 863

    (423) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END . SELECT ;

    SELECT          shift and go to state 909


state 864

    (419) select_alt -> delay_stmt stmts_opt .

    OR              reduce using rule 419 (select_alt -> delay_stmt stmts_opt .)
    ELSE            reduce using rule 419 (select_alt -> delay_stmt stmts_opt .)
    END             reduce using rule 419 (select_alt -> delay_stmt stmts_opt .)


state 865

    (413) select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT . ;

    ;               shift and go to state 910


state 866

    (281) case_stmt -> case_hdr pragma_s alternative_s END CASE ; .

    EXCEPTION       reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    LESSLESS        reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    error           reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    PRAGMA          reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    NuLL            reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    EXIT            reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    RETURN          reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    GOTO            reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    DELAY           reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    ABORT           reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    RAISE           reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    REQUEUE         reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    IF              reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    CASE            reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    IDENTIFIER      reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    ACCEPT          reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    SELECT          reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    STRING          reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    WHILE           reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    DECLARE         reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    FOR             reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    LOOP            reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    BEGIN           reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    END             reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    OR              reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    ELSE            reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    THEN            reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    ELSIF           reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)
    WHEN            reduce using rule 281 (case_stmt -> case_hdr pragma_s alternative_s END CASE ; .)


state 867

    (285) alternative -> WHEN choice_s ARROW . statement_s
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s m statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (305) exit_stmt -> . EXIT name_opt when_opt ;
    (310) return_stmt -> . RETURN ;
    (311) return_stmt -> . RETURN expression ;
    (312) goto_stmt -> . GOTO name ;
    (335) procedure_call -> . name ;
    (407) delay_stmt -> . DELAY expression ;
    (408) delay_stmt -> . DELAY UNTIL expression ;
    (428) abort_stmt -> . ABORT name_s ;
    (467) raise_stmt -> . RAISE name_opt ;
    (513) code_stmt -> . qualified ;
    (468) requeue_stmt -> . REQUEUE name ;
    (469) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (281) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (286) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (298) block -> . label_opt block_decl block_body END id_opt ;
    (402) accept_stmt -> . accept_hdr ;
    (403) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (409) select_stmt -> . select_wait
    (410) select_stmt -> . async_select
    (411) select_stmt -> . timed_entry_call
    (412) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (282) case_hdr -> . CASE expression IS
    (287) label_opt -> .
    (288) label_opt -> . IDENTIFIER :
    (404) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (413) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (423) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (424) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (425) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 287 (label_opt -> .)
    DECLARE         reduce using rule 287 (label_opt -> .)
    FOR             reduce using rule 287 (label_opt -> .)
    LOOP            reduce using rule 287 (label_opt -> .)
    BEGIN           reduce using rule 287 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 139

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 911
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 138
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    attribute                      shift and go to state 121
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 868

    (403) accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .

    LESSLESS        reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    error           reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    PRAGMA          reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    NuLL            reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    EXIT            reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    RETURN          reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    GOTO            reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    DELAY           reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    ABORT           reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    RAISE           reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    REQUEUE         reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    IF              reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    CASE            reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    IDENTIFIER      reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    ACCEPT          reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    SELECT          reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    STRING          reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    WHILE           reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    DECLARE         reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    FOR             reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    LOOP            reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    BEGIN           reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    WHEN            reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    END             reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    EXCEPTION       reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    OR              reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    ELSE            reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    THEN            reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)
    ELSIF           reduce using rule 403 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt ; .)


state 869

    (461) exception_handler -> WHEN except_choice_s ARROW statement_s .
    (245) statement_s -> statement_s . m statement
    (197) m -> .

    WHEN            reduce using rule 461 (exception_handler -> WHEN except_choice_s ARROW statement_s .)
    END             reduce using rule 461 (exception_handler -> WHEN except_choice_s ARROW statement_s .)
    LESSLESS        reduce using rule 197 (m -> .)
    error           reduce using rule 197 (m -> .)
    PRAGMA          reduce using rule 197 (m -> .)
    NuLL            reduce using rule 197 (m -> .)
    EXIT            reduce using rule 197 (m -> .)
    RETURN          reduce using rule 197 (m -> .)
    GOTO            reduce using rule 197 (m -> .)
    DELAY           reduce using rule 197 (m -> .)
    ABORT           reduce using rule 197 (m -> .)
    RAISE           reduce using rule 197 (m -> .)
    REQUEUE         reduce using rule 197 (m -> .)
    IF              reduce using rule 197 (m -> .)
    CASE            reduce using rule 197 (m -> .)
    IDENTIFIER      reduce using rule 197 (m -> .)
    ACCEPT          reduce using rule 197 (m -> .)
    SELECT          reduce using rule 197 (m -> .)
    STRING          reduce using rule 197 (m -> .)
    WHILE           reduce using rule 197 (m -> .)
    DECLARE         reduce using rule 197 (m -> .)
    FOR             reduce using rule 197 (m -> .)
    LOOP            reduce using rule 197 (m -> .)
    BEGIN           reduce using rule 197 (m -> .)

    m                              shift and go to state 454

state 870

    (464) except_choice_s -> except_choice_s | except_choice .

    ARROW           reduce using rule 464 (except_choice_s -> except_choice_s | except_choice .)
    |               reduce using rule 464 (except_choice_s -> except_choice_s | except_choice .)


state 871

    (462) exception_handler -> WHEN IDENTIFIER : except_choice_s . ARROW statement_s
    (464) except_choice_s -> except_choice_s . | except_choice

    ARROW           shift and go to state 912
    |               shift and go to state 805


state 872

    (272) if_stmt -> IF cond_clause_s else_opt END IF ; .

    LESSLESS        reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    error           reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    PRAGMA          reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    NuLL            reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    EXIT            reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    RETURN          reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    GOTO            reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    DELAY           reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    ABORT           reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    RAISE           reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    REQUEUE         reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    IF              reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    CASE            reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    IDENTIFIER      reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    ACCEPT          reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    SELECT          reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    STRING          reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    WHILE           reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    DECLARE         reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    FOR             reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    LOOP            reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    BEGIN           reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    WHEN            reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    END             reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    OR              reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    ELSE            reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    THEN            reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    EXCEPTION       reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)
    ELSIF           reduce using rule 272 (if_stmt -> IF cond_clause_s else_opt END IF ; .)


state 873

    (507) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD . ;

    ;               shift and go to state 913


state 874

    (511) comp_loc_s -> comp_loc_s mark AT . expression RANGE range ;
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 914

state 875

    (509) align_opt -> AT MOD expression ; .

    END             reduce using rule 509 (align_opt -> AT MOD expression ; .)
    IDENTIFIER      reduce using rule 509 (align_opt -> AT MOD expression ; .)


state 876

    (368) task_body -> TASK BODY simple_name IS decl_part block_body END id_opt . ;

    ;               shift and go to state 915


state 877

    (367) task_private_opt -> PRIVATE entry_decl_s rep_spec_s .
    (400) rep_spec_s -> rep_spec_s . rep_spec pragma_s
    (503) rep_spec -> . attrib_def
    (504) rep_spec -> . record_type_spec
    (505) rep_spec -> . address_spec
    (506) attrib_def -> . FOR mark USE expression ;
    (507) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (512) address_spec -> . FOR mark USE AT expression ;

    END             reduce using rule 367 (task_private_opt -> PRIVATE entry_decl_s rep_spec_s .)
    FOR             shift and go to state 63

    record_type_spec               shift and go to state 68
    rep_spec                       shift and go to state 717
    attrib_def                     shift and go to state 70
    address_spec                   shift and go to state 52

state 878

    (365) task_def -> IS entry_decl_s rep_spec_s task_private_opt END id_opt .

    ;               reduce using rule 365 (task_def -> IS entry_decl_s rep_spec_s task_private_opt END id_opt .)


state 879

    (113) discrim_spec -> def_id_s : access_opt mark init_opt .

    )               reduce using rule 113 (discrim_spec -> def_id_s : access_opt mark init_opt .)
    ;               reduce using rule 113 (discrim_spec -> def_id_s : access_opt mark init_opt .)


state 880

    (59) derived_type -> ABSTRACT NEW subtype_ind WITH . PRIVATE
    (60) derived_type -> ABSTRACT NEW subtype_ind WITH . record_def
    (96) record_def -> . RECORD pragma_s comp_list END RECORD
    (97) record_def -> . NuLL RECORD

    PRIVATE         shift and go to state 916
    RECORD          shift and go to state 832
    NuLL            shift and go to state 833

    record_def                     shift and go to state 917

state 881

    (57) derived_type -> NEW subtype_ind WITH PRIVATE .

    ;               reduce using rule 57 (derived_type -> NEW subtype_ind WITH PRIVATE .)


state 882

    (58) derived_type -> NEW subtype_ind WITH record_def .

    ;               reduce using rule 58 (derived_type -> NEW subtype_ind WITH record_def .)


state 883

    (66) enum_id_s -> enum_id_s , enum_id .

    )               reduce using rule 66 (enum_id_s -> enum_id_s , enum_id .)
    ,               reduce using rule 66 (enum_id_s -> enum_id_s , enum_id .)


state 884

    (77) fixed_type -> DELTA expression DIGITS expression . range_spec_opt
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (71) range_spec_opt -> .
    (72) range_spec_opt -> . range_spec
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE
    (70) range_spec -> . range_constraint
    (61) range_constraint -> . RANGE range

    ;               reduce using rule 71 (range_spec_opt -> .)
    AND             shift and go to state 247
    OR              shift and go to state 250
    RANGE           shift and go to state 371

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249
    range_constraint               shift and go to state 602
    range_spec                     shift and go to state 824
    range_spec_opt                 shift and go to state 918

state 885

    (132) access_type -> ACCESS prot_opt FUNCTION formal_part_opt . RETURN mark

    RETURN          shift and go to state 919


state 886

    (131) access_type -> ACCESS prot_opt PROCEDURE formal_part_opt .

    ;               reduce using rule 131 (access_type -> ACCESS prot_opt PROCEDURE formal_part_opt .)


state 887

    (96) record_def -> RECORD pragma_s . comp_list END RECORD
    (9) pragma_s -> pragma_s . pragma
    (101) comp_list -> . comp_decl_s variant_part_opt
    (102) comp_list -> . variant_part pragma_s
    (103) comp_list -> . NuLL ; pragma_s
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (104) comp_decl_s -> . comp_decl
    (105) comp_decl_s -> . comp_decl_s pragma_s comp_decl
    (117) variant_part -> . CASE simple_name IS pragma_s variant_s END CASE ;
    (108) comp_decl -> . def_id_s : component_subtype_def init_opt ;
    (109) comp_decl -> . error ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    NuLL            shift and go to state 925
    PRAGMA          shift and go to state 4
    CASE            shift and go to state 921
    error           shift and go to state 783
    IDENTIFIER      shift and go to state 76

    def_id_s                       shift and go to state 779
    comp_list                      shift and go to state 922
    comp_decl                      shift and go to state 923
    def_id                         shift and go to state 89
    variant_part                   shift and go to state 924
    pragma                         shift and go to state 14
    comp_decl_s                    shift and go to state 920

state 888

    (97) record_def -> NuLL RECORD .

    ;               reduce using rule 97 (record_def -> NuLL RECORD .)


state 889

    (90) iter_discrete_range_s -> iter_discrete_range_s , discrete_range .

    )               reduce using rule 90 (iter_discrete_range_s -> iter_discrete_range_s , discrete_range .)
    ,               reduce using rule 90 (iter_discrete_range_s -> iter_discrete_range_s , discrete_range .)


state 890

    (80) unconstr_array_type -> ARRAY ( index_s ) OF . component_subtype_def
    (82) component_subtype_def -> . aliased_opt subtype_ind
    (83) aliased_opt -> .
    (84) aliased_opt -> . ALIASED

    IDENTIFIER      reduce using rule 83 (aliased_opt -> .)
    STRING          reduce using rule 83 (aliased_opt -> .)
    ALIASED         shift and go to state 902

    aliased_opt                    shift and go to state 903
    component_subtype_def          shift and go to state 926

state 891

    (86) index_s -> index_s , index .

    )               reduce using rule 86 (index_s -> index_s , index .)
    ,               reduce using rule 86 (index_s -> index_s , index .)


state 892

    (87) index -> name . RANGE LESSMORE
    (168) indexed_comp -> name . ( value_s )
    (174) selected_comp -> name . . simple_name
    (175) selected_comp -> name . . used_char
    (176) selected_comp -> name . . operator_symbol
    (177) selected_comp -> name . . ALL
    (178) attribute -> name . TICK attribute_id

    RANGE           shift and go to state 927
    (               shift and go to state 243
    .               shift and go to state 244
    TICK            shift and go to state 253


state 893

    (87) index -> name RANGE LESSMORE .

    )               reduce using rule 87 (index -> name RANGE LESSMORE .)
    ,               reduce using rule 87 (index -> name RANGE LESSMORE .)


state 894

    (343) pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .

    PACKAGE         reduce using rule 343 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    TASK            reduce using rule 343 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    PROTECTED       reduce using rule 343 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    error           reduce using rule 343 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    USE             reduce using rule 343 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    PRAGMA          reduce using rule 343 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    TYPE            reduce using rule 343 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    SUBTYPE         reduce using rule 343 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    FOR             reduce using rule 343 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    PROCEDURE       reduce using rule 343 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    FUNCTION        reduce using rule 343 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    GENERIC         reduce using rule 343 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    IDENTIFIER      reduce using rule 343 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    BEGIN           reduce using rule 343 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    PRIVATE         reduce using rule 343 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    WITH            reduce using rule 343 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    SEPARATE        reduce using rule 343 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    $end            reduce using rule 343 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)
    END             reduce using rule 343 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ; .)


state 895

    (477) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .

    PACKAGE         reduce using rule 477 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    PROCEDURE       reduce using rule 477 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    FUNCTION        reduce using rule 477 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    TYPE            reduce using rule 477 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    WITH            reduce using rule 477 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    error           reduce using rule 477 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    USE             reduce using rule 477 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)
    IDENTIFIER      reduce using rule 477 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default ; .)


state 896

    (478) generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE . ) ;

    )               shift and go to state 928


state 897

    (499) generic_derived_type -> ABSTRACT NEW subtype_ind WITH . PRIVATE

    PRIVATE         shift and go to state 929


state 898

    (498) generic_derived_type -> NEW subtype_ind WITH PRIVATE .

    ;               reduce using rule 498 (generic_derived_type -> NEW subtype_ind WITH PRIVATE .)


state 899

    (491) generic_type_def -> DELTA LESSMORE DIGITS LESSMORE .

    ;               reduce using rule 491 (generic_type_def -> DELTA LESSMORE DIGITS LESSMORE .)


state 900

    (396) entry_body -> ENTRY IDENTIFIER ( iter_part . discrete_range ) formal_part_opt WHEN condition entry_body_part
    (91) discrete_range -> . name range_constr_opt
    (92) discrete_range -> . range
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    simple_expression              shift and go to state 358
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    allocator                      shift and go to state 130
    factor                         shift and go to state 137
    parenthesized_primary          shift and go to state 142
    discrete_range                 shift and go to state 930
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 680
    operator_symbol                shift and go to state 138
    range                          shift and go to state 681
    qualified                      shift and go to state 141

state 901

    (395) entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN . condition entry_body_part
    (278) condition -> . expression
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    allocator                      shift and go to state 130
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    condition                      shift and go to state 931
    term                           shift and go to state 147
    name                           shift and go to state 148
    expression                     shift and go to state 461

state 902

    (84) aliased_opt -> ALIASED .

    IDENTIFIER      reduce using rule 84 (aliased_opt -> ALIASED .)
    STRING          reduce using rule 84 (aliased_opt -> ALIASED .)


state 903

    (82) component_subtype_def -> aliased_opt . subtype_ind
    (51) subtype_ind -> . name constraint
    (52) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    name                           shift and go to state 481
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 138
    subtype_ind                    shift and go to state 932
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157

state 904

    (108) comp_decl -> def_id_s : component_subtype_def . init_opt ;
    (33) init_opt -> .
    (34) init_opt -> . ASSIGNMENT expression

    ;               reduce using rule 33 (init_opt -> .)
    ASSIGNMENT      shift and go to state 632

    init_opt                       shift and go to state 933

state 905

    (394) entry_decl -> ENTRY IDENTIFIER ( discrete_range ) . formal_part_opt ;
    (321) formal_part_opt -> .
    (322) formal_part_opt -> . formal_part
    (323) formal_part -> . ( param_s )

    ;               reduce using rule 321 (formal_part_opt -> .)
    (               shift and go to state 189

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 934

state 906

    (295) basic_loop -> LOOP statement_s END LOOP .

    STRING          reduce using rule 295 (basic_loop -> LOOP statement_s END LOOP .)
    IDENTIFIER      reduce using rule 295 (basic_loop -> LOOP statement_s END LOOP .)
    ;               reduce using rule 295 (basic_loop -> LOOP statement_s END LOOP .)


state 907

    (425) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT . ;

    ;               shift and go to state 935


state 908

    (424) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END . SELECT ;

    SELECT          shift and go to state 936


state 909

    (423) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT . ;

    ;               shift and go to state 937


state 910

    (413) select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .

    LESSLESS        reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    error           reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    PRAGMA          reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    NuLL            reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    EXIT            reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    RETURN          reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    GOTO            reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    DELAY           reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    ABORT           reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    RAISE           reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    REQUEUE         reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    IF              reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    CASE            reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    IDENTIFIER      reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    ACCEPT          reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    SELECT          reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    STRING          reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    WHILE           reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    DECLARE         reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    FOR             reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    LOOP            reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    BEGIN           reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    OR              reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    ELSE            reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    END             reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    EXCEPTION       reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    THEN            reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    ELSIF           reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)
    WHEN            reduce using rule 413 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT ; .)


state 911

    (285) alternative -> WHEN choice_s ARROW statement_s .
    (245) statement_s -> statement_s . m statement
    (197) m -> .

    END             reduce using rule 285 (alternative -> WHEN choice_s ARROW statement_s .)
    WHEN            reduce using rule 285 (alternative -> WHEN choice_s ARROW statement_s .)
    LESSLESS        reduce using rule 197 (m -> .)
    error           reduce using rule 197 (m -> .)
    PRAGMA          reduce using rule 197 (m -> .)
    NuLL            reduce using rule 197 (m -> .)
    EXIT            reduce using rule 197 (m -> .)
    RETURN          reduce using rule 197 (m -> .)
    GOTO            reduce using rule 197 (m -> .)
    DELAY           reduce using rule 197 (m -> .)
    ABORT           reduce using rule 197 (m -> .)
    RAISE           reduce using rule 197 (m -> .)
    REQUEUE         reduce using rule 197 (m -> .)
    IF              reduce using rule 197 (m -> .)
    CASE            reduce using rule 197 (m -> .)
    IDENTIFIER      reduce using rule 197 (m -> .)
    ACCEPT          reduce using rule 197 (m -> .)
    SELECT          reduce using rule 197 (m -> .)
    STRING          reduce using rule 197 (m -> .)
    WHILE           reduce using rule 197 (m -> .)
    DECLARE         reduce using rule 197 (m -> .)
    FOR             reduce using rule 197 (m -> .)
    LOOP            reduce using rule 197 (m -> .)
    BEGIN           reduce using rule 197 (m -> .)

    m                              shift and go to state 454

state 912

    (462) exception_handler -> WHEN IDENTIFIER : except_choice_s ARROW . statement_s
    (244) statement_s -> . statement
    (245) statement_s -> . statement_s m statement
    (246) statement -> . unlabeled
    (247) statement -> . label statement
    (248) unlabeled -> . simple_stmt
    (249) unlabeled -> . compound_stmt
    (250) unlabeled -> . pragma
    (269) label -> . LESSLESS IDENTIFIER MOREMORE
    (251) simple_stmt -> . null_stmt
    (252) simple_stmt -> . assign_stmt
    (253) simple_stmt -> . exit_stmt
    (254) simple_stmt -> . return_stmt
    (255) simple_stmt -> . goto_stmt
    (256) simple_stmt -> . procedure_call
    (257) simple_stmt -> . delay_stmt
    (258) simple_stmt -> . abort_stmt
    (259) simple_stmt -> . raise_stmt
    (260) simple_stmt -> . code_stmt
    (261) simple_stmt -> . requeue_stmt
    (262) simple_stmt -> . error ;
    (263) compound_stmt -> . if_stmt
    (264) compound_stmt -> . case_stmt
    (265) compound_stmt -> . loop_stmt
    (266) compound_stmt -> . block
    (267) compound_stmt -> . accept_stmt
    (268) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (270) null_stmt -> . NuLL ;
    (271) assign_stmt -> . name ASSIGNMENT expression ;
    (305) exit_stmt -> . EXIT name_opt when_opt ;
    (310) return_stmt -> . RETURN ;
    (311) return_stmt -> . RETURN expression ;
    (312) goto_stmt -> . GOTO name ;
    (335) procedure_call -> . name ;
    (407) delay_stmt -> . DELAY expression ;
    (408) delay_stmt -> . DELAY UNTIL expression ;
    (428) abort_stmt -> . ABORT name_s ;
    (467) raise_stmt -> . RAISE name_opt ;
    (513) code_stmt -> . qualified ;
    (468) requeue_stmt -> . REQUEUE name ;
    (469) requeue_stmt -> . REQUEUE name WITH ABORT ;
    (272) if_stmt -> . IF cond_clause_s else_opt END IF ;
    (281) case_stmt -> . case_hdr pragma_s alternative_s END CASE ;
    (286) loop_stmt -> . label_opt iteration m basic_loop id_opt ;
    (298) block -> . label_opt block_decl block_body END id_opt ;
    (402) accept_stmt -> . accept_hdr ;
    (403) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt ;
    (409) select_stmt -> . select_wait
    (410) select_stmt -> . async_select
    (411) select_stmt -> . timed_entry_call
    (412) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (241) qualified -> . name TICK parenthesized_primary
    (282) case_hdr -> . CASE expression IS
    (287) label_opt -> .
    (288) label_opt -> . IDENTIFIER :
    (404) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (413) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT ;
    (423) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ;
    (424) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ;
    (425) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT ;
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LESSLESS        shift and go to state 272
    error           shift and go to state 298
    PRAGMA          shift and go to state 4
    NuLL            shift and go to state 271
    EXIT            shift and go to state 297
    RETURN          shift and go to state 274
    GOTO            shift and go to state 264
    DELAY           shift and go to state 260
    ABORT           shift and go to state 270
    RAISE           shift and go to state 284
    REQUEUE         shift and go to state 288
    IF              shift and go to state 305
    CASE            shift and go to state 287
    WHILE           reduce using rule 287 (label_opt -> .)
    DECLARE         reduce using rule 287 (label_opt -> .)
    FOR             reduce using rule 287 (label_opt -> .)
    LOOP            reduce using rule 287 (label_opt -> .)
    BEGIN           reduce using rule 287 (label_opt -> .)
    IDENTIFIER      shift and go to state 290
    ACCEPT          shift and go to state 275
    SELECT          shift and go to state 277
    STRING          shift and go to state 139

    indexed_comp                   shift and go to state 129
    accept_stmt                    shift and go to state 273
    label_opt                      shift and go to state 263
    select_wait                    shift and go to state 304
    abort_stmt                     shift and go to state 299
    return_stmt                    shift and go to state 285
    procedure_call                 shift and go to state 276
    assign_stmt                    shift and go to state 308
    statement_s                    shift and go to state 938
    simple_name                    shift and go to state 157
    code_stmt                      shift and go to state 301
    case_stmt                      shift and go to state 278
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 138
    label                          shift and go to state 279
    exit_stmt                      shift and go to state 303
    select_stmt                    shift and go to state 262
    statement                      shift and go to state 289
    attribute                      shift and go to state 121
    compound_stmt                  shift and go to state 280
    case_hdr                       shift and go to state 282
    delay_stmt                     shift and go to state 291
    unlabeled                      shift and go to state 302
    simple_stmt                    shift and go to state 265
    loop_stmt                      shift and go to state 266
    qualified                      shift and go to state 267
    pragma                         shift and go to state 293
    async_select                   shift and go to state 261
    requeue_stmt                   shift and go to state 294
    raise_stmt                     shift and go to state 295
    name                           shift and go to state 269
    if_stmt                        shift and go to state 268
    accept_hdr                     shift and go to state 292
    cond_entry_call                shift and go to state 306
    timed_entry_call               shift and go to state 296
    goto_stmt                      shift and go to state 281
    null_stmt                      shift and go to state 307
    block                          shift and go to state 283

state 913

    (507) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .

    PACKAGE         reduce using rule 507 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    TASK            reduce using rule 507 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    PROTECTED       reduce using rule 507 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    error           reduce using rule 507 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    USE             reduce using rule 507 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    PRAGMA          reduce using rule 507 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    TYPE            reduce using rule 507 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    SUBTYPE         reduce using rule 507 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    FOR             reduce using rule 507 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    PROCEDURE       reduce using rule 507 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    FUNCTION        reduce using rule 507 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    GENERIC         reduce using rule 507 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    IDENTIFIER      reduce using rule 507 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    BEGIN           reduce using rule 507 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    END             reduce using rule 507 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    PRIVATE         reduce using rule 507 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)
    ENTRY           reduce using rule 507 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD ; .)


state 914

    (511) comp_loc_s -> comp_loc_s mark AT expression . RANGE range ;
    (199) expression -> expression . logical m relation
    (200) expression -> expression . short_circuit m relation
    (201) logical -> . AND
    (202) logical -> . OR
    (203) short_circuit -> . AND THEN
    (204) short_circuit -> . OR ELSE

    RANGE           shift and go to state 939
    AND             shift and go to state 247
    OR              shift and go to state 250

    logical                        shift and go to state 248
    short_circuit                  shift and go to state 249

state 915

    (368) task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .

    PACKAGE         reduce using rule 368 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    TASK            reduce using rule 368 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    PROTECTED       reduce using rule 368 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    error           reduce using rule 368 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    USE             reduce using rule 368 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    PRAGMA          reduce using rule 368 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    TYPE            reduce using rule 368 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    SUBTYPE         reduce using rule 368 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    FOR             reduce using rule 368 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    PROCEDURE       reduce using rule 368 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    FUNCTION        reduce using rule 368 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    GENERIC         reduce using rule 368 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    IDENTIFIER      reduce using rule 368 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    BEGIN           reduce using rule 368 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    END             reduce using rule 368 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    PRIVATE         reduce using rule 368 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    WITH            reduce using rule 368 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    SEPARATE        reduce using rule 368 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)
    $end            reduce using rule 368 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt ; .)


state 916

    (59) derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .

    ;               reduce using rule 59 (derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .)


state 917

    (60) derived_type -> ABSTRACT NEW subtype_ind WITH record_def .

    ;               reduce using rule 60 (derived_type -> ABSTRACT NEW subtype_ind WITH record_def .)


state 918

    (77) fixed_type -> DELTA expression DIGITS expression range_spec_opt .

    ;               reduce using rule 77 (fixed_type -> DELTA expression DIGITS expression range_spec_opt .)


state 919

    (132) access_type -> ACCESS prot_opt FUNCTION formal_part_opt RETURN . mark
    (158) mark -> . simple_name
    (159) mark -> . mark TICK attribute_id
    (160) mark -> . mark . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 165
    mark                           shift and go to state 940

state 920

    (101) comp_list -> comp_decl_s . variant_part_opt
    (105) comp_decl_s -> comp_decl_s . pragma_s comp_decl
    (106) variant_part_opt -> . pragma_s
    (107) variant_part_opt -> . pragma_s variant_part pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    error           reduce using rule 8 (pragma_s -> .)
    CASE            reduce using rule 8 (pragma_s -> .)
    PRAGMA          reduce using rule 8 (pragma_s -> .)
    IDENTIFIER      reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 941
    variant_part_opt               shift and go to state 942

state 921

    (117) variant_part -> CASE . simple_name IS pragma_s variant_s END CASE ;
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 39

    simple_name                    shift and go to state 943

state 922

    (96) record_def -> RECORD pragma_s comp_list . END RECORD

    END             shift and go to state 944


state 923

    (104) comp_decl_s -> comp_decl .

    error           reduce using rule 104 (comp_decl_s -> comp_decl .)
    CASE            reduce using rule 104 (comp_decl_s -> comp_decl .)
    PRAGMA          reduce using rule 104 (comp_decl_s -> comp_decl .)
    IDENTIFIER      reduce using rule 104 (comp_decl_s -> comp_decl .)
    END             reduce using rule 104 (comp_decl_s -> comp_decl .)
    WHEN            reduce using rule 104 (comp_decl_s -> comp_decl .)


state 924

    (102) comp_list -> variant_part . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 945

state 925

    (103) comp_list -> NuLL . ; pragma_s

    ;               shift and go to state 946


state 926

    (80) unconstr_array_type -> ARRAY ( index_s ) OF component_subtype_def .

    ;               reduce using rule 80 (unconstr_array_type -> ARRAY ( index_s ) OF component_subtype_def .)
    ASSIGNMENT      reduce using rule 80 (unconstr_array_type -> ARRAY ( index_s ) OF component_subtype_def .)


state 927

    (87) index -> name RANGE . LESSMORE

    LESSMORE        shift and go to state 893


state 928

    (478) generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) . ;

    ;               shift and go to state 947


state 929

    (499) generic_derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .

    ;               reduce using rule 499 (generic_derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .)


state 930

    (396) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range . ) formal_part_opt WHEN condition entry_body_part

    )               shift and go to state 948


state 931

    (395) entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition . entry_body_part
    (397) entry_body_part -> . ;
    (398) entry_body_part -> . IS decl_part block_body END id_opt ;

    ;               shift and go to state 951
    IS              shift and go to state 950

    entry_body_part                shift and go to state 949

state 932

    (82) component_subtype_def -> aliased_opt subtype_ind .

    ASSIGNMENT      reduce using rule 82 (component_subtype_def -> aliased_opt subtype_ind .)
    ;               reduce using rule 82 (component_subtype_def -> aliased_opt subtype_ind .)


state 933

    (108) comp_decl -> def_id_s : component_subtype_def init_opt . ;

    ;               shift and go to state 952


state 934

    (394) entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt . ;

    ;               shift and go to state 953


state 935

    (425) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .

    LESSLESS        reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    error           reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    PRAGMA          reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    NuLL            reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    EXIT            reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    RETURN          reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    GOTO            reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    DELAY           reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    ABORT           reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    RAISE           reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    REQUEUE         reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    IF              reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    CASE            reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    IDENTIFIER      reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    ACCEPT          reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    SELECT          reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    STRING          reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    WHILE           reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    DECLARE         reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    FOR             reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    LOOP            reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    BEGIN           reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    OR              reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    ELSE            reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    THEN            reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    WHEN            reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    END             reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    EXCEPTION       reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)
    ELSIF           reduce using rule 425 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT ; .)


state 936

    (424) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT . ;

    ;               shift and go to state 954


state 937

    (423) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .

    LESSLESS        reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    error           reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    PRAGMA          reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    NuLL            reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    EXIT            reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    RETURN          reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    GOTO            reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    DELAY           reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    ABORT           reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    RAISE           reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    REQUEUE         reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    IF              reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    CASE            reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    IDENTIFIER      reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    ACCEPT          reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    SELECT          reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    STRING          reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    WHILE           reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    DECLARE         reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    FOR             reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    LOOP            reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    BEGIN           reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    END             reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    THEN            reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    OR              reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    ELSE            reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    ELSIF           reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    WHEN            reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)
    EXCEPTION       reduce using rule 423 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT ; .)


state 938

    (462) exception_handler -> WHEN IDENTIFIER : except_choice_s ARROW statement_s .
    (245) statement_s -> statement_s . m statement
    (197) m -> .

    WHEN            reduce using rule 462 (exception_handler -> WHEN IDENTIFIER : except_choice_s ARROW statement_s .)
    END             reduce using rule 462 (exception_handler -> WHEN IDENTIFIER : except_choice_s ARROW statement_s .)
    LESSLESS        reduce using rule 197 (m -> .)
    error           reduce using rule 197 (m -> .)
    PRAGMA          reduce using rule 197 (m -> .)
    NuLL            reduce using rule 197 (m -> .)
    EXIT            reduce using rule 197 (m -> .)
    RETURN          reduce using rule 197 (m -> .)
    GOTO            reduce using rule 197 (m -> .)
    DELAY           reduce using rule 197 (m -> .)
    ABORT           reduce using rule 197 (m -> .)
    RAISE           reduce using rule 197 (m -> .)
    REQUEUE         reduce using rule 197 (m -> .)
    IF              reduce using rule 197 (m -> .)
    CASE            reduce using rule 197 (m -> .)
    IDENTIFIER      reduce using rule 197 (m -> .)
    ACCEPT          reduce using rule 197 (m -> .)
    SELECT          reduce using rule 197 (m -> .)
    STRING          reduce using rule 197 (m -> .)
    WHILE           reduce using rule 197 (m -> .)
    DECLARE         reduce using rule 197 (m -> .)
    FOR             reduce using rule 197 (m -> .)
    LOOP            reduce using rule 197 (m -> .)
    BEGIN           reduce using rule 197 (m -> .)

    m                              shift and go to state 454

state 939

    (511) comp_loc_s -> comp_loc_s mark AT expression RANGE . range ;
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    simple_expression              shift and go to state 358
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    factor                         shift and go to state 137
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    term                           shift and go to state 147
    name                           shift and go to state 520
    operator_symbol                shift and go to state 138
    range                          shift and go to state 955

state 940

    (132) access_type -> ACCESS prot_opt FUNCTION formal_part_opt RETURN mark .
    (159) mark -> mark . TICK attribute_id
    (160) mark -> mark . . simple_name

    ;               reduce using rule 132 (access_type -> ACCESS prot_opt FUNCTION formal_part_opt RETURN mark .)
    TICK            shift and go to state 312
    .               shift and go to state 311


state 941

    (105) comp_decl_s -> comp_decl_s pragma_s . comp_decl
    (106) variant_part_opt -> pragma_s .
    (107) variant_part_opt -> pragma_s . variant_part pragma_s
    (9) pragma_s -> pragma_s . pragma
    (108) comp_decl -> . def_id_s : component_subtype_def init_opt ;
    (109) comp_decl -> . error ;
    (117) variant_part -> . CASE simple_name IS pragma_s variant_s END CASE ;
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    END             reduce using rule 106 (variant_part_opt -> pragma_s .)
    WHEN            reduce using rule 106 (variant_part_opt -> pragma_s .)
    error           shift and go to state 783
    CASE            shift and go to state 921
    PRAGMA          shift and go to state 4
    IDENTIFIER      shift and go to state 76

    comp_decl                      shift and go to state 956
    def_id                         shift and go to state 89
    def_id_s                       shift and go to state 779
    pragma                         shift and go to state 14
    variant_part                   shift and go to state 957

state 942

    (101) comp_list -> comp_decl_s variant_part_opt .

    END             reduce using rule 101 (comp_list -> comp_decl_s variant_part_opt .)
    WHEN            reduce using rule 101 (comp_list -> comp_decl_s variant_part_opt .)


state 943

    (117) variant_part -> CASE simple_name . IS pragma_s variant_s END CASE ;

    IS              shift and go to state 958


state 944

    (96) record_def -> RECORD pragma_s comp_list END . RECORD

    RECORD          shift and go to state 959


state 945

    (102) comp_list -> variant_part pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 102 (comp_list -> variant_part pragma_s .)
    WHEN            reduce using rule 102 (comp_list -> variant_part pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 946

    (103) comp_list -> NuLL ; . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 960

state 947

    (478) generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .

    PACKAGE         reduce using rule 478 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)
    PROCEDURE       reduce using rule 478 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)
    FUNCTION        reduce using rule 478 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)
    TYPE            reduce using rule 478 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)
    WITH            reduce using rule 478 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)
    error           reduce using rule 478 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)
    USE             reduce using rule 478 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)
    IDENTIFIER      reduce using rule 478 (generic_formal -> WITH PACKAGE simple_name IS NEW name ( LESSMORE ) ; .)


state 948

    (396) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) . formal_part_opt WHEN condition entry_body_part
    (321) formal_part_opt -> .
    (322) formal_part_opt -> . formal_part
    (323) formal_part -> . ( param_s )

    WHEN            reduce using rule 321 (formal_part_opt -> .)
    (               shift and go to state 189

    formal_part                    shift and go to state 188
    formal_part_opt                shift and go to state 961

state 949

    (395) entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .

    PRAGMA          reduce using rule 395 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)
    END             reduce using rule 395 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)
    ENTRY           reduce using rule 395 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)
    PROCEDURE       reduce using rule 395 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)
    FUNCTION        reduce using rule 395 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)


state 950

    (398) entry_body_part -> IS . decl_part block_body END id_opt ;
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (334) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt ;
    (343) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt ;
    (368) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt ;
    (385) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt ;
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error ;
    (349) use_clause -> . USE name_s ;
    (350) use_clause -> . USE TYPE name_s ;
    (503) rep_spec -> . attrib_def
    (504) rep_spec -> . record_type_spec
    (505) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (333) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s : object_qualifier_opt object_subtype_def init_opt ;
    (35) number_decl -> . def_id_s : CONSTANT ASSIGNMENT expression ;
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion ;
    (50) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind ;
    (313) subprog_decl -> . subprog_spec ;
    (314) subprog_decl -> . generic_subp_inst ;
    (315) subprog_decl -> . subprog_spec_is_push ABSTRACT ;
    (336) pkg_decl -> . pkg_spec ;
    (337) pkg_decl -> . generic_pkg_inst ;
    (361) task_decl -> . task_spec ;
    (369) prot_decl -> . prot_spec ;
    (458) exception_decl -> . def_id_s : EXCEPTION ;
    (353) rename_decl -> . def_id_s : object_qualifier_opt subtype_ind renames ;
    (354) rename_decl -> . def_id_s : EXCEPTION renames ;
    (355) rename_decl -> . rename_unit
    (470) generic_decl -> . generic_formal_part subprog_spec ;
    (471) generic_decl -> . generic_formal_part pkg_spec ;
    (454) body_stub -> . TASK BODY simple_name IS SEPARATE ;
    (455) body_stub -> . PACKAGE BODY compound_name IS SEPARATE ;
    (456) body_stub -> . subprog_spec IS SEPARATE ;
    (457) body_stub -> . PROTECTED BODY simple_name IS SEPARATE ;
    (506) attrib_def -> . FOR mark USE expression ;
    (507) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD ;
    (512) address_spec -> . FOR mark USE AT expression ;
    (316) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (317) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (318) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (500) generic_subp_inst -> . subprog_spec IS generic_inst
    (338) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (501) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (362) task_spec -> . TASK simple_name task_def
    (363) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (370) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (371) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (356) rename_unit -> . PACKAGE compound_name renames ;
    (357) rename_unit -> . subprog_spec renames ;
    (358) rename_unit -> . generic_formal_part PACKAGE compound_name renames ;
    (359) rename_unit -> . generic_formal_part subprog_spec renames ;
    (472) generic_formal_part -> . GENERIC
    (473) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 72
    TASK            shift and go to state 67
    PROTECTED       shift and go to state 51
    error           shift and go to state 78
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 80
    SUBTYPE         shift and go to state 84
    FOR             shift and go to state 63
    PROCEDURE       shift and go to state 31
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 76

    decl                           shift and go to state 50
    subprog_body                   shift and go to state 59
    task_decl                      shift and go to state 60
    type_decl                      shift and go to state 56
    rep_spec                       shift and go to state 82
    task_body                      shift and go to state 83
    subtype_decl                   shift and go to state 61
    exception_decl                 shift and go to state 85
    address_spec                   shift and go to state 52
    subprog_spec_is_push           shift and go to state 86
    decl_part                      shift and go to state 962
    prot_decl                      shift and go to state 55
    record_type_spec               shift and go to state 68
    generic_decl                   shift and go to state 69
    def_id                         shift and go to state 89
    attrib_def                     shift and go to state 70
    subprog_spec                   shift and go to state 87
    def_id_s                       shift and go to state 88
    decl_item_or_body_s1           shift and go to state 71
    decl_item                      shift and go to state 53
    task_spec                      shift and go to state 65
    body                           shift and go to state 62
    object_decl                    shift and go to state 64
    body_stub                      shift and go to state 73
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 90
    generic_subp_inst              shift and go to state 29
    pragma                         shift and go to state 74
    rename_unit                    shift and go to state 91
    subprog_decl                   shift and go to state 58
    pkg_decl                       shift and go to state 57
    prot_spec                      shift and go to state 75
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 92
    use_clause                     shift and go to state 66
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 77
    decl_item_or_body              shift and go to state 79
    number_decl                    shift and go to state 93

state 951

    (397) entry_body_part -> ; .

    PRAGMA          reduce using rule 397 (entry_body_part -> ; .)
    END             reduce using rule 397 (entry_body_part -> ; .)
    ENTRY           reduce using rule 397 (entry_body_part -> ; .)
    PROCEDURE       reduce using rule 397 (entry_body_part -> ; .)
    FUNCTION        reduce using rule 397 (entry_body_part -> ; .)


state 952

    (108) comp_decl -> def_id_s : component_subtype_def init_opt ; .

    error           reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    ENTRY           reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    PROCEDURE       reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    FUNCTION        reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    PRAGMA          reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    FOR             reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    IDENTIFIER      reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    END             reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    CASE            reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)
    WHEN            reduce using rule 108 (comp_decl -> def_id_s : component_subtype_def init_opt ; .)


state 953

    (394) entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .

    PRAGMA          reduce using rule 394 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    ENTRY           reduce using rule 394 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    FOR             reduce using rule 394 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    END             reduce using rule 394 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    PRIVATE         reduce using rule 394 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    PROCEDURE       reduce using rule 394 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    FUNCTION        reduce using rule 394 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    error           reduce using rule 394 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)
    IDENTIFIER      reduce using rule 394 (entry_decl -> ENTRY IDENTIFIER ( discrete_range ) formal_part_opt ; .)


state 954

    (424) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .

    EXCEPTION       reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    LESSLESS        reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    error           reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    PRAGMA          reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    NuLL            reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    EXIT            reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    RETURN          reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    GOTO            reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    DELAY           reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    ABORT           reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    RAISE           reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    REQUEUE         reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    IF              reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    CASE            reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    IDENTIFIER      reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    ACCEPT          reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    SELECT          reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    STRING          reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    WHILE           reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    DECLARE         reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    FOR             reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    LOOP            reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    BEGIN           reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    END             reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    OR              reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    ELSE            reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    THEN            reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    ELSIF           reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)
    WHEN            reduce using rule 424 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT ; .)


state 955

    (511) comp_loc_s -> comp_loc_s mark AT expression RANGE range . ;

    ;               shift and go to state 963


state 956

    (105) comp_decl_s -> comp_decl_s pragma_s comp_decl .

    error           reduce using rule 105 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
    CASE            reduce using rule 105 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
    PRAGMA          reduce using rule 105 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
    IDENTIFIER      reduce using rule 105 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
    END             reduce using rule 105 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)
    WHEN            reduce using rule 105 (comp_decl_s -> comp_decl_s pragma_s comp_decl .)


state 957

    (107) variant_part_opt -> pragma_s variant_part . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 964

state 958

    (117) variant_part -> CASE simple_name IS . pragma_s variant_s END CASE ;
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    WHEN            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 965

state 959

    (96) record_def -> RECORD pragma_s comp_list END RECORD .

    ;               reduce using rule 96 (record_def -> RECORD pragma_s comp_list END RECORD .)


state 960

    (103) comp_list -> NuLL ; pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 103 (comp_list -> NuLL ; pragma_s .)
    WHEN            reduce using rule 103 (comp_list -> NuLL ; pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 961

    (396) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt . WHEN condition entry_body_part

    WHEN            shift and go to state 966


state 962

    (398) entry_body_part -> IS decl_part . block_body END id_opt ;
    (301) block_body -> . BEGIN handled_stmt_s

    BEGIN           shift and go to state 162

    block_body                     shift and go to state 967

state 963

    (511) comp_loc_s -> comp_loc_s mark AT expression RANGE range ; .

    END             reduce using rule 511 (comp_loc_s -> comp_loc_s mark AT expression RANGE range ; .)
    IDENTIFIER      reduce using rule 511 (comp_loc_s -> comp_loc_s mark AT expression RANGE range ; .)


state 964

    (107) variant_part_opt -> pragma_s variant_part pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;

    END             reduce using rule 107 (variant_part_opt -> pragma_s variant_part pragma_s .)
    WHEN            reduce using rule 107 (variant_part_opt -> pragma_s variant_part pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 965

    (117) variant_part -> CASE simple_name IS pragma_s . variant_s END CASE ;
    (9) pragma_s -> pragma_s . pragma
    (118) variant_s -> . variant
    (119) variant_s -> . variant_s variant
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (120) variant -> . WHEN choice_s ARROW pragma_s comp_list

    PRAGMA          shift and go to state 4
    WHEN            shift and go to state 969

    variant_s                      shift and go to state 968
    variant                        shift and go to state 970
    pragma                         shift and go to state 14

state 966

    (396) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN . condition entry_body_part
    (278) condition -> . expression
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 128
    indexed_comp                   shift and go to state 129
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    allocator                      shift and go to state 130
    factor                         shift and go to state 137
    operator_symbol                shift and go to state 138
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    condition                      shift and go to state 971
    term                           shift and go to state 147
    name                           shift and go to state 148
    qualified                      shift and go to state 141
    expression                     shift and go to state 461

state 967

    (398) entry_body_part -> IS decl_part block_body . END id_opt ;

    END             shift and go to state 972


state 968

    (117) variant_part -> CASE simple_name IS pragma_s variant_s . END CASE ;
    (119) variant_s -> variant_s . variant
    (120) variant -> . WHEN choice_s ARROW pragma_s comp_list

    END             shift and go to state 973
    WHEN            shift and go to state 969

    variant                        shift and go to state 974

state 969

    (120) variant -> WHEN . choice_s ARROW pragma_s comp_list
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (198) expression -> . relation
    (199) expression -> . expression logical m relation
    (200) expression -> . expression short_circuit m relation
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (205) relation -> . simple_expression
    (206) relation -> . simple_expression relational simple_expression
    (207) relation -> . simple_expression membership range
    (208) relation -> . simple_expression membership name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (62) range -> . simple_expression DOTDOT simple_expression
    (63) range -> . name
    (217) simple_expression -> . unary term
    (218) simple_expression -> . term
    (219) simple_expression -> . simple_expression adding term
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name ( value_s )
    (174) selected_comp -> . name . simple_name
    (175) selected_comp -> . name . used_char
    (176) selected_comp -> . name . operator_symbol
    (177) selected_comp -> . name . ALL
    (178) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (220) unary -> . +
    (221) unary -> . -
    (225) term -> . factor
    (226) term -> . term multiplying factor
    (231) factor -> . primary
    (232) factor -> . NOT primary
    (233) factor -> . primary STARSTAR primary
    (234) primary -> . literal
    (235) primary -> . name
    (236) primary -> . allocator
    (237) primary -> . qualified
    (238) primary -> . parenthesized_primary
    (183) literal -> . INTEGER
    (184) literal -> . BASE_INTEGER
    (185) literal -> . FLOAT
    (186) literal -> . BASE_FLOAT
    (187) literal -> . used_char
    (188) literal -> . NuLL
    (242) allocator -> . NEW name
    (243) allocator -> . NEW qualified
    (241) qualified -> . name TICK parenthesized_primary
    (239) parenthesized_primary -> . aggregate
    (240) parenthesized_primary -> . ( expression )
    (166) used_char -> . CHAR
    (189) aggregate -> . ( comp_assoc )
    (190) aggregate -> . ( value_s_2 )
    (191) aggregate -> . ( expression WITH value_s )
    (192) aggregate -> . ( expression WITH NuLL RECORD )
    (193) aggregate -> . ( NuLL RECORD )

    OTHERS          shift and go to state 223
    IDENTIFIER      shift and go to state 39
    STRING          shift and go to state 139
    +               shift and go to state 133
    -               shift and go to state 134
    NOT             shift and go to state 150
    INTEGER         shift and go to state 143
    BASE_INTEGER    shift and go to state 136
    FLOAT           shift and go to state 149
    BASE_FLOAT      shift and go to state 126
    NuLL            shift and go to state 151
    NEW             shift and go to state 127
    (               shift and go to state 132
    CHAR            shift and go to state 146

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 122
    used_char                      shift and go to state 145
    unary                          shift and go to state 124
    relation                       shift and go to state 125
    simple_expression              shift and go to state 514
    indexed_comp                   shift and go to state 129
    allocator                      shift and go to state 130
    simple_name                    shift and go to state 157
    literal                        shift and go to state 135
    choice_s                       shift and go to state 975
    operator_symbol                shift and go to state 138
    factor                         shift and go to state 137
    choice                         shift and go to state 227
    qualified                      shift and go to state 141
    parenthesized_primary          shift and go to state 142
    aggregate                      shift and go to state 144
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 147
    name                           shift and go to state 516
    range                          shift and go to state 232
    expression                     shift and go to state 517

state 970

    (118) variant_s -> variant .

    END             reduce using rule 118 (variant_s -> variant .)
    WHEN            reduce using rule 118 (variant_s -> variant .)


state 971

    (396) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition . entry_body_part
    (397) entry_body_part -> . ;
    (398) entry_body_part -> . IS decl_part block_body END id_opt ;

    ;               shift and go to state 951
    IS              shift and go to state 950

    entry_body_part                shift and go to state 976

state 972

    (398) entry_body_part -> IS decl_part block_body END . id_opt ;
    (296) id_opt -> .
    (297) id_opt -> . designator
    (319) designator -> . compound_name
    (320) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name . simple_name
    (161) simple_name -> . IDENTIFIER

    ;               reduce using rule 296 (id_opt -> .)
    STRING          shift and go to state 115
    IDENTIFIER      shift and go to state 39

    designator                     shift and go to state 462
    id_opt                         shift and go to state 977
    compound_name                  shift and go to state 114
    simple_name                    shift and go to state 41

state 973

    (117) variant_part -> CASE simple_name IS pragma_s variant_s END . CASE ;

    CASE            shift and go to state 978


state 974

    (119) variant_s -> variant_s variant .

    END             reduce using rule 119 (variant_s -> variant_s variant .)
    WHEN            reduce using rule 119 (variant_s -> variant_s variant .)


state 975

    (120) variant -> WHEN choice_s . ARROW pragma_s comp_list
    (122) choice_s -> choice_s . | choice

    ARROW           shift and go to state 979
    |               shift and go to state 365


state 976

    (396) entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .

    PRAGMA          reduce using rule 396 (entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)
    END             reduce using rule 396 (entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)
    ENTRY           reduce using rule 396 (entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)
    PROCEDURE       reduce using rule 396 (entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)
    FUNCTION        reduce using rule 396 (entry_body -> ENTRY IDENTIFIER ( iter_part discrete_range ) formal_part_opt WHEN condition entry_body_part .)


state 977

    (398) entry_body_part -> IS decl_part block_body END id_opt . ;

    ;               shift and go to state 980


state 978

    (117) variant_part -> CASE simple_name IS pragma_s variant_s END CASE . ;

    ;               shift and go to state 981


state 979

    (120) variant -> WHEN choice_s ARROW . pragma_s comp_list
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    NuLL            reduce using rule 8 (pragma_s -> .)
    PRAGMA          reduce using rule 8 (pragma_s -> .)
    CASE            reduce using rule 8 (pragma_s -> .)
    error           reduce using rule 8 (pragma_s -> .)
    IDENTIFIER      reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 982

state 980

    (398) entry_body_part -> IS decl_part block_body END id_opt ; .

    PRAGMA          reduce using rule 398 (entry_body_part -> IS decl_part block_body END id_opt ; .)
    END             reduce using rule 398 (entry_body_part -> IS decl_part block_body END id_opt ; .)
    ENTRY           reduce using rule 398 (entry_body_part -> IS decl_part block_body END id_opt ; .)
    PROCEDURE       reduce using rule 398 (entry_body_part -> IS decl_part block_body END id_opt ; .)
    FUNCTION        reduce using rule 398 (entry_body_part -> IS decl_part block_body END id_opt ; .)


state 981

    (117) variant_part -> CASE simple_name IS pragma_s variant_s END CASE ; .

    PRAGMA          reduce using rule 117 (variant_part -> CASE simple_name IS pragma_s variant_s END CASE ; .)
    END             reduce using rule 117 (variant_part -> CASE simple_name IS pragma_s variant_s END CASE ; .)
    WHEN            reduce using rule 117 (variant_part -> CASE simple_name IS pragma_s variant_s END CASE ; .)


state 982

    (120) variant -> WHEN choice_s ARROW pragma_s . comp_list
    (9) pragma_s -> pragma_s . pragma
    (101) comp_list -> . comp_decl_s variant_part_opt
    (102) comp_list -> . variant_part pragma_s
    (103) comp_list -> . NuLL ; pragma_s
    (2) pragma -> . PRAGMA IDENTIFIER ;
    (3) pragma -> . PRAGMA simple_name ( pragma_arg_s ) ;
    (104) comp_decl_s -> . comp_decl
    (105) comp_decl_s -> . comp_decl_s pragma_s comp_decl
    (117) variant_part -> . CASE simple_name IS pragma_s variant_s END CASE ;
    (108) comp_decl -> . def_id_s : component_subtype_def init_opt ;
    (109) comp_decl -> . error ;
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s , def_id
    (26) def_id -> . IDENTIFIER

    NuLL            shift and go to state 925
    PRAGMA          shift and go to state 4
    CASE            shift and go to state 921
    error           shift and go to state 783
    IDENTIFIER      shift and go to state 76

    def_id_s                       shift and go to state 779
    comp_list                      shift and go to state 983
    comp_decl                      shift and go to state 923
    def_id                         shift and go to state 89
    variant_part                   shift and go to state 924
    pragma                         shift and go to state 14
    comp_decl_s                    shift and go to state 920

state 983

    (120) variant -> WHEN choice_s ARROW pragma_s comp_list .

    END             reduce using rule 120 (variant -> WHEN choice_s ARROW pragma_s comp_list .)
    WHEN            reduce using rule 120 (variant -> WHEN choice_s ARROW pragma_s comp_list .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 230 resolved using rule (range -> name)
WARNING: rejected rule (primary -> name) in state 230
WARNING: reduce/reduce conflict in state 359 resolved using rule (range -> name)
WARNING: rejected rule (relation -> simple_expression membership name) in state 359
WARNING: reduce/reduce conflict in state 516 resolved using rule (range -> name)
WARNING: rejected rule (primary -> name) in state 516
WARNING: reduce/reduce conflict in state 680 resolved using rule (range -> name)
WARNING: rejected rule (range_constr_opt -> <empty>) in state 680
WARNING: reduce/reduce conflict in state 747 resolved using rule (range -> name)
WARNING: rejected rule (range_constr_opt -> <empty>) in state 747
WARNING: Rule (relation -> simple_expression membership name) is never reduced
